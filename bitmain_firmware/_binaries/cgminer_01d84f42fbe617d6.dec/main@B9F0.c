void __fastcall __noreturn main(int a1, const char **a2, char **a3)
{
  int (**v3)(); // r9
  int v4; // r0
  int (*v5)(void); // r3
  bool v6; // zf
  size_t v7; // r0
  _DWORD *v8; // r0
  int v9; // r3
  _DWORD *v10; // r6
  const char **v11; // r7
  int v12; // r4
  int v13; // r5
  char *v14; // r0
  int v15; // r0
  char *v16; // r0
  char *v17; // r7
  char *v18; // r6
  char *v19; // r0
  char *v20; // r4
  int v21; // r6
  unsigned __int8 *v22; // r5
  size_t v23; // r0
  int v24; // r9
  int v25; // r3
  int v26; // r10
  unsigned int v27; // r7
  int v28; // r6
  int v29; // r3
  size_t i; // r8
  int v31; // r1
  int v32; // r12
  int v33; // r2
  int v34; // r0
  unsigned int v35; // r3
  unsigned int v36; // r7
  int v37; // r6
  unsigned int v38; // r2
  unsigned int v39; // r3
  int v40; // r1
  unsigned int v41; // r2
  unsigned int v42; // r3
  size_t v43; // r0
  int v44; // r3
  unsigned int v45; // r3
  int v46; // r2
  unsigned int v47; // r0
  unsigned int v48; // r3
  int v49; // r2
  unsigned int v50; // r0
  unsigned int v51; // r3
  unsigned int v52; // r2
  unsigned int v53; // r3
  _DWORD *v54; // r2
  int v55; // r3
  int v56; // r2
  _DWORD *v57; // r2
  int v58; // r1
  int v59; // r5
  size_t v60; // r6
  _DWORD *v61; // r0
  _DWORD *v62; // r7
  _DWORD *v63; // r0
  unsigned int v64; // r3
  _DWORD *v65; // r1
  _DWORD *v66; // r5
  unsigned int ii; // r6
  _DWORD *v68; // r9
  int v69; // r6
  char *v70; // r8
  unsigned int v71; // r3
  int v72; // r3
  _DWORD *v73; // r3
  unsigned int v74; // r1
  unsigned int v75; // r2
  bool v76; // cc
  int v77; // r2
  int v78; // r3
  int v79; // r5
  int v80; // r9
  _DWORD *v81; // r0
  const char *v82; // r2
  _DWORD *v83; // r3
  int v84; // r0
  int v85; // r1
  int v86; // r2
  int v87; // r3
  int v88; // r3
  int v89; // r4
  int v90; // r5
  int v91; // r9
  int *v92; // r9
  void *v93; // r0
  FILE *v94; // r4
  char *v95; // r0
  const char *v96; // r1
  char *v97; // r4
  char *v98; // r0
  int *v99; // r4
  char *v100; // r3
  char *v101; // r3
  char *v102; // r3
  char *v103; // r12
  int v104; // r2
  int v105; // r0
  bool v106; // zf
  char *v107; // r12
  int v108; // r3
  int v109; // r3
  bool v110; // zf
  int *v111; // r6
  int v112; // r10
  char *v113; // r9
  int v114; // r3
  int v115; // r10
  char *v116; // r6
  char *v117; // r9
  char *v118; // r4
  int v119; // r3
  char *v120; // r12
  int v121; // r5
  int v122; // r6
  int v123; // r0
  char *v124; // r0
  char *v125; // r7
  int v126; // r5
  char *v127; // r8
  unsigned int v128; // r6
  int v129; // r3
  int v130; // r3
  char *v131; // r12
  char *v132; // r12
  int *v133; // r3
  int v134; // r0
  int v135; // t1
  char *v136; // r12
  char *v137; // r12
  int v138; // r6
  int *v139; // r7
  int v140; // r9
  int v141; // r3
  const char *v142; // r10
  size_t v143; // r0
  size_t v144; // r4
  char *v145; // r0
  char *v146; // r12
  int v147; // r2
  __sighandler_t v148; // r7
  __sighandler_t v149; // r0
  bool v150; // zf
  __pid_t v151; // r0
  __pid_t v152; // r7
  char *v153; // r12
  _DWORD *v154; // r0
  _DWORD *v155; // r7
  void *v156; // r0
  int v157; // r3
  char *v158; // r12
  char *v159; // r12
  int v160; // r3
  int v161; // r12
  int v162; // r1
  int v163; // r2
  int j; // r7
  int v165; // r6
  int v166; // r9
  int k; // r8
  int v168; // r7
  _DWORD *v169; // r4
  int v170; // r6
  _DWORD *v171; // r0
  int v172; // r3
  _DWORD *v173; // r0
  _DWORD *v174; // r6
  int v175; // r4
  int v176; // r3
  int *v177; // r1
  int v178; // r12
  int v179; // r1
  int v180; // r0
  int v181; // lr
  int v182; // r1
  int v183; // r2
  int v184; // r3
  int v185; // r1
  int v186; // r2
  int v187; // r3
  int v188; // r6
  int v189; // r9
  int v190; // r6
  int v191; // r12
  int v192; // r2
  int v193; // lr
  int v194; // r3
  int v195; // r2
  int v196; // r1
  char *v197; // r1
  char *v198; // r12
  int v199; // r1
  int v200; // r2
  int v201; // r3
  char *v202; // r12
  int v203; // r7
  int v204; // r6
  int v205; // r3
  int v206; // r0
  int *v207; // r1
  int v208; // r3
  int v209; // r0
  int v210; // r0
  int *v211; // r8
  int v212; // r2
  int *v213; // lr
  int v214; // r0
  int v215; // r3
  int v216; // t1
  int v217; // r9
  int v218; // t1
  int v219; // r3
  int v220; // r9
  int v221; // r3
  int v222; // r3
  int v223; // r0
  int v224; // r1
  int v225; // r12
  int v226; // r0
  int v227; // r6
  int v228; // r9
  int *v229; // r3
  int v230; // r3
  int v231; // r1
  int v232; // r0
  const char *v233; // lr
  int v234; // r0
  int v235; // r1
  int v236; // r2
  int v237; // r3
  _DWORD *v238; // lr
  char *v239; // r12
  int v240; // r1
  int v241; // r2
  char *v242; // r12
  int v243; // r0
  int v244; // r3
  char *v245; // r12
  int *v246; // r3
  int v247; // r1
  int v248; // t1
  int v249; // r9
  int *v250; // lr
  int v251; // r3
  int v252; // t1
  int v253; // r6
  int v254; // t1
  int v255; // r3
  int v256; // r6
  int v257; // r3
  int v258; // r3
  int v259; // r12
  int v260; // r6
  int v261; // r9
  int *v262; // r8
  int v263; // r0
  int v264; // r1
  int v265; // r2
  int v266; // r3
  int v267; // r0
  int v268; // r1
  int v269; // r2
  int v270; // r3
  int v271; // r3
  const char **v272; // r12
  char *v273; // r12
  char *v274; // r12
  char *v275; // r12
  char *v276; // r12
  int m; // r6
  int v278; // r3
  int v279; // r8
  char *v280; // r10
  char *v281; // r9
  int n; // r8
  char *v283; // r12
  int v284; // r2
  char *v285; // r12
  char *v286; // r12
  char v287; // [sp+10h] [bp-29FCh] BYREF
  char v288[4088]; // [sp+1018h] [bp-19F4h] BYREF
  const char *v289; // [sp+2024h] [bp-9E8h]
  int *v290; // [sp+2028h] [bp-9E4h]
  void (**v291)(void); // [sp+202Ch] [bp-9E0h]
  char *v292; // [sp+2030h] [bp-9DCh]
  int *v293; // [sp+2034h] [bp-9D8h]
  char *v294; // [sp+2038h] [bp-9D4h]
  const char **v295; // [sp+203Ch] [bp-9D0h]
  char *s; // [sp+2040h] [bp-9CCh]
  int v297; // [sp+2044h] [bp-9C8h]
  int *v298; // [sp+2048h] [bp-9C4h]
  int v299; // [sp+204Ch] [bp-9C0h] BYREF
  struct sigaction v300; // [sp+2054h] [bp-9B8h] BYREF
  char v301[256]; // [sp+20E0h] [bp-92Ch] BYREF
  int v302[513]; // [sp+21E0h] [bp-82Ch] BYREF

  v295 = a2;
  v299 = a1;
  strcpy(dword_62FA0, "cgminer.log");
  strcpy(word_630A0, "a+");
  byte_62F98 = 0;
  v4 = sysconf(84);
  v6 = v4 == 1;
  if ( v4 == 1 )
  {
    v5 = sched_yield;
    v3 = &off_60178;
  }
  v7 = 4 * (v299 + 1);
  if ( v6 )
    *v3 = v5;
  v8 = malloc(v7);
  v9 = v299;
  v10 = v8;
  dword_6141C = (int)v8;
  if ( v299 > 0 )
  {
    v11 = v295;
    v12 = 0;
    v13 = 0;
    do
    {
      ++v13;
      v14 = _strdup(v11[v12]);
      v9 = v299;
      v76 = v299 <= v13;
      v10[v12++] = v14;
    }
    while ( !v76 );
  }
  v10[v9] = 0;
  sub_173C0(&stru_6392C, "main", 10697);
  sub_173C0(&unk_63DFC, "main", 10698);
  sub_173C0(&stru_63D48, "main", 10699);
  sub_17418(&stru_63FB0, "main", 10700);
  sub_173C0(&mutex, "main", 10701);
  sub_173C0(&stru_61538, "main", 10702);
  sub_17418(&stru_63F78, "main", 10703);
  sub_173C0(&stru_612DC, "main", 10704);
  sub_173EC(&stru_61550, "main", 10705);
  sub_173EC(&unk_63880, "main", 10706);
  sub_173EC(&rwlock, "main", 10707);
  sub_173EC(&stru_63CA0, "main", 10708);
  sub_173C0(&stru_61314, "main", 10710);
  if ( pthread_cond_init(&stru_61330, 0) )
  {
    strcpy((char *)v302, "Failed to pthread_cond_init lp_cond");
    sub_38438(3, v302, 1);
    sub_1C160(1, 0);
  }
  sub_173C0(&stru_63BCC, "main", 10714);
  if ( pthread_cond_init(&cond, 0) )
  {
    strcpy((char *)v302, "Failed to pthread_cond_init restart_cond");
    v197 = (char *)v302;
    goto LABEL_325;
  }
  if ( pthread_cond_init(&stru_63748, 0) )
  {
    strcpy((char *)v302, "Failed to pthread_cond_init gws_cond");
  }
  else
  {
    v15 = sub_2AA90();
    dword_63BC0 = v15;
    if ( v15 )
    {
      dword_612C8 = v15 + 12;
      snprintf(byte_60EA4, 0x100u, "%s %s", "cgminer", a49);
      v300.sa_flags = 0;
      v300.sa_handler = (__sighandler_t)sub_1738C;
      sigemptyset(&v300.sa_mask);
      sigaction(15, &v300, &oact);
      sigaction(2, &v300, &stru_63EEC);
      signal(13, (__sighandler_t)1);
      dword_64214 = (int)v288;
      strcpy(v288, "/usr/bin");
      dword_63E54 = (int)&v287;
      v16 = _strdup(*v295);
      v17 = (char *)dword_63E54;
      v18 = v16;
      v19 = dirname(v16);
      strcpy(v17, v19);
      free(v18);
      *(_WORD *)(dword_63E54 + strlen((const char *)dword_63E54)) = 47;
      dword_61308 = 8;
      dword_612FC = 9;
      dword_61304 = 10;
      v20 = (char *)calloc(0x68u, 1u);
      if ( !v20 )
      {
        s = (char *)v302;
        strcpy((char *)v302, "main OOM");
        sub_38438(3, v302, 1);
        sub_16724(1);
      }
      v21 = 36;
      do
      {
        v22 = (unsigned __int8 *)v20;
        --v21;
        *(_WORD *)&v20[strlen(v20)] = 48;
      }
      while ( v21 );
      *((_DWORD *)v20 + 19) = 0;
      *((_DWORD *)v20 + 22) = v20;
      v23 = strlen(v20);
      v24 = dword_61570;
      v6 = dword_61570 == 0;
      *((_DWORD *)v20 + 23) = v23;
      if ( v6 )
      {
        *((_DWORD *)v20 + 18) = 0;
        dword_61570 = (int)v20;
        v154 = malloc(0x2Cu);
        v155 = v154;
        *((_DWORD *)v20 + 17) = v154;
        if ( !v154 )
          goto LABEL_310;
        memset(v154, 0, 0x2Cu);
        v298 = (int *)(v20 + 68);
        v155[1] = 32;
        v155[2] = 5;
        v155[4] = v20 + 68;
        v155[5] = 68;
        v156 = malloc(0x180u);
        *v155 = v156;
        if ( !v156 )
          goto LABEL_310;
        memset(v156, 0, 0x180u);
        v24 = (int)v20;
        v155[10] = -1609490463;
      }
      else
      {
        v25 = *(_DWORD *)(v24 + 68);
        v298 = (int *)(v20 + 68);
        *(_DWORD *)(*(_DWORD *)(v25 + 16) + 8) = v20;
        *((_DWORD *)v20 + 18) = *(_DWORD *)(*(_DWORD *)(v24 + 68) + 16) - *(_DWORD *)(*(_DWORD *)(v24 + 68) + 20);
        *(_DWORD *)(*(_DWORD *)(v24 + 68) + 16) = v20 + 68;
      }
      v26 = -17973521;
      v27 = -1640531527;
      v28 = -1640531527;
      ++*(_DWORD *)(*(_DWORD *)(v24 + 68) + 12);
      v29 = *(_DWORD *)(v24 + 68);
      *((_DWORD *)v20 + 24) = -17973521;
      *((_DWORD *)v20 + 17) = v29;
      for ( i = strlen(v20); i > 0xB; *((_DWORD *)v20 + 24) = v26 )
      {
        i -= 12;
        v31 = (v22[2] << 16) + (v22[1] << 8) + *v22;
        v32 = v22[3];
        v33 = (v22[6] << 16) + (v22[5] << 8) + v22[4];
        v34 = v22[7];
        v35 = (v22[10] << 16) + (v22[9] << 8) + v22[8] + (v22[11] << 24) + v26;
        v22 += 12;
        v36 = v33 + (v34 << 24) + v27;
        v37 = (v31 + (v32 << 24) - v35 - v36 + v28) ^ (v35 >> 13);
        v38 = (v36 - v35 - v37) ^ (v37 << 8);
        v39 = (v35 - v37 - v38) ^ (v38 >> 13);
        v40 = (v37 - v38 - v39) ^ (v39 >> 12);
        v41 = (v38 - v39 - v40) ^ (v40 << 16);
        v42 = (v39 - v40 - v41) ^ (v41 >> 5);
        v28 = (v40 - v41 - v42) ^ (v42 >> 3);
        v27 = (v41 - v42 - v28) ^ (v28 << 10);
        v26 = (v42 - v28 - v27) ^ (v27 >> 15);
      }
      v43 = v26 + strlen(v20);
      *((_DWORD *)v20 + 24) = v43;
      switch ( i )
      {
        case 1u:
          v45 = *((_DWORD *)v20 + 24);
          goto LABEL_31;
        case 2u:
          v45 = *((_DWORD *)v20 + 24);
          goto LABEL_30;
        case 3u:
          v45 = *((_DWORD *)v20 + 24);
          goto LABEL_29;
        case 4u:
          v45 = *((_DWORD *)v20 + 24);
          goto LABEL_28;
        case 5u:
          v45 = *((_DWORD *)v20 + 24);
          goto LABEL_27;
        case 6u:
          v45 = *((_DWORD *)v20 + 24);
          goto LABEL_26;
        case 7u:
          v45 = *((_DWORD *)v20 + 24);
          goto LABEL_25;
        case 8u:
          v45 = *((_DWORD *)v20 + 24);
          goto LABEL_24;
        case 9u:
          v44 = *((_DWORD *)v20 + 24);
          goto LABEL_23;
        case 0xAu:
          goto LABEL_22;
        case 0xBu:
          *((_DWORD *)v20 + 24) = v43 + (v22[10] << 24);
LABEL_22:
          v44 = *((_DWORD *)v20 + 24) + (v22[9] << 16);
          *((_DWORD *)v20 + 24) = v44;
LABEL_23:
          v45 = v44 + (v22[8] << 8);
          *((_DWORD *)v20 + 24) = v45;
LABEL_24:
          v27 += v22[7] << 24;
LABEL_25:
          v27 += v22[6] << 16;
LABEL_26:
          v27 += v22[5] << 8;
LABEL_27:
          v27 += v22[4];
LABEL_28:
          v28 += v22[3] << 24;
LABEL_29:
          v28 += v22[2] << 16;
LABEL_30:
          v28 += v22[1] << 8;
LABEL_31:
          v28 += *v22;
          break;
        default:
          v45 = *((_DWORD *)v20 + 24);
          break;
      }
      v46 = (v28 - v27 - v45) ^ (v45 >> 13);
      v47 = (v27 - v45 - v46) ^ (v46 << 8);
      v48 = (v45 - v46 - v47) ^ (v47 >> 13);
      v49 = (v46 - v47 - v48) ^ (v48 >> 12);
      v50 = (v47 - v48 - v49) ^ (v49 << 16);
      v51 = (v48 - v49 - v50) ^ (v50 >> 5);
      v52 = v49 - v50 - v51;
      v53 = (v51 - (v52 ^ (v51 >> 3)) - ((v50 - v51 - (v52 ^ (v51 >> 3))) ^ ((v52 ^ (v51 >> 3)) << 10)))
          ^ (((v50 - v51 - (v52 ^ (v51 >> 3))) ^ ((v52 ^ (v51 >> 3)) << 10)) >> 15);
      *((_DWORD *)v20 + 24) = v53;
      v54 = *(_DWORD **)(v24 + 68);
      v55 = 12 * (v53 & (v54[1] - 1));
      ++*(_DWORD *)(*v54 + v55 + 4);
      v56 = *(_DWORD *)(**(_DWORD **)(v24 + 68) + v55);
      *((_DWORD *)v20 + 20) = 0;
      *((_DWORD *)v20 + 21) = v56;
      v57 = *(_DWORD **)(v24 + 68);
      v58 = *(_DWORD *)(*v57 + v55);
      if ( v58 )
      {
        *(_DWORD *)(v58 + 12) = v298;
        v57 = *(_DWORD **)(v24 + 68);
      }
      *(_DWORD *)(*v57 + v55) = v298;
      if ( *(_DWORD *)(**(_DWORD **)(v24 + 68) + v55 + 4) < (unsigned int)(10
                                                                         * (*(_DWORD *)(**(_DWORD **)(v24 + 68) + v55 + 8)
                                                                          + 1))
        || (v59 = *((_DWORD *)v20 + 17), *(_DWORD *)(v59 + 36) == 1) )
      {
LABEL_57:
        strcpy(dest, v20);
        dword_639E8 = (int)&dword_639E8;
        dword_639EC = (int)&dword_639E8;
        sub_48430(&off_5F8A0, "Options for both config file and command line");
        sub_48430(&off_600C4, "Options for command line only");
        sub_484FC(&v299, v295, sub_1187C);
        if ( v299 != 1 )
        {
          strcpy((char *)v302, "Unexpected extra commandline arguments");
          sub_38438(3, v302, 1);
          sub_1C160(1, 0);
        }
        v79 = (unsigned __int8)byte_611D0;
        if ( !byte_611D0 )
        {
          dword_611D4 = (int)malloc(0x1000u);
          sub_15C88();
          if ( access((const char *)dword_611D4, 4) )
          {
            free((void *)dword_611D4);
            dword_611D4 = v79;
          }
          else
          {
            sub_16814((char *)dword_611D4);
          }
        }
        if ( byte_615C9 || dword_612AC )
        {
          if ( byte_63DF9 )
          {
            s = (char *)v302;
            strcpy((char *)v302, "Cannot use benchmark mode with scrypt");
            sub_38438(3, v302, 1);
            sub_16724(1);
          }
          s = (char *)v302;
          v80 = sub_1746C();
          v81 = malloc(0xFFu);
          if ( dword_612AC )
            v82 = "Benchfile";
          else
            v82 = "Benchmark";
          *(_DWORD *)(v80 + 164) = v81;
          v83 = v81;
          v84 = *(_DWORD *)v82;
          v85 = *((_DWORD *)v82 + 1);
          v86 = *((_DWORD *)v82 + 2);
          *v83 = v84;
          v83[1] = v85;
          *((_WORD *)v83 + 4) = v86;
          v87 = *(_DWORD *)(v80 + 164);
          *(_DWORD *)(v80 + 172) = v87;
          *(_DWORD *)(v80 + 176) = v87;
          *(_DWORD *)(v80 + 168) = v87;
          *(_DWORD *)(v80 + 592) = v87;
          strncpy((char *)(v80 + 48), "?", 7u);
          v88 = *(_DWORD *)(v80 + 100);
          *(_BYTE *)(v80 + 55) = 0;
          if ( v88 != 1 )
          {
            *(_DWORD *)(v80 + 100) = 1;
            ++dword_63B84;
          }
          v89 = 0;
          *(_BYTE *)(v80 + 97) = 0;
          byte_62F60 = 1;
          do
          {
            v90 = 324 * v89;
            v91 = 5 * v89++;
            v92 = (int *)(32 * v91);
            sub_295B8((char *)&unk_615D8 + (_DWORD)v92, &a000000029c6bf4[v90], 160);
            sub_295B8((char *)&unk_61FD8 + (_DWORD)v92, &a00000002c01f50[v90], 160);
          }
          while ( v89 != 16 );
          sub_15D7C(dword_629EC);
        }
        else
        {
          v92 = v302;
          s = (char *)v302;
        }
        v93 = (void *)dword_60EA0;
        if ( !dword_60EA0 )
        {
          v99 = (int *)byte_62E80;
          v294 = &byte_632F0;
          goto LABEL_103;
        }
        v94 = fopen((const char *)dword_60EA0, "rb");
        v93 = memset(v301, 0, sizeof(v301));
        if ( v94 )
        {
          v93 = (void *)fread(v301, 1u, 0x100u, v94);
          if ( (int)v93 > 0 )
          {
            v95 = strchr(v301, 10);
            v96 = v301;
            v97 = v95;
            v6 = v95 == 0;
            v98 = ::s;
            if ( !v6 )
            {
              memcpy(::s, v301, v97 - v301);
              v98 = byte_62B0C;
              v96 = v97 + 1;
            }
            strcpy(v98, v96);
            v99 = (int *)byte_62E80;
            v100 = (char *)&byte_62E80[strlen(::s) - 1];
            if ( *(v100 - 1140) == 10 )
              *(v100 - 1140) = 0;
            v101 = (char *)&byte_62E80[strlen(::s) - 1];
            if ( *(v101 - 1140) == 13 )
              *(v101 - 1140) = 0;
            v102 = (char *)&byte_62E80[strlen(byte_62B0C) - 1];
            if ( *(v102 - 884) == 10 )
              *(v102 - 884) = 0;
            v93 = (void *)(strlen(byte_62B0C) - 1);
            v104 = byte_62E80[(_DWORD)v93 - 884];
            if ( v104 == 13 )
            {
              v103 = &byte_632F0;
              byte_62E80[(_DWORD)v93 - 884] = 0;
            }
            else
            {
              v92 = (int *)&byte_632F0;
            }
            if ( v104 == 13 )
              v294 = v103;
            else
              v294 = (char *)v92;
            goto LABEL_98;
          }
          v294 = &byte_632F0;
          if ( byte_632F0 || (v292 = &byte_630C0, byte_630C0) || dword_60964 > 2 )
          {
            snprintf(s, 0x800u, "Read miner version file %s error %d", (const char *)dword_60EA0, v93);
            goto LABEL_252;
          }
        }
        else
        {
          v294 = &byte_632F0;
          if ( byte_632F0 || (v292 = &byte_630C0, byte_630C0) || dword_60964 > 2 )
          {
            snprintf(s, 0x800u, "Open miner version file %s error", (const char *)dword_60EA0);
LABEL_252:
            v99 = (int *)byte_62E80;
            v93 = (void *)sub_38438(3, s, 0);
LABEL_98:
            if ( *v294 )
            {
LABEL_102:
              snprintf(s, 0x800u, "Miner compile time: %s type: %s", ::s, byte_62B0C);
              v93 = (void *)sub_38438(3, s, 0);
              goto LABEL_103;
            }
            v292 = &byte_630C0;
            goto LABEL_100;
          }
        }
        v99 = (int *)byte_62E80;
LABEL_100:
        if ( *v292 || dword_60964 > 2 )
          goto LABEL_102;
LABEL_103:
        if ( dword_60E90 )
        {
          byte_62F98 = 1;
          v93 = strcpy(dword_62FA0, (const char *)dword_60E90);
          if ( dword_60E9C )
            v93 = strcpy(word_630A0, (const char *)dword_60E9C);
          if ( *v294 || byte_630C0 || dword_60964 > 2 )
          {
            snprintf(s, 0x800u, "Log file path: %s Open flag: %s", dword_62FA0, word_630A0);
            v93 = (void *)sub_38438(3, s, 0);
          }
        }
        if ( dword_60E98 )
        {
          memset(v301, 0, sizeof(v301));
          if ( dword_60E94 )
          {
            if ( !*(_BYTE *)dword_60E94 )
            {
              v153 = s;
              *(_DWORD *)s = *(_DWORD *)"Log work asic num empty";
              strcpy(v153 + 4, "work asic num empty");
              sub_38438(3, s, 1);
              sub_16724(1);
            }
            v105 = strtol((const char *)dword_60E94, 0, 10);
            v106 = v105 == 32;
            if ( v105 != 32 )
              v106 = v105 == 1;
            dword_62C0C = v105;
            if ( !v106 && v105 != 64 )
            {
              v107 = s;
              *(_DWORD *)s = *(_DWORD *)"Log work asic num must be 1, 32, 64";
              strcpy(v107 + 4, "work asic num must be 1, 32, 64");
              sub_38438(3, s, 1);
              sub_16724(1);
            }
            if ( *v294 || byte_630C0 || dword_60964 > 2 )
            {
              snprintf(
                s,
                0x800u,
                "Log work path: %s Asic num: %s",
                (const char *)dword_60E98,
                (const char *)dword_60E94);
              sub_38438(3, s, 0);
            }
          }
          else if ( *v294 || byte_630C0 || dword_60964 > 2 )
          {
            snprintf(s, 0x800u, "Log work path: %s", (const char *)dword_60E98);
            sub_38438(3, s, 0);
          }
          sprintf(v301, "%s.txt", (const char *)dword_60E98);
          v93 = fopen(v301, "a+");
          v108 = (unsigned __int8)*v294;
          dword_62C10 = (int)v93;
          if ( v108 || byte_630C0 || dword_60964 > 2 )
          {
            snprintf(s, 0x800u, "Log work open file %s", v301);
            v93 = (void *)sub_38438(3, s, 0);
          }
          v109 = dword_62C0C;
          if ( dword_62C0C == 1 )
          {
            sprintf(v301, "%s%02d.txt", (const char *)dword_60E98, 1);
            v93 = fopen(v301, "a+");
            v157 = (unsigned __int8)*v294;
            dword_62C14 = (int)v93;
            if ( v157 || byte_630C0 || dword_60964 > 2 )
            {
              snprintf(s, 0x800u, "Log work open asic %d file %s", dword_62C0C, v301);
              v93 = (void *)sub_38438(3, s, 0);
            }
          }
          else
          {
            v110 = dword_62C0C == 32;
            if ( dword_62C0C != 32 )
              v110 = dword_62C0C == 64;
            if ( v110 && dword_62C0C >= 0 )
            {
              v111 = &dword_62C10;
              v112 = 0;
              v113 = s;
              do
              {
                sprintf(v301, "%s%02d_%02d.txt", (const char *)dword_60E98, v109, v112);
                v93 = fopen(v301, "a+");
                v114 = (unsigned __int8)*v294;
                v111[1] = (int)v93;
                ++v111;
                if ( v114 || byte_630C0 || dword_60964 > 2 )
                {
                  snprintf(v113, 0x800u, "Log work open asic %d file %s", dword_62C0C, v301);
                  v93 = (void *)sub_38438(3, v113, 0);
                }
                v109 = dword_62C0C;
                ++v112;
              }
              while ( dword_62C0C >= v112 );
            }
          }
          if ( byte_62D18 )
          {
            v298 = (int *)byte_62E80;
            v115 = 0;
            v116 = &byte_62D18;
            v117 = s;
            v118 = v294;
            do
            {
              sprintf(v301, "%s_diff_%02d.txt", (const char *)dword_60E98, v115);
              v93 = fopen(v301, "a+");
              v119 = (unsigned __int8)*v118;
              *((_DWORD *)v116 + 1) = v93;
              v116 += 4;
              if ( v119 || byte_630C0 || dword_60964 > 2 )
              {
                snprintf(v117, 0x800u, "Log work open diff file %s", v301);
                v93 = (void *)sub_38438(3, v117, 0);
              }
              ++v115;
            }
            while ( v115 != 65 );
            v99 = v298;
          }
        }
        if ( byte_640B8 )
        {
          v293 = &dword_5F890;
          byte_6007C = 0;
        }
        else
        {
          v293 = &dword_5F890;
          if ( byte_6007C )
            sub_277B0(v93);
        }
        if ( *v294 || byte_630C0 || dword_60964 > 3 )
        {
          snprintf(s, 0x800u, "Started %s", byte_60EA4);
          sub_38438(4, s, 0);
        }
        if ( !dword_611D4 )
        {
LABEL_167:
          *(_WORD *)(dword_64214 + strlen((const char *)dword_64214)) = 47;
          if ( byte_63DF8 )
            byte_630C0 = 1;
          if ( v293[512] < 0 )
          {
            if ( byte_63DF9 )
              v130 = 30;
            else
              v130 = 60;
            v293[512] = v130;
          }
          *(int *)((char *)v99 + 0xFFFFFFA0) = 8;
          dword_636A4 = (int)calloc(8u, 0x40u);
          if ( !dword_636A4 )
          {
            v159 = s;
            *(_DWORD *)s = *(_DWORD *)"Failed to calloc control_thr";
            strcpy(v159 + 4, "ed to calloc control_thr");
            sub_38438(3, s, 1);
            sub_1C160(1, 0);
          }
          v121 = 0;
          dword_62E24 = 0;
          v289 = (const char *)&unk_63CC8;
          sub_278E0(&unk_63CC8);
          sub_278E0(&unk_63270);
          sub_278E0(&unk_63D78);
          sub_278E0(&unk_639F0);
          sub_278E0(&unk_60D68);
          sub_278E0(&unk_64240);
          sub_278E0(&unk_63A78);
          sub_278E0(&unk_63C18);
          sub_278E0(&unk_63FE8);
          sub_278E0(&unk_63310);
          sub_278E0(&unk_64110);
          sub_278E0(&unk_63418);
          sub_278E0(&unk_638A8);
          sub_278E0(&unk_63800);
          sub_278E0(&unk_63518);
          sub_278E0(&unk_63E60);
          sub_278E0(&unk_63620);
          sub_278E0(&unk_63598);
          sub_278E0(&unk_63B00);
          sub_278E0(&unk_63948);
          sub_278E0(&unk_63778);
          sub_278E0(&unk_64190);
          sub_278E0(&unk_63498);
          sub_278E0(&unk_63390);
          (*((void (__fastcall **)(_DWORD))v289 + 3))(0);
          off_6327C(0);
          off_63D84(0);
          off_639FC(0);
          off_60D74(0);
          off_6424C(0);
          off_63A84(0);
          off_63C24(0);
          ((void (__fastcall *)(_DWORD))off_63FF4)(0);
          off_6331C(0);
          off_6411C(0);
          off_63424(0);
          off_638B4(0);
          ((void (__fastcall *)(_DWORD))off_6380C)(0);
          off_63524(0);
          off_63E6C(0);
          off_6362C(0);
          off_635A4(0);
          ((void (__fastcall *)(_DWORD))off_63B0C)(0);
          off_63954(0);
          off_63784(0);
          off_6419C(0);
          off_634A4(0);
          ((void (__fastcall *)(_DWORD))off_6339C)(0);
          v122 = dword_63CC0;
          dword_6410C = 0;
          if ( dword_63CC0 > 0 )
          {
            v298 = &dword_63BC8;
            do
            {
              v123 = *(_DWORD *)(dword_63BC8 + 4 * v121++);
              sub_27B20(v123);
              v122 = dword_63CC0;
            }
            while ( dword_63CC0 > v121 );
          }
          if ( !v122 )
          {
            v158 = s;
            *(_DWORD *)s = *(_DWORD *)"All devices disabled, cannot mine!";
            strcpy(v158 + 4, "devices disabled, cannot mine!");
            sub_38438(3, s, 1);
            sub_1C160(1, 0);
          }
          dword_6130C = v122;
          if ( dword_611B0 )
          {
            v124 = strtok((char *)dword_611B0, ",");
            v298 = &dword_63BC8;
            v125 = v124;
            if ( v124 )
            {
              v126 = 0;
              v127 = s;
              do
              {
                if ( v126 >= dword_63CC0 )
                {
                  strcpy(v127, "Too many values passed to set temp cutoff");
                  sub_38438(3, v127, 1);
                  sub_16724(1);
                }
                v128 = strtol(v125, 0, 10);
                if ( v128 > 0xC8 )
                {
                  strcpy(v127, "Invalid value passed to set temp cutoff");
                  sub_38438(3, v127, 1);
                  sub_16724(1);
                }
                sub_1A4EC(&stru_63CA0, "load_temp_cutoffs", 1143);
                v129 = *(_DWORD *)(dword_63BC8 + 4 * v126++);
                *(_DWORD *)(v129 + 184) = v128;
                sub_19598(&stru_63CA0, "load_temp_cutoffs", 1145);
                v125 = strtok(0, ",");
              }
              while ( v125 );
              if ( v126 != 1 )
                goto LABEL_198;
            }
            else
            {
              v126 = 0;
              v128 = 0;
            }
            sub_1A4EC(&stru_63CA0, "load_temp_cutoffs", 1162);
            v194 = *v298;
            v195 = dword_63CC0;
            while ( v126 < v195 )
            {
              v196 = *(_DWORD *)(v194 + 4 * v126++);
              *(_DWORD *)(v196 + 184) = v128;
            }
            sub_19598(&stru_63CA0, "load_temp_cutoffs", 1165);
            goto LABEL_198;
          }
          v298 = &dword_63BC8;
          sub_1A4EC(&stru_63CA0, "load_temp_cutoffs", 1150);
          v160 = 0;
          v161 = dword_63BC8;
          v162 = dword_63CC0;
          while ( v160 < v162 )
          {
            v163 = *(_DWORD *)(v161 + 4 * v160++);
            if ( !*(_DWORD *)(v163 + 184) )
              *(_DWORD *)(v163 + 184) = 95;
          }
          sub_19598(&stru_63CA0, "load_temp_cutoffs", 1156);
LABEL_198:
          if ( dword_63CC0 > 0 )
          {
            v133 = (int *)*v298;
            v134 = *v298 + 4 * dword_63CC0;
            do
            {
              v135 = *v133++;
              *(_DWORD *)(v135 + 312) = 99999999;
            }
            while ( v133 != (int *)v134 );
          }
          if ( !byte_63EE0 )
          {
            dword_612FC += dword_6130C;
            dword_61304 = dword_612FC + 1;
            sub_191C4();
          }
          if ( !dword_63740 )
          {
            if ( *v294 || byte_630C0 || dword_60964 > 3 )
            {
              v136 = s;
              *(_DWORD *)s = *(_DWORD *)"Need to specify at least one pool server.";
              strcpy(v136 + 4, " to specify at least one pool server.");
              sub_38438(4, s, 0);
            }
            if ( !*((_BYTE *)v293 + 2028) || !sub_26934(0) )
            {
              v137 = s;
              *(_DWORD *)s = *(_DWORD *)"Pool setup failed";
              strcpy(v137 + 4, " setup failed");
              sub_38438(3, s, 1);
              sub_1C160(1, 0);
            }
          }
          if ( dword_63740 > 0 )
          {
            v138 = 0;
            v139 = v99;
            do
            {
              v140 = *(_DWORD *)(dword_639E0 + 4 * v138);
              v141 = *(_DWORD *)(v140 + 168);
              *(_DWORD *)(v140 + 396) = 99999999;
              *(_DWORD *)(v140 + 432) = 99999999;
              if ( !v141 )
              {
                if ( !*(_DWORD *)(v140 + 176) )
                  *(_DWORD *)(v140 + 176) = calloc(1u, 1u);
                v142 = *(const char **)(v140 + 172);
                if ( !v142 )
                {
                  snprintf(
                    s,
                    0x800u,
                    "No login credentials supplied for pool %u %s",
                    v138,
                    *(const char **)(v140 + 164));
                  sub_38438(3, s, 1);
                  sub_1C160(1, 0);
                }
                v143 = strlen(*(const char **)(v140 + 172));
                v289 = *(const char **)(v140 + 176);
                v144 = v143 + strlen(v289) + 2;
                v145 = (char *)malloc(v144);
                *(_DWORD *)(v140 + 168) = v145;
                if ( !v145 )
                {
                  v286 = s;
                  *(_DWORD *)s = *(_DWORD *)"Failed to malloc userpass";
                  strcpy(v286 + 4, "ed to malloc userpass");
                  sub_38438(3, s, 1);
                  sub_1C160(1, 0);
                }
                snprintf(v145, v144, "%s:%s", v142, v289);
              }
              ++v138;
            }
            while ( dword_63740 > v138 );
            v99 = v139;
          }
          v147 = (unsigned __int8)*v294;
          dword_61310 = *(_DWORD *)dword_639E0;
          if ( v147 )
            openlog("cgminer", 1, 8);
          if ( *(int *)((char *)v99 + 0xFFFFFFA8) )
          {
            if ( pipe((int *)s) < 0 )
            {
              perror("pipe - failed to create pipe for --monitor");
              exit(1);
            }
            fflush((FILE *)stderr);
            if ( dup2(v302[1], 2) < 0 )
            {
              perror("dup2 - failed to alias stderr to write end of pipe for --monitor");
              exit(1);
            }
            if ( close(v302[1]) < 0 )
            {
              perror("close - failed to close write end of pipe for --monitor");
              exit(1);
            }
            v148 = signal(13, (__sighandler_t)1);
            v149 = signal(13, (__sighandler_t)1);
            v150 = (__sighandler_t)((char *)v149 + 1) == 0;
            if ( v149 != (__sighandler_t)-1 )
              v150 = (__sighandler_t)((char *)v148 + 1) == 0;
            if ( v150 )
            {
              perror("signal - failed to edit signal mask for --monitor");
              exit(1);
            }
            v151 = fork();
            v152 = v151;
            dword_61418 = v151;
            if ( v151 < 0 )
            {
              perror("fork - failed to fork child process for --monitor");
              exit(1);
            }
            if ( !v151 )
            {
              if ( dup2(v302[0], v151) >= 0 )
              {
                close(v302[0]);
                execl("/bin/bash", "/bin/bash", "-c", dword_62E28, v152);
                perror("execl - in child failed to exec user specified command for --monitor");
                exit(1);
              }
              perror("dup2 - in child, failed to alias read end of pipe to stdin for --monitor");
              exit(1);
            }
            if ( close(v302[0]) < 0 )
            {
              perror("close - failed to close read end of pipe for --monitor");
              exit(1);
            }
          }
          dword_63B80 = (int)calloc(dword_6410C, 4u);
          if ( !dword_63B80 )
          {
            v283 = s;
            *(_DWORD *)s = *(_DWORD *)"Failed to calloc mining_thr";
            strcpy(v283 + 4, "ed to calloc mining_thr");
            goto LABEL_485;
          }
          for ( j = 0; j < dword_6410C; ++j )
          {
            v165 = dword_63B80;
            *(_DWORD *)(v165 + 4 * j) = calloc(1u, 0x40u);
            if ( !*(_DWORD *)(dword_63B80 + 4 * j) )
            {
              snprintf(s, 0x800u, "Failed to calloc mining_thr[%d]", j);
LABEL_485:
              v197 = s;
LABEL_325:
              sub_38438(3, v197, 1);
              sub_1C160(1, 0);
            }
          }
          v166 = 0;
          v297 = (int)v99;
          for ( k = 0; k < dword_63CC0; ++k )
          {
            v168 = 0;
            v169 = *(_DWORD **)(*v298 + 4 * k);
            v170 = v169[37];
            v171 = malloc(4 * (v170 + 1));
            v169[38] = v171;
            v171[v170] = 0;
            v172 = v169[37];
            v169[24] = 4;
            if ( v172 > 0 )
            {
              do
              {
                v173 = (_DWORD *)sub_1C36C(v166);
                *v173 = v166;
                v174 = v173;
                v173[9] = v169;
                v173[1] = v168;
                if ( (*(int (**)(void))(v169[1] + 44))() )
                {
                  if ( sub_2F0EC(v174, 0, sub_11A5C, v174) )
                  {
                    snprintf(s, 0x800u, "thread %d create failed", *v174);
                    sub_38438(3, s, 1);
                    sub_1C160(1, 0);
                  }
                  *(_DWORD *)(v169[38] + 4 * v168) = v174;
                  if ( v169[8] != 1 )
                  {
                    if ( byte_630C1 && (*v294 || byte_630C0 || dword_60964 > 6) )
                    {
                      snprintf(s, 0x800u, "Pushing sem post to thread %d", *v174);
                      sub_38438(7, s, 0);
                    }
                    sub_2F134(v174 + 4, "cgminer.c", "main", 11102);
                  }
                }
                ++v168;
                ++v166;
              }
              while ( v169[37] > v168 );
            }
          }
          v175 = v297;
          if ( byte_615C9 || (v176 = dword_612AC) != 0 )
          {
LABEL_298:
            v177 = (int *)&unk_61380;
            dbl_63268 = 0.0;
            do
            {
              *(_QWORD *)v177 = 0;
              v177 += 2;
            }
            while ( v177 != &dword_613E0 );
            v178 = dword_63CC0;
            v179 = 0;
            dword_613E0 = 0;
            v180 = *v298;
            while ( v179 < v178 )
            {
              v181 = *(_DWORD *)(v180 + 4 * v179++);
              *(_QWORD *)(v181 + 80) = 0;
              *(_QWORD *)(v181 + 48) = 0;
            }
            sub_2B13C(&dword_61370, v179, 0, 0);
            sub_2B13C(&dword_613E4, v182, v183, v184);
            sub_2B13C(&unk_61378, v185, v186, v187);
            sub_14D9C(&unk_613EC, 40, &dword_61370);
            dword_61420 = 2;
            v188 = dword_636A4;
            if ( sub_2F0EC(dword_636A4 + 128, 0, sub_21364, 0) )
            {
              v275 = s;
              *(_DWORD *)s = *(_DWORD *)"watchpool thread create failed";
              strcpy(v275 + 4, "hpool thread create failed");
              sub_38438(3, s, 1);
              sub_1C160(1, 0);
            }
            pthread_detach(*(_DWORD *)(v188 + 140));
            dword_61424 = 3;
            v289 = (const char *)dword_636A4;
            if ( sub_2F0EC(dword_636A4 + 192, 0, sub_23018, 0) )
            {
              v198 = s;
              *(_DWORD *)s = *(_DWORD *)"watchdog thread create failed";
              strcpy(v198 + 4, "hdog thread create failed");
              sub_38438(3, s, 1);
              sub_1C160(1, 0);
            }
            pthread_detach(*((_DWORD *)v289 + 51));
            dword_611A8 = 5;
            if ( sub_2F0EC(dword_636A4 + 320, 0, sub_11CBC, dword_636A4 + 320) )
            {
              v274 = s;
              *(_DWORD *)s = *(_DWORD *)"API thread create failed";
              strcpy(v274 + 4, "thread create failed");
LABEL_309:
              sub_38438(3, s, 1);
              sub_1C160(1, 0);
            }
            v189 = dword_636A4;
            *(_DWORD *)(v175 + 0xFFFFFFAC) = 7;
            if ( sub_2F0EC(v189 + 448, 0, sub_276A8, v189 + 448) )
            {
              v273 = s;
              *(_DWORD *)s = *(_DWORD *)"input thread create failed";
              strcpy(v273 + 4, "t thread create failed");
              sub_38438(3, s, 1);
              sub_1C160(1, 0);
            }
            pthread_detach(*(_DWORD *)(v189 + 460));
            if ( dword_62E20 != 8 )
            {
              snprintf(s, 0x800u, "incorrect total_control_threads (%d) should be 8", dword_62E20);
              goto LABEL_309;
            }
            if ( nice(-10) )
            {
              v292 = &byte_630C0;
              v290 = &dword_60964;
              v295 = (const char **)&byte_630C1;
            }
            else
            {
              v295 = (const char **)&byte_630C1;
              if ( byte_630C1 )
              {
                v201 = (unsigned __int8)*v294;
                v292 = &byte_630C0;
                if ( v201 || byte_630C0 )
                {
                  v290 = &dword_60964;
                }
                else
                {
                  v290 = &dword_60964;
                  if ( dword_60964 <= 6 )
                    goto LABEL_333;
                }
                v202 = s;
                *(_DWORD *)s = *(_DWORD *)"Unable to set thread to high priority";
                strcpy(v202 + 4, "le to set thread to high priority");
                sub_38438(7, s, 0);
              }
              else
              {
                v292 = &byte_630C0;
                v290 = &dword_60964;
              }
            }
LABEL_333:
            v297 = 0;
            v291 = (void (**)(void))&off_60178;
            while ( 1 )
            {
              while ( 1 )
              {
                v203 = v293[504];
                if ( byte_63E4C )
                {
                  v244 = *(unsigned __int8 *)v295;
                  if ( *(_BYTE *)v295 )
                  {
                    if ( *v294 || *v292 || (v244 = *v290, *v290 > 6) )
                    {
                      v245 = s;
                      *(_DWORD *)s = *(_DWORD *)"Work update message received";
                      strcpy(v245 + 4, " update message received");
                      sub_38438(7, s, 0);
                    }
                  }
                  sub_2B13C(&unk_611BC, v199, v200, v244);
                  if ( pthread_rwlock_rdlock(&rwlock) )
                    sub_B76C("signal_work_update", 5292);
                  if ( dword_6410C > 0 )
                  {
                    v246 = (int *)dword_63B80;
                    v247 = dword_63B80 + 4 * dword_6410C;
                    do
                    {
                      v248 = *v246++;
                      *(_BYTE *)(v248 + 63) = 1;
                    }
                    while ( v246 != (int *)v247 );
                  }
                  if ( pthread_rwlock_unlock(&rwlock) )
                    sub_B700("signal_work_update", 5295);
                  (*v291)();
                }
                byte_63E4C = 0;
                ((void (*)(void))sub_1D644)();
                if ( pthread_mutex_lock((pthread_mutex_t *)dword_612C8) )
                  sub_B4E4("main", 11239);
                v204 = dword_612CC;
                if ( dword_612CC )
                  v204 = *(_DWORD *)(*(_DWORD *)(dword_612CC + 344) + 12);
                if ( v203 < v204 )
                {
                  if ( byte_612D2 )
                  {
                    v205 = v293[504];
                    if ( v205 < v293[505] )
                    {
                      dword_60070 = v205 + 1;
                      byte_612D2 = 0;
                    }
                  }
                  byte_612D1 = 1;
                  pthread_cond_wait(&stru_63748, (pthread_mutex_t *)dword_612C8);
                  v204 = dword_612CC;
                  if ( dword_612CC )
                    v204 = *(_DWORD *)(*(_DWORD *)(dword_612CC + 344) + 12);
                }
                if ( pthread_mutex_unlock((pthread_mutex_t *)dword_612C8) )
                  sub_B694("main", 11257);
                v206 = ((int (*)(void))*v291)();
                if ( v204 <= v203 )
                  break;
                if ( byte_612D2 )
                {
                  v207 = &dword_5F890;
                  v208 = v293[504];
                  if ( v208 < v293[505] )
                  {
                    dword_60070 = v208 + 1;
                    byte_612D2 = 0;
                  }
                }
                byte_612D1 = 1;
                v209 = sub_17A14(0, v207);
                v297 = v209;
                if ( v209 )
                {
                  sub_154EC(v209);
                  v297 = 0;
                }
              }
              if ( v297 )
                v206 = sub_154EC(v297);
              v297 = sub_19DA0(v206);
              v210 = ((int (*)(void))sub_1D644)();
              v211 = (int *)v210;
              if ( dword_611AC == 4 )
              {
                v210 = sub_11DA8();
                v211 = (int *)v210;
              }
              else if ( dword_611AC == 3 )
              {
                v200 = dword_63740;
                if ( dword_63740 <= 0 )
                  goto LABEL_436;
                v199 = *(_DWORD *)(*(_DWORD *)dword_639E0 + 60);
                if ( v199 <= *(_DWORD *)(*(_DWORD *)dword_639E0 + 64) )
                {
                  v250 = (int *)dword_639E0;
                  v210 = dword_639E0;
                  v251 = 0;
                  while ( ++v251 != dword_63740 )
                  {
                    v252 = *(_DWORD *)(v210 + 4);
                    v210 += 4;
                    v199 = *(_DWORD *)(v252 + 60);
                    if ( *(_DWORD *)(v252 + 64) < v199 )
                      goto LABEL_438;
                  }
                  v253 = dword_639E0 + 4 * dword_63740;
                  do
                  {
                    v254 = *v250++;
                    *(_DWORD *)(v254 + 64) = 0;
                  }
                  while ( v250 != (int *)v253 );
LABEL_436:
                  v199 = (int)byte_62E80;
                  v255 = *(_DWORD *)(v175 + 0xFFFFFFB0) + 1;
                  *(_DWORD *)(v175 + 0xFFFFFFB0) = v255;
                  if ( v255 >= v200 )
                    dword_62E30 = 0;
                }
LABEL_438:
                v256 = 0;
                while ( 1 )
                {
                  v76 = v256++ < v200;
                  if ( !v76 )
                    break;
                  v258 = *(_DWORD *)(v175 + 0xFFFFFFB0);
                  v210 = *(_DWORD *)(dword_639E0 + 4 * v258);
                  v199 = *(_DWORD *)(v210 + 64);
                  v259 = *(_DWORD *)(v210 + 60);
                  *(_DWORD *)(v210 + 64) = v199 + 1;
                  if ( v199 < v259 )
                  {
                    if ( !*(_BYTE *)(v210 + 97) && *(_DWORD *)(v210 + 100) == 1 )
                    {
                      v199 = *(unsigned __int8 *)(v210 + 632);
                      if ( !*(_BYTE *)(v210 + 632) )
                        goto LABEL_450;
                      v199 = *(unsigned __int8 *)(v210 + 633);
                      if ( *(_BYTE *)(v210 + 633) )
                        goto LABEL_450;
                    }
                    v199 = (unsigned __int8)byte_63BC5;
                    if ( byte_63BC5 )
                    {
                      v210 = sub_11B90(0);
                      v258 = *(_DWORD *)(v175 + 0xFFFFFFB0);
                      v200 = dword_63740;
                      v199 = *(_DWORD *)(v210 + 64) - 1;
                      *(_DWORD *)(v210 + 64) = v199;
                    }
                  }
                  v257 = v258 + 1;
                  *(_DWORD *)(v175 + 0xFFFFFFB0) = v257;
                  if ( v257 >= v200 )
                    dword_62E30 = 0;
                }
                if ( v200 > 0 )
                {
                  v260 = 0;
                  while ( 1 )
                  {
                    v210 = sub_11B90(v260);
                    if ( !*(_BYTE *)(v210 + 97) && *(_DWORD *)(v210 + 100) == 1 )
                      break;
                    if ( ++v260 >= dword_63740 )
                      goto LABEL_355;
                  }
LABEL_450:
                  v211 = (int *)v210;
                }
              }
LABEL_355:
              if ( *(_BYTE *)v295 && (*v294 || *v292 || *v290 > 6) )
              {
                snprintf(s, 0x800u, "Selecting pool %d for work", *v211);
                v210 = sub_38438(7, s, 0);
              }
              if ( *((_BYTE *)v211 + 632) )
              {
                while ( !*((_BYTE *)v211 + 633) || !*((_BYTE *)v211 + 635) )
                {
                  v298 = (int *)sub_1D644(v210);
                  if ( dword_611AC == 4 )
                  {
                    v298 = (int *)sub_11DA8();
                  }
                  else if ( dword_611AC == 3 || !byte_63BC5 )
                  {
                    v212 = dword_63740;
                    if ( dword_63740 <= 0 )
                      goto LABEL_374;
                    if ( *(_DWORD *)(*(_DWORD *)dword_639E0 + 60) <= *(_DWORD *)(*(_DWORD *)dword_639E0 + 64) )
                    {
                      v213 = (int *)dword_639E0;
                      v214 = dword_639E0;
                      v215 = 0;
                      while ( ++v215 != dword_63740 )
                      {
                        v216 = *(_DWORD *)(v214 + 4);
                        v214 += 4;
                        if ( *(_DWORD *)(v216 + 64) < *(_DWORD *)(v216 + 60) )
                          goto LABEL_376;
                      }
                      v217 = dword_639E0 + 4 * dword_63740;
                      do
                      {
                        v218 = *v213++;
                        *(_DWORD *)(v218 + 64) = 0;
                      }
                      while ( v213 != (int *)v217 );
LABEL_374:
                      v219 = *(_DWORD *)(v175 + 0xFFFFFFB0) + 1;
                      *(_DWORD *)(v175 + 0xFFFFFFB0) = v219;
                      if ( v219 >= v212 )
                        dword_62E30 = 0;
                    }
LABEL_376:
                    v220 = 0;
                    while ( 1 )
                    {
                      v76 = v220++ < v212;
                      if ( !v76 )
                        break;
                      v222 = *(_DWORD *)(v175 + 0xFFFFFFB0);
                      v223 = *(_DWORD *)(dword_639E0 + 4 * v222);
                      v224 = *(_DWORD *)(v223 + 64);
                      v225 = *(_DWORD *)(v223 + 60);
                      *(_DWORD *)(v223 + 64) = v224 + 1;
                      if ( v224 < v225 )
                      {
                        if ( !*(_BYTE *)(v223 + 97)
                          && *(_DWORD *)(v223 + 100) == 1
                          && (!*(_BYTE *)(v223 + 632) || *(_BYTE *)(v223 + 633)) )
                        {
                          goto LABEL_388;
                        }
                        if ( byte_63BC5 )
                        {
                          v226 = sub_11B90(0);
                          v222 = *(_DWORD *)(v175 + 0xFFFFFFB0);
                          v212 = dword_63740;
                          --*(_DWORD *)(v226 + 64);
                        }
                      }
                      v221 = v222 + 1;
                      *(_DWORD *)(v175 + 0xFFFFFFB0) = v221;
                      if ( v221 >= v212 )
                        dword_62E30 = 0;
                    }
                    if ( v212 > 0 )
                    {
                      v249 = 0;
                      while ( 1 )
                      {
                        v223 = sub_11B90(v249);
                        if ( !*(_BYTE *)(v223 + 97) && *(_DWORD *)(v223 + 100) == 1 )
                          break;
                        if ( ++v249 >= dword_63740 )
                          goto LABEL_389;
                      }
LABEL_388:
                      v298 = (int *)v223;
                    }
                  }
LABEL_389:
                  if ( *(_BYTE *)v295 && (*v294 || *v292 || *v290 > 6) )
                  {
                    snprintf(s, 0x800u, "Selecting pool %d for work", *v298);
                    sub_38438(7, s, 0);
                  }
                  v210 = sub_2B21C(5000);
                  if ( v211 != v298 )
                  {
                    v211 = v298;
                    if ( !*((_BYTE *)v298 + 632) )
                      goto LABEL_396;
                  }
                }
                sub_1A514(v211, v297);
                if ( *(_BYTE *)v295 && (*v294 || *v292 || *v290 > 6) )
                {
                  v242 = s;
                  *(_DWORD *)s = *(_DWORD *)"Generated stratum work";
                  strcpy(v242 + 4, "rated stratum work");
                  sub_38438(7, s, 0);
                }
LABEL_409:
                v243 = v297;
                v297 = 0;
                sub_1ED4C(v243);
              }
              else
              {
LABEL_396:
                if ( dword_612AC )
                {
                  v227 = v297 + 400;
                  sub_16CD0();
                  v228 = v297;
                  v229 = (int *)dword_639E0;
                  *(_BYTE *)(v297 + 282) = 1;
                  v230 = *v229;
                  *(_DWORD *)(v228 + 260) = v230;
                  sub_2B13C(v227, v231, 1, v230);
                  sub_2AE20(v228 + 408, v227);
                  v232 = v297;
                  *(_BYTE *)(v228 + 440) = 66;
                  sub_113C4(v232);
                  if ( !*(_BYTE *)v295 || !*v294 && !*v292 && *v290 <= 6 )
                    goto LABEL_409;
                  v233 = "Generated benchfile work";
                  goto LABEL_402;
                }
                if ( byte_615C9 )
                {
                  v261 = v297;
                  *(_QWORD *)(v297 + 376) = 0x4040000000000000LL;
                  v262 = (int *)dword_639E0;
                  v263 = dword_629EC[0];
                  v264 = dword_629EC[1];
                  v265 = dword_629EC[2];
                  v266 = dword_629EC[3];
                  *(_DWORD *)(v261 + 244) = 0;
                  *(_BYTE *)(v261 + 282) = 1;
                  *(_DWORD *)(v261 + 160) = v263;
                  *(_DWORD *)(v261 + 164) = v264;
                  *(_DWORD *)(v261 + 168) = v265;
                  *(_DWORD *)(v261 + 172) = v266;
                  v267 = unk_629FC;
                  v268 = unk_62A00;
                  v269 = unk_62A04;
                  v270 = unk_62A08;
                  *(_DWORD *)(v261 + 184) = unk_62A04;
                  *(_DWORD *)(v261 + 176) = v267;
                  *(_DWORD *)(v261 + 180) = v268;
                  *(_DWORD *)(v261 + 188) = v270;
                  v271 = *v262;
                  *(_DWORD *)(v261 + 260) = *v262;
                  sub_2B13C(v261 + 400, v268, v269, v271);
                  sub_2AE20(v261 + 408, v261 + 400);
                  v272 = v295;
                  *(_BYTE *)(v261 + 440) = 66;
                  if ( !*(_BYTE *)v272 || !*v294 && !*v292 && *v290 <= 6 )
                    goto LABEL_409;
                  v233 = "Generated benchmark work";
LABEL_402:
                  v234 = *(_DWORD *)v233;
                  v235 = *((_DWORD *)v233 + 1);
                  v236 = *((_DWORD *)v233 + 2);
                  v237 = *((_DWORD *)v233 + 3);
                  v238 = v233 + 16;
                  v239 = s;
                  *(_DWORD *)s = v234;
                  *((_DWORD *)v239 + 1) = v235;
                  *((_DWORD *)v239 + 2) = v236;
                  *((_DWORD *)v239 + 3) = v237;
                  v239 += 16;
                  v240 = v238[1];
                  v241 = v238[2];
                  *(_DWORD *)v239 = *v238;
                  *((_DWORD *)v239 + 1) = v240;
                  v239[8] = v241;
                  sub_38438(7, s, 0);
                  goto LABEL_409;
                }
              }
            }
          }
          v190 = dword_639E0;
          v191 = dword_63740;
          while ( v176 < v191 )
          {
            v192 = *(_DWORD *)(v190 + 4 * v176++);
            v193 = *(_DWORD *)(v192 + 100);
            *(_BYTE *)(v192 + 97) = 1;
            if ( v193 != 1 )
            {
              *(_DWORD *)(v192 + 100) = 1;
              ++dword_63B84;
            }
          }
          if ( byte_630C1 && (*v294 || byte_630C0 || dword_60964 > 6) )
          {
            v276 = s;
            *(_DWORD *)s = *(_DWORD *)"Probing for an alive pool";
            strcpy(v276 + 4, "ing for an alive pool");
            sub_38438(7, s, 0);
          }
          for ( m = 0; m < dword_63740; ++m )
          {
            v278 = *(_DWORD *)(dword_639E0 + 4 * m);
            *(_BYTE *)(v278 + 284) = 1;
            pthread_create((pthread_t *)(v278 + 280), 0, start_routine, (void *)v278);
          }
          v279 = 60;
          while ( 1 )
          {
            sleep(1u);
            if ( byte_615C8 )
              break;
            if ( !--v279 )
              goto LABEL_490;
          }
          v279 = 0;
LABEL_490:
          v280 = s;
          v281 = v294;
          while ( 1 )
          {
            if ( byte_615C8 )
              goto LABEL_298;
            if ( !v279 )
            {
              if ( ((*v281 || byte_630C0 || dword_60964 > 2)
                 && ((strcpy(v280, "No servers were found that could be used to get work from."),
                      sub_38438(3, v280, 0),
                      *v281)
                  || byte_630C0)
                 || dword_60964 > 2)
                && ((strcpy(v280, "Please check the details from the list below of the servers you have input"),
                     sub_38438(3, v280, 0),
                     *v281)
                 || byte_630C0)
                || dword_60964 > 2 )
              {
                strcpy(
                  v280,
                  "Most likely you have input the wrong URL, forgotten to add a port, or have not set up workers");
                sub_38438(3, v280, 0);
              }
              for ( n = 0; n < dword_63740; ++n )
              {
                if ( *v281 || byte_630C0 || dword_60964 > 3 )
                {
                  snprintf(
                    v280,
                    0x800u,
                    "Pool: %d  URL: %s  User: %s  Password: %s",
                    n,
                    *(const char **)(*(_DWORD *)(dword_639E0 + 4 * n) + 164),
                    *(const char **)(*(_DWORD *)(dword_639E0 + 4 * n) + 172),
                    *(const char **)(*(_DWORD *)(dword_639E0 + 4 * n) + 176));
                  sub_38438(4, v280, 0);
                }
              }
              if ( !*((_BYTE *)v293 + 2028) )
              {
LABEL_524:
                v285 = s;
                *(_DWORD *)s = *(_DWORD *)"No servers could be used! Exiting.";
                strcpy(v285 + 4, "ervers could be used! Exiting.");
                sub_38438(3, s, 1);
                sub_1C160(0, 0);
              }
              if ( !*v281 && !byte_630C0 && dword_60964 <= 2 )
              {
                v279 = 1;
                goto LABEL_518;
              }
              v279 = 1;
              strcpy(v280, "Press any key to exit, or cgminer will wait indefinitely for an alive pool.");
              sub_38438(3, v280, 0);
            }
            if ( !*((_BYTE *)v293 + 2028) )
              goto LABEL_524;
LABEL_518:
            if ( dword_639D8 )
              v284 = *(__int16 *)(dword_639D8 + 4);
            else
              v284 = -1;
            v289 = (const char *)&dword_639D8;
            if ( dword_639D8 )
              ++v284;
            wtouchln((WINDOW *)dword_639D8, 0, v284, 1);
            wrefresh(*(WINDOW **)v289);
            halfdelay(10);
            if ( wgetch((WINDOW *)stdscr) != -1 )
              goto LABEL_524;
            cbreak();
          }
        }
        if ( byte_630C1 && (*v294 || byte_630C0 || dword_60964 > 6) )
        {
          snprintf(s, 0x800u, "Loaded configuration file %s", (const char *)dword_611D4);
          sub_38438(7, s, 0);
        }
        if ( dword_612A4 == -1 )
        {
          if ( *v294 || byte_630C0 || dword_60964 > 3 )
          {
            v131 = s;
            *(_DWORD *)s = *(_DWORD *)"Error in configuration file, partially loaded.";
            strcpy(v131 + 4, "r in configuration file, partially loaded.");
            sub_38438(4, s, 0);
          }
          if ( *((_BYTE *)v293 + 2028) && (*v294 || byte_630C0 || dword_60964 > 3) )
          {
            v132 = s;
            *(_DWORD *)s = *(_DWORD *)"Start cgminer with -T to see what failed to load.";
            strcpy(v132 + 4, "t cgminer with -T to see what failed to load.");
            sub_38438(4, s, 0);
          }
          goto LABEL_166;
        }
        if ( !dword_612A4 )
        {
          if ( *v294 || byte_630C0 || (v290 = &dword_60964, dword_60964 > 3) )
          {
            v146 = s;
            *(_DWORD *)s = *(_DWORD *)"Fatal JSON error in configuration file.";
            strcpy(v146 + 4, "l JSON error in configuration file.");
            sub_38438(4, s, 0);
            if ( *v294 || byte_630C0 )
              goto LABEL_165;
            v290 = &dword_60964;
          }
          if ( *v290 > 3 )
          {
LABEL_165:
            v120 = s;
            *(_DWORD *)s = *(_DWORD *)"Configuration file could not be used.";
            strcpy(v120 + 4, "iguration file could not be used.");
            sub_38438(4, s, 0);
          }
        }
LABEL_166:
        free((void *)dword_611D4);
        dword_611D4 = 0;
        goto LABEL_167;
      }
      v60 = 24 * *(_DWORD *)(v59 + 4);
      v61 = malloc(v60);
      v62 = v61;
      if ( v61 )
      {
        memset(v61, 0, v60);
        *(_DWORD *)(v59 + 24) = (((2 * *(_DWORD *)(v59 + 4) - 1) & *(_DWORD *)(v59 + 12)) != 0)
                              + (*(_DWORD *)(v59 + 12) >> (*(_BYTE *)(v59 + 8) + 1));
        *(_DWORD *)(*((_DWORD *)v20 + 17) + 28) = 0;
        v63 = (_DWORD *)*((_DWORD *)v20 + 17);
        v64 = v63[1];
        v65 = v63;
        if ( v64 )
        {
          v298 = 0;
          v297 = 0;
          do
          {
            v66 = *(_DWORD **)((char *)v298 + *v63);
            if ( v66 )
            {
              for ( ii = v64; ; ii = v65[1] )
              {
                v68 = (_DWORD *)v66[4];
                v69 = 3 * ((2 * ii - 1) & v66[7]);
                v70 = (char *)&v62[v69];
                v71 = *((_DWORD *)v70 + 1) + 1;
                *((_DWORD *)v70 + 1) = v71;
                if ( v71 > v65[6] )
                {
                  ++v65[7];
                  *((_DWORD *)v70 + 2) = sub_48EC0(*((_DWORD *)v70 + 1), *(_DWORD *)(*((_DWORD *)v20 + 17) + 24));
                }
                v66[3] = 0;
                v66[4] = v62[v69];
                v72 = v62[v69];
                if ( v72 )
                  *(_DWORD *)(v72 + 12) = v66;
                v62[v69] = v66;
                if ( !v68 )
                  break;
                v65 = (_DWORD *)*((_DWORD *)v20 + 17);
                v66 = v68;
              }
              v63 = (_DWORD *)*((_DWORD *)v20 + 17);
            }
            v65 = v63;
            v64 = v63[1];
            v76 = v64 > ++v297;
            v298 += 3;
          }
          while ( v76 );
        }
        free((void *)*v63);
        *(_DWORD *)(*((_DWORD *)v20 + 17) + 4) *= 2;
        ++*(_DWORD *)(*((_DWORD *)v20 + 17) + 8);
        **((_DWORD **)v20 + 17) = v62;
        v73 = (_DWORD *)*((_DWORD *)v20 + 17);
        v74 = v73[3];
        v75 = v73[7];
        v76 = v75 > v74 >> 1;
        if ( v75 <= v74 >> 1 )
          v77 = 0;
        else
          v77 = v73[8];
        if ( v76 )
          ++v77;
        v73[8] = v77;
        v78 = *((_DWORD *)v20 + 17);
        if ( *(_DWORD *)(v78 + 32) > 1u )
          *(_DWORD *)(v78 + 36) = 1;
        goto LABEL_57;
      }
LABEL_310:
      exit(-1);
    }
    strcpy((char *)v302, "Failed to create getq");
  }
  sub_38438(3, v302, 1);
  sub_1C160(1, 0);
}

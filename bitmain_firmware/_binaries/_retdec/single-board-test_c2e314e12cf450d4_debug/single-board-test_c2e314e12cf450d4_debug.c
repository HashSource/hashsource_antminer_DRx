//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <assert.h>
#include <errno.h>
#include <fcntl.h>
#include <locale.h>
#include <math.h>
#include <pthread.h>
#include <signal.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stropts.h>
#include <sys/mman.h>
#include <sys/socket.h>
#include <sys/time.h>
#include <unistd.h>

// ---------------- Integer Types Definitions -----------------

typedef int8_t int2_t;

// ----------------- Float Types Definitions ------------------

typedef float float32_t;
typedef double float64_t;

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

struct lconv {
    char *e0;
    char *e1;
    char *e2;
    char *e3;
    char *e4;
    char *e5;
    char *e6;
    char *e7;
    char *e8;
    char *e9;
    char e10;
    char e11;
    char e12;
    char e13;
    char e14;
    char e15;
    char e16;
    char e17;
    char e18;
    char e19;
    char e20;
    char e21;
    char e22;
    char e23;
};

struct timeval {
    int32_t e0;
    int32_t e1;
};

// ------------------- Function Prototypes --------------------

int32_t $d(void);
int32_t _24_d(int32_t i_a1);
int32_t _24_t(void);
int32_t __adddf3(int32_t i_a1, uint32_t i_a2, int32_t i_a3, uint32_t i_a4);
int32_t __aeabi_drsub(int32_t i_a1, int32_t i_a2, int32_t i_a3);
int32_t __aeabi_dsub(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t __aeabi_f2d(int32_t i_a1);
int32_t __aeabi_i2d(int32_t i_a1);
int32_t __aeabi_idiv(int32_t i_a1, int32_t i_a2);
int32_t __aeabi_idiv0(int32_t i_a1, int32_t i_a2);
int32_t __aeabi_idivmod(int32_t i_a1, int32_t i_a2);
int32_t __aeabi_l2d(int32_t i_a1, int32_t i_a2);
int32_t __aeabi_ui2d(int32_t i_a1);
int32_t __aeabi_uidiv(uint32_t i_a1, uint32_t i_a2, int32_t i_a3);
int32_t __aeabi_uidivmod(uint32_t i_a1, uint32_t i_a2);
int32_t __aeabi_ul2d(int32_t i_a1, int32_t i_a2);
int32_t __delete_c_rb_node(int32_t i_a1, int32_t i_a2);
int32_t __do_global_dtors_aux(void);
int32_t __left_rotate(int32_t i_a1, int32_t i_a2);
int32_t __libc_csu_fini(void);
int32_t __libc_csu_init(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t __rb_insert_fixup(int32_t i_a1, int32_t i_a2);
int32_t __rb_remove_fixup(int32_t i_a1, int32_t i_a2);
int32_t __remove_c_rb(int32_t i_a1, int32_t i_a2);
int32_t __right_rotate(int32_t i_a1, int32_t i_a2);
int32_t _fini(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t _init(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t _start(int32_t i_a1, int32_t i_a2);
int32_t add_point(int32_t *p_a1, uint32_t i_a2);
int32_t add_port_to_gpio_map(int32_t i_a1, int32_t i_a2, int32_t i_a3);
int32_t array_copy(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4,
                   int32_t i_a5);
int32_t array_move(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t beeper_flicker(void);
int32_t beeper_off(void);
int32_t beeper_on(void);
int32_t blake32(int32_t i_a1, int32_t i_a2, uint32_t i_a3);
int32_t blake32_close(int32_t i_a1, int32_t i_a2, uint32_t i_a3, int32_t i_a4,
                      uint32_t i_a5);
int32_t blake32_init(int32_t i_a1, int32_t i_a2, int32_t i_a3);
int32_t blake64(int32_t i_a1, int32_t i_a2, uint32_t i_a3, int32_t i_a4);
int32_t blake64_close(int32_t i_a1, int32_t i_a2, uint32_t i_a3, int32_t i_a4,
                      uint32_t i_a5);
int32_t blake64_init(int32_t i_a1, int32_t *p_a2, int32_t *p_a3);
int32_t BM1722_chain_inactive(uint32_t i_a1);
int32_t BM1722_open_core(uint32_t i_a1);
int32_t BM1722_set_address(uint32_t i_a1, int32_t i_a2);
int32_t BM1722_set_address_all(uint32_t i_a1);
int32_t BM1725_chain_inactive(uint32_t i_a1);
int32_t BM1725_open_core(uint32_t i_a1);
int32_t BM1725_set_address(uint32_t i_a1, int32_t i_a2);
int32_t BM1725_set_address_all(uint32_t i_a1);
int32_t board_reset(int32_t i_a1);
int32_t board_reset_high(int32_t i_a1);
int32_t board_reset_low(int32_t i_a1);
int32_t bucket_is_empty(int32_t i_a1, int32_t i_a2);
int32_t buffer_get(int32_t i_a1);
int32_t c2hex(uint32_t i_a1);
int32_t calculate_asic_number(uint32_t i_a1);
int32_t calculate_core_number(uint32_t i_a1);
int32_t calculate_how_many_nonce_per_asic_get(int32_t i_a1, uint32_t i_a2,
                                              uint32_t i_a3);
int32_t calculate_timeout_and_baud(int32_t i_a1, int32_t i_a2, int32_t i_a3,
                                   int32_t i_a4);
int32_t call_gmon_start(void);
int32_t callback_get(int32_t i_a1);
int32_t cgpu_init(void);
int32_t chain_reset(int32_t i_a1);
int32_t chain_reset_high(uint32_t i_a1);
int32_t chain_reset_low(uint32_t i_a1);
int32_t check_BM1722_asic_reg(int32_t i_a1, int32_t i_a2, uint32_t i_a3,
                              int32_t i_a4);
int32_t check_BM1725_asic_reg(int32_t i_a1, int32_t i_a2, uint32_t i_a3,
                              int32_t i_a4);
int32_t check_chain(void);
int32_t check_how_many_uart_data_in_fpga(uint32_t i_a1, int32_t i_a2,
                                         int32_t i_a3, int32_t i_a4);
int32_t check_hw(int32_t i_a1, int32_t i_a2, int32_t i_a3, uint32_t i_a4);
int32_t check_nonce(uint32_t i_a1, int32_t i_a2);
int32_t check_register_value(int32_t i_a1, int32_t i_a2);
int32_t clear_register_value_buf(void);
int32_t clear_uart_rx_fifo(uint32_t i_a1);
int32_t clear_uart_tx_fifo(int32_t i_a1);
int32_t clib_copy(int32_t i_a1, int32_t i_a2, int32_t i_a3);
int32_t clib_get(int32_t i_a1, int32_t i_a2, int32_t i_a3);
int32_t clib_strdup(int32_t i_a1);
int32_t close_i2c(void);
int32_t close_key(void);
int32_t configMiner(void);
int32_t convert_port_to_ui_type(int32_t i_a1);
int32_t convert_ui_type_to_port(uint32_t i_a1);
int32_t CRC16(int32_t *p_a1, int32_t i_a2);
int32_t CRC5(char *p_a1, uint32_t i_a2);
int32_t crc_itu_t_byte(uint32_t i_a1, uint32_t i_a2);
int32_t dcr_uart_send(uint32_t i_a1, char *p_a2, int32_t i_a3);
int32_t debug_node_color(int32_t i_a1, int32_t i_a2);
int32_t debug_verify_properties(int32_t i_a1);
int32_t debug_verify_property_1(int32_t i_a1, int32_t i_a2);
int32_t debug_verify_property_2(int32_t i_a1, int32_t i_a2);
int32_t debug_verify_property_4(int32_t i_a1, int32_t i_a2);
int32_t debug_verify_property_5(int32_t i_a1, int32_t i_a2);
int32_t debug_verify_property_5_helper(int32_t i_a1, int32_t i_a2, int32_t i_a3,
                                       int32_t *p_a4);
int32_t decode_unicode_escape(int32_t i_a1);
int32_t decred_hash_simple(int32_t *p_a1, int32_t *p_a2);
int32_t delete_c_map(int32_t i_a1);
int32_t delete_c_rb(int32_t i_a1);
int32_t delete_clib_object(int32_t i_a1);
int32_t delete_iterator_c_map(int32_t i_a1);
int32_t deregister_tm_clones(int32_t i_a1, int32_t i_a2, int32_t i_a3,
                             char i_a4);
int32_t disable_bypass_mode(void);
int32_t display_arguments(void);
int32_t display_level_result_on_lcd(void);
int32_t do_dump(uint32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t dump_indent(uint32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4,
                    int32_t i_a5);
int32_t dump_string(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t dump_to_file(int32_t i_a1, int32_t i_a2, int32_t i_a3);
int32_t dump_to_strbuffer(int32_t i_a1, int32_t i_a2, int32_t i_a3);
int32_t empty_c_rb(int32_t i_a1);
int32_t enable_bypass_mode(void);
int32_t enable_extended_mode_of_temperature_sensor_chain(uint32_t i_a1);
int32_t enable_PIC16F1704_dc_dc(uint32_t i_a1, uint32_t i_a2, int32_t i_a3);
int32_t enable_read_temperature_from_asic_chain(int32_t i_a1, int32_t i_a2);
int32_t erase_PIC16F1704_app_flash(int32_t i_a1, uint32_t i_a2);
int32_t erase_PIC16F1704_flash(uint32_t i_a1, uint32_t i_a2);
int32_t error_set(int32_t i_a1, int32_t i_a2, char *p_a3, int32_t i_a4);
int32_t exists_c_map(int32_t i_a1, int32_t *p_a2);
int32_t fan_control(uint32_t i_a1);
int32_t fan_get_max_num(void);
int32_t fan_get_max_speed(int32_t i_a1);
int32_t fan_get_realtime_speed(int32_t i_a1);
int32_t fan_init(void);
int32_t fan_uninit(int32_t i_a1);
int32_t find_c_map(int32_t i_a1, int32_t *p_a2, int32_t *p_a3);
int32_t find_c_rb(int32_t i_a1, int32_t i_a2);
int32_t fpga_init(void);
int32_t fpga_read(int32_t i_a1, int32_t *p_a2);
int32_t fpga_uninit(void);
int32_t fpga_write(int32_t i_a1, int32_t i_a2);
int32_t frame_dummy(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t from_locale(int32_t i_a1);
int32_t function_102f2c0(void);
int32_t function_1061830(void);
int32_t function_1062f2c(void);
int32_t function_1062f36(void);
int32_t function_1062f66(void);
int32_t function_10c9a28(void);
int32_t function_10c9a30(void);
int32_t function_10c9a38(void);
int32_t function_11d74(void);
int32_t function_1209c98(void);
int32_t function_1209cd0(void);
int32_t function_1220ecc(void);
int32_t function_1220ef0(void);
int32_t function_1222e9e(void);
int32_t function_1222f4a(void);
int32_t function_1222f6a(void);
int32_t function_1222fd4(void);
int32_t function_145e726(void);
int32_t function_1499e0(void);
int32_t function_149a18(void);
int32_t function_149a78(void);
int32_t function_160dc(void);
int32_t function_18bc54(void);
int32_t function_18d368fa(void);
int32_t function_1a09e88(void);
int32_t function_1a09ec0(void);
int32_t function_1b4b890(void);
int32_t function_1bb4c(void);
int32_t function_209c48(void);
int32_t function_209c80(void);
int32_t function_209dd0(void);
int32_t function_209e08(void);
int32_t function_20cf107(void);
int32_t function_21000303(void);
int32_t function_230060fb(void);
int32_t function_230071fb(void);
int32_t function_2300ff7f(void);
int32_t function_23e0f645(void);
int32_t function_23e8f645(void);
int32_t function_273d6(void);
int32_t function_27464(void);
int32_t function_2746a(void);
int32_t function_2746e(void);
int32_t function_27482(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t function_2749e(void);
int32_t function_274a8(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t function_2750c(int32_t i_a1);
int32_t function_28244(int32_t i_a1);
int32_t function_28b944(void);
int32_t function_2f2c0(void);
int32_t function_303cf248(void);
int32_t function_303f2c0(void);
int32_t function_30b968(void);
int32_t function_30ccf8c7(void);
int32_t function_30cf107(void);
int32_t function_429a68bb(void);
int32_t function_44958(void);
int32_t function_4495c(void);
int32_t function_4603af00(void);
int32_t function_4603af02(void);
int32_t function_461023b8(void);
int32_t function_461079fa(void);
int32_t function_46197080(void);
int32_t function_461a0102(void);
int32_t function_461a2100(void);
int32_t function_461a4603(void);
int32_t function_46268(void);
int32_t function_4626c(void);
int32_t function_46bd0710(void);
int32_t function_4b824(void);
int32_t function_4bb34(void);
int32_t function_54992101(void);
int32_t function_5cb350(void);
int32_t function_5cb660(void);
int32_t function_5cbc78(void);
int32_t function_604434(void);
int32_t function_605d44(void);
int32_t function_60bb3301(void);
int32_t function_610cf248(void);
int32_t function_681b0303(void);
int32_t function_68bbec68(void);
int32_t function_71ba460a(void);
int32_t function_733b2320(void);
int32_t function_733b23ff(void);
int32_t function_737b2300(void);
int32_t function_79fa5499(void);
int32_t function_79fb60bb(void);
int32_t function_79fbec16(void);
int32_t function_90b9b6(void);
int32_t function_92cc(int32_t i_a1, int32_t i_a2, int32_t i_a3);
int32_t function_92fc(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t function_931c(int32_t i_a1, int32_t i_a2, int32_t i_a3);
int32_t function_9348(void);
int32_t function_abdc(int32_t i_a1, int32_t i_a2, int32_t i_a3);
int32_t function_abf8(int32_t i_a1, int32_t i_a2);
int32_t function_ac0c(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t function_ac2c(int32_t i_a1, int32_t i_a2, int32_t i_a3);
int32_t function_ac48(int32_t i_a1);
int32_t function_ac64(void);
int32_t function_b084b580(void);
int32_t function_b0b6b580(void);
int32_t function_b2db68fb(void);
int32_t function_bf00bd80(void);
int32_t function_d49a68(void);
int32_t function_dc7064(void);
int32_t function_e01560bb(void);
int32_t function_e400(void);
int32_t function_e420(void);
int32_t function_e432(int32_t i_a1, int32_t i_a2);
int32_t function_e49a70(void);
int32_t function_e4c2(int32_t i_a1, int32_t i_a2, int32_t i_a3, uint32_t i_a4);
int32_t function_ebc6f7ff(void);
int32_t function_ec9a60(void);
int32_t function_ecb4f7ff(void);
int32_t function_f107d8da(void);
int32_t function_f24160fb(void);
int32_t function_f2480002(void);
int32_t function_f24879fb(void);
int32_t function_f2c023dc(void);
int32_t function_f2c023e8(void);
int32_t function_f2c0303c(void);
int32_t function_f2c051f8(void);
int32_t function_f44f681b(void);
int32_t function_f64579fa(void);
int32_t function_f645ffaf(void);
int32_t function_f7ff3088(void);
int32_t function_f7ff4618(void);
int32_t function_f7ff4619(void);
int32_t function_f7ff461a(void);
int32_t function_fa44f01e(void);
int32_t function_fe449c96(void);
int32_t function_fe80b7be(void);
int32_t function_feadea6e(void);
int32_t function_ff049ef4(void);
int32_t function_ff209ed8(void);
int32_t function_ff20a02a(void);
int32_t function_ff20bc16(void);
int32_t function_ff20bce8(void);
int32_t function_ff20be0e(void);
int32_t function_ff2dea72(void);
int32_t function_ffa04db0(void);
int32_t function_ffa04e00(void);
int32_t function_ffa066c0(void);
int32_t function_ffa06710(void);
int32_t function_ffa0bc1a(void);
int32_t function_ffa0bcc0(void);
int32_t function_ffa0bcc8(void);
int32_t function_ffa0bcec(void);
int32_t function_ffa0be12(void);
int32_t function_ffa0bfd0(void);
int32_t function_ffa0bfd8(void);
int32_t function_ffa0bffc(void);
int32_t function_ffb5ea76(void);
int32_t function_ffe6b02e(void);
int32_t function_fffccc36(void);
int32_t get_BM1722_asic_register(unsigned char i_a1, char i_a2, char i_a3,
                                 char i_a4);
int32_t get_BM1725_asic_register(unsigned char i_a1, char i_a2, char i_a3,
                                 char i_a4);
int32_t get_eeprom_N(int32_t i_a1, int32_t *p_a2);
int32_t get_eth_mac(char *p_a1, int32_t i_a2);
int32_t get_hardware_type(void);
int32_t get_hardware_version(void);
int32_t get_mac(int32_t i_a1);
int32_t get_next_c_map(int32_t i_a1);
int32_t get_PIC16F1704_freq(uint32_t i_a1, uint32_t i_a2, int32_t i_a3);
int32_t get_PIC16F1704_software_version(uint32_t i_a1, uint32_t i_a2,
                                        int32_t i_a3);
int32_t get_PIC16F1704_voltage(uint32_t i_a1, uint32_t i_a2, int32_t i_a3);
int32_t get_pllparam_divider(int32_t i_a1, int32_t i_a2, int32_t i_a3,
                             int32_t i_a4);
int32_t get_raw_clib_object(int32_t i_a1, int32_t *p_a2);
int32_t get_read_address_info(uint32_t i_a1, int32_t *p_a2, int32_t *p_a3,
                              int32_t *p_a4);
int32_t get_send_address_info(uint32_t i_a1, int32_t *p_a2, int32_t *p_a3,
                              int32_t *p_a4);
int32_t get_system_capability(int32_t *p_a1);
int32_t get_temperature_offset_value_from_asic_chain(uint32_t i_a1);
int32_t get_uuid(int32_t i_a1);
int32_t get_value_c_map(int32_t i_a1);
int32_t get_work(int32_t i_a1, int32_t i_a2, int32_t i_a3, uint32_t i_a4);
int32_t get_works(void);
int32_t gpio_compare_e(int32_t i_a1, int32_t i_a2);
int32_t gpio_compare_e2(int32_t i_a1, int32_t i_a2);
int32_t gpio_ctrl_ui(int32_t i_a1, int32_t i_a2);
int32_t gpio_direction(int32_t i_a1, int32_t i_a2);
int32_t gpio_export(int32_t i_a1);
int32_t gpio_init(void);
int32_t gpio_key_callback(int32_t i_a1, uint32_t i_a2);
int32_t gpio_read(int32_t i_a1, char *p_a2);
int32_t gpio_reg_callback(int32_t i_a1, int32_t i_a2);
int32_t gpio_set_led_filker_freq(int32_t i_a1, int32_t i_a2);
int32_t gpio_thread_function(int32_t i_a1);
int32_t gpio_unexport(int32_t i_a1);
int32_t gpio_uninit(void);
int32_t gpio_unreg_callback(int32_t i_a1, int32_t i_a2);
int32_t gpio_write(int32_t i_a1, uint32_t i_a2);
int32_t green_led_flicker(void);
int32_t green_led_off(int32_t i_a1);
int32_t green_led_on(void);
int32_t hal_chain_max_num(void);
int32_t hal_chain_plug_addr(int32_t i_a1);
int32_t hal_chain_reset_addr(int32_t i_a1);
int32_t hal_chain_uart_addr(int32_t i_a1);
int32_t hal_fan_addr(int32_t i_a1);
int32_t hal_fan_max_speed(int32_t i_a1);
int32_t hal_fan_number(void);
int32_t hal_key_ipreport_addr(void);
int32_t hal_key_reset_addr(void);
int32_t hal_led_green_addr(void);
int32_t hal_led_red_addr(void);
int32_t hal_load_conf(int32_t *p_a1);
int32_t hash_str(int32_t i_a1);
int32_t hashtable_clear(int32_t i_a1);
int32_t hashtable_close(int32_t i_a1);
int32_t hashtable_del(int32_t i_a1, int32_t i_a2);
int32_t hashtable_do_clear(int32_t i_a1);
int32_t hashtable_do_del(int32_t i_a1, int32_t i_a2, uint32_t i_a3);
int32_t hashtable_do_rehash(int32_t i_a1);
int32_t hashtable_find_pair(int32_t i_a1, int32_t i_a2, int32_t i_a3,
                            int32_t i_a4);
int32_t hashtable_get(int32_t i_a1, int32_t i_a2);
int32_t hashtable_init(int32_t i_a1);
int32_t hashtable_iter(int32_t i_a1);
int32_t hashtable_iter_at(int32_t i_a1, int32_t i_a2);
int32_t hashtable_iter_key(int32_t i_a1);
int32_t hashtable_iter_next(int32_t i_a1, int32_t i_a2);
int32_t hashtable_iter_serial(int32_t i_a1);
int32_t hashtable_iter_set(int32_t i_a1, int32_t i_a2);
int32_t hashtable_iter_value(int32_t i_a1);
int32_t hashtable_set(uint32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t heart_beat_PIC16F1704(uint32_t i_a1, uint32_t i_a2);
int32_t hexdump(int32_t i_a1, int32_t i_a2, int32_t i_a3);
int32_t i2c_compare_e(int32_t i_a1, int32_t i_a2);
int32_t i2c_init(int32_t i_a1);
int32_t i2c_ioctl(int32_t i_a1, uint32_t i_a2, int32_t i_a3);
int32_t i2c_read(int32_t i_a1, int32_t i_a2, uint32_t i_a3);
int32_t i2c_read_reg(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4,
                     uint32_t i_a5);
int32_t i2c_select(int32_t i_a1, int32_t i_a2);
int32_t i2c_uninit(int32_t i_a1);
int32_t i2c_write(int32_t i_a1, int32_t i_a2, uint32_t i_a3);
int32_t i2c_write_reg(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4,
                      uint32_t i_a5);
int32_t iic_i2c_read(char *p_a1, int32_t i_a2);
int32_t iic_i2c_read_reg(int32_t i_a1, int32_t *p_a2, int32_t i_a3);
int32_t iic_i2c_write(char *p_a1, int32_t i_a2);
int32_t iic_i2c_write_reg(int32_t i_a1, int32_t *p_a2, int32_t i_a3);
int32_t iic_init(int32_t *p_a1);
int32_t iic_read(int32_t i_a1, int32_t i_a2, int32_t i_a3);
int32_t iic_read_reg(int32_t i_a1, char *p_a2, int32_t i_a3, char *p_a4,
                     int32_t i_a5);
int32_t iic_uninit(int32_t i_a1);
int32_t iic_write(int32_t i_a1, int32_t i_a2, int32_t i_a3);
int32_t iic_write_reg(int32_t i_a1, char *p_a2, int32_t i_a3, char *p_a4,
                      int32_t i_a5);
int32_t InitElapsedTime(void);
int32_t insert_c_map(int32_t i_a1, int32_t *p_a2, int32_t i_a3, int32_t *p_a4,
                     int32_t i_a5);
int32_t insert_c_rb(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4,
                    int32_t i_a5);
int32_t insert_to_bucket(int32_t i_a1, int32_t i_a2, int32_t i_a3);
int32_t is_bypass_mode_enable(void);
int32_t is_nonce_or_reg_value(uint32_t i_a1);
int32_t json_array(void);
int32_t json_array_append(int32_t i_a1, int32_t i_a2);
int32_t json_array_append2(int32_t i_a1, int32_t i_a2);
int32_t json_array_append_new(int32_t i_a1, int32_t i_a2);
int32_t json_array_clear(int32_t i_a1);
int32_t json_array_copy(int32_t i_a1);
int32_t json_array_deep_copy(int32_t i_a1);
int32_t json_array_equal(int32_t i_a1, int32_t i_a2);
int32_t json_array_extend(int32_t i_a1, int32_t i_a2);
int32_t json_array_get(int32_t i_a1, uint32_t i_a2);
int32_t json_array_grow(int32_t i_a1, int32_t i_a2, int32_t i_a3);
int32_t json_array_insert_new(int32_t i_a1, uint32_t i_a2, int32_t i_a3);
int32_t json_array_remove(int32_t i_a1, uint32_t i_a2);
int32_t json_array_set_new(int32_t i_a1, uint32_t i_a2, int32_t i_a3);
int32_t json_array_size(int32_t i_a1);
int32_t json_copy(int32_t i_a1);
int32_t json_decref(int32_t i_a1);
int32_t json_decref2(int32_t i_a1);
int32_t json_decref3(int32_t i_a1);
int32_t json_decref4(int32_t i_a1);
int32_t json_deep_copy(int32_t i_a1);
int32_t json_delete(int32_t i_a1);
int32_t json_delete_array(int32_t i_a1);
int32_t json_delete_integer(int32_t i_a1);
int32_t json_delete_object(int32_t i_a1);
int32_t json_delete_real(int32_t i_a1);
int32_t json_delete_string(int32_t i_a1);
int32_t json_dump_callback(int32_t i_a1, int32_t i_a2, int32_t *p_a3,
                           int32_t i_a4);
int32_t json_dump_file(int32_t i_a1, int32_t i_a2, int32_t i_a3);
int32_t json_dumpf(int32_t i_a1, int32_t i_a2, int32_t i_a3);
int32_t json_dumps(int32_t i_a1, int32_t i_a2);
int32_t json_equal(int32_t i_a1, int32_t i_a2);
int32_t json_false(void);
int32_t json_incref(int32_t i_a1);
int32_t json_incref2(int32_t i_a1);
int32_t json_init(int32_t i_a1, int32_t i_a2);
int32_t json_integer(int32_t i_a1, int32_t i_a2);
int32_t json_integer_copy(int32_t i_a1, int32_t i_a2);
int32_t json_integer_equal(int32_t i_a1, int32_t i_a2);
int32_t json_integer_set(int32_t i_a1, int32_t i_a2, int32_t i_a3,
                         int32_t i_a4);
int32_t json_integer_value(int32_t i_a1);
int32_t json_load_callback(int32_t i_a1, int32_t i_a2, int32_t i_a3,
                           int32_t i_a4);
int32_t json_load_file(int32_t i_a1, int32_t i_a2, int32_t *p_a3);
int32_t json_loadb(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t json_loadf(int32_t i_a1, int32_t i_a2, int32_t i_a3);
int32_t json_loads(int32_t i_a1, int32_t i_a2, int32_t i_a3);
int32_t json_null(void);
int32_t json_number_value(int32_t i_a1, int32_t i_a2);
int32_t json_object(void);
int32_t json_object_clear(int32_t i_a1);
int32_t json_object_copy(int32_t i_a1);
int32_t json_object_deep_copy(int32_t i_a1);
int32_t json_object_del(int32_t i_a1, int32_t i_a2);
int32_t json_object_equal(int32_t i_a1, int32_t i_a2);
int32_t json_object_get(int32_t i_a1, char *p_a2);
int32_t json_object_iter(int32_t i_a1);
int32_t json_object_iter_at(int32_t i_a1, int32_t i_a2);
int32_t json_object_iter_key(int32_t i_a1);
int32_t json_object_iter_next(int32_t i_a1, int32_t i_a2);
int32_t json_object_iter_set_new(int32_t i_a1, int32_t i_a2, int32_t i_a3);
int32_t json_object_iter_value(int32_t i_a1);
int32_t json_object_key_to_iter(int32_t i_a1);
int32_t json_object_set_new(int32_t i_a1, int32_t i_a2, int32_t i_a3);
int32_t json_object_set_new_nocheck(int32_t i_a1, int32_t i_a2, int32_t i_a3);
int32_t json_object_set_nocheck(int32_t i_a1, int32_t i_a2, int32_t i_a3);
int32_t json_object_set_nocheck2(int32_t i_a1, int32_t i_a2, int32_t i_a3);
int32_t json_object_size(int32_t i_a1);
int32_t json_object_update(int32_t i_a1, int32_t i_a2);
int32_t json_object_update_existing(int32_t i_a1, int32_t i_a2);
int32_t json_object_update_missing(int32_t i_a1, int32_t i_a2);
int32_t json_real(void);
int32_t json_real_copy(int32_t i_a1);
int32_t json_real_equal(int32_t i_a1, int32_t i_a2);
int32_t json_real_set(int32_t i_a1);
int32_t json_real_value(int32_t i_a1);
int32_t json_set_alloc_funcs(int32_t i_a1, int32_t i_a2);
int32_t json_string(int32_t i_a1);
int32_t json_string_copy(int32_t i_a1);
int32_t json_string_equal(int32_t i_a1, int32_t i_a2);
int32_t json_string_nocheck(int32_t i_a1);
int32_t json_string_set(int32_t i_a1, int32_t i_a2);
int32_t json_string_set_nocheck(int32_t i_a1, int32_t i_a2);
int32_t json_string_value(int32_t i_a1);
int32_t json_true(void);
int32_t jsonp_dtostr(int32_t i_a1, uint32_t i_a2);
int32_t jsonp_error_init(int32_t i_a1, char *p_a2);
int32_t jsonp_error_set(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4,
                        int32_t i_a5, int32_t i_a6);
int32_t jsonp_error_set_source(int32_t i_a1, int32_t i_a2);
int32_t jsonp_error_vset(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4,
                         int32_t i_a5, int32_t i_a6);
int32_t jsonp_free(int32_t i_a1);
int32_t jsonp_malloc(int32_t i_a1);
int32_t jsonp_strdup(int32_t i_a1);
int32_t jsonp_strtod(int32_t i_a1, int32_t *p_a2);
int32_t jump_from_loader_to_app_PIC16F1704(uint32_t i_a1, uint32_t i_a2);
int32_t key_callback(int32_t i_a1, int32_t i_a2);
int32_t lcd_clear(int32_t i_a1);
int32_t lcd_clear_result(void);
int32_t lcd_flush(int32_t i_a1);
int32_t lcd_init(int32_t i_a1);
int32_t lcd_show_result(int32_t i_a1, int32_t i_a2, int32_t i_a3);
int32_t lcd_uninit(int32_t i_a1);
int32_t lcd_write(int32_t i_a1, int32_t i_a2, int32_t i_a3, uint32_t i_a4);
int32_t lex_close(int32_t *p_a1);
int32_t lex_get(int32_t i_a1, int32_t i_a2);
int32_t lex_get_save(int32_t i_a1, int32_t i_a2);
int32_t lex_init(int32_t *p_a1, int32_t i_a2, int32_t *p_a3);
int32_t lex_save(int32_t i_a1, uint32_t i_a2);
int32_t lex_save_cached(int32_t i_a1);
int32_t lex_scan(int32_t i_a1, int32_t i_a2);
int32_t lex_scan_number(int32_t i_a1, int32_t i_a2, int32_t i_a3);
int32_t lex_scan_string(int32_t i_a1, int32_t i_a2);
int32_t lex_steal_string(int32_t i_a1);
int32_t lex_unget(int32_t i_a1, int32_t i_a2);
int32_t lex_unget_unsave(int32_t i_a1, uint32_t i_a2);
int32_t list_init(int32_t i_a1);
int32_t list_insert(int32_t i_a1, int32_t i_a2);
int32_t list_remove(int32_t i_a1);
int32_t malloc_register_buf(void);
int32_t maximum_c_rb(int32_t i_a1, int32_t i_a2);
int32_t minimum_c_map(int32_t i_a1);
int32_t minimum_c_rb(int32_t i_a1, int32_t i_a2);
int32_t new_c_map(int32_t i_a1, int32_t i_a2, int32_t i_a3);
int32_t new_c_rb(int32_t i_a1, int32_t i_a2, int32_t i_a3);
int32_t new_clib_object(int32_t i_a1, int32_t i_a2);
int32_t new_iterator_c_map(int32_t i_a1);
int32_t num_buckets(int32_t i_a1);
int32_t object_key_compare_keys(int32_t i_a1, int32_t i_a2);
int32_t object_key_compare_serials(uint32_t i_a1, uint32_t i_a2);
int32_t open_i2c(void);
int32_t open_key(void);
int32_t parse_array(int32_t i_a1, int32_t i_a2, int32_t i_a3);
int32_t parse_json(int32_t *p_a1, int32_t i_a2, int32_t i_a3);
int32_t parse_object(int32_t i_a1, uint32_t i_a2, int32_t i_a3);
int32_t parse_value(int32_t i_a1, int32_t i_a2, int32_t i_a3);
int32_t PIC1704_update_pic_app_program(int32_t i_a1, uint32_t i_a2);
int32_t pic_heart_beat_func(int32_t i_a1);
int32_t platform_dump_capability(int32_t *p_a1);
int32_t platform_init(void);
int32_t platform_uninit(void);
int32_t power_check_protocal_type(void);
int32_t power_check_reply(int32_t i_a1, int32_t i_a2, int32_t i_a3);
int32_t power_get_adc_value(void);
int32_t power_get_da_value(void);
int32_t power_get_da_value_simple(void);
int32_t power_get_device_no(void);
int32_t power_get_firmware_version(void);
int32_t power_get_voltage(int32_t i_a1);
int32_t power_init(void);
int32_t power_is_support_cmd_package(void);
int32_t power_off(void);
int32_t power_on(void);
int32_t power_read_eeprom_data(uint32_t i_a1, int32_t i_a2, int32_t i_a3);
int32_t power_save_eeprom_data(uint32_t i_a1, int32_t i_a2, int32_t i_a3);
int32_t power_send_cmd(int32_t *p_a1, uint32_t i_a2, int32_t *p_a3,
                       uint32_t i_a4);
int32_t power_set_da_value(uint32_t i_a1);
int32_t power_set_da_value_simple(int32_t i_a1);
int32_t power_set_voltage(uint32_t i_a1);
int32_t print_works(void);
int32_t PrintElapsedTime(int32_t i_a1);
int32_t pwm_get(int32_t i_a1, uint32_t i_a2);
int32_t pwm_init(int32_t i_a1, int32_t i_a2);
int32_t pwm_set(int32_t i_a1, uint32_t i_a2);
int32_t pwm_uninit(int32_t i_a1);
int32_t read_asic_temperature(uint32_t i_a1);
int32_t read_config(void);
int32_t read_hash_id_PIC16F1704(uint32_t i_a1, uint32_t i_a2, int32_t i_a3);
int32_t read_key(int32_t *p_a1);
int32_t read_pic(int32_t i_a1, int32_t i_a2);
int32_t read_PIC16F1704_flash_data(uint32_t i_a1, uint32_t i_a2, int32_t i_a3);
int32_t read_PIC16F1704_flash_point32_ter(uint32_t i_a1, uint32_t i_a2,
                                          int32_t i_a3, int32_t i_a4);
int32_t read_temp_func(int32_t i_a1);
int32_t read_temperature_offset_PIC16F1704(uint32_t i_a1, uint32_t i_a2,
                                           int32_t i_a3);
int32_t read_uart_data_in_fpga(int32_t i_a1, int32_t i_a2, uint32_t i_a3);
int32_t receive_func(int32_t i_a1);
int32_t red_led_flicker(void);
int32_t red_led_off(void);
int32_t red_led_on(void);
int32_t reg_key_callback(int32_t i_a1);
int32_t register_tm_clones(int32_t *p_a1, int32_t i_a2, int32_t i_a3,
                           int32_t i_a4);
int32_t remove_c_map(int32_t i_a1, int32_t *p_a2);
int32_t remove_c_rb(int32_t i_a1, int32_t i_a2);
int32_t remove_port_form_gpio_map(int32_t i_a1, int32_t i_a2);
int32_t replace_raw_clib_object(int32_t i_a1, int32_t i_a2, int32_t i_a3);
int32_t replace_value_c_map(int32_t i_a1, int32_t i_a2, int32_t i_a3);
int32_t reset(void);
int32_t reset_global_arg(void);
int32_t reset_PIC16F1704_pic(uint32_t i_a1, uint32_t i_a2);
int32_t rev(int32_t i_a1, int32_t i_a2);
int32_t s2hex(int32_t i_a1, int32_t i_a2, int32_t i_a3);
int32_t save_byte_to_eeprom(uint32_t i_a1, uint32_t i_a2);
int32_t save_eeprom_N(int32_t i_a1, int32_t i_a2);
int32_t save_freq_PIC16F1704(uint32_t i_a1, uint32_t i_a2, int32_t i_a3);
int32_t save_voltage_info_to_eeprom(int32_t i_a1, int32_t i_a2);
int32_t send_data_to_PIC16F1704(uint32_t i_a1, uint32_t i_a2, int32_t *p_a3);
int32_t send_func(int32_t i_a1);
int32_t set_baud(uint32_t i_a1, uint32_t i_a2);
int32_t set_BM1722_asic_register(uint32_t i_a1, int32_t i_a2, int32_t i_a3,
                                 uint32_t i_a4, int32_t i_a5);
int32_t set_BM1722_freq(int32_t i_a1, int32_t i_a2, int32_t i_a3);
int32_t set_BM1725_asic_register(uint32_t i_a1, int32_t i_a2, int32_t i_a3,
                                 uint32_t i_a4, int32_t i_a5);
int32_t set_BM1725_freq(int32_t i_a1, int32_t i_a2, int32_t i_a3);
int32_t set_default_temperature_offset_value_chain(uint32_t i_a1);
int32_t set_hardware_type(int32_t i_a1);
int32_t set_PIC16F1704_flash_point32_ter(uint32_t i_a1, uint32_t i_a2,
                                         int32_t i_a3, int32_t i_a4);
int32_t set_PIC16F1704_voltage(uint32_t i_a1, uint32_t i_a2, int32_t i_a3);
int32_t set_PWM_according_to_temperature(void);
int32_t set_temperature_offset_value(int32_t i_a1, uint32_t i_a2, char *p_a3);
int32_t set_voltage(int32_t i_a1, int32_t i_a2, uint32_t i_a3, int32_t i_a4);
int32_t show_status_func(int32_t i_a1);
int32_t single_asic_get_result(uint32_t i_a1);
int32_t single_asic_print_lcd(int32_t i_a1, uint32_t i_a2);
int32_t single_board_get_result(int32_t i_a1);
int32_t single_board_print_lcd(uint32_t i_a1);
int32_t singleAsicTest_BM1722(void);
int32_t singleAsicTest_BM1725(void);
int32_t singleBoardTest_BBD12601(void);
int32_t singleBoardTest_BBD25601(void);
int32_t sph_blake224(int32_t i_a1, int32_t i_a2, int32_t i_a3);
int32_t sph_blake224_addbits_and_close(int32_t i_a1, int32_t i_a2, int32_t i_a3,
                                       int32_t i_a4);
int32_t sph_blake224_close(int32_t i_a1, int32_t i_a2);
int32_t sph_blake224_init(int32_t i_a1);
int32_t sph_blake256(int32_t *p_a1, int32_t i_a2, int32_t i_a3);
int32_t sph_blake256_addbits_and_close(int32_t i_a1, int32_t i_a2, int32_t i_a3,
                                       int32_t i_a4);
int32_t sph_blake256_close(int32_t *p_a1, int32_t i_a2);
int32_t sph_blake256_init(int32_t *p_a1);
int32_t sph_blake384(int32_t i_a1, int32_t i_a2, int32_t i_a3);
int32_t sph_blake384_addbits_and_close(int32_t i_a1, int32_t i_a2, int32_t i_a3,
                                       int32_t i_a4);
int32_t sph_blake384_close(int32_t i_a1, int32_t i_a2);
int32_t sph_blake384_init(int32_t i_a1);
int32_t sph_blake512(int32_t i_a1, int32_t i_a2, int32_t i_a3);
int32_t sph_blake512_addbits_and_close(int32_t i_a1, int32_t i_a2, int32_t i_a3,
                                       int32_t i_a4);
int32_t sph_blake512_close(int32_t i_a1, int32_t i_a2);
int32_t sph_blake512_init(int32_t i_a1);
int32_t sph_bswap32(int32_t i_a1);
int32_t sph_bswap64(int64_t i_a1, int32_t i_a2);
int32_t sph_dec32be_aligned(int32_t i_a1);
int32_t sph_dec64be_aligned(int32_t i_a1);
int32_t sph_enc32be(int32_t i_a1, uint32_t i_a2);
int32_t sph_enc32be_aligned(int32_t *p_a1, int32_t i_a2);
int32_t sph_enc64be(int32_t i_a1, int32_t i_a2, int64_t i_a3, int64_t i_a4);
int32_t sph_enc64be_aligned(int32_t *p_a1, int32_t i_a2, int64_t i_a3,
                            int32_t i_a4);
int32_t strbuffer_append(int32_t i_a1, int32_t i_a2);
int32_t strbuffer_append_byte(int32_t i_a1, int32_t i_a2);
int32_t strbuffer_append_bytes(int32_t i_a1, int32_t i_a2, uint32_t i_a3);
int32_t strbuffer_clear(int32_t i_a1);
int32_t strbuffer_close(int32_t *p_a1);
int32_t strbuffer_init(int32_t *p_a1);
int32_t strbuffer_pop(int32_t i_a1);
int32_t strbuffer_steal_value(int32_t i_a1);
int32_t strbuffer_value(int32_t *p_a1);
int32_t stream_get(int32_t i_a1, int32_t i_a2);
int32_t stream_init(int32_t i_a1, int32_t i_a2, int32_t i_a3);
int32_t stream_unget(int32_t i_a1, uint32_t i_a2);
int32_t string_get(int32_t i_a1);
int32_t target_to_dcrdiff(int32_t *p_a1);
int32_t test_eeprom(void);
int32_t to_locale(int32_t i_a1);
int32_t tree_successor(int32_t i_a1, int32_t i_a2);
int32_t twoc2hex(uint32_t i_a1, uint32_t i_a2);
int32_t uart_flush(int32_t i_a1);
int32_t uart_flush_rx(int32_t i_a1);
int32_t uart_flush_tx(int32_t i_a1);
int32_t uart_get_config(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t uart_get_readable_byte_num(uint32_t i_a1);
int32_t uart_init(void);
int32_t uart_receive(uint32_t i_a1, int32_t i_a2, uint32_t i_a3, int32_t i_a4);
int32_t uart_send(int32_t i_a1, int32_t *p_a2, uint32_t i_a3);
int32_t uart_set_baud(uint32_t i_a1, int32_t i_a2);
int32_t uart_set_config(int32_t i_a1, int32_t i_a2, int32_t *p_a3,
                        int32_t i_a4);
int32_t uart_uninit(void);
int32_t ui_init(void);
int32_t ui_pull_function(int32_t i_a1);
int32_t ui_uninit(void);
int32_t unknown_449fd0(void);
int32_t unknown_449fe8(void);
int32_t unknown_463042(void);
int32_t unreg_key_callback(int32_t i_a1);
int32_t update_filcker_freq(int32_t i_a1, int32_t i_a2, int32_t i_a3);
int32_t use_point_add_1(uint32_t i_a1, int32_t i_a2);
int32_t use_point_sub_1(int32_t i_a1, int32_t i_a2);
int32_t utf8_check_first(uint32_t i_a1);
int32_t utf8_check_full(int32_t i_a1, uint32_t i_a2, int32_t i_a3);
int32_t utf8_check_string(int32_t i_a1, int32_t i_a2);
int32_t utf8_encode(uint32_t i_a1, int32_t *p_a2, int32_t *p_a3);
int32_t utf8_iterate(int32_t i_a1, int32_t *p_a2);
int32_t wait4i2c_data(int32_t i_a1);
int32_t wait4i2c_ready(void);
int32_t write_data_int32_to_PIC16F1704_flash(uint32_t i_a1, uint32_t i_a2);
int32_t write_hash_ID_PIC16F1704(uint32_t i_a1, uint32_t i_a2, int32_t i_a3);
int32_t write_lcd(int32_t i_a1, int32_t i_a2, int32_t i_a3);
int32_t write_lcd_no_memset(int32_t i_a1, int32_t *p_a2, int32_t i_a3);
int32_t write_pic(int32_t i_a1, int32_t i_a2, int32_t i_a3);
int32_t write_sensor_info_int32_to_pic(int32_t i_a1, uint32_t i_a2);
int32_t write_temperature_offset_PIC16F1704(uint32_t i_a1, uint32_t i_a2,
                                            int32_t i_a3);
int32_t znyq_set_iic(int32_t i_a1, int32_t i_a2, uint32_t i_a3, int32_t i_a4,
                     uint32_t i_a5);

// --------------------- Global Variables ---------------------

// Detected cryptographic pattern: CRC_16_CCITT_poly_0x1021 (16-bit, little
// endian)
int16_t CRC_16_CCITT_poly_0x1021_at_28d10[256] = {
    0,       0x1021,  0x2042,  0x3063,  0x4084,  0x50a5,  0x60c6,
    0x70e7,  -0x7ef8, -0x6ed7, -0x5eb6, -0x4e95, -0x3e74, -0x2e53,
    -0x1e32, -3601,   0x1231,  528,     0x3273,  0x2252,  0x52b5,
    0x4294,  0x72f7,  0x62d6,  -0x6cc7, -0x7ce8, -0x4c85, -0x5ca6,
    -0x2c43, -0x3c64, -3073,   -0x1c22, 0x2462,  0x3443,  1056,
    0x1401,  0x64e6,  0x74c7,  0x44a4,  0x5485,  -0x5a96, -0x4ab5,
    -0x7ad8, -0x6af7, -0x1a12, -2609,   -0x3a54, -0x2a73, 0x3653,
    0x2672,  0x1611,  1584,    0x76d7,  0x66f6,  0x5695,  0x46b4,
    -0x48a5, -0x5886, -0x68e7, -0x78c8, -2081,   -0x1802, -0x2863,
    -0x3844, 0x48c4,  0x58e5,  0x6886,  0x78a7,  2112,    0x1861,
    0x2802,  0x3823,  -0x3634, -0x2613, -0x1672, -1617,   -0x76b8,
    -0x6697, -0x56f6, -0x46d5, 0x5af5,  0x4ad4,  0x7ab7,  0x6a96,
    0x1a71,  2640,    0x3a33,  0x2a12,  -0x2403, -0x3424, -1089,
    -0x1462, -0x6487, -0x74a8, -0x44c5, -0x54e6, 0x6ca6,  0x7c87,
    0x4ce4,  0x5cc5,  0x2c22,  0x3c03,  3168,    0x1c41,  -0x1252,
    -625,    -0x3214, -0x2233, -0x52d6, -0x42f5, -0x7298, -0x62b7,
    0x7e97,  0x6eb6,  0x5ed5,  0x4ef4,  0x3e13,  0x2e32,  0x1e51,
    3696,    -97,     -0x1042, -0x2023, -0x3004, -0x40e5, -0x50c6,
    -0x60a7, -0x7088, -0x6e78, -0x7e57, -0x4e36, -0x5e15, -0x2ef4,
    -0x3ed3, -3762,   -0x1e91, 0x1080,  161,     0x30c2,  0x20e3,
    0x5004,  0x4025,  0x7046,  0x6067,  -0x7c47, -0x6c68, -0x5c05,
    -0x4c26, -0x3cc3, -0x2ce4, -0x1c81, -3234,   689,     0x1290,
    0x22f3,  0x32d2,  0x4235,  0x5214,  0x6277,  0x7256,  -0x4a16,
    -0x5a35, -0x6a58, -0x7a77, -2706,   -0x1ab1, -0x2ad4, -0x3af3,
    0x34e2,  0x24c3,  0x14a0,  1153,    0x7466,  0x6447,  0x5424,
    0x4405,  -0x5825, -0x4806, -0x7867, -0x6848, -0x18a1, -2178,
    -0x38e3, -0x28c4, 0x26d3,  0x36f2,  1681,    0x16b0,  0x6657,
    0x7676,  0x4615,  0x5634,  -0x26b4, -0x3693, -1778,   -0x16d1,
    -0x6638, -0x7617, -0x4676, -0x5655, 0x5844,  0x4865,  0x7806,
    0x6827,  0x18c0,  2273,    0x3882,  0x28a3,  -0x3483, -0x24a4,
    -0x14c1, -1250,   -0x7407, -0x6428, -0x5445, -0x4466, 0x4a75,
    0x5a54,  0x6a37,  0x7a16,  2801,    0x1ad0,  0x2ab3,  0x3a92,
    -722,    -0x12f1, -0x2294, -0x32b3, -0x4256, -0x5275, -0x6218,
    -0x7237, 0x7c26,  0x6c07,  0x5c64,  0x4c45,  0x3ca2,  0x2c83,
    0x1ce0,  3265,    -0x10e1, -194,    -0x30a3, -0x2084, -0x5065,
    -0x4046, -0x7027, -0x6008, 0x6e17,  0x7e36,  0x4e55,  0x5e74,
    0x2e93,  0x3eb2,  3793,    0x1ef0}; // 0x28d10
// Detected cryptographic pattern: SHA512 (64-bit, little endian)
int64_t SHA512_at_2b350[8] = {
    0x6a09e667f3bcc908,  -0x4498517a7b3558c5, 0x3c6ef372fe94f82b,
    -0x5ab00ac5a0e2c90f, 0x510e527fade682d1,  -0x64fa9773d4c193e1,
    0x1f83d9abfb41bd6b,  0x5be0cd19137e2179}; // 0x2b350
bool i_g1 = false;                            // 0x100000
int32_t i_g2 = 0;                             // 0x1004c4
bool i_g3 = false;                            // 0x10ffff
int32_t i_g4 = 0;                             // 0x1c0000
int32_t i_g5 = -0x40ff4280;                   // 0x20000
bool i_g6 = false;                            // 0x200000
int32_t i_g7 = 0;                             // 0x235b34
char *p_g8;                                   // 0x235b50
char *p_g9;                                   // 0x235b54
char *p_g10;                                  // 0x235b58
char *p_g11;                                  // 0x235b5c
char *p_g12;                                  // 0x235b60
int32_t i_g13 = 0;                            // 0x235b64
int32_t i_g14 = 0;                            // 0x235b74
int32_t i_g15 = 0;                            // 0x235b84
int32_t i_g16 = 0;                            // 0x235b94
int32_t i_g17 = 0;                            // 0x235ba4
int32_t i_g18 = 0;                            // 0x235bb4
int32_t i_g19 = 0;                            // 0x235bc4
int32_t i_g20 = 0;                            // 0x235bd4
int32_t i_g21 = 0;                            // 0x235be4
int32_t i_g22 = 0;                            // 0x235bf4
char *p_g23;                                  // 0x235c04
char *p_g24;                                  // 0x235c08
int32_t i_g25 = 0;                            // 0x235c0c
char *p_g26;                                  // 0x235c1c
char *p_g27;                                  // 0x235c20
struct timeval *p_g28 = NULL;                 // 0x235c24
int32_t i_g29 = 0;                            // 0x235c28
struct timeval *p_g30 = NULL;                 // 0x235c2c
int32_t i_g31 = 0;                            // 0x235c30
int32_t i_g32 = 0;                            // 0x235c34
int32_t i_g33 = 0;                            // 0x235c38
char *p_g34;                                  // 0x235c3c
int32_t i_g35 = 0;                            // 0x235c40
int32_t i_g36 = 0;                            // 0x235c44
int32_t i_g37 = 0;                            // 0x235c48
int32_t i_g38 = 0;                            // 0x235c4c
int32_t i_g39 = 0;                            // 0x235c50
int32_t i_g40 = 0;                            // 0x235c54
int32_t i_g41 = 0;                            // 0x235c58
int32_t i_g42 = 0;                            // 0x235c5c
int32_t i_g43 = 0;                            // 0x235d80
int32_t i_g44 = 0;                            // 0x235d84
int32_t i_g45 = 0;                            // 0x235d88
int32_t i_g46 = 0;                            // 0x235d8c
int32_t i_g47 = 0;                            // 0x235d90
int32_t i_g48 = 0;                            // 0x235d94
int32_t i_g49 = 0;                            // 0x235d98
int32_t i_g50 = 0;                            // 0x235db0
int32_t i_g51 = 0;                            // 0x235dc8
int32_t i_g52 = 0;                            // 0x235dcc
int32_t i_g53 = 0;                            // 0x235de4
int32_t i_g54 = 0;                            // 0x235df4
int32_t i_g55 = 0;                            // 0x235f74
int32_t i_g56 = 0;                            // 0x2360f4
int32_t i_g57 = 0;                            // 0x23610c
int32_t i_g58 = 0;                            // 0x236110
int32_t i_g59 = 0;                            // 0x236114
int32_t i_g60 = 0;                            // 0x236118
int32_t i_g61 = 0;                            // 0x23611c
int32_t i_g62 = 0;                            // 0x236130
int32_t i_g63 = 0;                            // 0x236134
int32_t i_g64 = 0;                            // 0x236138
int32_t i_g65 = 0;                            // 0x236150
int32_t i_g66 = 0;                            // 0x236190
int32_t i_g67 = 0;                            // 0x2361a8
int32_t i_g68 = 0;                            // 0x2361ac
int32_t i_g69 = 0;                            // 0x2361b0
int32_t i_g70 = 0;                            // 0x2361b4
int32_t i_g71 = 0;                            // 0x2362b4
int32_t i_g72 = 0;                            // 0x2362fc
int32_t i_g73 = 0;                            // 0x236300
int32_t i_g74 = 0;                            // 0x236304
int32_t i_g75 = 0;                            // 0x236308
int32_t i_g76 = 0;                            // 0x23630c
int32_t i_g77 = 0x6a09e667;                   // 0x2b2f0
int32_t i_g78 = -0x3efa6128;                  // 0x2b310
int32_t i_g79 = 0;                            // 0x2b390
int32_t i_g80 = 0;                            // 0x2b630c
int32_t i_g81 = 0;                            // 0x2b6310
int32_t i_g82 = 0;                            // 0x2b6314
int32_t i_g83 = 0;                            // 0x2b6318
int32_t i_g84 = 0;                            // 0x2b631c
char *p_g85;                                  // 0x2b632c
char *p_g86;                                  // 0x2b636c
int32_t i_g87 = 0;                            // 0x2b63ac
int32_t i_g88 = 0;                            // 0x2b67ac
int64_t *p_g89 = (int64_t *)-0x7a5cf72d;      // 0x2b790
int32_t i_g90 = 0;                            // 0x2b820
int32_t i_g91 = 32;                           // 0x2ce04
int32_t i_g92 = 5;                            // 0x2cec0
int32_t i_g93 = 0;                            // 0x2e2e2e
char *p_g94;                                  // 0x330000
int32_t i_g95 = 0;                            // 0x3367ac
int32_t i_g96 = 0;                            // 0x3367c8
char *p_g97;                                  // 0x3367cc
char *p_g98;                                  // 0x3367cd
char *p_g99;                                  // 0x3367ce
int32_t i_g100 = 0;                           // 0x3367d0
int32_t i_g101 = 0;                           // 0x3367d8
int32_t i_g102 = 0;                           // 0x3367dc
char i_g103 = 0;                              // 0x3367dd
char i_g104 = 0;                              // 0x3367de
char i_g105 = 0;                              // 0x3367df
char i_g106 = 0;                              // 0x3367e0
char i_g107 = 0;                              // 0x3367e1
char i_g108 = 0;                              // 0x3367e2
char i_g109 = 0;                              // 0x3367e3
int32_t i_g110 = 0;                           // 0x33681c
int32_t i_g111 = 0;                           // 0x336820
int32_t i_g112 = 0;                           // 0x336824
int32_t i_g113 = 0;                           // 0x336848
int32_t i_g114 = 0;                           // 0x33684c
int32_t i_g115 = 0;                           // 0x336850
int32_t i_g116 = 0;                           // 0x336878
int32_t i_g117 = 0;                           // 0x33687c
int32_t i_g118 = 0;                           // 0x336880
int32_t i_g119 = 0;                           // 0x336884
int32_t i_g120 = 0;                           // 0x336888
int32_t i_g121 = 0;                           // 0x33688c
int32_t i_g122 = 0;                           // 0x336890
int32_t i_g123 = 0;                           // 0x336894
int32_t i_g124 = 0;                           // 0x336898
int32_t i_g125 = 0;                           // 0x33689c
int32_t i_g126 = 0;                           // 0x3368a0
int32_t i_g127 = 0;                           // 0x3368a4
char i_g128 = 0;                              // 0x3368ac
char i_g129 = 0;                              // 0x3368ad
char i_g130 = 0;                              // 0x3368ae
char i_g131 = 0;                              // 0x3368af
char i_g132 = 0;                              // 0x3368b0
char i_g133 = 0;                              // 0x3368b1
char i_g134 = 0;                              // 0x3368b2
int32_t i_g135 = 0;                           // 0x3368b4
int32_t i_g136 = 0;                           // 0x3368b8
char i_g137 = 0;                              // 0x3368bc
int32_t i_g138 = 0;                           // 0x3368c0
int32_t i_g139 = 0;                           // 0x3368c4
int32_t i_g140 = 0;                           // 0x3368c8
int32_t i_g141 = 0;                           // 0x3368cc
int32_t i_g142 = 0;                           // 0x3368d0
int32_t i_g143 = 0;                           // 0x3368d4
char i_g144 = 0;                              // 0x3368d8
int32_t i_g145 = 0;                           // 0x3368e0
int32_t i_g146 = 0;                           // 0x3368e4
int32_t i_g147 = 0;                           // 0x3368e8
int32_t i_g148 = 0;                           // 0x336948
char *p_g149;                                 // 0x338950
char *p_g150;                                 // 0x338960
char *p_g151;                                 // 0x338970
int32_t i_g152 = 0x9029;                      // 0x35324
int32_t i_g153 = 0;                           // 0x3532c
int32_t i_g154 = 0;                           // 0x35524
char *p_g155 = "\xff";                        // 0x35530
char *x_g156[3] = {"/media/card/minertest-BM1722/dcr-asic-",
                   "/media/card/minertest-BM1725/dcr-asic-",
                   "/core_"}; // 0x35534
char (*p_g157)[39] = "/media/card/minertest-BM1725/dcr-asic-";    // 0x35538
char (*p_g158)[7] = "/core_";                                     // 0x3553c
char *p_g159 = "\x01";                                            // 0x35540
char *p_g160 = "\x01";                                            // 0x35544
char *p_g161 = "\x01";                                            // 0x35548
int16_t *p_g162 = (int16_t *)0x1100001;                           // 0x3554c
char i_g163 = 16;                                                 // 0x3554e
char i_g164 = 1;                                                  // 0x3554f
int32_t i_g165 = 0;                                               // 0x35550
int32_t i_g166 = 1;                                               // 0x35554
int32_t i_g167 = 12;                                              // 0x3557c
int32_t i_g168 = 13;                                              // 0x35580
int32_t i_g169 = 15;                                              // 0x35588
int32_t i_g170 = 0;                                               // 0x357e4
int32_t i_g171 = 1;                                               // 0x357e8
int32_t i_g172 = 12;                                              // 0x35810
int32_t i_g173 = 13;                                              // 0x35814
int32_t i_g174 = 15;                                              // 0x3581c
int32_t i_g175 = -1;                                              // 0x35a78
char (*p_g176)[17] = "/dev/bitmain-lcd";                          // 0x35a7c
int32_t i_g177 = 0x8dd4;                                          // 0x35a80
int32_t i_g178 = 0x8cf0;                                          // 0x35a84
int32_t i_g179 = 7;                                               // 0x35a88
int32_t i_g180 = 6;                                               // 0x35a90
int32_t i_g181 = 5;                                               // 0x35a98
int32_t i_g182 = 0;                                               // 0x35aa0
char *p_g183;                                                     // 0x35aa4
char *p_g184;                                                     // 0x35aa8
char *p_g185;                                                     // 0x35aa9
int32_t i_g186 = 0;                                               // 0x35aac
char *p_g187;                                                     // 0x35ac4
char *p_g188;                                                     // 0x35ac5
char i_g189 = 0;                                                  // 0x35ac6
int32_t i_g190 = 0;                                               // 0x35ac8
char *p_g191;                                                     // 0x35ad8
char *p_g192;                                                     // 0x35adc
char *p_g193;                                                     // 0x35ae0
char *p_g194;                                                     // 0x35ae4
int32_t i_g195 = 0;                                               // 0x35ae8
int32_t i_g196 = 0;                                               // 0x35aec
int32_t i_g197 = 0;                                               // 0x35af0
int32_t i_g198 = 0;                                               // 0x35af4
int32_t i_g199 = 0;                                               // 0x35b04
int32_t i_g200 = 0;                                               // 0x35b14
int32_t i_g201 = 0;                                               // 0x35b24
int32_t i_g202 = 0;                                               // 0x35b34
int32_t i_g203 = 0;                                               // 0x3f000
int32_t i_g204 = 0;                                               // 0x493e0
int32_t i_g205 = 0;                                               // 0x50464
int32_t i_g206 = 0;                                               // 0x61a80
int32_t i_g207 = 0;                                               // 0x7a120
int32_t i_g208 = 0;                                               // 0x8200
char *p_g209 = "\b";                                              // 0x825c
char *p_g210 = "\x06";                                            // 0x8270
char *p_g211;                                                     // 0x82ac
int32_t i_g212 = 0;                                               // 0x82dc
char *p_g213 = "5";                                               // 0x8330
char *p_g214;                                                     // 0x833c
char *p_g215 = "\x8d\x01";                                        // 0x8354
char *p_g216 = "\xc0\x8c";                                        // 0x8398
char *p_g217 = "\x12";                                            // 0x83c0
char *p_g218;                                                     // 0x83dc
char *p_g219;                                                     // 0x83ec
char *p_g220 = "|";                                               // 0x83f4
char *p_g221;                                                     // 0x840c
char *p_g222;                                                     // 0x842c
int32_t i_g223 = 18;                                              // 0x8430
int32_t i_g224 = 327;                                             // 0x8444
char *p_g225 = "P\x8d";                                           // 0x8458
char *p_g226 = "\xdc\x01";                                        // 0x8474
char *p_g227 = "\x12";                                            // 0x8490
int32_t i_g228 = 483;                                             // 0x84c4
int32_t i_g229 = 0x8db0;                                          // 0x84d8
int32_t i_g230 = 0;                                               // 0x84ec
int32_t i_g231 = 18;                                              // 0x8500
char *p_g232 = "\x12";                                            // 0x8510
char *p_g233 = "\x12";                                            // 0x8530
char *p_g234 = "\x14\x8e";                                        // 0x8558
char *p_g235 = "t\x01";                                           // 0x8574
int32_t i_g236 = 501;                                             // 0x8594
char *p_g237;                                                     // 0x864c
char *p_g238 = "\xc8\x8e";                                        // 0x8658
int32_t i_g239 = 32;                                              // 0x86a0
char *p_g240 = "\x04\x8f";                                        // 0x86b8
char *p_g241;                                                     // 0x86fc
char *p_g242 = "\xac\x01";                                        // 0x8724
char *p_g243;                                                     // 0x87a8
char *p_g244 = "n";                                               // 0x87b8
int32_t i_g245 = 0x5f5f0070;                                      // 0x8890
char *p_g246 = "k";                                               // 0x88dc
char *p_g247 = "l";                                               // 0x88fc
char *p_g249 = "B\x02";                                           // 0x8a3c
char *p_g250 = "\x14ii\r";                                        // 0x8a54
char *p_g251;                                                     // 0x8a58
char *p_g252;                                                     // 0x8a60
char *p_g253 = "\x16\x02";                                        // 0x8a80
char *p_g254 = "\x16\x06";                                        // 0x8aa0
char *p_g255 = "\x16\b";                                          // 0x8ab0
char *p_g256 = "LT\x03";                                          // 0x8ab4
char *p_g257 = "\x16\n";                                          // 0x8ac0
char *p_g258 = "XT\x03";                                          // 0x8acc
char *p_g259 = "\x16\r";                                          // 0x8ad8
char *p_g260 = "\x16\x0e";                                        // 0x8ae0
char *p_g261 = "\x16\x0f";                                        // 0x8ae8
char *p_g262 = "\x16\x10";                                        // 0x8af0
char *p_g263 = "\x16\x11";                                        // 0x8af8
char *p_g264 = "\x16\x12";                                        // 0x8b00
char *p_g265 = "\x16\x13";                                        // 0x8b08
char *p_g266 = "\x16\x14";                                        // 0x8b10
char *p_g267 = "\x16\x15";                                        // 0x8b18
char *p_g268 = "\x16\x16";                                        // 0x8b20
char *p_g269 = "\x88T\x03";                                       // 0x8b2c
char *p_g270 = "\x16\x19";                                        // 0x8b38
char *p_g271 = "\x94T\x03";                                       // 0x8b44
char *p_g272 = "\x16\x1c";                                        // 0x8b50
char *p_g273 = "\xa0T\x03";                                       // 0x8b5c
char *p_g274 = "\x16\x1f";                                        // 0x8b68
char *p_g275 = "\xacT\x03";                                       // 0x8b74
char *p_g276 = "\x16\"";                                          // 0x8b80
char *p_g277 = "\xb8T\x03";                                       // 0x8b8c
char *p_g278 = "\xc0T\x03";                                       // 0x8b9c
char *p_g279 = "\x16(";                                           // 0x8ba8
char *p_g280 = "\x16*";                                           // 0x8bb8
char *p_g281 = "\xd0T\x03";                                       // 0x8bbc
char *p_g282 = "\x16-";                                           // 0x8bd0
char *p_g283 = "\x16/";                                           // 0x8be0
char *p_g284 = "\x16\x31";                                        // 0x8bf0
char *p_g285 = "\x16\x33";                                        // 0x8c00
char *p_g286 = "\x16\x35";                                        // 0x8c10
char *p_g287;                                                     // 0x8c1c
char *p_g288 = "\x16\x39";                                        // 0x8c28
char *p_g289 = "\x14U\x03";                                       // 0x8c44
char *p_g290 = "\x16?";                                           // 0x8c58
char *p_g291 = "\xa0\xc7\x02";                                    // 0x8c80
char *p_g292 = "\x03K\x04J{D\x9bX\v\xb1\xff\xf7'\xbfpGp\xc4\x02"; // 0x8fa8
char *p_g293;                                                     // 0x8fe0
char *p_g294 = "\xa0Z\x03";                                       // 0x9004
char *p_g295 = "\x05H\b\xb5\x03h\x13\xb1\x04K\x03\xb1\x98G\xbd\xe8\b@"
               "\xff\xf7\xd3\xbf"; // 0x9028
char *p_g296 = "[";                // 0x95a8
char *p_g297 = "E\xf2\x30S\xc0\xf2\x03\x03\x1bx\x1a\x46\x45\xf6\xc8#"
               "\xc0\xf2\x03\x03S\xf8\" "
               "F\xf2\xdcs\xc0\xf2\x33\x03\xd3\xf8\xd8\x30\x9a\x42J\xd3\x46\xf2"
               "\f3\xc0\xf2#\x03\x03\xf5"; // 0x9ec0
char *p_g298 = "\xc0\xf2\x04";             // 0xa1c0
char *p_g299 = "[";                        // 0xaf5c
int32_t i_g300 = 0x18c3005b;               // 0xb22c
int32_t i_g301 = -0x802ffcd;               // 0xb2d0
char *p_g302 = "\xfd\xf7\x94\xe8\x45\xf2\x30S\xc0\xf2\x03\x03\x1bx\x1a\x46\x46"
               "\xf2\f3\xc0\xf2#"
               "\x03\x9b\x18\x03\xf5\x80\x13\x03\xf5\x97\x63\x1bx:"
               "\x1d\a2\x10\x46H\xf2\xf8q\xc0\xf2\x02\x01\x1a\x46\xfd\xf7\xba"
               "\xe9";                      // 0xbb58
char *p_g303 = "\x10\x63+";                 // 0xbc34
char *p_g304 = "\xbd\x46\x90\xbd\x1c\x63+"; // 0xc208
char *p_g305 = "\x80\xb5\x84\xb0";          // 0xc214
int32_t i_g306 = 0x4582e8f0;                // 0xcba1
int32_t i_g307 = 0;                         // 0xf4240
int32_t i_g308 = -0x78dcfea0;               // 0xffff
int32_t i_g309;
int32_t *p_g248 = (int32_t *)&i_g1; // 0x8a2e

// ------- Dynamically Linked Functions Without Header --------

int32_t __libc_start_main(int32_t i_a1, int32_t i_a2, char **p_a3,
                          void (*p_a4)(), void (*p_a5)(), void (*p_a6)());

// ------------------------ Functions -------------------------

// Address range: 0x8c64 - 0x8c6e
int32_t _init(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    // 0x8c64
    return __asm_nop(call_gmon_start(), i_a2, i_a3, i_a4);
}

// Address range: 0x8e04 - 0x8e14
int32_t _24_t(void) {
    // 0x8e04
    return function_461a4603();
}

// Address range: 0x8f70 - 0x8fa0
int32_t _start(int32_t i_a1, int32_t i_a2) {
    // 0x8f70
    int32_t i_v1; // 0x8f70
    __libc_start_main(0x9049, i_a2, (char **)&i_v1, (void (*)())0x28205,
                      (void (*)())0x9049, (void (*)())i_a1);
    abort();
    *(int16_t *)(i_a2 + 18) = (int16_t)i_a2;
    return &i_g309;
}

// Address range: 0x8fa8 - 0x8fb8
int32_t call_gmon_start(void) {
    // 0x8fa8
    if (i_g154 == 0) {
        // 0x8fb6
        int32_t i_v1; // 0x8fa8
        return i_v1;
    }
    // 0x8fb2
    return _24_t();
}

// Address range: 0x8fc0 - 0x8fd8
int32_t deregister_tm_clones(int32_t i_a1, int32_t i_a2, int32_t i_a3,
                             char i_a4) {
    // 0x8fc0
    return &i_g182;
}

// Address range: 0x8fe4 - 0x9002
int32_t register_tm_clones(int32_t *p_a1, int32_t i_a2, int32_t i_a3,
                           int32_t i_a4) {
    // 0x8fe4
    return &i_g182;
}

// Address range: 0x9010 - 0x9022
int32_t __do_global_dtors_aux(void) {
    // 0x9010
    int32_t i_v1; // 0x9010
    if (*(char *)&p_g183 == 0) {
        // 0x9018
        int32_t i_v2;                                             // 0x9010
        int32_t i_v3 = deregister_tm_clones(i_v2, i_v2, i_v2, 0); // 0x9018
        *(char *)&p_g183 = 1;
        i_v1 = i_v3;
    }
    // 0x9020
    return i_v1;
}

// Address range: 0x9028 - 0x903e
int32_t frame_dummy(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    // 0x9028
    return register_tm_clones(&i_g153, i_a2, i_a3, i_a4);
}

// Address range: 0x9048 - 0x919c
int main(int argc, char **argv) {
    // 0x9048
    int32_t i_v1; // bp-76, 0x9048
    memset(&i_v1, 0, 64);
    int32_t i_v2 = cgpu_init(); // 0x905c
    if (i_v2 < 0) {
        // 0x9192
        return i_v2;
    }
    int32_t i_v3 = configMiner(); // 0x906c
    if (i_v3 < 0) {
        // 0x9192
        return i_v3;
    }
    // 0x907c
    display_arguments();
    puts((char *)((int32_t)&p_g209 | 0x20000));
    int32_t i_v4 = 0;  // 0x908c
    int32_t i_v5 = 64; // 0x908c
    int32_t i_v6;      // 0x9048
    int32_t i_v7;      // 0x9048
    int32_t i_v8;      // 0x9048
    int32_t i_v9;      // 0x9048
    int32_t i_v10;     // 0x9048
    int32_t i_v11;     // 0x9094
    while (true) {
    lab_0x9090:
        // 0x9090
        i_v8 = i_v4;
        i_v11 = read_key(&i_v1);
        if (i_g113 == 1) {
            int32_t i_v12 = i_v5;
            i_v6 = i_v11;
            i_v7 = i_v8;
            i_v9 = i_v12;
            i_v10 = i_v11;
            if (i_v11 >= 1) {
                int32_t i_v13 = i_v1 % 256; // 0x90ae
                i_v6 = i_v11;
                i_v7 = i_v8;
                i_v9 = i_v12;
                i_v10 = i_v13;
                if (i_v13 == 1) {
                    // 0x90b4
                    switch (i_g115) {
                    case 1722: {
                        // 0x90c6
                        i_v6 = singleAsicTest_BM1722();
                        i_v7 = i_v8;
                        i_v9 = 1722;
                        i_v10 = 1722;
                        // break -> 0x908e
                        break;
                    }
                    case 1725: {
                        // 0x90de
                        i_v6 = singleAsicTest_BM1725();
                        i_v7 = i_v8;
                        i_v9 = 1725;
                        i_v10 = 1725;
                        // break -> 0x908e
                        break;
                    }
                    default: {
                        // 0x90e4
                        i_v6 = printf((char *)((int32_t)&p_g210 | 0x20000));
                        i_v7 = i_g115;
                        i_v9 = i_g115;
                        i_v10 = i_g115;
                        // break -> 0x908e
                        break;
                    }
                    }
                }
            }
            goto lab_0x908e;
        } else {
            if (i_v11 < 1) {
                goto lab_0x910a;
            } else {
                // 0x9104
                if (i_v1 % 256 == 1) {
                    goto lab_0x9130;
                } else {
                    goto lab_0x910a;
                }
            }
        }
    }
lab_0x908e:
    // 0x908e
    i_v4 = i_v7;
    __asm_nop(i_v6, i_v4, i_v9, i_v10);
    i_v5 = i_v9;
    goto lab_0x9090;
lab_0x910a:;
    unsigned char i_v14 = *(char *)&p_g188; // 0x9112
    int32_t i_v15 = i_v11;                  // 0x9120
    int32_t i_v16 = i_v8;                   // 0x9120
    if (i_v14 == 0 | i_v14 >= *(char *)&p_g187) {
        goto lab_0x916c;
    } else {
        goto lab_0x9130;
    }
lab_0x916c:;
    int32_t i_v17 = i_v16;
    int32_t i_v18 = i_v15;
    unsigned char i_v19 = *(char *)&p_g188; // 0x9174
    unsigned char i_v20 = *(char *)&p_g187; // 0x917e
    i_v6 = i_v18;
    i_v7 = i_v17;
    i_v9 = i_v19;
    i_v10 = i_v20;
    if (i_v19 >= i_v20) {
        // 0x9184
        *(char *)&p_g188 = 0;
        i_v6 = i_v18;
        i_v7 = i_v17;
        i_v9 = 0;
        i_v10 = (int32_t)&p_g188;
    }
    goto lab_0x908e;
lab_0x9130:
    // 0x9130
    if (*(char *)&p_g184 == 0) {
        // 0x9144
        if (*(char *)&p_g185 == 0) {
            // 0x9158
            i_v15 = printf((char *)((int32_t)&p_g211 | 0x20000));
            i_v16 = (int32_t)&i_g212 | 0x20000;
        } else {
            // 0x9152
            i_v15 = singleBoardTest_BBD25601();
            i_v16 = i_v8;
        }
    } else {
        // 0x913e
        i_v15 = singleBoardTest_BBD12601();
        i_v16 = i_v8;
    }
    goto lab_0x916c;
}

// Address range: 0x919c - 0x9206
int32_t get_BM1722_asic_register(unsigned char i_a1, char i_a2, char i_a3,
                                 char i_a4) {
    char i_v1 = i_a4 == 0 ? 66 : 82;
    CRC5(&i_v1, 32);
    return dcr_uart_send((int32_t)i_a1, &i_v1, 5);
}

// Address range: 0x9208 - 0x92a0
int32_t set_BM1722_asic_register(uint32_t i_a1, int32_t i_a2, int32_t i_a3,
                                 uint32_t i_a4, int32_t i_a5) {
    char i_v1 = i_a4 % 256 == 0 ? 65 : 81;
    CRC5(&i_v1, 64);
    return dcr_uart_send(i_a1 % 256, &i_v1, 9);
}

// Address range: 0x92a0 - 0x92cc
int32_t set_BM1722_freq(int32_t i_a1, int32_t i_a2, int32_t i_a3) {
    // 0x92a0
    float32_t f_v1; // 0x92a0
    int32_t i_v2;   // 0x92a0
    __asm_vstr(f_v1, i_v2);
    __asm_vldr(i_v2);
    return i_a1;
}

// Address range: 0x92cc - 0x92fc
int32_t function_92cc(int32_t i_a1, int32_t i_a2, int32_t i_a3) {
    int32_t i_v1 = i_a1; // 0x92cc
    bool i_v2;           // 0x92cc
    if (!i_v2) {
        i_v1 = function_ffa04db0();
    }
    // 0x92d0
    if (i_v2 || i_v2) {
        // 0x92f8
        return i_v1;
    }
    // 0x92d8
    int32_t i_v3; // 0x92cc
    if (!i_v2) {
        // 0x92e4
        __asm_stcl(7, 15, i_v3, 1020);
        return i_v1;
    }
    int32_t i_v4; // 0x92e0
    if (i_v3 != i_v3 >> 4) {
        if ((i_v3 & 8) == 0) {
            // 0x92e4
            __asm_stcl(7, 15, i_v3, 1020);
            return i_v1;
        }
        i_v4 = function_604434();
        // 0x92e4
        __asm_stcl(7, 15, i_v3, 1020);
        return i_v4;
    }
    __asm_smlabteq(i_v1, i_a3, 0x92e4);
    if ((i_v3 & 8) == 0) {
        // 0x92e4
        __asm_stcl(7, 15, i_v3, 1020);
        return i_v1;
    }
    i_v4 = function_604434();
    // 0x92e4
    __asm_stcl(7, 15, i_v3, 1020);
    return i_v4;
}

// Address range: 0x92fc - 0x931c
int32_t function_92fc(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    int32_t i_v1 = get_pllparam_divider(i_a1, i_a2, i_a4, i_a4); // 0x92fe
    int32_t i_v2;                                                // 0x92fc
    *(int32_t *)(i_v2 + 20) = i_v1;
    int32_t *p_v3 = (int32_t *)(i_v2 + 16); // 0x9304
    *p_v3 = *p_v3 | -0x40000000;
    char *p_v4 = (char *)(i_v2 + 15); // 0x930c
    *p_v4 = *p_v4 - 1;
    __asm_vldr(*(int32_t *)(i_v2 + 8));
    return i_v1;
}

// Address range: 0x931c - 0x9348
int32_t function_931c(int32_t i_a1, int32_t i_a2, int32_t i_a3) {
    int32_t i_v1 = i_a1; // 0x931c
    bool i_v2;           // 0x931c
    if (!i_v2) {
        function_ffa04e00();
        i_v1 = function_4495c();
    }
    // 0x9324
    if (i_v2 || i_v2) {
        return i_v1;
    }
    int32_t i_v3; // 0x931c
    if (i_v2) {
        uint32_t i_v4 = i_v3 >> 4 ^ i_v3; // 0x932c
        if (i_v4 == 0) {
            __asm_smlabteq(i_v1, i_a3, 0x9338);
            __asm_ldc(7, 15, 0x20f8f248, 1020);
            return i_v1;
        }
        // .thread
        __asm_ldc(7, 15, 0x20f8f248, 1020);
        if (i_v4 >= 0) {
            return i_v1;
        }
        int32_t i_v5; // 0x931c
        int32_t i_v6; // 0x931c
        *(int32_t *)i_v5 = i_v6;
        return i_v1;
    }
    __asm_ldc(7, 15, 0x20f8f248, 1020);
    if (!i_v2) {
        return i_v1;
    }
    *(int32_t *)*(int32_t *)(*(int32_t *)(i_v3 + 20) - 24) = i_v3 + 28;
    return i_v1;
}

// Address range: 0x9348 - 0x938e
int32_t function_9348(void) {
    // 0x9348
    int32_t i_v1; // 0x9348
    set_BM1722_asic_register(i_v1, i_v1, i_v1, i_v1, (int32_t)&i_g309);
    usleep(1000);
    unsigned char i_v2 = *(char *)(i_v1 + 15); // 0x9354
    char *p_v3 = (char *)(i_v1 + 7);           // 0x9358
    unsigned char i_v4 = *p_v3;                // 0x9358
    char *p_v5 = (char *)(i_v1 + 6);           // 0x935a
    unsigned char i_v6 = *p_v5;                // 0x935a
    char *p_v7 = (char *)(i_v1 + 5);           // 0x935c
    unsigned char i_v8 = *p_v7;                // 0x935c
    set_BM1722_asic_register((int32_t)i_v4, (int32_t)i_v6, 112, (int32_t)i_v8,
                             (int32_t)i_v2);
    usleep(1000);
    int32_t i_v9 = *(int32_t *)(i_v1 + 16); // 0x9372
    unsigned char i_v10 = *p_v3;            // 0x9374
    unsigned char i_v11 = *p_v5;            // 0x9376
    unsigned char i_v12 = *p_v7;            // 0x9378
    return set_BM1722_asic_register((int32_t)i_v10, (int32_t)i_v11, 12,
                                    (int32_t)i_v12, i_v9);
}

// Address range: 0x9390 - 0x9402
int32_t BM1722_chain_inactive(uint32_t i_a1) {
    // 0x9390
    printf((char *)((int32_t)&p_g213 | 0x20000));
    char i_v1 = 83; // bp-16, 0x93c4
    CRC5(&i_v1, 32);
    dcr_uart_send(i_a1 % 256, &i_v1, 5);
    return usleep(0x1388);
}

// Address range: 0x9404 - 0x945e
int32_t BM1722_set_address(uint32_t i_a1, int32_t i_a2) {
    char i_v1 = 64; // bp-16, 0x9428
    CRC5(&i_v1, 32);
    return dcr_uart_send(i_a1 % 256, &i_v1, 5);
}

// Address range: 0x9460 - 0x94ea
int32_t BM1722_set_address_all(uint32_t i_a1) {
    uint32_t i_v1 = i_a1 % 256;
    printf((char *)((int32_t)&p_g214 | 0x20000));
    BM1722_chain_inactive(i_v1);
    int32_t i_v2 = 0; // 0x94e0
    if (i_g195 > 256) {
        // 0x94e2
        return 256 / i_g195;
    }
    int32_t i_v3 = 0; // 0x94e0
    BM1722_set_address(i_v1, i_v3 % 256);
    usleep(0x1388);
    i_v2++;
    uint32_t i_v4 = 256 / i_g195; // 0x94d4
    i_v3 += i_g195;
    while (i_v4 >= i_v2 == (i_v4 != i_v2)) {
        // 0x9498
        BM1722_set_address(i_v1, i_v3 % 256);
        usleep(0x1388);
        i_v2++;
        i_v4 = 256 / i_g195;
        i_v3 += i_g195;
    }
    // 0x94e2
    return i_v4;
}

// Address range: 0x94ec - 0x96f8
int32_t BM1722_open_core(uint32_t i_a1) {
    uint32_t i_v1 = i_a1 % 256;
    int32_t i_v2; // bp-204, 0x94ec
    memset(&i_v2, 0, 184);
    i_v2 = -1;
    printf((char *)((int32_t)&p_g214 | 0x20000));
    char *p_v3 = (char *)(i_v1 + (int32_t)&p_g192); // 0x9534
    *p_v3 = 0;
    char *p_v4 = (char *)(i_v1 + (int32_t)&p_g193); // 0x9542
    *p_v4 = 1;
    i_v2 = 32;
    int32_t i_v5; // bp-202, 0x94ec
    memset(&i_v5, 0, 180);
    CRC16(&i_v2, 182);
    int32_t i_v6; // 0x96d0
    if (i_g114 == 0) {
        // 0x96cc
        i_v6 = uart_flush_rx(i_v1);
        *p_v4 = 0;
        *p_v3 = 1;
        return i_v6;
    }
    uint32_t i_v7 = 0;
    int32_t i_v8;  // 0x94ec
    int32_t i_v9;  // 0x94ec
    int32_t i_v10; // 0x962e
    int32_t i_v11; // 0x9670
    int32_t i_v12; // 0x95aa
    int32_t i_v13; // 0x95ec
    if (i_v7 >= 31 == (i_v7 != 31)) {
        if (i_v7 >= 63 == (i_v7 != 63) || i_v7 == 31 || i_v7 < 31) {
            if (i_v7 >= 95 == (i_v7 != 95) || i_v7 == 63 || i_v7 < 63) {
                // 0x964c
                i_v8 = i_v9;
                if (i_v7 >= 127 != i_v7 != 127 && i_v7 != 95 && i_v7 >= 95) {
                    // 0x965c
                    i_v11 = i_v7 == 96 ? 1 : 2 * i_v9 | 1;
                    set_BM1722_asic_register(i_v1, 0, 92, 1, i_v11);
                    i_v8 = i_v11;
                }
            } else {
                // 0x961a
                i_v10 = i_v7 == 64 ? 1 : 2 * i_v9 | 1;
                set_BM1722_asic_register(i_v1, 0, 88, 1, i_v10);
                i_v8 = i_v10;
            }
        } else {
            // 0x95d8
            i_v13 = i_v7 == 32 ? 1 : 2 * i_v9 | 1;
            set_BM1722_asic_register(i_v1, 0, 84, 1, i_v13);
            i_v8 = i_v13;
        }
    } else {
        // 0x9596
        i_v12 = i_v7 == 0 ? 1 : 2 * i_v9 | 1;
        set_BM1722_asic_register(i_v1, 0, 80, 1, i_v12);
        i_v8 = i_v12;
    }
    // 0x968c
    dcr_uart_send(i_v1, (char *)&i_v2, 184);
    usleep(i_g126);
    int32_t i_v14 = i_v7 + 1; // 0x96b2
    uint32_t i_v15 = i_g114;  // 0x96c0
    while (i_v15 >= i_v14 == (i_v15 != i_v14)) {
        int32_t i_v16 = i_v8;
        i_v7 = i_v14;
        if (i_v7 >= 31 == (i_v7 != 31)) {
            if (i_v7 >= 63 == (i_v7 != 63) || i_v7 == 31 || i_v7 < 31) {
                if (i_v7 >= 95 == (i_v7 != 95) || i_v7 == 63 || i_v7 < 63) {
                    // 0x964c
                    i_v8 = i_v16;
                    if (i_v7 >= 127 != i_v7 != 127 && i_v7 != 95 &&
                        i_v7 >= 95) {
                        // 0x965c
                        i_v11 = i_v7 == 96 ? 1 : 2 * i_v16 | 1;
                        set_BM1722_asic_register(i_v1, 0, 92, 1, i_v11);
                        i_v8 = i_v11;
                    }
                } else {
                    // 0x961a
                    i_v10 = i_v7 == 64 ? 1 : 2 * i_v16 | 1;
                    set_BM1722_asic_register(i_v1, 0, 88, 1, i_v10);
                    i_v8 = i_v10;
                }
            } else {
                // 0x95d8
                i_v13 = i_v7 == 32 ? 1 : 2 * i_v16 | 1;
                set_BM1722_asic_register(i_v1, 0, 84, 1, i_v13);
                i_v8 = i_v13;
            }
        } else {
            // 0x9596
            i_v12 = i_v7 == 0 ? 1 : 2 * i_v16 | 1;
            set_BM1722_asic_register(i_v1, 0, 80, 1, i_v12);
            i_v8 = i_v12;
        }
        // 0x968c
        dcr_uart_send(i_v1, (char *)&i_v2, 184);
        usleep(i_g126);
        i_v14 = i_v7 + 1;
        i_v15 = i_g114;
    }
    // 0x96cc
    i_v6 = uart_flush_rx(i_v1);
    *p_v4 = 0;
    *p_v3 = 1;
    return i_v6;
}

// Address range: 0x96f8 - 0x9b5c
int32_t check_BM1722_asic_reg(int32_t i_a1, int32_t i_a2, uint32_t i_a3,
                              int32_t i_a4) {
    uint32_t i_v1 = 0x1000000 * i_a1 >> 24; // 0x96fe
    char i_v2 = 0;                          // bp-40, 0x9708
    clear_register_value_buf();
    get_BM1722_asic_register((char)i_a1, (char)i_a2, (char)i_a3, (char)i_a4);
    char *p_v3 = (char *)(i_v1 % 256 + (int32_t)&i_g76 + (int32_t)&i_g1 + 1208);
    if (i_a3 % 256 == 0) {
        // 0x974c
        *p_v3 = 0;
    }
    int32_t i_v4 = -0x80000000; // 0x96f8
    goto lab_0x9ab4;
lab_0x97a6:;
    // 0x97a6
    int32_t i_v9; // 0x96f8
    int32_t i_v13 = i_v9;
    pthread_mutex_lock((int32_t *)((int32_t) "ettimeofday" | (int32_t)&p_g94));
    int32_t *p_v25 = (int32_t *)(i_g101 + 4); // 0x97c6
    int32_t i_v26 = *p_v25;                   // 0x97c6
    int32_t i_v22;                            // 0x96f8
    int32_t *p_v21;                           // 0x99c4
    int32_t i_v16;                            // 0x96f8
    if (*(char *)(i_g101 + 25 + 10 * i_v26) == (char)i_v1) {
        // 0x9868
        memset((int32_t *)&i_v2, 0, 7);
        int32_t i_v27 = i_g101;
        int32_t i_v28 =
            *(int32_t *)(i_v27 + 16 + 10 * *(int32_t *)(i_v27 + 4)); // 0x989c
        i_v2 = i_v28;
        int32_t i_v29 = CRC5(&i_v2, 51); // 0x98b0
        int32_t *p_v30 = (int32_t *)(i_g101 + 4);
        int32_t i_v31 = *p_v30; // 0x98cc
        int32_t i_v32 = 10 * i_v31;
        if (i_v29 == (int32_t) * (char *)(i_g101 + 24 + i_v32)) {
            // 0x997a
            i_v16 = i_v32;
            i_v22 = i_v31;
            p_v21 = p_v30;
            if (i_a3 % 256 == 0) {
                // 0x9980
                *p_v3 = *p_v3 + 1;
                p_v21 = (int32_t *)(i_g101 + 4);
                i_v22 = *p_v21;
                i_v16 = 10 * i_v22;
                goto lab_0x99b0;
            } else {
                goto lab_0x99b0;
            }
        } else {
            // 0x98e0
            *p_v30 = i_v31 + 1;
            int32_t *p_v33 = (int32_t *)(i_g101 + 8); // 0x98fa
            *p_v33 = *p_v33 - 1;
            int32_t *p_v34 = (int32_t *)(i_g101 + 4); // 0x990a
            if (*p_v34 == 513) {
                // 0x9914
                *p_v34 = 0;
                goto lab_0x9922;
            } else {
                goto lab_0x9922;
            }
        }
    } else {
        // 0x97dc
        *p_v25 = i_v26 + 1;
        int32_t *p_v35 = (int32_t *)(i_g101 + 8); // 0x97f6
        *p_v35 = *p_v35 - 1;
        int32_t *p_v36 = (int32_t *)(i_g101 + 4); // 0x9806
        if (*p_v36 == 513) {
            // 0x9810
            *p_v36 = 0;
            goto lab_0x981e;
        } else {
            goto lab_0x981e;
        }
    }
lab_0x9ab4:;
    int32_t i_v5;  // 0x96f8
    int32_t i_v6;  // 0x96f8
    uint32_t i_v7; // 0x9784
    while (true) {
        // 0x9ab4
        i_v5 = i_v4;
        int32_t i_v8 = 0; // 0x9ab0
        while (true) {
            // 0x9766
            usleep(0xc350);
            pthread_mutex_lock(
                (int32_t *)((int32_t) "ettimeofday" | (int32_t)&p_g94));
            i_v7 = *(int32_t *)(i_g101 + 8);
            pthread_mutex_unlock(
                (int32_t *)((int32_t) "ettimeofday" | (int32_t)&p_g94));
            i_v6 = 0;
            i_v9 = i_v5;
            if (i_v7 != 0) {
                goto lab_0x97a6;
            }
            // 0x9ab4
            i_v8++;
            if (i_v8 != 2 && i_v8 >= 2) {
                // break (via goto) -> 0x9abc
                goto lab_0x9abc;
            }
        }
    }
lab_0x9abc:
    if (i_a3 % 256 != 0) {
        // 0x9b4c
        clear_register_value_buf();
        return i_v5;
    }
    int32_t i_v10 = (int32_t)*p_v3; // 0x9ada
    uint32_t i_v11 = i_g96;         // 0x9aee
    if (i_v11 != i_v10 && i_v11 <= i_v10) {
        // 0x9af4
        i_g96 = i_v10;
    }
    // 0x9b1e
    printf((char *)((int32_t)&p_g217 | 0x20000));
    // 0x9b4c
    clear_register_value_buf();
    return i_v5;
lab_0x981e:
    // 0x981e
    printf((char *)((int32_t)&p_g215 | 0x20000));
    pthread_mutex_unlock(
        (int32_t *)((int32_t) "ettimeofday" | (int32_t)&p_g94));
    int32_t i_v12 = i_v13; // 0x9866
    goto lab_0x9a9c;
lab_0x99b0:;
    int32_t i_v15 = i_v16 + i_g101;              // 0x99ce
    unsigned char i_v17 = *(char *)(i_v15 + 16); // 0x99d2
    unsigned char i_v18 = *(char *)(i_v15 + 17); // 0x99f8
    unsigned char i_v19 = *(char *)(i_v15 + 18); // 0x9a20
    unsigned char i_v20 = *(char *)(i_v15 + 19); // 0x9a48
    *p_v21 = i_v22 + 1;
    int32_t *p_v23 = (int32_t *)(i_g101 + 8); // 0x9a68
    *p_v23 = *p_v23 - 1;
    int32_t *p_v24 = (int32_t *)(i_g101 + 4); // 0x9a78
    if (*p_v24 == 513) {
        // 0x9a82
        *p_v24 = 0;
        // 0x9a90
        pthread_mutex_unlock(
            (int32_t *)((int32_t) "ettimeofday" | (int32_t)&p_g94));
        i_v12 = 0x10000 * (int32_t)i_v18 | 0x1000000 * (int32_t)i_v17 |
                256 * (int32_t)i_v19 | (int32_t)i_v20;
        goto lab_0x9a9c;
    } else {
        // 0x9a90
        pthread_mutex_unlock(
            (int32_t *)((int32_t) "ettimeofday" | (int32_t)&p_g94));
        i_v12 = 0x10000 * (int32_t)i_v18 | 0x1000000 * (int32_t)i_v17 |
                256 * (int32_t)i_v19 | (int32_t)i_v20;
        goto lab_0x9a9c;
    }
lab_0x9922:
    // 0x9922
    CRC5(&i_v2, 51);
    printf((char *)((int32_t)&p_g216 | 0x20000));
    pthread_mutex_unlock(
        (int32_t *)((int32_t) "ettimeofday" | (int32_t)&p_g94));
    i_v12 = i_v13;
    goto lab_0x9a9c;
lab_0x9a9c:;
    int32_t i_v14 = i_v6 + 1; // 0x9a9e
    i_v6 = i_v14;
    i_v9 = i_v12;
    i_v4 = i_v12;
    if (i_v14 < i_v7) {
        goto lab_0x97a6;
    } else {
        goto lab_0x9ab4;
    }
}

// Address range: 0x9b5c - 0xa05e
int32_t singleAsicTest_BM1722(void) {
    int32_t i_v1 = *(int32_t *)((int32_t)&i_g231 | (int32_t)&i_g5); // 0x9b7e
    int32_t i_v2 = i_v1; // bp-44, 0x9b86
    printf((char *)((int32_t)&p_g218 | 0x20000));
    system((char *)((int32_t)&p_g219 | 0x20000));
    putchar(10);
    reset_global_arg();
    chain_reset((int32_t) * (char *)&p_g155);
    fan_control(50);
    unsigned char i_v3 = *(char *)&p_g155; // 0x9bd0
    pthread_create(&i_g82, NULL, (int32_t * (*)(int32_t *))0xe135,
                   (int32_t *)(2 * (int32_t)i_v3 + (int32_t)&i_g100));
    unsigned char i_v4 = *(char *)&p_g155; // 0x9bf6
    *(char *)((int32_t)i_v4 + (int32_t)&p_g194) = 1;
    unsigned char i_v5 = *(char *)&p_g155; // 0x9c0e
    pthread_create(&i_g81, NULL, (int32_t * (*)(int32_t *))0xebc5,
                   (int32_t *)(2 * (int32_t)i_v5 + (int32_t)&i_g100));
    set_baud((int32_t) * (char *)&p_g155, 26);
    puts((char *)((int32_t)&p_g220 | 0x20000));
    check_BM1722_asic_reg((int32_t) * (char *)&p_g155, 0, 0, 1);
    unsigned char i_v6 = *(char *)&p_g155; // 0x9c68
    unsigned char i_v7 = *(char *)((int32_t)i_v6 + (int32_t)&i_g76 +
                                   (int32_t)&i_g1 + 1208);       // 0x9c7e
    int32_t i_v8 = printf((char *)((int32_t)&p_g221 | 0x20000)); // 0x9c8a
    unsigned char i_v9 = *(char *)&p_g155;                       // 0x9c96
    unsigned char i_v10 = *(char *)((int32_t)i_v9 + (int32_t)&i_g76 +
                                    (int32_t)&i_g1 + 1208); // 0x9cac
    int32_t i_v11 = i_v10;                                  // 0x9cac
    if (i_g113 != i_v11) {
        // 0x9cbe
        pthread_cancel(i_g81);
        pthread_cancel(i_g82);
        int32_t i_v12; // bp-37, 0x9b5c
        sprintf((char *)&i_v12, (char *)((int32_t)&p_g222 | 0x20000));
        write_lcd(0, (int32_t)&i_g223 | 0x20000, 16);
        write_lcd_no_memset(1, &i_v2, 16);
        write_lcd_no_memset(2, (int32_t *)((int32_t)&i_g224 | 0x20000), 16);
        // 0xa056
        return printf((char *)((int32_t)&p_g225 | 0x20000));
    }
    // 0x9d80
    calculate_timeout_and_baud(i_v8, (int32_t)i_v7, i_v11, i_v11);
    set_baud((int32_t) * (char *)&p_g155, i_g145 % 256);
    __asm_vmov_f32(__asm_vcvt_f32_u32(__asm_vldr(i_g111)));
    set_BM1722_freq((int32_t) * (char *)&p_g155, 0, 1);
    BM1722_set_address_all((int32_t) * (char *)&p_g155);
    check_BM1722_asic_reg((int32_t) * (char *)&p_g155, 0, 0, 1);
    if (i_g144 == 1) {
        int32_t i_v13 = (int32_t) * (char *)&p_g155;
        if (*(char *)&p_g188 == 0) {
            // 0x9e10
            get_temperature_offset_value_from_asic_chain(i_v13);
            set_default_temperature_offset_value_chain((int32_t) *
                                                       (char *)&p_g155);
        } else {
            // 0x9e32
            set_default_temperature_offset_value_chain(i_v13);
        }
    }
    unsigned char i_v14 = *(char *)&p_g155; // 0x9e4a
    pthread_create(&i_g84, NULL, (int32_t * (*)(int32_t *))0xf349,
                   (int32_t *)(2 * (int32_t)i_v14 + (int32_t)&i_g100));
    set_BM1725_asic_register((int32_t) * (char *)&p_g155, 0, 20, 1, 38);
    BM1722_open_core((int32_t) * (char *)&p_g155);
    puts((char *)((int32_t)&p_g226 | 0x20000));
    system((char *)((int32_t)&p_g219 | 0x20000));
    putchar(10);
    int32_t i_v15 = (int32_t) * (char *)&p_g155; // 0x9f8e
    int32_t i_v16 = i_v15;                       // 0x9fa4
    int32_t i_v17 = i_v15;                       // 0x9fa4
    if (*(char *)(i_v15 + (int32_t)&p_g191) == 1) {
    lab_0x9fa6:
        // 0x9fa6
        pthread_create(&i_g80, NULL, (int32_t * (*)(int32_t *))0xef59,
                       (int32_t *)(2 * i_v17 + (int32_t)&i_g100));
        pthread_join(i_g80, NULL);
        pthread_join(i_g81, NULL);
        pthread_cancel(i_g82);
        pthread_cancel(i_g84);
        int32_t i_v18 =
            single_asic_get_result((int32_t) * (char *)&p_g155); // 0xa038
        single_asic_print_lcd((int32_t) * (char *)&p_g155, i_v18);
        // 0xa056
        return fan_control(0);
    }
    while (*(int32_t *)(4 * i_v16 + (int32_t)&i_g190) < i_g135) {
        // 0x9f7e
        usleep(0x2710);
        i_v16 = (int32_t) * (char *)&p_g155;
        i_v17 = i_v16;
        if (*(char *)(i_v16 + (int32_t)&p_g191) == 1) {
            goto lab_0x9fa6;
        }
    }
    // 0x9ee8
    pthread_cancel(i_g84);
    pthread_cancel(i_g81);
    pthread_cancel(i_g82);
    puts((char *)((int32_t)&p_g227 | 0x20000));
    write_lcd(0, (int32_t)&i_g228 | 0x20000, 16);
    write_lcd_no_memset(1, (int32_t *)((int32_t)&i_g229 | 0x20000), 16);
    int32_t i_v19 = write_lcd_no_memset(
        2, (int32_t *)((int32_t)&i_g230 | 0x20000), 16); // 0x9f60
    *(char *)&p_g188 = (char)((int32_t)&i_g189 & 255);
    // 0xa056
    return i_v19;
}

// Address range: 0xa064 - 0xa958
int32_t singleBoardTest_BBD12601(void) {
    int32_t i_v1 = *(int32_t *)((int32_t)&i_g231 | (int32_t)&i_g5); // 0xa080
    int32_t i_v2 = i_v1; // bp-44, 0xa088
    printf((char *)((int32_t)&p_g218 | 0x20000));
    system((char *)((int32_t)&p_g219 | 0x20000));
    putchar(10);
    reset_global_arg();
    chain_reset((int32_t) * (char *)&p_g155);
    unsigned char i_v3 = *(char *)&p_g155; // 0xa0cc
    pthread_create(&i_g82, NULL, (int32_t * (*)(int32_t *))0xe135,
                   (int32_t *)(2 * (int32_t)i_v3 + (int32_t)&i_g100));
    chain_reset_low((int32_t) * (char *)&p_g155);
    usleep((int32_t)&i_g204);
    reset_PIC16F1704_pic((int32_t) * (char *)&p_g155, 0);
    jump_from_loader_to_app_PIC16F1704((int32_t) * (char *)&p_g155, 0);
    set_voltage((int32_t) * (char *)&p_g155, 0, 0, 0);
    enable_PIC16F1704_dc_dc((int32_t) * (char *)&p_g155, 0, 1);
    unsigned char i_v4 = *(char *)&p_g155; // 0xa188
    pthread_create(&i_g83, NULL, (int32_t * (*)(int32_t *))0x14089,
                   (int32_t *)(2 * (int32_t)i_v4 + (int32_t)&i_g100));
    usleep(100);
    chain_reset_high((int32_t) * (char *)&p_g155);
    usleep((int32_t)&i_g204);
    fan_control(50);
    set_baud((int32_t) * (char *)&p_g155, 26);
    unsigned char i_v5 = *(char *)&p_g155; // 0xa1e8
    *(char *)((int32_t)i_v5 + (int32_t)&p_g194) = 1;
    unsigned char i_v6 = *(char *)&p_g155; // 0xa200
    pthread_create(&i_g81, NULL, (int32_t * (*)(int32_t *))0xebc5,
                   (int32_t *)(2 * (int32_t)i_v6 + (int32_t)&i_g100));
    usleep(0x1388);
    puts((char *)((int32_t)&p_g232 | 0x20000));
    check_BM1722_asic_reg((int32_t) * (char *)&p_g155, 0, 0, 1);
    printf((char *)((int32_t)&p_g233 | 0x20000));
    int32_t i_v7 = (int32_t) * (char *)&p_g155; // 0xa28c
    unsigned char i_v8 =
        *(char *)(i_v7 + (int32_t)&i_g76 + (int32_t)&i_g1 + 1208); // 0xa2a2
    int32_t i_v9; // bp-37, 0xa064
    if (i_g113 != (int32_t)i_v8) {
        // 0xa2b6
        pthread_cancel(i_g81);
        pthread_cancel(i_g82);
        pthread_mutex_lock(&i_g186);
        pthread_cancel(i_g83);
        pthread_mutex_unlock(&i_g186);
        sprintf((char *)&i_v9, (char *)((int32_t)&p_g222 | 0x20000));
        write_lcd(0, (int32_t)&i_g223 | 0x20000, 16);
        write_lcd_no_memset(1, &i_v2, 16);
        write_lcd_no_memset(2, (int32_t *)((int32_t)&i_g224 | 0x20000), 16);
        printf((char *)((int32_t)&p_g234 | 0x20000));
        sleep(i_g146);
        // 0xa950
        return enable_PIC16F1704_dc_dc((int32_t) * (char *)&p_g155, 0, 0);
    }
    // 0xa3e4
    chain_reset(i_v7);
    uart_flush((int32_t) * (char *)&p_g155);
    uart_set_baud((int32_t) * (char *)&p_g155, 26);
    puts((char *)((int32_t)&p_g235 | 0x20000));
    check_BM1722_asic_reg((int32_t) * (char *)&p_g155, 0, 0, 1);
    int32_t i_v10 = printf((char *)((int32_t)&p_g233 | 0x20000)); // 0xa470
    unsigned char i_v11 = *(char *)&p_g155;                       // 0xa47c
    unsigned char i_v12 = *(char *)((int32_t)i_v11 + (int32_t)&i_g76 +
                                    (int32_t)&i_g1 + 1208); // 0xa492
    int32_t i_v13 = i_v12;                                  // 0xa492
    if (i_g113 != i_v13) {
        // 0xa4a6
        pthread_cancel(i_g81);
        pthread_cancel(i_g82);
        pthread_mutex_lock(&i_g186);
        pthread_cancel(i_g83);
        pthread_mutex_unlock(&i_g186);
        sprintf((char *)&i_v9, (char *)((int32_t)&p_g222 | 0x20000));
        write_lcd(0, (int32_t)&i_g223 | 0x20000, 16);
        write_lcd_no_memset(1, &i_v2, 16);
        write_lcd_no_memset(2, (int32_t *)((int32_t)&i_g224 | 0x20000), 16);
        printf((char *)((int32_t)&p_g234 | 0x20000));
        sleep(i_g146);
        // 0xa950
        return enable_PIC16F1704_dc_dc((int32_t) * (char *)&p_g155, 0, 0);
    }
    // 0xa5c8
    calculate_timeout_and_baud(i_v10, (int32_t) * (char *)&p_g155, i_v13,
                               i_v13);
    set_baud((int32_t) * (char *)&p_g155, i_g145 % 256);
    __asm_vmov_f32(__asm_vcvt_f32_u32(__asm_vldr(i_g111)));
    set_BM1722_freq((int32_t) * (char *)&p_g155, 0, 1);
    BM1722_set_address_all((int32_t) * (char *)&p_g155);
    if (i_g144 == 1) {
        int32_t i_v14 = (int32_t) * (char *)&p_g155;
        if (*(char *)&p_g188 == 0) {
            // 0xa642
            get_temperature_offset_value_from_asic_chain(i_v14);
            set_default_temperature_offset_value_chain((int32_t) *
                                                       (char *)&p_g155);
        } else {
            // 0xa664
            set_default_temperature_offset_value_chain(i_v14);
        }
    }
    unsigned char i_v15 = *(char *)&p_g155; // 0xa67c
    pthread_create(&i_g84, NULL, (int32_t * (*)(int32_t *))0xf349,
                   (int32_t *)(2 * (int32_t)i_v15 + (int32_t)&i_g100));
    set_BM1722_asic_register((int32_t) * (char *)&p_g155, 0, 20, 1, 38);
    BM1722_open_core((int32_t) * (char *)&p_g155);
    puts((char *)((int32_t)&p_g226 | 0x20000));
    unsigned char i_v16 = *(char *)&p_g155; // 0xa6d8
    *(char *)((int32_t)i_v16 + (int32_t)&p_g191) = 1;
    int32_t i_v17 = (int32_t) * (char *)&p_g155; // 0xa7ee
    int32_t i_v18 = i_v17;                       // 0xa804
    int32_t i_v19 = i_v17;                       // 0xa804
    if (*(char *)(i_v17 + (int32_t)&p_g191) != 1) {
        while (*(int32_t *)(4 * i_v18 + (int32_t)&i_g190) < i_g135) {
            // 0xa7de
            usleep(0x2710);
            i_v18 = (int32_t) * (char *)&p_g155;
            i_v19 = i_v18;
            if (*(char *)(i_v18 + (int32_t)&p_g191) == 1) {
                goto lab_0xa808;
            }
        }
        // 0xa712
        pthread_cancel(i_g84);
        pthread_cancel(i_g81);
        pthread_cancel(i_g82);
        pthread_cancel(i_g83);
        puts((char *)((int32_t)&p_g227 | 0x20000));
        write_lcd(0, (int32_t)&i_g228 | 0x20000, 16);
        write_lcd_no_memset(1, (int32_t *)((int32_t)&i_g236 | 0x20000), 16);
        write_lcd_no_memset(2, (int32_t *)((int32_t)&i_g230 | 0x20000), 16);
        *(char *)&p_g188 = (char)((int32_t)&i_g189 & 255);
        // 0xa950
        return enable_PIC16F1704_dc_dc((int32_t) * (char *)&p_g155, 0, 0);
    }
lab_0xa808:
    // 0xa808
    pthread_create(&i_g80, NULL, (int32_t * (*)(int32_t *))0xef59,
                   (int32_t *)(2 * i_v19 + (int32_t)&i_g100));
    pthread_join(i_g80, NULL);
    pthread_join(i_g81, NULL);
    pthread_cancel(i_g82);
    pthread_cancel(i_g84);
    uint32_t i_v20 =
        single_board_get_result((int32_t) * (char *)&p_g155); // 0xa89a
    single_board_print_lcd(i_v20);
    if (i_v20 != 7 || i_g137 == 0) {
        if (i_v20 % 2 == 0) {
            // 0xa8e4
            if (*(char *)&p_g188 < *(char *)&p_g187) {
                goto lab_0xa91c;
            } else {
                // 0xa8fc
                enable_PIC16F1704_dc_dc((int32_t) * (char *)&p_g155, 0, 0);
                goto lab_0xa91c;
            }
        } else {
            // 0xa8fc
            enable_PIC16F1704_dc_dc((int32_t) * (char *)&p_g155, 0, 0);
            goto lab_0xa91c;
        }
    } else {
        // 0xa8da
        set_voltage((int32_t) * (char *)&p_g155, 0, 1, 0);
        // 0xa8fc
        enable_PIC16F1704_dc_dc((int32_t) * (char *)&p_g155, 0, 0);
        goto lab_0xa91c;
    }
lab_0xa91c:
    // 0xa91c
    pthread_mutex_lock(&i_g186);
    pthread_cancel(i_g83);
    pthread_mutex_unlock(&i_g186);
    // 0xa950
    return fan_control(0);
}

// Address range: 0xa960 - 0xa9ca
int32_t get_BM1725_asic_register(unsigned char i_a1, char i_a2, char i_a3,
                                 char i_a4) {
    char i_v1 = i_a4 == 0 ? 66 : 82;
    CRC5(&i_v1, 32);
    return dcr_uart_send((int32_t)i_a1, &i_v1, 5);
}

// Address range: 0xa9cc - 0xaa64
int32_t set_BM1725_asic_register(uint32_t i_a1, int32_t i_a2, int32_t i_a3,
                                 uint32_t i_a4, int32_t i_a5) {
    char i_v1 = i_a4 % 256 == 0 ? 65 : 81;
    CRC5(&i_v1, 64);
    return dcr_uart_send(i_a1 % 256, &i_v1, 9);
}

// Address range: 0xaa64 - 0xaabe
int32_t BM1725_set_address(uint32_t i_a1, int32_t i_a2) {
    char i_v1 = 64; // bp-16, 0xaa88
    CRC5(&i_v1, 32);
    return dcr_uart_send(i_a1 % 256, &i_v1, 5);
}

// Address range: 0xaac0 - 0xab32
int32_t BM1725_chain_inactive(uint32_t i_a1) {
    // 0xaac0
    printf((char *)((int32_t)&p_g237 | 0x20000));
    char i_v1 = 83; // bp-16, 0xaaf4
    CRC5(&i_v1, 32);
    dcr_uart_send(i_a1 % 256, &i_v1, 5);
    return usleep(0x1388);
}

// Address range: 0xab34 - 0xabb0
int32_t BM1725_set_address_all(uint32_t i_a1) {
    uint32_t i_v1 = i_a1 % 256;
    printf((char *)((int32_t)&p_g238 | 0x20000));
    int32_t i_v2 = BM1725_chain_inactive(i_v1); // 0xab62
    char i_v3 = 0;                              // 0xaba6
    if (i_g113 == 0) {
        // 0xaba8
        return i_v2;
    }
    char i_v4 = 0; // 0xaba6
    BM1725_set_address(i_v1, (int32_t)i_v4);
    i_v3++;
    i_v4 += (char)i_g195;
    int32_t i_v5 = usleep(0x1388); // 0xaba6
    while (i_g113 > (int32_t)i_v3) {
        // 0xab6c
        BM1725_set_address(i_v1, (int32_t)i_v4);
        i_v3++;
        i_v4 += (char)i_g195;
        i_v5 = usleep(0x1388);
    }
    // 0xaba8
    return i_v5;
}

// Address range: 0xabb0 - 0xabdc
int32_t set_BM1725_freq(int32_t i_a1, int32_t i_a2, int32_t i_a3) {
    // 0xabb0
    float32_t f_v1; // 0xabb0
    int32_t i_v2;   // 0xabb0
    __asm_vstr(f_v1, i_v2);
    __asm_vldr(i_v2);
    return i_a1;
}

// Address range: 0xabdc - 0xabf8
int32_t function_abdc(int32_t i_a1, int32_t i_a2, int32_t i_a3) {
    int32_t i_v1 = i_a1; // 0xabdc
    bool i_v2;           // 0xabdc
    if (!i_v2) {
        i_v1 = function_ffa066c0();
    }
    return i_v1;
}

// Address range: 0xabf8 - 0xac0c
int32_t function_abf8(int32_t i_a1, int32_t i_a2) {
    // 0xabf8
    return i_a1;
}

// Address range: 0xac0c - 0xac2c
int32_t function_ac0c(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    int32_t i_v1 = get_pllparam_divider(i_a1, i_a2, i_a4, i_a4); // 0xac0e
    int32_t i_v2;                                                // 0xac0c
    *(int32_t *)(i_v2 + 20) = i_v1;
    int32_t *p_v3 = (int32_t *)(i_v2 + 16); // 0xac14
    *p_v3 = *p_v3 | -0x40000000;
    char *p_v4 = (char *)(i_v2 + 15); // 0xac1c
    *p_v4 = *p_v4 - 1;
    __asm_vldr(*(int32_t *)(i_v2 + 8));
    return i_v1;
}

// Address range: 0xac2c - 0xac48
int32_t function_ac2c(int32_t i_a1, int32_t i_a2, int32_t i_a3) {
    int32_t i_v1 = i_a1; // 0xac2c
    bool i_v2;           // 0xac2c
    if (!i_v2) {
        function_ffa06710();
        i_v1 = function_4626c();
    }
    return i_v1;
}

// Address range: 0xac48 - 0xac64
int32_t function_ac48(int32_t i_a1) {
    // 0xac48
    int32_t i_v1; // 0xac48
    int32_t i_v2; // 0xac48
    bool i_v3;    // 0xac48
    int32_t i_v4; // 0xac48
    if (!i_v3) {
        i_v2 = i_v4 + 28;
        i_v1 = *(int32_t *)(*(int32_t *)(i_v4 + 20) - 24);
    }
    if (i_v3) {
        *(int32_t *)i_v1 = i_v2;
    }
    __asm_mrc2(7, 5, i_v4, 8, 15, 7);
    return i_a1;
}

// Address range: 0xac64 - 0xac9e
int32_t function_ac64(void) {
    // 0xac64
    int32_t i_v1;                              // 0xac64
    unsigned char i_v2 = *(char *)(i_v1 + 15); // 0xac64
    char *p_v3 = (char *)(i_v1 + 7);           // 0xac68
    unsigned char i_v4 = *p_v3;                // 0xac68
    char *p_v5 = (char *)(i_v1 + 6);           // 0xac6a
    unsigned char i_v6 = *p_v5;                // 0xac6a
    char *p_v7 = (char *)(i_v1 + 5);           // 0xac6c
    unsigned char i_v8 = *p_v7;                // 0xac6c
    set_BM1725_asic_register((int32_t)i_v4, (int32_t)i_v6, 112, (int32_t)i_v8,
                             (int32_t)i_v2);
    usleep(1000);
    int32_t i_v9 = *(int32_t *)(i_v1 + 16); // 0xac82
    unsigned char i_v10 = *p_v3;            // 0xac84
    unsigned char i_v11 = *p_v5;            // 0xac86
    unsigned char i_v12 = *p_v7;            // 0xac88
    return set_BM1725_asic_register((int32_t)i_v10, (int32_t)i_v11, 12,
                                    (int32_t)i_v12, i_v9);
}

// Address range: 0xaca0 - 0xadd2
int32_t BM1725_open_core(uint32_t i_a1) {
    uint32_t i_v1 = i_a1 % 256;
    int32_t i_v2; // bp-204, 0xaca0
    memset(&i_v2, 0, 184);
    i_v2 = -1;
    printf((char *)((int32_t)&p_g238 | 0x20000));
    char *p_v3 = (char *)(i_v1 + (int32_t)&p_g192); // 0xace8
    *p_v3 = 0;
    char *p_v4 = (char *)(i_v1 + (int32_t)&p_g193); // 0xacf6
    *p_v4 = 1;
    i_v2 = 32;
    int32_t i_v5; // bp-202, 0xaca0
    memset(&i_v5, 0, 180);
    CRC16(&i_v2, 182);
    int32_t i_v6 = 0; // 0xad94
    set_BM1725_asic_register(i_v1, 0, 36, 1,
                             0x10000 * i_v6 | (int32_t)&i_g208 | 1);
    usleep(100);
    dcr_uart_send(i_v1, (char *)&i_v2, 184);
    usleep(i_g126);
    i_v6++;
    while (i_v6 == 275 || i_v6 < 275) {
        // 0xad42
        set_BM1725_asic_register(i_v1, 0, 36, 1,
                                 0x10000 * i_v6 | (int32_t)&i_g208 | 1);
        usleep(100);
        dcr_uart_send(i_v1, (char *)&i_v2, 184);
        usleep(i_g126);
        i_v6++;
    }
    int32_t i_v7 = uart_flush_rx(i_v1); // 0xadaa
    *p_v4 = 0;
    *p_v3 = 1;
    return i_v7;
}

// Address range: 0xadd4 - 0xb398
int32_t check_BM1725_asic_reg(int32_t i_a1, int32_t i_a2, uint32_t i_a3,
                              int32_t i_a4) {
    uint32_t i_v1 = 0x1000000 * i_a1 >> 24; // 0xaddc
    int32_t i_v2 = 0;                       // bp-56, 0xade6
    clear_register_value_buf();
    get_BM1725_asic_register((char)i_a1, (char)i_a2, (char)i_a3, (char)i_a4);
    char *p_v3 = (char *)(i_v1 % 256 + (int32_t)&i_g76 + (int32_t)&i_g1 + 1208);
    if (i_a3 % 256 == 0) {
        // 0xae16
        *p_v3 = 0;
    }
    int32_t i_v4 = -0x80000000; // 0xadd4
    goto lab_0xb2ee;
lab_0xae70:;
    // 0xae70
    int32_t i_v9; // 0xadd4
    int32_t i_v13 = i_v9;
    pthread_mutex_lock((int32_t *)((int32_t) "ettimeofday" | (int32_t)&p_g94));
    int32_t *p_v25 = (int32_t *)(i_g101 + 4); // 0xae90
    int32_t i_v26 = *p_v25;                   // 0xae90
    int32_t i_v22;                            // 0xadd4
    int32_t *p_v21;                           // 0xb1fe
    int32_t i_v16;                            // 0xadd4
    if (*(char *)(i_g101 + 25 + 10 * i_v26) == (char)i_v1) {
        // 0xaf32
        memset(&i_v2, 0, 8);
        int32_t i_v27 = i_g101;
        i_v2 = *(int32_t *)(i_v27 + 16 + 10 * *(int32_t *)(i_v27 + 4));
        int32_t i_v28 = CRC5((char *)&i_v2, 59); // 0xaf74
        int32_t *p_v29 = (int32_t *)(i_g101 + 4);
        int32_t i_v30 = *p_v29; // 0xaf90
        int32_t i_v31 = 10 * i_v30;
        if (i_v28 == (int32_t) * (char *)(i_g101 + 24 + i_v31)) {
            // 0xb03e
            i_v16 = i_v31;
            i_v22 = i_v30;
            p_v21 = p_v29;
            if (i_a3 % 256 == 0) {
                // 0xb046
                *p_v3 = *p_v3 + 1;
                printf((char *)((int32_t)&p_g242 | 0x20000));
                p_v21 = (int32_t *)(i_g101 + 4);
                i_v22 = *p_v21;
                i_v16 = 10 * i_v22;
                goto lab_0xb1ea;
            } else {
                goto lab_0xb1ea;
            }
        } else {
            // 0xafa4
            *p_v29 = i_v30 + 1;
            int32_t *p_v32 = (int32_t *)(i_g101 + 8); // 0xafbe
            *p_v32 = *p_v32 - 1;
            int32_t *p_v33 = (int32_t *)(i_g101 + 4); // 0xafce
            if (*p_v33 == 513) {
                // 0xafd8
                *p_v33 = 0;
                goto lab_0xafe6;
            } else {
                goto lab_0xafe6;
            }
        }
    } else {
        // 0xaea6
        *p_v25 = i_v26 + 1;
        int32_t *p_v34 = (int32_t *)(i_g101 + 8); // 0xaec0
        *p_v34 = *p_v34 - 1;
        int32_t *p_v35 = (int32_t *)(i_g101 + 4); // 0xaed0
        if (*p_v35 == 513) {
            // 0xaeda
            *p_v35 = 0;
            goto lab_0xaee8;
        } else {
            goto lab_0xaee8;
        }
    }
lab_0xb2ee:;
    int32_t i_v5;  // 0xadd4
    int32_t i_v6;  // 0xadd4
    uint32_t i_v7; // 0xae4e
    while (true) {
        // 0xb2ee
        i_v5 = i_v4;
        int32_t i_v8 = 0; // 0xb2ea
        while (true) {
            // 0xae30
            usleep(0xc350);
            pthread_mutex_lock(
                (int32_t *)((int32_t) "ettimeofday" | (int32_t)&p_g94));
            i_v7 = *(int32_t *)(i_g101 + 8);
            pthread_mutex_unlock(
                (int32_t *)((int32_t) "ettimeofday" | (int32_t)&p_g94));
            i_v6 = 0;
            i_v9 = i_v5;
            if (i_v7 != 0) {
                goto lab_0xae70;
            }
            // 0xb2ee
            i_v8++;
            if (i_v8 != 2 && i_v8 >= 2) {
                // break (via goto) -> 0xb2f6
                goto lab_0xb2f6;
            }
        }
    }
lab_0xb2f6:
    if (i_a3 % 256 != 0) {
        // 0xb386
        clear_register_value_buf();
        return i_v5;
    }
    int32_t i_v10 = (int32_t)*p_v3; // 0xb314
    uint32_t i_v11 = i_g96;         // 0xb328
    if (i_v11 != i_v10 && i_v11 <= i_v10) {
        // 0xb32e
        i_g96 = i_v10;
    }
    // 0xb358
    printf((char *)((int32_t) "thread_create" | 0x20000));
    // 0xb386
    clear_register_value_buf();
    return i_v5;
lab_0xaee8:
    // 0xaee8
    printf((char *)((int32_t)&p_g240 | 0x20000));
    pthread_mutex_unlock(
        (int32_t *)((int32_t) "ettimeofday" | (int32_t)&p_g94));
    int32_t i_v12 = i_v13; // 0xaf30
    goto lab_0xb2d6;
lab_0xb1ea:;
    int32_t i_v15 = i_v16 + i_g101;              // 0xb208
    unsigned char i_v17 = *(char *)(i_v15 + 16); // 0xb20c
    unsigned char i_v18 = *(char *)(i_v15 + 17); // 0xb232
    unsigned char i_v19 = *(char *)(i_v15 + 18); // 0xb25a
    unsigned char i_v20 = *(char *)(i_v15 + 19); // 0xb282
    *p_v21 = i_v22 + 1;
    int32_t *p_v23 = (int32_t *)(i_g101 + 8); // 0xb2a2
    *p_v23 = *p_v23 - 1;
    int32_t *p_v24 = (int32_t *)(i_g101 + 4); // 0xb2b2
    if (*p_v24 == 513) {
        // 0xb2bc
        *p_v24 = 0;
        // 0xb2ca
        pthread_mutex_unlock(
            (int32_t *)((int32_t) "ettimeofday" | (int32_t)&p_g94));
        i_v12 = 0x10000 * (int32_t)i_v18 | 0x1000000 * (int32_t)i_v17 |
                256 * (int32_t)i_v19 | (int32_t)i_v20;
        goto lab_0xb2d6;
    } else {
        // 0xb2ca
        pthread_mutex_unlock(
            (int32_t *)((int32_t) "ettimeofday" | (int32_t)&p_g94));
        i_v12 = 0x10000 * (int32_t)i_v18 | 0x1000000 * (int32_t)i_v17 |
                256 * (int32_t)i_v19 | (int32_t)i_v20;
        goto lab_0xb2d6;
    }
lab_0xafe6:
    // 0xafe6
    CRC5((char *)&i_v2, 59);
    printf((char *)((int32_t)&p_g241 | 0x20000));
    pthread_mutex_unlock(
        (int32_t *)((int32_t) "ettimeofday" | (int32_t)&p_g94));
    i_v12 = i_v13;
    goto lab_0xb2d6;
lab_0xb2d6:;
    int32_t i_v14 = i_v6 + 1; // 0xb2d8
    i_v6 = i_v14;
    i_v9 = i_v12;
    i_v4 = i_v12;
    if (i_v14 < i_v7) {
        goto lab_0xae70;
    } else {
        goto lab_0xb2ee;
    }
}

// Address range: 0xb398 - 0xb8b2
int32_t singleAsicTest_BM1725(void) {
    int32_t i_v1 = *(int32_t *)((int32_t) "conv" | (int32_t)&i_g5); // 0xb3ba
    int32_t i_v2 = i_v1; // bp-44, 0xb3c2
    printf((char *)((int32_t)&p_g243 | 0x20000));
    system((char *)((int32_t)&p_g244 | 0x20000));
    putchar(10);
    reset_global_arg();
    chain_reset((int32_t) * (char *)&p_g155);
    fan_control(50);
    unsigned char i_v3 = *(char *)&p_g155; // 0xb40c
    pthread_create(&i_g82, NULL, (int32_t * (*)(int32_t *))0xe135,
                   (int32_t *)(2 * (int32_t)i_v3 + (int32_t)&i_g100));
    unsigned char i_v4 = *(char *)&p_g155; // 0xb432
    *(char *)((int32_t)i_v4 + (int32_t)&p_g194) = 1;
    unsigned char i_v5 = *(char *)&p_g155; // 0xb44a
    pthread_create(&i_g81, NULL, (int32_t * (*)(int32_t *))0xebc5,
                   (int32_t *)(2 * (int32_t)i_v5 + (int32_t)&i_g100));
    set_baud((int32_t) * (char *)&p_g155, 26);
    puts((char *)((int32_t) "pthread_mutex_lock" | 0x20000));
    check_BM1725_asic_reg((int32_t) * (char *)&p_g155, 0, 0, 1);
    unsigned char i_v6 = *(char *)&p_g155; // 0xb4a4
    unsigned char i_v7 = *(char *)((int32_t)i_v6 + (int32_t)&i_g76 +
                                   (int32_t)&i_g1 + 1208); // 0xb4ba
    int32_t i_v8 =
        printf((char *)((int32_t) "ad_mutex_destroy" | 0x20000)); // 0xb4c6
    unsigned char i_v9 = *(char *)&p_g155;                        // 0xb4d2
    unsigned char i_v10 = *(char *)((int32_t)i_v9 + (int32_t)&i_g76 +
                                    (int32_t)&i_g1 + 1208); // 0xb4e8
    int32_t i_v11 = i_v10;                                  // 0xb4e8
    if (i_g113 != i_v11) {
        // 0xb4fa
        pthread_cancel(i_g81);
        pthread_cancel(i_g82);
        int32_t i_v12; // bp-37, 0xb398
        sprintf((char *)&i_v12,
                (char *)((int32_t) "read_mutex_init" | 0x20000));
        write_lcd(0, (int32_t) "_mutex_init" | 0x20000, 16);
        write_lcd_no_memset(1, &i_v2, 16);
        write_lcd_no_memset(2, (int32_t *)((int32_t) "gmon_start__" | 0x20000),
                            16);
        // 0xb8aa
        return printf((char *)((int32_t) ".6" | 0x20000));
    }
    // 0xb5bc
    calculate_timeout_and_baud(i_v8, (int32_t)i_v7, i_v11, i_v11);
    set_baud((int32_t) * (char *)&p_g155, i_g145 % 256);
    __asm_vmov_f32(__asm_vcvt_f32_u32(__asm_vldr(i_g111)));
    set_BM1725_freq((int32_t) * (char *)&p_g155, 0, 1);
    BM1725_set_address_all((int32_t) * (char *)&p_g155);
    check_BM1725_asic_reg((int32_t) * (char *)&p_g155, 0, 0, 1);
    if (i_g144 == 1) {
        // 0xb63e
        set_BM1725_asic_register((int32_t) * (char *)&p_g155, 0, 64, 0, 1);
        int32_t i_v13 = (int32_t) * (char *)&p_g155;
        if (*(char *)&p_g188 == 0) {
            // 0xb666
            get_temperature_offset_value_from_asic_chain(i_v13);
            set_default_temperature_offset_value_chain((int32_t) *
                                                       (char *)&p_g155);
        } else {
            // 0xb688
            set_default_temperature_offset_value_chain(i_v13);
        }
    }
    unsigned char i_v14 = *(char *)&p_g155; // 0xb6a0
    pthread_create(&i_g84, NULL, (int32_t * (*)(int32_t *))0xf349,
                   (int32_t *)(2 * (int32_t)i_v14 + (int32_t)&i_g100));
    set_BM1725_asic_register((int32_t) * (char *)&p_g155, 0, 20, 1, 38);
    BM1725_open_core((int32_t) * (char *)&p_g155);
    puts((char *)((int32_t) "en" | 0x20000));
    system((char *)((int32_t)&p_g244 | 0x20000));
    putchar(10);
    int32_t i_v15 = (int32_t) * (char *)&p_g155; // 0xb7e2
    int32_t i_v16 = i_v15;                       // 0xb7f8
    int32_t i_v17 = i_v15;                       // 0xb7f8
    if (*(char *)(i_v15 + (int32_t)&p_g191) == 1) {
    lab_0xb7fa:
        // 0xb7fa
        pthread_create(&i_g80, NULL, (int32_t * (*)(int32_t *))0xef59,
                       (int32_t *)(2 * i_v17 + (int32_t)&i_g100));
        pthread_join(i_g80, NULL);
        pthread_join(i_g81, NULL);
        pthread_cancel(i_g82);
        pthread_cancel(i_g84);
        int32_t i_v18 =
            single_asic_get_result((int32_t) * (char *)&p_g155); // 0xb88c
        single_asic_print_lcd((int32_t) * (char *)&p_g155, i_v18);
        // 0xb8aa
        return fan_control(0);
    }
    while (*(int32_t *)(4 * i_v16 + (int32_t)&i_g190) < i_g135) {
        // 0xb7d2
        usleep(0x2710);
        i_v16 = (int32_t) * (char *)&p_g155;
        i_v17 = i_v16;
        if (*(char *)(i_v16 + (int32_t)&p_g191) == 1) {
            goto lab_0xb7fa;
        }
    }
    // 0xb73c
    pthread_cancel(i_g84);
    pthread_cancel(i_g81);
    pthread_cancel(i_g82);
    puts((char *)((int32_t) "isnan" | 0x20000));
    write_lcd(0, (int32_t)&i_g245 | 0x20000, 16);
    write_lcd_no_memset(1, (int32_t *)((int32_t) "od" | 0x20000), 16);
    int32_t i_v19 = write_lcd_no_memset(
        2, (int32_t *)((int32_t) "strlen" | 0x20000), 16); // 0xb7b4
    *(char *)&p_g188 = (char)((int32_t)&i_g189 & 255);
    // 0xb8aa
    return i_v19;
}

// Address range: 0xb8b8 - 0xc20c
int32_t singleBoardTest_BBD25601(void) {
    int32_t i_v1 = *(int32_t *)((int32_t) "conv" | (int32_t)&i_g5); // 0xb8d4
    int32_t i_v2 = i_v1; // bp-44, 0xb8dc
    printf((char *)((int32_t)&p_g243 | 0x20000));
    system((char *)((int32_t)&p_g244 | 0x20000));
    putchar(10);
    reset_global_arg();
    chain_reset((int32_t) * (char *)&p_g155);
    unsigned char i_v3 = *(char *)&p_g155; // 0xb920
    pthread_create(&i_g82, NULL, (int32_t * (*)(int32_t *))0xe135,
                   (int32_t *)(2 * (int32_t)i_v3 + (int32_t)&i_g100));
    chain_reset_low((int32_t) * (char *)&p_g155);
    usleep((int32_t)&i_g204);
    power_init();
    reset_PIC16F1704_pic((int32_t) * (char *)&p_g155, 0);
    jump_from_loader_to_app_PIC16F1704((int32_t) * (char *)&p_g155, 0);
    unsigned char i_v4 = *(char *)&p_g155; // 0xb9a2
    pthread_create(&i_g83, NULL, (int32_t * (*)(int32_t *))0x14089,
                   (int32_t *)(2 * (int32_t)i_v4 + (int32_t)&i_g100));
    usleep(100);
    int32_t i_v5 = (int32_t) * (char *)&p_g155; // 0xb9ce
    set_voltage(i_v5, 255, 0, i_v5);
    enable_PIC16F1704_dc_dc((int32_t) * (char *)&p_g155, 0, 1);
    chain_reset_high((int32_t) * (char *)&p_g155);
    usleep((int32_t)&i_g204);
    fan_control(80);
    set_baud((int32_t) * (char *)&p_g155, 26);
    unsigned char i_v6 = *(char *)&p_g155; // 0xba36
    *(char *)((int32_t)i_v6 + (int32_t)&p_g194) = 1;
    unsigned char i_v7 = *(char *)&p_g155; // 0xba4e
    pthread_create(&i_g81, NULL, (int32_t * (*)(int32_t *))0xebc5,
                   (int32_t *)(2 * (int32_t)i_v7 + (int32_t)&i_g100));
    usleep(0x1388);
    puts((char *)((int32_t)&p_g246 | 0x20000));
    check_BM1725_asic_reg((int32_t) * (char *)&p_g155, 0, 0, 1);
    printf((char *)((int32_t)&p_g247 | 0x20000));
    int32_t i_v8 = (int32_t) * (char *)&p_g155; // 0xbada
    unsigned char i_v9 =
        *(char *)(i_v8 + (int32_t)&i_g76 + (int32_t)&i_g1 + 1208); // 0xbaf0
    int32_t i_v10; // bp-37, 0xb8b8
    if (i_g113 != (int32_t)i_v9) {
        // 0xbb04
        pthread_cancel(i_g81);
        pthread_cancel(i_g82);
        pthread_mutex_lock(&i_g186);
        pthread_cancel(i_g83);
        pthread_mutex_unlock(&i_g186);
        sprintf((char *)&i_v10,
                (char *)((int32_t) "read_mutex_init" | 0x20000));
        write_lcd(0, (int32_t) "_mutex_init" | 0x20000, 16);
        write_lcd_no_memset(1, &i_v2, 16);
        write_lcd_no_memset(2, (int32_t *)((int32_t) "gmon_start__" | 0x20000),
                            16);
        printf((char *)((int32_t) "te" | 0x20000));
        sleep(i_g146);
        enable_PIC16F1704_dc_dc((int32_t) * (char *)&p_g155, 0, 0);
        // 0xc204
        return power_off();
    }
    // 0xbc38
    chain_reset(i_v8);
    uart_flush((int32_t) * (char *)&p_g155);
    uart_set_baud((int32_t) * (char *)&p_g155, 26);
    puts((char *)((int32_t) "qsort" | 0x20000));
    check_BM1725_asic_reg((int32_t) * (char *)&p_g155, 0, 0, 1);
    int32_t i_v11 = printf((char *)((int32_t)&p_g247 | 0x20000)); // 0xbcc4
    unsigned char i_v12 = *(char *)&p_g155;                       // 0xbcd0
    unsigned char i_v13 = *(char *)((int32_t)i_v12 + (int32_t)&i_g76 +
                                    (int32_t)&i_g1 + 1208); // 0xbce6
    int32_t i_v14 = i_v13;                                  // 0xbce6
    if (i_g113 != i_v14) {
        // 0xbcfa
        pthread_cancel(i_g81);
        pthread_cancel(i_g82);
        pthread_mutex_lock(&i_g186);
        pthread_cancel(i_g83);
        pthread_mutex_unlock(&i_g186);
        sprintf((char *)&i_v10,
                (char *)((int32_t) "read_mutex_init" | 0x20000));
        write_lcd(0, (int32_t) "_mutex_init" | 0x20000, 16);
        write_lcd_no_memset(1, &i_v2, 16);
        write_lcd_no_memset(2, (int32_t *)((int32_t) "gmon_start__" | 0x20000),
                            16);
        printf((char *)((int32_t) "te" | 0x20000));
        sleep(i_g146);
        enable_PIC16F1704_dc_dc((int32_t) * (char *)&p_g155, 0, 0);
        // 0xc204
        return power_off();
    }
    // 0xbe20
    calculate_timeout_and_baud(i_v11, (int32_t) * (char *)&p_g155, i_v14,
                               i_v14);
    set_baud((int32_t) * (char *)&p_g155, i_g145 % 256);
    __asm_vmov_f32(__asm_vcvt_f32_u32(__asm_vldr(i_g111)));
    set_BM1725_freq((int32_t) * (char *)&p_g155, 0, 1);
    BM1725_set_address_all((int32_t) * (char *)&p_g155);
    check_BM1725_asic_reg((int32_t) * (char *)&p_g155, 0, 0, 1);
    if (i_g144 == 1) {
        int32_t i_v15 = (int32_t) * (char *)&p_g155;
        if (*(char *)&p_g188 == 0) {
            // 0xbeb0
            get_temperature_offset_value_from_asic_chain(i_v15);
            set_default_temperature_offset_value_chain((int32_t) *
                                                       (char *)&p_g155);
        } else {
            // 0xbed2
            set_default_temperature_offset_value_chain(i_v15);
        }
    }
    unsigned char i_v16 = *(char *)&p_g155; // 0xbeea
    pthread_create(&i_g84, NULL, (int32_t * (*)(int32_t *))0xf349,
                   (int32_t *)(2 * (int32_t)i_v16 + (int32_t)&i_g100));
    set_BM1725_asic_register((int32_t) * (char *)&p_g155, 0, 20, 1, 38);
    BM1725_open_core((int32_t) * (char *)&p_g155);
    puts((char *)((int32_t) "en" | 0x20000));
    int32_t i_v17 = (int32_t) * (char *)&p_g155; // 0xc048
    int32_t i_v18 = i_v17;                       // 0xc05e
    int32_t i_v19 = i_v17;                       // 0xc05e
    if (*(char *)(i_v17 + (int32_t)&p_g191) != 1) {
        while (*(int32_t *)(4 * i_v18 + (int32_t)&i_g190) < i_g135) {
            // 0xc038
            usleep(0x2710);
            i_v18 = (int32_t) * (char *)&p_g155;
            i_v19 = i_v18;
            if (*(char *)(i_v18 + (int32_t)&p_g191) == 1) {
                goto lab_0xc062;
            }
        }
        // 0xbf68
        pthread_cancel(i_g84);
        pthread_cancel(i_g81);
        pthread_cancel(i_g82);
        pthread_cancel(i_g83);
        puts((char *)((int32_t) "isnan" | 0x20000));
        write_lcd(0, (int32_t)&i_g245 | 0x20000, 16);
        write_lcd_no_memset(1, (int32_t *)((int32_t) "od" | 0x20000), 16);
        write_lcd_no_memset(2, (int32_t *)((int32_t) "strlen" | 0x20000), 16);
        *(char *)&p_g188 = (char)((int32_t)&i_g189 & 255);
        enable_PIC16F1704_dc_dc((int32_t) * (char *)&p_g155, 0, 0);
        // 0xc204
        return power_off();
    }
lab_0xc062:
    // 0xc062
    pthread_create(&i_g80, NULL, (int32_t * (*)(int32_t *))0xef59,
                   (int32_t *)(2 * i_v19 + (int32_t)&i_g100));
    pthread_join(i_g80, NULL);
    pthread_join(i_g81, NULL);
    pthread_cancel(i_g82);
    pthread_cancel(i_g84);
    uint32_t i_v20 =
        single_board_get_result((int32_t) * (char *)&p_g155); // 0xc0f4
    if (i_v20 == 7) {
        uint32_t i_v21 = save_voltage_info_to_eeprom(i_g111, i_g116); // 0xc11a
        *(char *)&p_g34 = (char)i_v21;
        if (i_v21 % 256 != 1) {
            int32_t i_v22 =
                save_voltage_info_to_eeprom(i_g111, i_g116); // 0xc15a
            *(char *)&p_g34 = (char)i_v22;
        }
        // 0xc16c
        single_board_print_lcd(7);
        goto lab_0xc194;
    } else {
        // 0xc16c
        single_board_print_lcd(i_v20);
        if (i_v20 % 2 == 0) {
            // 0xc17c
            if (*(char *)&p_g188 < *(char *)&p_g187) {
                goto lab_0xc1d6;
            } else {
                goto lab_0xc194;
            }
        } else {
            goto lab_0xc194;
        }
    }
lab_0xc194:
    // 0xc194
    enable_PIC16F1704_dc_dc((int32_t) * (char *)&p_g155, 0, 0);
    power_off();
    fan_control(0);
    printf((char *)((int32_t) "rror" | 0x20000));
    goto lab_0xc1d6;
lab_0xc1d6:
    // 0xc1d6
    pthread_mutex_lock(&i_g186);
    pthread_cancel(i_g83);
    // 0xc204
    return pthread_mutex_unlock(&i_g186);
}

// Address range: 0xc214 - 0xc2c4
int32_t calculate_asic_number(uint32_t i_a1) {
    int32_t i_v1 = 1; // 0xc214
    switch (i_a1) {
    case 2: {
        // 0xc2ba
        return 2;
    }
    default: {
        if (i_a1 < 2) {
            // 0xc2a4
            printf("actual_asic_number = %d, but it is error\n", i_a1);
            // 0xc2ba
            return -1;
        }
        // 0xc23e
        if (i_a1 >= 4 != i_a1 != 4) {
            // 0xc2ba
            return 4;
        }
        if (i_a1 != 4 && i_a1 >= 4) {
            // 0xc250
            if (i_a1 >= 8 != i_a1 != 8) {
                // 0xc2ba
                return 8;
            }
        }
        if (i_a1 != 8 && i_a1 >= 8) {
            // 0xc262
            if (i_a1 >= 16 != i_a1 != 16) {
                // 0xc2ba
                return 16;
            }
        }
        if (i_a1 != 16 && i_a1 >= 16) {
            // 0xc274
            if (i_a1 >= 32 != i_a1 != 32) {
                // 0xc2ba
                return 32;
            }
        }
        if (i_a1 != 32 && i_a1 >= 32) {
            // 0xc286
            if (i_a1 >= 64 != i_a1 != 64) {
                // 0xc2ba
                return 64;
            }
        }
        if (i_a1 == 64 || i_a1 < 64) {
            // 0xc2a4
            printf("actual_asic_number = %d, but it is error\n", i_a1);
            // 0xc2ba
            return -1;
        }
        // 0xc298
        i_v1 = 128;
        if (i_a1 >= 128 == (i_a1 != 128)) {
            // 0xc2a4
            printf("actual_asic_number = %d, but it is error\n", i_a1);
            // 0xc2ba
            return -1;
        }
    }
    case 1: {
        // 0xc2ba
        return i_v1;
    }
    }
}

// Address range: 0xc2c4 - 0xd32a
int32_t read_config(void) {
    // 0xc2c4
    int32_t i_v1; // bp-1052, 0xc2c4
    memset(&i_v1, 0, 1024);
    struct _IO_FILE *p_v2 =
        fopen((char *)((int32_t)&p_g249 | 0x20000),
              (char *)((int32_t)&p_g250 | 0x20000)); // 0xc300
    char *p_v3 = fgets((char *)&i_v1, 1023, p_v2);   // 0xd180
    if (p_v3 != NULL) {
        // 0xc30c
        char i_v4;           // 0xc2c4
        int32_t i_v5;        // 0xc2c4
        int32_t i_v6;        // 0xc2c4
        int32_t i_v7;        // 0xc2c4
        int32_t i_v8;        // 0xc2c4
        char *p_v9;          // 0xc2c4
        int32_t i_v10;       // 0xc2c4
        int32_t i_v11;       // 0xc2c4
        int32_t i_v12;       // 0xc2c4
        char *p_v13;         // 0xc32c
        char i_v14;          // 0xc2c4
        char *p_v15;         // 0xc4d4
        int32_t i_v16;       // 0xc32c
        char *p_v17;         // 0xc344
        char *p_v18;         // 0xc516
        char *p_v19;         // 0xc368
        char i_v20;          // 0xc370
        char *p_v21;         // 0xc558
        int32_t i_v22;       // 0xc384
        unsigned char i_v23; // 0xc3d4
        char *p_v24;         // 0xc59a
        char *p_v25;         // 0xc5dc
        char *p_v26;         // 0xc61e
        char *p_v27;         // 0xc660
        char *p_v28;         // 0xc6a2
        char *p_v29;         // 0xc6e4
        char *p_v30;         // 0xc726
        char *p_v31;         // 0xc768
        char *p_v32;         // 0xc7aa
        char *p_v33;         // 0xc7ec
        char *p_v34;         // 0xc82e
        char *p_v35;         // 0xc896
        char *p_v36;         // 0xc8fe
        char *p_v37;         // 0xc966
        char *p_v38;         // 0xc9cc
        char *p_v39;         // 0xca32
        char *p_v40;         // 0xca98
        char *p_v41;         // 0xcafe
        char *p_v42;         // 0xcb64
        char *p_v43;         // 0xcbca
        char *p_v44;         // 0xcc0a
        char *p_v45;         // 0xcc4a
        char *p_v46;         // 0xcc8a
        char *p_v47;         // 0xcccc
        char *p_v48;         // 0xcd30
        char *p_v49;         // 0xcd94
        char *p_v50;         // 0xcdf8
        char *p_v51;         // 0xce38
        char *p_v52;         // 0xce78
        char *p_v53;         // 0xceb8
        char *p_v54;         // 0xcef8
        char *p_v55;         // 0xcf38
        char *p_v56;         // 0xcf78
        char *p_v57;         // 0xcfb8
        char *p_v58;         // 0xcff8
        char *p_v59;         // 0xd038
        char *p_v60;         // 0xd078
        char *p_v61;         // 0xd0b8
        char *p_v62;         // 0xd0f8
        char *p_v63;         // 0xd138
        if (i_v14 == 35 || i_v1 % 256 == 35) {
            // 0xd16e
            __asm_nop((int32_t)p_v3, 1023, (int32_t)p_v2, 35);
        } else {
            // 0xc320
            p_v13 = strstr((char *)&i_v1, (char *)((int32_t)&p_g251 | 0x20000));
            if (p_v13 == NULL) {
                // 0xc4c8
                p_v15 =
                    strstr((char *)&i_v1, (char *)((int32_t)&p_g254 | 0x20000));
                if (p_v15 == NULL) {
                    // 0xc50a
                    p_v18 = strstr((char *)&i_v1,
                                   (char *)((int32_t)&p_g256 | 0x20000));
                    if (p_v18 == NULL) {
                        // 0xc54c
                        p_v21 = strstr((char *)&i_v1,
                                       (char *)((int32_t)&p_g257 | 0x20000));
                        if (p_v21 == NULL) {
                            // 0xc58e
                            p_v24 =
                                strstr((char *)&i_v1,
                                       (char *)((int32_t)&p_g258 | 0x20000));
                            if (p_v24 == NULL) {
                                // 0xc5d0
                                p_v25 = strstr(
                                    (char *)&i_v1,
                                    (char *)((int32_t)&p_g259 | 0x20000));
                                if (p_v25 == NULL) {
                                    // 0xc612
                                    p_v26 = strstr(
                                        (char *)&i_v1,
                                        (char *)((int32_t)&p_g260 | 0x20000));
                                    if (p_v26 == NULL) {
                                        // 0xc654
                                        p_v27 =
                                            strstr((char *)&i_v1,
                                                   (char *)((int32_t)&p_g261 |
                                                            0x20000));
                                        if (p_v27 == NULL) {
                                            // 0xc696
                                            p_v28 = strstr(
                                                (char *)&i_v1,
                                                (char *)((int32_t)&p_g262 |
                                                         0x20000));
                                            if (p_v28 == NULL) {
                                                // 0xc6d8
                                                p_v29 = strstr(
                                                    (char *)&i_v1,
                                                    (char *)((int32_t)&p_g263 |
                                                             0x20000));
                                                if (p_v29 == NULL) {
                                                    // 0xc71a
                                                    p_v30 = strstr(
                                                        (char *)&i_v1,
                                                        (char
                                                             *)((int32_t)&p_g264 |
                                                                0x20000));
                                                    if (p_v30 == NULL) {
                                                        // 0xc75c
                                                        p_v31 = strstr(
                                                            (char *)&i_v1,
                                                            (char
                                                                 *)((int32_t)&p_g265 |
                                                                    0x20000));
                                                        if (p_v31 == NULL) {
                                                            // 0xc79e
                                                            p_v32 = strstr(
                                                                (char *)&i_v1,
                                                                (char
                                                                     *)((int32_t)&p_g266 |
                                                                        0x20000));
                                                            if (p_v32 == NULL) {
                                                                // 0xc7e0
                                                                p_v33 = strstr(
                                                                    (char
                                                                         *)&i_v1,
                                                                    (char
                                                                         *)((int32_t)&p_g267 |
                                                                            0x20000));
                                                                if (p_v33 ==
                                                                    NULL) {
                                                                    // 0xc822
                                                                    p_v34 = strstr(
                                                                        (char
                                                                             *)&i_v1,
                                                                        (char
                                                                             *)((int32_t)&p_g268 |
                                                                                0x20000));
                                                                    if (p_v34 ==
                                                                        NULL) {
                                                                        // 0xc88a
                                                                        p_v35 = strstr(
                                                                            (char
                                                                                 *)&i_v1,
                                                                            (char
                                                                                 *)((int32_t)&p_g269 |
                                                                                    0x20000));
                                                                        if (p_v35 ==
                                                                            NULL) {
                                                                            // 0xc8f2
                                                                            p_v36 = strstr(
                                                                                (char
                                                                                     *)&i_v1,
                                                                                (char
                                                                                     *)((int32_t)&p_g270 |
                                                                                        0x20000));
                                                                            if (p_v36 ==
                                                                                NULL) {
                                                                                // 0xc95a
                                                                                p_v37 = strstr(
                                                                                    (char
                                                                                         *)&i_v1,
                                                                                    (char
                                                                                         *)((int32_t)&p_g271 |
                                                                                            0x20000));
                                                                                if (p_v37 ==
                                                                                    NULL) {
                                                                                    // 0xc9c0
                                                                                    p_v38 = strstr(
                                                                                        (char
                                                                                             *)&i_v1,
                                                                                        (char
                                                                                             *)((int32_t)&p_g272 |
                                                                                                0x20000));
                                                                                    if (p_v38 ==
                                                                                        NULL) {
                                                                                        // 0xca26
                                                                                        p_v39 = strstr(
                                                                                            (char
                                                                                                 *)&i_v1,
                                                                                            (char
                                                                                                 *)((int32_t)&p_g273 |
                                                                                                    0x20000));
                                                                                        if (p_v39 ==
                                                                                            NULL) {
                                                                                            // 0xca8c
                                                                                            p_v40 = strstr(
                                                                                                (char
                                                                                                     *)&i_v1,
                                                                                                (char
                                                                                                     *)((int32_t)&p_g274 |
                                                                                                        0x20000));
                                                                                            if (p_v40 ==
                                                                                                NULL) {
                                                                                                // 0xcaf2
                                                                                                p_v41 = strstr(
                                                                                                    (char
                                                                                                         *)&i_v1,
                                                                                                    (char
                                                                                                         *)((int32_t)&p_g275 |
                                                                                                            0x20000));
                                                                                                if (p_v41 ==
                                                                                                    NULL) {
                                                                                                    // 0xcb58
                                                                                                    p_v42 = strstr(
                                                                                                        (char
                                                                                                             *)&i_v1,
                                                                                                        (char
                                                                                                             *)((int32_t)&p_g276 |
                                                                                                                0x20000));
                                                                                                    if (p_v42 ==
                                                                                                        NULL) {
                                                                                                        // 0xcbbe
                                                                                                        p_v43 = strstr(
                                                                                                            (char
                                                                                                                 *)&i_v1,
                                                                                                            (char
                                                                                                                 *)((int32_t)&p_g277 |
                                                                                                                    0x20000));
                                                                                                        if (p_v43 ==
                                                                                                            NULL) {
                                                                                                            // 0xcbfe
                                                                                                            p_v44 = strstr(
                                                                                                                (char
                                                                                                                     *)&i_v1,
                                                                                                                (char
                                                                                                                     *)((int32_t)&p_g278 |
                                                                                                                        0x20000));
                                                                                                            if (p_v44 ==
                                                                                                                NULL) {
                                                                                                                // 0xcc3e
                                                                                                                p_v45 = strstr(
                                                                                                                    (char
                                                                                                                         *)&i_v1,
                                                                                                                    (char
                                                                                                                         *)((int32_t)&p_g279 |
                                                                                                                            0x20000));
                                                                                                                if (p_v45 ==
                                                                                                                    NULL) {
                                                                                                                    // 0xcc7e
                                                                                                                    p_v46 = strstr(
                                                                                                                        (char
                                                                                                                             *)&i_v1,
                                                                                                                        (char
                                                                                                                             *)((int32_t)&p_g281 |
                                                                                                                                0x20000));
                                                                                                                    if (p_v46 ==
                                                                                                                        NULL) {
                                                                                                                        // 0xccc0
                                                                                                                        p_v47 = strstr(
                                                                                                                            (char
                                                                                                                                 *)&i_v1,
                                                                                                                            (char
                                                                                                                                 *)((int32_t)&p_g282 |
                                                                                                                                    0x20000));
                                                                                                                        if (p_v47 ==
                                                                                                                            NULL) {
                                                                                                                            // 0xcd24
                                                                                                                            p_v48 = strstr(
                                                                                                                                (char
                                                                                                                                     *)&i_v1,
                                                                                                                                (char
                                                                                                                                     *)((int32_t)&p_g283 |
                                                                                                                                        0x20000));
                                                                                                                            if (p_v48 ==
                                                                                                                                NULL) {
                                                                                                                                // 0xcd88
                                                                                                                                p_v49 = strstr(
                                                                                                                                    (char
                                                                                                                                         *)&i_v1,
                                                                                                                                    (char
                                                                                                                                         *)((int32_t)&p_g284 |
                                                                                                                                            0x20000));
                                                                                                                                if (p_v49 ==
                                                                                                                                    NULL) {
                                                                                                                                    // 0xcdec
                                                                                                                                    p_v50 = strstr(
                                                                                                                                        (char
                                                                                                                                             *)&i_v1,
                                                                                                                                        (char
                                                                                                                                             *)((int32_t)&p_g285 |
                                                                                                                                                0x20000));
                                                                                                                                    if (p_v50 ==
                                                                                                                                        NULL) {
                                                                                                                                        // 0xce2c
                                                                                                                                        p_v51 = strstr(
                                                                                                                                            (char
                                                                                                                                                 *)&i_v1,
                                                                                                                                            (char
                                                                                                                                                 *)((int32_t)&p_g286 |
                                                                                                                                                    0x20000));
                                                                                                                                        if (p_v51 ==
                                                                                                                                            NULL) {
                                                                                                                                            // 0xce6c
                                                                                                                                            p_v52 = strstr(
                                                                                                                                                (char
                                                                                                                                                     *)&i_v1,
                                                                                                                                                (char
                                                                                                                                                     *)((int32_t)&p_g287 |
                                                                                                                                                        0x20000));
                                                                                                                                            if (p_v52 ==
                                                                                                                                                NULL) {
                                                                                                                                                // 0xceac
                                                                                                                                                p_v53 = strstr(
                                                                                                                                                    (char
                                                                                                                                                         *)&i_v1,
                                                                                                                                                    (char
                                                                                                                                                         *)((int32_t)&p_g288 |
                                                                                                                                                            0x20000));
                                                                                                                                                if (p_v53 ==
                                                                                                                                                    NULL) {
                                                                                                                                                    // 0xceec
                                                                                                                                                    p_v54 = strstr(
                                                                                                                                                        (char
                                                                                                                                                             *)&i_v1,
                                                                                                                                                        (char
                                                                                                                                                             *)((int32_t)&p_g289 |
                                                                                                                                                                0x20000));
                                                                                                                                                    if (p_v54 ==
                                                                                                                                                        NULL) {
                                                                                                                                                        // 0xcf2c
                                                                                                                                                        p_v55 = strstr(
                                                                                                                                                            (char
                                                                                                                                                                 *)&i_v1,
                                                                                                                                                            (char
                                                                                                                                                                 *)((int32_t)&p_g290 |
                                                                                                                                                                    0x20000));
                                                                                                                                                        if (p_v55 ==
                                                                                                                                                            NULL) {
                                                                                                                                                            // 0xcf6c
                                                                                                                                                            p_v56 = strstr(
                                                                                                                                                                (char
                                                                                                                                                                     *)&i_v1,
                                                                                                                                                                "HeatingUpTime=");
                                                                                                                                                            if (p_v56 ==
                                                                                                                                                                NULL) {
                                                                                                                                                                // 0xcfac
                                                                                                                                                                p_v57 = strstr(
                                                                                                                                                                    (char
                                                                                                                                                                         *)&i_v1,
                                                                                                                                                                    "MaxTempGap=");
                                                                                                                                                                if (p_v57 ==
                                                                                                                                                                    NULL) {
                                                                                                                                                                    // 0xcfec
                                                                                                                                                                    p_v58 = strstr(
                                                                                                                                                                        (char
                                                                                                                                                                             *)&i_v1,
                                                                                                                                                                        (char
                                                                                                                                                                             *)((int32_t)&p_g291 |
                                                                                                                                                                                0x20000));
                                                                                                                                                                    if (p_v58 ==
                                                                                                                                                                        NULL) {
                                                                                                                                                                        // 0xd02c
                                                                                                                                                                        p_v59 = strstr(
                                                                                                                                                                            (char
                                                                                                                                                                                 *)&i_v1,
                                                                                                                                                                            "Invalid_Core_Num=");
                                                                                                                                                                        if (p_v59 ==
                                                                                                                                                                            NULL) {
                                                                                                                                                                            // 0xd06c
                                                                                                                                                                            p_v60 = strstr(
                                                                                                                                                                                (char
                                                                                                                                                                                     *)&i_v1,
                                                                                                                                                                                "Least_nonce_per_core=");
                                                                                                                                                                            if (p_v60 ==
                                                                                                                                                                                NULL) {
                                                                                                                                                                                // 0xd0ac
                                                                                                                                                                                p_v61 = strstr(
                                                                                                                                                                                    (char
                                                                                                                                                                                         *)&i_v1,
                                                                                                                                                                                    "Most_lost_nonce_total=");
                                                                                                                                                                                if (p_v61 ==
                                                                                                                                                                                    NULL) {
                                                                                                                                                                                    // 0xd0ec
                                                                                                                                                                                    p_v62 = strstr(
                                                                                                                                                                                        (char
                                                                                                                                                                                             *)&i_v1,
                                                                                                                                                                                        "Most_HW_Num=");
                                                                                                                                                                                    if (p_v62 ==
                                                                                                                                                                                        NULL) {
                                                                                                                                                                                        // 0xd12c
                                                                                                                                                                                        p_v63 = strstr(
                                                                                                                                                                                            (char
                                                                                                                                                                                                 *)&i_v1,
                                                                                                                                                                                            "close_power_delay=");
                                                                                                                                                                                        if (p_v63 !=
                                                                                                                                                                                            NULL) {
                                                                                                                                                                                            // 0xd148
                                                                                                                                                                                            sscanf(
                                                                                                                                                                                                (char
                                                                                                                                                                                                     *)((int32_t)
                                                                                                                                                                                                            p_v63 +
                                                                                                                                                                                                        18),
                                                                                                                                                                                                (char
                                                                                                                                                                                                     *)((int32_t)&p_g255 |
                                                                                                                                                                                                        0x20000));
                                                                                                                                                                                        }
                                                                                                                                                                                    } else {
                                                                                                                                                                                        // 0xd108
                                                                                                                                                                                        sscanf(
                                                                                                                                                                                            (char
                                                                                                                                                                                                 *)((int32_t)
                                                                                                                                                                                                        p_v62 +
                                                                                                                                                                                                    12),
                                                                                                                                                                                            (char
                                                                                                                                                                                                 *)((int32_t)&p_g255 |
                                                                                                                                                                                                    0x20000));
                                                                                                                                                                                    }
                                                                                                                                                                                } else {
                                                                                                                                                                                    // 0xd0c8
                                                                                                                                                                                    sscanf(
                                                                                                                                                                                        (char
                                                                                                                                                                                             *)((int32_t)
                                                                                                                                                                                                    p_v61 +
                                                                                                                                                                                                22),
                                                                                                                                                                                        (char
                                                                                                                                                                                             *)((int32_t)&p_g255 |
                                                                                                                                                                                                0x20000));
                                                                                                                                                                                }
                                                                                                                                                                            } else {
                                                                                                                                                                                // 0xd088
                                                                                                                                                                                sscanf(
                                                                                                                                                                                    (char
                                                                                                                                                                                         *)((int32_t)
                                                                                                                                                                                                p_v60 +
                                                                                                                                                                                            21),
                                                                                                                                                                                    (char
                                                                                                                                                                                         *)((int32_t)&p_g255 |
                                                                                                                                                                                            0x20000));
                                                                                                                                                                            }
                                                                                                                                                                        } else {
                                                                                                                                                                            // 0xd048
                                                                                                                                                                            sscanf(
                                                                                                                                                                                (char
                                                                                                                                                                                     *)((int32_t)
                                                                                                                                                                                            p_v59 +
                                                                                                                                                                                        17),
                                                                                                                                                                                (char
                                                                                                                                                                                     *)((int32_t)&p_g255 |
                                                                                                                                                                                        0x20000));
                                                                                                                                                                        }
                                                                                                                                                                    } else {
                                                                                                                                                                        // 0xd008
                                                                                                                                                                        sscanf(
                                                                                                                                                                            (char
                                                                                                                                                                                 *)((int32_t)
                                                                                                                                                                                        p_v58 +
                                                                                                                                                                                    17),
                                                                                                                                                                            (char
                                                                                                                                                                                 *)((int32_t)&p_g255 |
                                                                                                                                                                                    0x20000));
                                                                                                                                                                    }
                                                                                                                                                                } else {
                                                                                                                                                                    // 0xcfc8
                                                                                                                                                                    sscanf(
                                                                                                                                                                        (char
                                                                                                                                                                             *)((int32_t)
                                                                                                                                                                                    p_v57 +
                                                                                                                                                                                11),
                                                                                                                                                                        (char
                                                                                                                                                                             *)((int32_t)&p_g255 |
                                                                                                                                                                                0x20000));
                                                                                                                                                                }
                                                                                                                                                            } else {
                                                                                                                                                                // 0xcf88
                                                                                                                                                                sscanf(
                                                                                                                                                                    (char
                                                                                                                                                                         *)((int32_t)
                                                                                                                                                                                p_v56 +
                                                                                                                                                                            14),
                                                                                                                                                                    (char
                                                                                                                                                                         *)((int32_t)&p_g255 |
                                                                                                                                                                            0x20000));
                                                                                                                                                            }
                                                                                                                                                        } else {
                                                                                                                                                            // 0xcf48
                                                                                                                                                            sscanf(
                                                                                                                                                                (char
                                                                                                                                                                     *)((int32_t)
                                                                                                                                                                            p_v55 +
                                                                                                                                                                        10),
                                                                                                                                                                (char
                                                                                                                                                                     *)((int32_t)&p_g255 |
                                                                                                                                                                        0x20000));
                                                                                                                                                        }
                                                                                                                                                    } else {
                                                                                                                                                        // 0xcf08
                                                                                                                                                        sscanf(
                                                                                                                                                            (char
                                                                                                                                                                 *)((int32_t)
                                                                                                                                                                        p_v54 +
                                                                                                                                                                    18),
                                                                                                                                                            (char
                                                                                                                                                                 *)((int32_t)&p_g255 |
                                                                                                                                                                    0x20000));
                                                                                                                                                    }
                                                                                                                                                } else {
                                                                                                                                                    // 0xcec8
                                                                                                                                                    sscanf(
                                                                                                                                                        (char
                                                                                                                                                             *)((int32_t)
                                                                                                                                                                    p_v53 +
                                                                                                                                                                26),
                                                                                                                                                        (char
                                                                                                                                                             *)((int32_t)&p_g255 |
                                                                                                                                                                0x20000));
                                                                                                                                                }
                                                                                                                                            } else {
                                                                                                                                                // 0xce88
                                                                                                                                                sscanf(
                                                                                                                                                    (char
                                                                                                                                                         *)((int32_t)
                                                                                                                                                                p_v52 +
                                                                                                                                                            11),
                                                                                                                                                    (char
                                                                                                                                                         *)((int32_t)&p_g255 |
                                                                                                                                                            0x20000));
                                                                                                                                            }
                                                                                                                                        } else {
                                                                                                                                            // 0xce48
                                                                                                                                            sscanf(
                                                                                                                                                (char
                                                                                                                                                     *)((int32_t)
                                                                                                                                                            p_v51 +
                                                                                                                                                        10),
                                                                                                                                                (char
                                                                                                                                                     *)((int32_t)&p_g255 |
                                                                                                                                                        0x20000));
                                                                                                                                        }
                                                                                                                                    } else {
                                                                                                                                        // 0xce08
                                                                                                                                        sscanf(
                                                                                                                                            (char
                                                                                                                                                 *)((int32_t)
                                                                                                                                                        p_v50 +
                                                                                                                                                    12),
                                                                                                                                            (char
                                                                                                                                                 *)((int32_t)&p_g255 |
                                                                                                                                                    0x20000));
                                                                                                                                    }
                                                                                                                                } else {
                                                                                                                                    // 0xcda4
                                                                                                                                    sscanf(
                                                                                                                                        (char
                                                                                                                                             *)((int32_t)
                                                                                                                                                    p_v49 +
                                                                                                                                                12),
                                                                                                                                        (char
                                                                                                                                             *)((int32_t)&p_g280 |
                                                                                                                                                0x20000));
                                                                                                                                    if (i_g130 !=
                                                                                                                                        0) {
                                                                                                                                        // 0xcdd4
                                                                                                                                        i_g197++;
                                                                                                                                    }
                                                                                                                                }
                                                                                                                            } else {
                                                                                                                                // 0xcd40
                                                                                                                                sscanf(
                                                                                                                                    (char
                                                                                                                                         *)((int32_t)
                                                                                                                                                p_v48 +
                                                                                                                                            12),
                                                                                                                                    (char
                                                                                                                                         *)((int32_t)&p_g280 |
                                                                                                                                            0x20000));
                                                                                                                                if (i_g129 !=
                                                                                                                                    0) {
                                                                                                                                    // 0xcd70
                                                                                                                                    i_g197++;
                                                                                                                                }
                                                                                                                            }
                                                                                                                        } else {
                                                                                                                            // 0xccdc
                                                                                                                            sscanf(
                                                                                                                                (char
                                                                                                                                     *)((int32_t)
                                                                                                                                            p_v47 +
                                                                                                                                        12),
                                                                                                                                (char
                                                                                                                                     *)((int32_t)&p_g280 |
                                                                                                                                        0x20000));
                                                                                                                            if (i_g128 !=
                                                                                                                                0) {
                                                                                                                                // 0xcd0c
                                                                                                                                i_g197++;
                                                                                                                            }
                                                                                                                        }
                                                                                                                    } else {
                                                                                                                        // 0xcc9a
                                                                                                                        sscanf(
                                                                                                                            (char
                                                                                                                                 *)((int32_t)
                                                                                                                                        p_v46 +
                                                                                                                                    17),
                                                                                                                            (char
                                                                                                                                 *)((int32_t)&p_g280 |
                                                                                                                                    0x20000));
                                                                                                                    }
                                                                                                                } else {
                                                                                                                    // 0xcc5a
                                                                                                                    sscanf(
                                                                                                                        (char
                                                                                                                             *)((int32_t)
                                                                                                                                    p_v45 +
                                                                                                                                13),
                                                                                                                        (char
                                                                                                                             *)((int32_t)&p_g280 |
                                                                                                                                0x20000));
                                                                                                                }
                                                                                                            } else {
                                                                                                                // 0xcc1a
                                                                                                                sscanf(
                                                                                                                    (char
                                                                                                                         *)((int32_t)
                                                                                                                                p_v44 +
                                                                                                                            10),
                                                                                                                    (char
                                                                                                                         *)((int32_t)&p_g255 |
                                                                                                                            0x20000));
                                                                                                            }
                                                                                                        } else {
                                                                                                            // 0xcbda
                                                                                                            sscanf(
                                                                                                                (char
                                                                                                                     *)((int32_t)
                                                                                                                            p_v43 +
                                                                                                                        12),
                                                                                                                (char
                                                                                                                     *)((int32_t)&p_g255 |
                                                                                                                        0x20000));
                                                                                                        }
                                                                                                    } else {
                                                                                                        // 0xcb74
                                                                                                        sscanf(
                                                                                                            (char
                                                                                                                 *)((int32_t)
                                                                                                                        p_v42 +
                                                                                                                    9),
                                                                                                            (char
                                                                                                                 *)((int32_t)&p_g255 |
                                                                                                                    0x20000));
                                                                                                        if (i_g125 !=
                                                                                                            0) {
                                                                                                            // 0xcba4
                                                                                                            *(char
                                                                                                                  *)&p_g187 =
                                                                                                                (char)((int32_t)&p_g188 &
                                                                                                                       255);
                                                                                                        }
                                                                                                    }
                                                                                                } else {
                                                                                                    // 0xcb0e
                                                                                                    sscanf(
                                                                                                        (char
                                                                                                             *)((int32_t)
                                                                                                                    p_v41 +
                                                                                                                9),
                                                                                                        (char
                                                                                                             *)((int32_t)&p_g255 |
                                                                                                                0x20000));
                                                                                                    if (i_g124 !=
                                                                                                        0) {
                                                                                                        // 0xcb3e
                                                                                                        *(char
                                                                                                              *)&p_g187 =
                                                                                                            (char)((int32_t)&p_g188 &
                                                                                                                   255);
                                                                                                    }
                                                                                                }
                                                                                            } else {
                                                                                                // 0xcaa8
                                                                                                sscanf(
                                                                                                    (char
                                                                                                         *)((int32_t)
                                                                                                                p_v40 +
                                                                                                            9),
                                                                                                    (char
                                                                                                         *)((int32_t)&p_g255 |
                                                                                                            0x20000));
                                                                                                if (i_g123 !=
                                                                                                    0) {
                                                                                                    // 0xcad8
                                                                                                    *(char
                                                                                                          *)&p_g187 =
                                                                                                        (char)((int32_t)&p_g188 &
                                                                                                               255);
                                                                                                }
                                                                                            }
                                                                                        } else {
                                                                                            // 0xca42
                                                                                            sscanf(
                                                                                                (char
                                                                                                     *)((int32_t)
                                                                                                            p_v39 +
                                                                                                        9),
                                                                                                (char
                                                                                                     *)((int32_t)&p_g255 |
                                                                                                        0x20000));
                                                                                            if (i_g122 !=
                                                                                                0) {
                                                                                                // 0xca72
                                                                                                *(char
                                                                                                      *)&p_g187 =
                                                                                                    (char)((int32_t)&p_g188 &
                                                                                                           255);
                                                                                            }
                                                                                        }
                                                                                    } else {
                                                                                        // 0xc9dc
                                                                                        sscanf(
                                                                                            (char
                                                                                                 *)((int32_t)
                                                                                                        p_v38 +
                                                                                                    9),
                                                                                            (char
                                                                                                 *)((int32_t)&p_g255 |
                                                                                                    0x20000));
                                                                                        if (i_g121 !=
                                                                                            0) {
                                                                                            // 0xca0c
                                                                                            *(char
                                                                                                  *)&p_g187 =
                                                                                                (char)((int32_t)&p_g188 &
                                                                                                       255);
                                                                                        }
                                                                                    }
                                                                                } else {
                                                                                    // 0xc976
                                                                                    sscanf(
                                                                                        (char
                                                                                             *)((int32_t)
                                                                                                    p_v37 +
                                                                                                9),
                                                                                        (char
                                                                                             *)((int32_t)&p_g255 |
                                                                                                0x20000));
                                                                                    if (i_g120 !=
                                                                                        0) {
                                                                                        // 0xc9a6
                                                                                        *(char
                                                                                              *)&p_g187 =
                                                                                            (char)((int32_t)&p_g188 &
                                                                                                   255);
                                                                                    }
                                                                                }
                                                                            } else {
                                                                                // 0xc90e
                                                                                sscanf(
                                                                                    (char
                                                                                         *)((int32_t)
                                                                                                p_v36 +
                                                                                            9),
                                                                                    (char
                                                                                         *)((int32_t)&p_g255 |
                                                                                            0x20000));
                                                                                if (i_g119 !=
                                                                                    0) {
                                                                                    // 0xc93e
                                                                                    *(char
                                                                                          *)&p_g187 =
                                                                                        (char)((int32_t)&p_g188 &
                                                                                               255);
                                                                                }
                                                                            }
                                                                        } else {
                                                                            // 0xc8a6
                                                                            sscanf(
                                                                                (char
                                                                                     *)((int32_t)
                                                                                            p_v35 +
                                                                                        9),
                                                                                (char
                                                                                     *)((int32_t)&p_g255 |
                                                                                        0x20000));
                                                                            if (i_g118 !=
                                                                                0) {
                                                                                // 0xc8d6
                                                                                *(char
                                                                                      *)&p_g187 =
                                                                                    (char)((int32_t)&p_g188 &
                                                                                           255);
                                                                            }
                                                                        }
                                                                    } else {
                                                                        // 0xc83e
                                                                        sscanf(
                                                                            (char
                                                                                 *)((int32_t)
                                                                                        p_v34 +
                                                                                    9),
                                                                            (char
                                                                                 *)((int32_t)&p_g255 |
                                                                                    0x20000));
                                                                        if (i_g117 !=
                                                                            0) {
                                                                            // 0xc86e
                                                                            *(char
                                                                                  *)&p_g187 =
                                                                                (char)((int32_t)&p_g188 &
                                                                                       255);
                                                                        }
                                                                    }
                                                                } else {
                                                                    // 0xc7fc
                                                                    sscanf(
                                                                        (char
                                                                             *)((int32_t)
                                                                                    p_v33 +
                                                                                6),
                                                                        (char
                                                                             *)((int32_t)&p_g255 |
                                                                                0x20000));
                                                                }
                                                            } else {
                                                                // 0xc7ba
                                                                sscanf(
                                                                    (char
                                                                         *)((int32_t)
                                                                                p_v32 +
                                                                            6),
                                                                    (char
                                                                         *)((int32_t)&p_g255 |
                                                                            0x20000));
                                                            }
                                                        } else {
                                                            // 0xc778
                                                            sscanf(
                                                                (char
                                                                     *)((int32_t)
                                                                            p_v31 +
                                                                        6),
                                                                (char
                                                                     *)((int32_t)&p_g255 |
                                                                        0x20000));
                                                        }
                                                    } else {
                                                        // 0xc736
                                                        sscanf(
                                                            (char *)((int32_t)
                                                                         p_v30 +
                                                                     6),
                                                            (char
                                                                 *)((int32_t)&p_g255 |
                                                                    0x20000));
                                                    }
                                                } else {
                                                    // 0xc6f4
                                                    sscanf(
                                                        (char *)((int32_t)
                                                                     p_v29 +
                                                                 6),
                                                        (char
                                                             *)((int32_t)&p_g255 |
                                                                0x20000));
                                                }
                                            } else {
                                                // 0xc6b2
                                                sscanf(
                                                    (char *)((int32_t)p_v28 +
                                                             6),
                                                    (char *)((int32_t)&p_g255 |
                                                             0x20000));
                                            }
                                        } else {
                                            // 0xc670
                                            sscanf((char *)((int32_t)p_v27 + 6),
                                                   (char *)((int32_t)&p_g255 |
                                                            0x20000));
                                        }
                                    } else {
                                        // 0xc62e
                                        sscanf((char *)((int32_t)p_v26 + 6),
                                               (char *)((int32_t)&p_g255 |
                                                        0x20000));
                                    }
                                } else {
                                    // 0xc5ec
                                    sscanf(
                                        (char *)((int32_t)p_v25 + 6),
                                        (char *)((int32_t)&p_g255 | 0x20000));
                                }
                            } else {
                                // 0xc5aa
                                sscanf((char *)((int32_t)p_v24 + 8),
                                       (char *)((int32_t)&p_g255 | 0x20000));
                            }
                        } else {
                            // 0xc568
                            sscanf((char *)((int32_t)p_v21 + 9),
                                   (char *)((int32_t)&p_g255 | 0x20000));
                        }
                    } else {
                        // 0xc526
                        sscanf((char *)((int32_t)p_v18 + 8),
                               (char *)((int32_t)&p_g255 | 0x20000));
                    }
                } else {
                    // 0xc4e4
                    sscanf((char *)((int32_t)p_v15 + 15),
                           (char *)((int32_t)&p_g255 | 0x20000));
                }
            } else {
                // 0xc33e
                i_v16 = (int32_t)p_v13;
                p_v17 = (char *)(i_v16 + 5);
                i_v4 = *p_v17;
                i_v10 = 0;
                p_v9 = p_v17;
                while (true) {
                    // 0xc350
                    i_v11 = i_v10;
                    *(char *)(i_v11 + (int32_t)&i_g102) = i_v4;
                    p_v19 = (char *)((int32_t)p_v9 + 1);
                    i_v20 = *p_v19;
                    i_v12 = i_v11;
                    switch (i_v20) {
                    case 10: {
                        goto lab_0xc392;
                    }
                    case 13: {
                        goto lab_0xc392;
                    }
                    default: {
                        // 0xc380
                        i_v22 = i_v11 + 1;
                        i_v4 = i_v20;
                        i_v10 = i_v22;
                        p_v9 = p_v19;
                        if (i_v22 >= 64) {
                            // break -> 0xc392
                            break;
                        }
                        goto lab_0xc350;
                    }
                    }
                }
                // 0xc392
                i_g196 = i_v12 + 1;
                *(char *)(i_v12 + (int32_t)&i_g102 + 1) = 0;
                *(char *)&p_g184 = 0;
                *(char *)&p_g185 = 0;
                i_v23 = *(char *)&i_g102;
                if (i_v23 == 66 == i_g103 == 66 == i_g104 == 68 == i_g105 ==
                    49 == i_g106 == 50 == i_g107 == 54 == i_g108 == 48 ==
                    i_g109 == 49) {
                    // 0xc420
                    *(char *)&p_g184 = 1;
                    printf((char *)((int32_t)&p_g252 | 0x20000));
                } else {
                    // 0xc444
                    i_v5 = i_v16;
                    i_v6 = &i_g102;
                    i_v7 = 0;
                    i_v8 = i_v23;
                    if (i_v23 == 66) {
                        // 0xc450
                        i_v5 = i_v16;
                        i_v6 = &i_g102;
                        i_v7 = 0;
                        i_v8 = i_g103;
                        if (i_g103 == 66) {
                            // 0xc45c
                            i_v5 = i_v16;
                            i_v6 = &i_g102;
                            i_v7 = 0;
                            i_v8 = i_g104;
                            if (i_g104 == 68) {
                                // 0xc468
                                i_v5 = i_v16;
                                i_v6 = &i_g102;
                                i_v7 = 0;
                                i_v8 = i_g105;
                                if (i_g105 == 50) {
                                    // 0xc474
                                    i_v5 = i_v16;
                                    i_v6 = &i_g102;
                                    i_v7 = 0;
                                    i_v8 = i_g106;
                                    if (i_g106 == 53) {
                                        // 0xc480
                                        i_v5 = i_v16;
                                        i_v6 = &i_g102;
                                        i_v7 = 0;
                                        i_v8 = i_g107;
                                        if (i_g107 == 54) {
                                            // 0xc48c
                                            i_v5 = i_v16;
                                            i_v6 = &i_g102;
                                            i_v7 = 0;
                                            i_v8 = i_g108;
                                            if (i_g108 == 48) {
                                                // 0xc498
                                                i_v5 = i_v16;
                                                i_v6 = &i_g102;
                                                i_v7 = 0;
                                                i_v8 = i_g109;
                                                if (i_g109 == 49) {
                                                    // 0xc4a4
                                                    *(char *)&p_g185 = 1;
                                                    i_v5 = printf((
                                                        char
                                                            *)((int32_t)&p_g253 |
                                                               0x20000));
                                                    i_v6 =
                                                        (int32_t) "read_config";
                                                    i_v7 = 1;
                                                    i_v8 = (int32_t)&p_g185;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    // 0xd172
                    __asm_nop(i_v5, i_v6, i_v7, i_v8);
                }
            }
        }
        char *p_v64 = fgets((char *)&i_v1, 1023, p_v2); // 0xd180
        char *p_v65 = p_v64;                            // 0xd188
        while (p_v64 != NULL) {
            // 0xc30c
            if (i_v14 == 35 || i_v1 % 256 == 35) {
                // 0xd16e
                __asm_nop((int32_t)p_v65, 1023, (int32_t)p_v2, 35);
            } else {
                // 0xc320
                p_v13 =
                    strstr((char *)&i_v1, (char *)((int32_t)&p_g251 | 0x20000));
                if (p_v13 == NULL) {
                    // 0xc4c8
                    p_v15 = strstr((char *)&i_v1,
                                   (char *)((int32_t)&p_g254 | 0x20000));
                    if (p_v15 == NULL) {
                        // 0xc50a
                        p_v18 = strstr((char *)&i_v1,
                                       (char *)((int32_t)&p_g256 | 0x20000));
                        if (p_v18 == NULL) {
                            // 0xc54c
                            p_v21 =
                                strstr((char *)&i_v1,
                                       (char *)((int32_t)&p_g257 | 0x20000));
                            if (p_v21 == NULL) {
                                // 0xc58e
                                p_v24 = strstr(
                                    (char *)&i_v1,
                                    (char *)((int32_t)&p_g258 | 0x20000));
                                if (p_v24 == NULL) {
                                    // 0xc5d0
                                    p_v25 = strstr(
                                        (char *)&i_v1,
                                        (char *)((int32_t)&p_g259 | 0x20000));
                                    if (p_v25 == NULL) {
                                        // 0xc612
                                        p_v26 =
                                            strstr((char *)&i_v1,
                                                   (char *)((int32_t)&p_g260 |
                                                            0x20000));
                                        if (p_v26 == NULL) {
                                            // 0xc654
                                            p_v27 = strstr(
                                                (char *)&i_v1,
                                                (char *)((int32_t)&p_g261 |
                                                         0x20000));
                                            if (p_v27 == NULL) {
                                                // 0xc696
                                                p_v28 = strstr(
                                                    (char *)&i_v1,
                                                    (char *)((int32_t)&p_g262 |
                                                             0x20000));
                                                if (p_v28 == NULL) {
                                                    // 0xc6d8
                                                    p_v29 = strstr(
                                                        (char *)&i_v1,
                                                        (char
                                                             *)((int32_t)&p_g263 |
                                                                0x20000));
                                                    if (p_v29 == NULL) {
                                                        // 0xc71a
                                                        p_v30 = strstr(
                                                            (char *)&i_v1,
                                                            (char
                                                                 *)((int32_t)&p_g264 |
                                                                    0x20000));
                                                        if (p_v30 == NULL) {
                                                            // 0xc75c
                                                            p_v31 = strstr(
                                                                (char *)&i_v1,
                                                                (char
                                                                     *)((int32_t)&p_g265 |
                                                                        0x20000));
                                                            if (p_v31 == NULL) {
                                                                // 0xc79e
                                                                p_v32 = strstr(
                                                                    (char
                                                                         *)&i_v1,
                                                                    (char
                                                                         *)((int32_t)&p_g266 |
                                                                            0x20000));
                                                                if (p_v32 ==
                                                                    NULL) {
                                                                    // 0xc7e0
                                                                    p_v33 = strstr(
                                                                        (char
                                                                             *)&i_v1,
                                                                        (char
                                                                             *)((int32_t)&p_g267 |
                                                                                0x20000));
                                                                    if (p_v33 ==
                                                                        NULL) {
                                                                        // 0xc822
                                                                        p_v34 = strstr(
                                                                            (char
                                                                                 *)&i_v1,
                                                                            (char
                                                                                 *)((int32_t)&p_g268 |
                                                                                    0x20000));
                                                                        if (p_v34 ==
                                                                            NULL) {
                                                                            // 0xc88a
                                                                            p_v35 = strstr(
                                                                                (char
                                                                                     *)&i_v1,
                                                                                (char
                                                                                     *)((int32_t)&p_g269 |
                                                                                        0x20000));
                                                                            if (p_v35 ==
                                                                                NULL) {
                                                                                // 0xc8f2
                                                                                p_v36 = strstr(
                                                                                    (char
                                                                                         *)&i_v1,
                                                                                    (char
                                                                                         *)((int32_t)&p_g270 |
                                                                                            0x20000));
                                                                                if (p_v36 ==
                                                                                    NULL) {
                                                                                    // 0xc95a
                                                                                    p_v37 = strstr(
                                                                                        (char
                                                                                             *)&i_v1,
                                                                                        (char
                                                                                             *)((int32_t)&p_g271 |
                                                                                                0x20000));
                                                                                    if (p_v37 ==
                                                                                        NULL) {
                                                                                        // 0xc9c0
                                                                                        p_v38 = strstr(
                                                                                            (char
                                                                                                 *)&i_v1,
                                                                                            (char
                                                                                                 *)((int32_t)&p_g272 |
                                                                                                    0x20000));
                                                                                        if (p_v38 ==
                                                                                            NULL) {
                                                                                            // 0xca26
                                                                                            p_v39 = strstr(
                                                                                                (char
                                                                                                     *)&i_v1,
                                                                                                (char
                                                                                                     *)((int32_t)&p_g273 |
                                                                                                        0x20000));
                                                                                            if (p_v39 ==
                                                                                                NULL) {
                                                                                                // 0xca8c
                                                                                                p_v40 = strstr(
                                                                                                    (char
                                                                                                         *)&i_v1,
                                                                                                    (char
                                                                                                         *)((int32_t)&p_g274 |
                                                                                                            0x20000));
                                                                                                if (p_v40 ==
                                                                                                    NULL) {
                                                                                                    // 0xcaf2
                                                                                                    p_v41 = strstr(
                                                                                                        (char
                                                                                                             *)&i_v1,
                                                                                                        (char
                                                                                                             *)((int32_t)&p_g275 |
                                                                                                                0x20000));
                                                                                                    if (p_v41 ==
                                                                                                        NULL) {
                                                                                                        // 0xcb58
                                                                                                        p_v42 = strstr(
                                                                                                            (char
                                                                                                                 *)&i_v1,
                                                                                                            (char
                                                                                                                 *)((int32_t)&p_g276 |
                                                                                                                    0x20000));
                                                                                                        if (p_v42 ==
                                                                                                            NULL) {
                                                                                                            // 0xcbbe
                                                                                                            p_v43 = strstr(
                                                                                                                (char
                                                                                                                     *)&i_v1,
                                                                                                                (char
                                                                                                                     *)((int32_t)&p_g277 |
                                                                                                                        0x20000));
                                                                                                            if (p_v43 ==
                                                                                                                NULL) {
                                                                                                                // 0xcbfe
                                                                                                                p_v44 = strstr(
                                                                                                                    (char
                                                                                                                         *)&i_v1,
                                                                                                                    (char
                                                                                                                         *)((int32_t)&p_g278 |
                                                                                                                            0x20000));
                                                                                                                if (p_v44 ==
                                                                                                                    NULL) {
                                                                                                                    // 0xcc3e
                                                                                                                    p_v45 = strstr(
                                                                                                                        (char
                                                                                                                             *)&i_v1,
                                                                                                                        (char
                                                                                                                             *)((int32_t)&p_g279 |
                                                                                                                                0x20000));
                                                                                                                    if (p_v45 ==
                                                                                                                        NULL) {
                                                                                                                        // 0xcc7e
                                                                                                                        p_v46 = strstr(
                                                                                                                            (char
                                                                                                                                 *)&i_v1,
                                                                                                                            (char
                                                                                                                                 *)((int32_t)&p_g281 |
                                                                                                                                    0x20000));
                                                                                                                        if (p_v46 ==
                                                                                                                            NULL) {
                                                                                                                            // 0xccc0
                                                                                                                            p_v47 = strstr(
                                                                                                                                (char
                                                                                                                                     *)&i_v1,
                                                                                                                                (char
                                                                                                                                     *)((int32_t)&p_g282 |
                                                                                                                                        0x20000));
                                                                                                                            if (p_v47 ==
                                                                                                                                NULL) {
                                                                                                                                // 0xcd24
                                                                                                                                p_v48 = strstr(
                                                                                                                                    (char
                                                                                                                                         *)&i_v1,
                                                                                                                                    (char
                                                                                                                                         *)((int32_t)&p_g283 |
                                                                                                                                            0x20000));
                                                                                                                                if (p_v48 ==
                                                                                                                                    NULL) {
                                                                                                                                    // 0xcd88
                                                                                                                                    p_v49 = strstr(
                                                                                                                                        (char
                                                                                                                                             *)&i_v1,
                                                                                                                                        (char
                                                                                                                                             *)((int32_t)&p_g284 |
                                                                                                                                                0x20000));
                                                                                                                                    if (p_v49 ==
                                                                                                                                        NULL) {
                                                                                                                                        // 0xcdec
                                                                                                                                        p_v50 = strstr(
                                                                                                                                            (char
                                                                                                                                                 *)&i_v1,
                                                                                                                                            (char
                                                                                                                                                 *)((int32_t)&p_g285 |
                                                                                                                                                    0x20000));
                                                                                                                                        if (p_v50 ==
                                                                                                                                            NULL) {
                                                                                                                                            // 0xce2c
                                                                                                                                            p_v51 = strstr(
                                                                                                                                                (char
                                                                                                                                                     *)&i_v1,
                                                                                                                                                (char
                                                                                                                                                     *)((int32_t)&p_g286 |
                                                                                                                                                        0x20000));
                                                                                                                                            if (p_v51 ==
                                                                                                                                                NULL) {
                                                                                                                                                // 0xce6c
                                                                                                                                                p_v52 = strstr(
                                                                                                                                                    (char
                                                                                                                                                         *)&i_v1,
                                                                                                                                                    (char
                                                                                                                                                         *)((int32_t)&p_g287 |
                                                                                                                                                            0x20000));
                                                                                                                                                if (p_v52 ==
                                                                                                                                                    NULL) {
                                                                                                                                                    // 0xceac
                                                                                                                                                    p_v53 = strstr(
                                                                                                                                                        (char
                                                                                                                                                             *)&i_v1,
                                                                                                                                                        (char
                                                                                                                                                             *)((int32_t)&p_g288 |
                                                                                                                                                                0x20000));
                                                                                                                                                    if (p_v53 ==
                                                                                                                                                        NULL) {
                                                                                                                                                        // 0xceec
                                                                                                                                                        p_v54 = strstr(
                                                                                                                                                            (char
                                                                                                                                                                 *)&i_v1,
                                                                                                                                                            (char
                                                                                                                                                                 *)((int32_t)&p_g289 |
                                                                                                                                                                    0x20000));
                                                                                                                                                        if (p_v54 ==
                                                                                                                                                            NULL) {
                                                                                                                                                            // 0xcf2c
                                                                                                                                                            p_v55 = strstr(
                                                                                                                                                                (char
                                                                                                                                                                     *)&i_v1,
                                                                                                                                                                (char
                                                                                                                                                                     *)((int32_t)&p_g290 |
                                                                                                                                                                        0x20000));
                                                                                                                                                            if (p_v55 ==
                                                                                                                                                                NULL) {
                                                                                                                                                                // 0xcf6c
                                                                                                                                                                p_v56 = strstr(
                                                                                                                                                                    (char
                                                                                                                                                                         *)&i_v1,
                                                                                                                                                                    "HeatingUpTime=");
                                                                                                                                                                if (p_v56 ==
                                                                                                                                                                    NULL) {
                                                                                                                                                                    // 0xcfac
                                                                                                                                                                    p_v57 = strstr(
                                                                                                                                                                        (char
                                                                                                                                                                             *)&i_v1,
                                                                                                                                                                        "MaxTempGap=");
                                                                                                                                                                    if (p_v57 ==
                                                                                                                                                                        NULL) {
                                                                                                                                                                        // 0xcfec
                                                                                                                                                                        p_v58 = strstr(
                                                                                                                                                                            (char
                                                                                                                                                                                 *)&i_v1,
                                                                                                                                                                            (char
                                                                                                                                                                                 *)((int32_t)&p_g291 |
                                                                                                                                                                                    0x20000));
                                                                                                                                                                        if (p_v58 ==
                                                                                                                                                                            NULL) {
                                                                                                                                                                            // 0xd02c
                                                                                                                                                                            p_v59 = strstr(
                                                                                                                                                                                (char
                                                                                                                                                                                     *)&i_v1,
                                                                                                                                                                                "Invalid_Core_Num=");
                                                                                                                                                                            if (p_v59 ==
                                                                                                                                                                                NULL) {
                                                                                                                                                                                // 0xd06c
                                                                                                                                                                                p_v60 = strstr(
                                                                                                                                                                                    (char
                                                                                                                                                                                         *)&i_v1,
                                                                                                                                                                                    "Least_nonce_per_core=");
                                                                                                                                                                                if (p_v60 ==
                                                                                                                                                                                    NULL) {
                                                                                                                                                                                    // 0xd0ac
                                                                                                                                                                                    p_v61 = strstr(
                                                                                                                                                                                        (char
                                                                                                                                                                                             *)&i_v1,
                                                                                                                                                                                        "Most_lost_nonce_total=");
                                                                                                                                                                                    if (p_v61 ==
                                                                                                                                                                                        NULL) {
                                                                                                                                                                                        // 0xd0ec
                                                                                                                                                                                        p_v62 = strstr(
                                                                                                                                                                                            (char
                                                                                                                                                                                                 *)&i_v1,
                                                                                                                                                                                            "Most_HW_Num=");
                                                                                                                                                                                        if (p_v62 ==
                                                                                                                                                                                            NULL) {
                                                                                                                                                                                            // 0xd12c
                                                                                                                                                                                            p_v63 = strstr(
                                                                                                                                                                                                (char
                                                                                                                                                                                                     *)&i_v1,
                                                                                                                                                                                                "close_power_delay=");
                                                                                                                                                                                            if (p_v63 !=
                                                                                                                                                                                                NULL) {
                                                                                                                                                                                                // 0xd148
                                                                                                                                                                                                sscanf(
                                                                                                                                                                                                    (char
                                                                                                                                                                                                         *)((int32_t)
                                                                                                                                                                                                                p_v63 +
                                                                                                                                                                                                            18),
                                                                                                                                                                                                    (char
                                                                                                                                                                                                         *)((int32_t)&p_g255 |
                                                                                                                                                                                                            0x20000));
                                                                                                                                                                                            }
                                                                                                                                                                                        } else {
                                                                                                                                                                                            // 0xd108
                                                                                                                                                                                            sscanf(
                                                                                                                                                                                                (char
                                                                                                                                                                                                     *)((int32_t)
                                                                                                                                                                                                            p_v62 +
                                                                                                                                                                                                        12),
                                                                                                                                                                                                (char
                                                                                                                                                                                                     *)((int32_t)&p_g255 |
                                                                                                                                                                                                        0x20000));
                                                                                                                                                                                        }
                                                                                                                                                                                    } else {
                                                                                                                                                                                        // 0xd0c8
                                                                                                                                                                                        sscanf(
                                                                                                                                                                                            (char
                                                                                                                                                                                                 *)((int32_t)
                                                                                                                                                                                                        p_v61 +
                                                                                                                                                                                                    22),
                                                                                                                                                                                            (char
                                                                                                                                                                                                 *)((int32_t)&p_g255 |
                                                                                                                                                                                                    0x20000));
                                                                                                                                                                                    }
                                                                                                                                                                                } else {
                                                                                                                                                                                    // 0xd088
                                                                                                                                                                                    sscanf(
                                                                                                                                                                                        (char
                                                                                                                                                                                             *)((int32_t)
                                                                                                                                                                                                    p_v60 +
                                                                                                                                                                                                21),
                                                                                                                                                                                        (char
                                                                                                                                                                                             *)((int32_t)&p_g255 |
                                                                                                                                                                                                0x20000));
                                                                                                                                                                                }
                                                                                                                                                                            } else {
                                                                                                                                                                                // 0xd048
                                                                                                                                                                                sscanf(
                                                                                                                                                                                    (char
                                                                                                                                                                                         *)((int32_t)
                                                                                                                                                                                                p_v59 +
                                                                                                                                                                                            17),
                                                                                                                                                                                    (char
                                                                                                                                                                                         *)((int32_t)&p_g255 |
                                                                                                                                                                                            0x20000));
                                                                                                                                                                            }
                                                                                                                                                                        } else {
                                                                                                                                                                            // 0xd008
                                                                                                                                                                            sscanf(
                                                                                                                                                                                (char
                                                                                                                                                                                     *)((int32_t)
                                                                                                                                                                                            p_v58 +
                                                                                                                                                                                        17),
                                                                                                                                                                                (char
                                                                                                                                                                                     *)((int32_t)&p_g255 |
                                                                                                                                                                                        0x20000));
                                                                                                                                                                        }
                                                                                                                                                                    } else {
                                                                                                                                                                        // 0xcfc8
                                                                                                                                                                        sscanf(
                                                                                                                                                                            (char
                                                                                                                                                                                 *)((int32_t)
                                                                                                                                                                                        p_v57 +
                                                                                                                                                                                    11),
                                                                                                                                                                            (char
                                                                                                                                                                                 *)((int32_t)&p_g255 |
                                                                                                                                                                                    0x20000));
                                                                                                                                                                    }
                                                                                                                                                                } else {
                                                                                                                                                                    // 0xcf88
                                                                                                                                                                    sscanf(
                                                                                                                                                                        (char
                                                                                                                                                                             *)((int32_t)
                                                                                                                                                                                    p_v56 +
                                                                                                                                                                                14),
                                                                                                                                                                        (char
                                                                                                                                                                             *)((int32_t)&p_g255 |
                                                                                                                                                                                0x20000));
                                                                                                                                                                }
                                                                                                                                                            } else {
                                                                                                                                                                // 0xcf48
                                                                                                                                                                sscanf(
                                                                                                                                                                    (char
                                                                                                                                                                         *)((int32_t)
                                                                                                                                                                                p_v55 +
                                                                                                                                                                            10),
                                                                                                                                                                    (char
                                                                                                                                                                         *)((int32_t)&p_g255 |
                                                                                                                                                                            0x20000));
                                                                                                                                                            }
                                                                                                                                                        } else {
                                                                                                                                                            // 0xcf08
                                                                                                                                                            sscanf(
                                                                                                                                                                (char
                                                                                                                                                                     *)((int32_t)
                                                                                                                                                                            p_v54 +
                                                                                                                                                                        18),
                                                                                                                                                                (char
                                                                                                                                                                     *)((int32_t)&p_g255 |
                                                                                                                                                                        0x20000));
                                                                                                                                                        }
                                                                                                                                                    } else {
                                                                                                                                                        // 0xcec8
                                                                                                                                                        sscanf(
                                                                                                                                                            (char
                                                                                                                                                                 *)((int32_t)
                                                                                                                                                                        p_v53 +
                                                                                                                                                                    26),
                                                                                                                                                            (char
                                                                                                                                                                 *)((int32_t)&p_g255 |
                                                                                                                                                                    0x20000));
                                                                                                                                                    }
                                                                                                                                                } else {
                                                                                                                                                    // 0xce88
                                                                                                                                                    sscanf(
                                                                                                                                                        (char
                                                                                                                                                             *)((int32_t)
                                                                                                                                                                    p_v52 +
                                                                                                                                                                11),
                                                                                                                                                        (char
                                                                                                                                                             *)((int32_t)&p_g255 |
                                                                                                                                                                0x20000));
                                                                                                                                                }
                                                                                                                                            } else {
                                                                                                                                                // 0xce48
                                                                                                                                                sscanf(
                                                                                                                                                    (char
                                                                                                                                                         *)((int32_t)
                                                                                                                                                                p_v51 +
                                                                                                                                                            10),
                                                                                                                                                    (char
                                                                                                                                                         *)((int32_t)&p_g255 |
                                                                                                                                                            0x20000));
                                                                                                                                            }
                                                                                                                                        } else {
                                                                                                                                            // 0xce08
                                                                                                                                            sscanf(
                                                                                                                                                (char
                                                                                                                                                     *)((int32_t)
                                                                                                                                                            p_v50 +
                                                                                                                                                        12),
                                                                                                                                                (char
                                                                                                                                                     *)((int32_t)&p_g255 |
                                                                                                                                                        0x20000));
                                                                                                                                        }
                                                                                                                                    } else {
                                                                                                                                        // 0xcda4
                                                                                                                                        sscanf(
                                                                                                                                            (char
                                                                                                                                                 *)((int32_t)
                                                                                                                                                        p_v49 +
                                                                                                                                                    12),
                                                                                                                                            (char
                                                                                                                                                 *)((int32_t)&p_g280 |
                                                                                                                                                    0x20000));
                                                                                                                                        if (i_g130 !=
                                                                                                                                            0) {
                                                                                                                                            // 0xcdd4
                                                                                                                                            i_g197++;
                                                                                                                                        }
                                                                                                                                    }
                                                                                                                                } else {
                                                                                                                                    // 0xcd40
                                                                                                                                    sscanf(
                                                                                                                                        (char
                                                                                                                                             *)((int32_t)
                                                                                                                                                    p_v48 +
                                                                                                                                                12),
                                                                                                                                        (char
                                                                                                                                             *)((int32_t)&p_g280 |
                                                                                                                                                0x20000));
                                                                                                                                    if (i_g129 !=
                                                                                                                                        0) {
                                                                                                                                        // 0xcd70
                                                                                                                                        i_g197++;
                                                                                                                                    }
                                                                                                                                }
                                                                                                                            } else {
                                                                                                                                // 0xccdc
                                                                                                                                sscanf(
                                                                                                                                    (char
                                                                                                                                         *)((int32_t)
                                                                                                                                                p_v47 +
                                                                                                                                            12),
                                                                                                                                    (char
                                                                                                                                         *)((int32_t)&p_g280 |
                                                                                                                                            0x20000));
                                                                                                                                if (i_g128 !=
                                                                                                                                    0) {
                                                                                                                                    // 0xcd0c
                                                                                                                                    i_g197++;
                                                                                                                                }
                                                                                                                            }
                                                                                                                        } else {
                                                                                                                            // 0xcc9a
                                                                                                                            sscanf(
                                                                                                                                (char
                                                                                                                                     *)((int32_t)
                                                                                                                                            p_v46 +
                                                                                                                                        17),
                                                                                                                                (char
                                                                                                                                     *)((int32_t)&p_g280 |
                                                                                                                                        0x20000));
                                                                                                                        }
                                                                                                                    } else {
                                                                                                                        // 0xcc5a
                                                                                                                        sscanf(
                                                                                                                            (char
                                                                                                                                 *)((int32_t)
                                                                                                                                        p_v45 +
                                                                                                                                    13),
                                                                                                                            (char
                                                                                                                                 *)((int32_t)&p_g280 |
                                                                                                                                    0x20000));
                                                                                                                    }
                                                                                                                } else {
                                                                                                                    // 0xcc1a
                                                                                                                    sscanf(
                                                                                                                        (char
                                                                                                                             *)((int32_t)
                                                                                                                                    p_v44 +
                                                                                                                                10),
                                                                                                                        (char
                                                                                                                             *)((int32_t)&p_g255 |
                                                                                                                                0x20000));
                                                                                                                }
                                                                                                            } else {
                                                                                                                // 0xcbda
                                                                                                                sscanf(
                                                                                                                    (char
                                                                                                                         *)((int32_t)
                                                                                                                                p_v43 +
                                                                                                                            12),
                                                                                                                    (char
                                                                                                                         *)((int32_t)&p_g255 |
                                                                                                                            0x20000));
                                                                                                            }
                                                                                                        } else {
                                                                                                            // 0xcb74
                                                                                                            sscanf(
                                                                                                                (char
                                                                                                                     *)((int32_t)
                                                                                                                            p_v42 +
                                                                                                                        9),
                                                                                                                (char
                                                                                                                     *)((int32_t)&p_g255 |
                                                                                                                        0x20000));
                                                                                                            if (i_g125 !=
                                                                                                                0) {
                                                                                                                // 0xcba4
                                                                                                                *(char
                                                                                                                      *)&p_g187 =
                                                                                                                    (char)((int32_t)&p_g188 &
                                                                                                                           255);
                                                                                                            }
                                                                                                        }
                                                                                                    } else {
                                                                                                        // 0xcb0e
                                                                                                        sscanf(
                                                                                                            (char
                                                                                                                 *)((int32_t)
                                                                                                                        p_v41 +
                                                                                                                    9),
                                                                                                            (char
                                                                                                                 *)((int32_t)&p_g255 |
                                                                                                                    0x20000));
                                                                                                        if (i_g124 !=
                                                                                                            0) {
                                                                                                            // 0xcb3e
                                                                                                            *(char
                                                                                                                  *)&p_g187 =
                                                                                                                (char)((int32_t)&p_g188 &
                                                                                                                       255);
                                                                                                        }
                                                                                                    }
                                                                                                } else {
                                                                                                    // 0xcaa8
                                                                                                    sscanf(
                                                                                                        (char
                                                                                                             *)((int32_t)
                                                                                                                    p_v40 +
                                                                                                                9),
                                                                                                        (char
                                                                                                             *)((int32_t)&p_g255 |
                                                                                                                0x20000));
                                                                                                    if (i_g123 !=
                                                                                                        0) {
                                                                                                        // 0xcad8
                                                                                                        *(char
                                                                                                              *)&p_g187 =
                                                                                                            (char)((int32_t)&p_g188 &
                                                                                                                   255);
                                                                                                    }
                                                                                                }
                                                                                            } else {
                                                                                                // 0xca42
                                                                                                sscanf(
                                                                                                    (char
                                                                                                         *)((int32_t)
                                                                                                                p_v39 +
                                                                                                            9),
                                                                                                    (char
                                                                                                         *)((int32_t)&p_g255 |
                                                                                                            0x20000));
                                                                                                if (i_g122 !=
                                                                                                    0) {
                                                                                                    // 0xca72
                                                                                                    *(char
                                                                                                          *)&p_g187 =
                                                                                                        (char)((int32_t)&p_g188 &
                                                                                                               255);
                                                                                                }
                                                                                            }
                                                                                        } else {
                                                                                            // 0xc9dc
                                                                                            sscanf(
                                                                                                (char
                                                                                                     *)((int32_t)
                                                                                                            p_v38 +
                                                                                                        9),
                                                                                                (char
                                                                                                     *)((int32_t)&p_g255 |
                                                                                                        0x20000));
                                                                                            if (i_g121 !=
                                                                                                0) {
                                                                                                // 0xca0c
                                                                                                *(char
                                                                                                      *)&p_g187 =
                                                                                                    (char)((int32_t)&p_g188 &
                                                                                                           255);
                                                                                            }
                                                                                        }
                                                                                    } else {
                                                                                        // 0xc976
                                                                                        sscanf(
                                                                                            (char
                                                                                                 *)((int32_t)
                                                                                                        p_v37 +
                                                                                                    9),
                                                                                            (char
                                                                                                 *)((int32_t)&p_g255 |
                                                                                                    0x20000));
                                                                                        if (i_g120 !=
                                                                                            0) {
                                                                                            // 0xc9a6
                                                                                            *(char
                                                                                                  *)&p_g187 =
                                                                                                (char)((int32_t)&p_g188 &
                                                                                                       255);
                                                                                        }
                                                                                    }
                                                                                } else {
                                                                                    // 0xc90e
                                                                                    sscanf(
                                                                                        (char
                                                                                             *)((int32_t)
                                                                                                    p_v36 +
                                                                                                9),
                                                                                        (char
                                                                                             *)((int32_t)&p_g255 |
                                                                                                0x20000));
                                                                                    if (i_g119 !=
                                                                                        0) {
                                                                                        // 0xc93e
                                                                                        *(char
                                                                                              *)&p_g187 =
                                                                                            (char)((int32_t)&p_g188 &
                                                                                                   255);
                                                                                    }
                                                                                }
                                                                            } else {
                                                                                // 0xc8a6
                                                                                sscanf(
                                                                                    (char
                                                                                         *)((int32_t)
                                                                                                p_v35 +
                                                                                            9),
                                                                                    (char
                                                                                         *)((int32_t)&p_g255 |
                                                                                            0x20000));
                                                                                if (i_g118 !=
                                                                                    0) {
                                                                                    // 0xc8d6
                                                                                    *(char
                                                                                          *)&p_g187 =
                                                                                        (char)((int32_t)&p_g188 &
                                                                                               255);
                                                                                }
                                                                            }
                                                                        } else {
                                                                            // 0xc83e
                                                                            sscanf(
                                                                                (char
                                                                                     *)((int32_t)
                                                                                            p_v34 +
                                                                                        9),
                                                                                (char
                                                                                     *)((int32_t)&p_g255 |
                                                                                        0x20000));
                                                                            if (i_g117 !=
                                                                                0) {
                                                                                // 0xc86e
                                                                                *(char
                                                                                      *)&p_g187 =
                                                                                    (char)((int32_t)&p_g188 &
                                                                                           255);
                                                                            }
                                                                        }
                                                                    } else {
                                                                        // 0xc7fc
                                                                        sscanf(
                                                                            (char
                                                                                 *)((int32_t)
                                                                                        p_v33 +
                                                                                    6),
                                                                            (char
                                                                                 *)((int32_t)&p_g255 |
                                                                                    0x20000));
                                                                    }
                                                                } else {
                                                                    // 0xc7ba
                                                                    sscanf(
                                                                        (char
                                                                             *)((int32_t)
                                                                                    p_v32 +
                                                                                6),
                                                                        (char
                                                                             *)((int32_t)&p_g255 |
                                                                                0x20000));
                                                                }
                                                            } else {
                                                                // 0xc778
                                                                sscanf(
                                                                    (char
                                                                         *)((int32_t)
                                                                                p_v31 +
                                                                            6),
                                                                    (char
                                                                         *)((int32_t)&p_g255 |
                                                                            0x20000));
                                                            }
                                                        } else {
                                                            // 0xc736
                                                            sscanf(
                                                                (char
                                                                     *)((int32_t)
                                                                            p_v30 +
                                                                        6),
                                                                (char
                                                                     *)((int32_t)&p_g255 |
                                                                        0x20000));
                                                        }
                                                    } else {
                                                        // 0xc6f4
                                                        sscanf(
                                                            (char *)((int32_t)
                                                                         p_v29 +
                                                                     6),
                                                            (char
                                                                 *)((int32_t)&p_g255 |
                                                                    0x20000));
                                                    }
                                                } else {
                                                    // 0xc6b2
                                                    sscanf(
                                                        (char *)((int32_t)
                                                                     p_v28 +
                                                                 6),
                                                        (char
                                                             *)((int32_t)&p_g255 |
                                                                0x20000));
                                                }
                                            } else {
                                                // 0xc670
                                                sscanf(
                                                    (char *)((int32_t)p_v27 +
                                                             6),
                                                    (char *)((int32_t)&p_g255 |
                                                             0x20000));
                                            }
                                        } else {
                                            // 0xc62e
                                            sscanf((char *)((int32_t)p_v26 + 6),
                                                   (char *)((int32_t)&p_g255 |
                                                            0x20000));
                                        }
                                    } else {
                                        // 0xc5ec
                                        sscanf((char *)((int32_t)p_v25 + 6),
                                               (char *)((int32_t)&p_g255 |
                                                        0x20000));
                                    }
                                } else {
                                    // 0xc5aa
                                    sscanf(
                                        (char *)((int32_t)p_v24 + 8),
                                        (char *)((int32_t)&p_g255 | 0x20000));
                                }
                            } else {
                                // 0xc568
                                sscanf((char *)((int32_t)p_v21 + 9),
                                       (char *)((int32_t)&p_g255 | 0x20000));
                            }
                        } else {
                            // 0xc526
                            sscanf((char *)((int32_t)p_v18 + 8),
                                   (char *)((int32_t)&p_g255 | 0x20000));
                        }
                    } else {
                        // 0xc4e4
                        sscanf((char *)((int32_t)p_v15 + 15),
                               (char *)((int32_t)&p_g255 | 0x20000));
                    }
                } else {
                    // 0xc33e
                    i_v16 = (int32_t)p_v13;
                    p_v17 = (char *)(i_v16 + 5);
                    i_v4 = *p_v17;
                    i_v10 = 0;
                    p_v9 = p_v17;
                    while (true) {
                        // 0xc350
                        i_v11 = i_v10;
                        *(char *)(i_v11 + (int32_t)&i_g102) = i_v4;
                        p_v19 = (char *)((int32_t)p_v9 + 1);
                        i_v20 = *p_v19;
                        i_v12 = i_v11;
                        switch (i_v20) {
                        case 10: {
                            goto lab_0xc392;
                        }
                        case 13: {
                            goto lab_0xc392;
                        }
                        default: {
                            // 0xc380
                            i_v22 = i_v11 + 1;
                            i_v4 = i_v20;
                            i_v10 = i_v22;
                            p_v9 = p_v19;
                            if (i_v22 >= 64) {
                                // break -> 0xc392
                                break;
                            }
                            goto lab_0xc350;
                        }
                        }
                    }
                    // 0xc392
                    i_g196 = i_v12 + 1;
                    *(char *)(i_v12 + (int32_t)&i_g102 + 1) = 0;
                    *(char *)&p_g184 = 0;
                    *(char *)&p_g185 = 0;
                    i_v23 = *(char *)&i_g102;
                    if (i_v23 == 66 == i_g103 == 66 == i_g104 == 68 == i_g105 ==
                        49 == i_g106 == 50 == i_g107 == 54 == i_g108 == 48 ==
                        i_g109 == 49) {
                        // 0xc420
                        *(char *)&p_g184 = 1;
                        printf((char *)((int32_t)&p_g252 | 0x20000));
                    } else {
                        // 0xc444
                        i_v5 = i_v16;
                        i_v6 = &i_g102;
                        i_v7 = 0;
                        i_v8 = i_v23;
                        if (i_v23 == 66) {
                            // 0xc450
                            i_v5 = i_v16;
                            i_v6 = &i_g102;
                            i_v7 = 0;
                            i_v8 = i_g103;
                            if (i_g103 == 66) {
                                // 0xc45c
                                i_v5 = i_v16;
                                i_v6 = &i_g102;
                                i_v7 = 0;
                                i_v8 = i_g104;
                                if (i_g104 == 68) {
                                    // 0xc468
                                    i_v5 = i_v16;
                                    i_v6 = &i_g102;
                                    i_v7 = 0;
                                    i_v8 = i_g105;
                                    if (i_g105 == 50) {
                                        // 0xc474
                                        i_v5 = i_v16;
                                        i_v6 = &i_g102;
                                        i_v7 = 0;
                                        i_v8 = i_g106;
                                        if (i_g106 == 53) {
                                            // 0xc480
                                            i_v5 = i_v16;
                                            i_v6 = &i_g102;
                                            i_v7 = 0;
                                            i_v8 = i_g107;
                                            if (i_g107 == 54) {
                                                // 0xc48c
                                                i_v5 = i_v16;
                                                i_v6 = &i_g102;
                                                i_v7 = 0;
                                                i_v8 = i_g108;
                                                if (i_g108 == 48) {
                                                    // 0xc498
                                                    i_v5 = i_v16;
                                                    i_v6 = &i_g102;
                                                    i_v7 = 0;
                                                    i_v8 = i_g109;
                                                    if (i_g109 == 49) {
                                                        // 0xc4a4
                                                        *(char *)&p_g185 = 1;
                                                        i_v5 = printf((
                                                            char
                                                                *)((int32_t)&p_g253 |
                                                                   0x20000));
                                                        i_v6 =
                                                            (int32_t) "read_"
                                                                      "config";
                                                        i_v7 = 1;
                                                        i_v8 = (int32_t)&p_g185;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        // 0xd172
                        __asm_nop(i_v5, i_v6, i_v7, i_v8);
                    }
                }
            }
            // 0xd174
            p_v64 = fgets((char *)&i_v1, 1023, p_v2);
            p_v65 = p_v64;
        }
    }
    // 0xd18c
    if (i_g113 == 1) {
        // 0xd196
        i_g195 = 256;
        int32_t i_v66 = 1725; // 0xc2c4
        switch (i_g115) {
        case 1722: {
            // 0xd1b2
            strcpy((char *)&p_g85, (char *)*(int32_t *)&x_g156);
            strcpy((char *)&p_g86, p_g158);
            i_g114 = 120;
            i_v66 = &i_g102;
            // break -> 0xd31c
            break;
        }
        case 1725: {
            // 0xd1f0
            strcpy((char *)&p_g85, p_g157);
            strcpy((char *)&p_g86, p_g158);
            i_g114 = 276;
            i_v66 = &i_g102;
            // break -> 0xd31c
            break;
        }
        }
        // 0xd31c
        return i_v66;
    }
    // 0xd220
    if ((*(char *)&p_g185 | *(char *)&p_g184) == 0) {
        // 0xd31c
        return 0;
    }
    // 0xd23c
    switch (i_g115) {
    case 1722: {
        // 0xd24a
        strcpy((char *)&p_g85, (char *)*(int32_t *)&x_g156);
        strcpy((char *)&p_g86, p_g158);
        i_g114 = 120;
        i_g115 = 1722;
        i_g195 = 256 / calculate_asic_number(i_g113);
        // 0xd31c
        return &i_g195;
    }
    case 1725: {
        // 0xd2ba
        strcpy((char *)&p_g85, p_g157);
        strcpy((char *)&p_g86, p_g158);
        i_g114 = 276;
        i_g115 = 1725;
        i_g195 = 256 / calculate_asic_number(i_g113);
        // 0xd31c
        return &i_g195;
    }
    }
    // 0xd31c
    return 1725;
}

// Address range: 0xd334 - 0xd454
int32_t CRC5(char *p_a1, uint32_t i_a2) {
    uint32_t i_v1 = i_a2 % 256;
    char i_v2 = 0;  // 0xd3fa
    char i_v3 = 0;  // 0xd3fa
    char i_v4 = 1;  // 0xd3fa
    char i_v5 = 16; // 0xd3fa
    char i_v6;      // 0xd334
    if (i_v1 != 0) {
        unsigned char i_v7 = -128;
        char *p_v8 = p_a1;
        char i_v9 = i_v7 / 2;  // 0xd3cc
        char i_v10 = i_v3 + 1; // 0xd3cc
        char *p_v11 = p_v8;    // 0xd3cc
        if (i_v3 == 7) {
            // 0xd3ce
            i_v9 = -128;
            i_v10 = 0;
            p_v11 = (char *)((int32_t)p_v8 + 1);
        }
        // 0xd3dc
        i_v2++;
        i_v3 = i_v10;
        while (i_v1 > (int32_t)i_v2) {
            // 0xd37e
            i_v7 = i_v9;
            p_v8 = p_v11;
            i_v9 = i_v7 / 2;
            i_v10 = i_v3 + 1;
            p_v11 = p_v8;
            if (i_v3 == 7) {
                // 0xd3ce
                i_v9 = -128;
                i_v10 = 0;
                p_v11 = (char *)((int32_t)p_v8 + 1);
            }
            // 0xd3dc
            i_v2++;
            i_v3 = i_v10;
        }
        char i_v12 = *p_v8; // 0xd380
        i_v4 = 1 != (char)((i_v12 & i_v7) != 0);
        i_v5 = i_v6 == 0 ? 0 : 16;
    }
    char i_v13 = i_v5;
    char i_v14 = i_v6 == 0 ? i_v13 : i_v13 | 8;
    char i_v15 = i_v6 == 0 ? i_v14 : i_v14 | 4;
    return (i_v6 == 0 ? i_v15 : i_v15 | 2) | i_v4;
}

// Address range: 0xd454 - 0xd496
// Used cryptographic patterns:
//  - CRC_16_CCITT_poly_0x1021 (16-bit, little endian)
int32_t crc_itu_t_byte(uint32_t i_a1, uint32_t i_a2) {
    uint16_t i_v1 =
        *(int16_t *)(2 * (i_a2 % 256 ^ i_a1 / 256 & (int32_t)&i_g308 & 255) +
                     (int32_t)&CRC_16_CCITT_poly_0x1021_at_28d10); // 0xd47e
    return 256 * i_a1 & 0xff00 ^ (int32_t)i_v1;
}

// Address range: 0xd498 - 0xd4e4
int32_t CRC16(int32_t *p_a1, int32_t i_a2) {
    // 0xd498
    if (i_a2 == 0) {
        // 0xd4d8
        __asm_ite();
        return 0xffff;
    }
    int32_t i_v1 = 0xffff;
    int32_t i_v2 = (int32_t)p_a1; // 0xd498
    int32_t i_v3 = i_a2;          // 0xd4d0
    i_v3--;
    i_v1 = crc_itu_t_byte(i_v1, (int32_t) * (char *)i_v2) % 0x10000;
    i_v2++;
    int32_t i_v4 = i_v1; // 0xd4c6
    while (i_v3 != 0) {
        // 0xd4aa
        i_v3--;
        i_v1 = crc_itu_t_byte(i_v1, (int32_t) * (char *)i_v2) % 0x10000;
        i_v2++;
        i_v4 = i_v1;
    }
    // 0xd4d8
    __asm_ite();
    return i_v4;
}

// Address range: 0xd4e8 - 0xd4fc
int32_t InitElapsedTime(void) {
    // 0xd4e8
    return gettimeofday((struct timeval *)&p_g28, NULL);
}

// Address range: 0xd4fc - 0xd5b4
int32_t PrintElapsedTime(int32_t i_a1) {
    // 0xd4fc
    gettimeofday((struct timeval *)&p_g30, NULL);
    int32_t i_v1 = (int32_t)p_g30 - (int32_t)p_g28; // 0xd526
    i_g32 = i_v1;
    int32_t i_v2 = i_g31 - i_g29; // 0xd546
    i_g33 = i_v2;
    int32_t i_v3 = i_v1; // 0xd55e
    if (i_v2 < 0) {
        // 0xd560
        i_v3 = i_v1 - 1;
        i_g32 = i_v3;
        i_g33 = &i_g307;
    }
    // 0xd592
    return printf("Timestamp %s : %d sec\n", (char *)i_a1, i_v3);
}

// Address range: 0xd5b4 - 0xd6b8
int32_t cgpu_init(void) {
    // 0xd5b4
    printf("\n%s\n", "cgpu_init");
    memset(&i_g76, 0, (int32_t)&i_g2);
    int32_t i_v1 = 0; // 0xd5f6
    if (check_chain() != 0) {
        // 0xd5f8
        printf("!!! %s: check chain error\n", "cgpu_init");
        i_v1 = 1;
    }
    // 0xd610
    if (open_key() <= 0) {
        // 0xd61c
        printf((char *)((int32_t)&p_g292 | 0x20000));
        close_key();
        // 0xd6ae
        return -1;
    }
    // 0xd63a
    if (open_i2c() <= 0) {
        // 0xd646
        printf("!!! %s: open i2c error\n", "cgpu_init");
        close_i2c();
        close_key();
        // 0xd6ae
        return -1;
    }
    // 0xd668
    memset((int32_t *)((int32_t) "qsort" | (int32_t)&p_g94), 32, 64);
    write_lcd(0, (int32_t) "qsort" | (int32_t)&p_g94, 64);
    if (i_v1 == 1) {
        // 0xd68e
        printf((char *)((int32_t)&p_g293 | 0x20000));
        write_lcd(0, (int32_t) "No Hashboard", 16);
    }
    // 0xd6ae
    return 0;
}

// Address range: 0xd6b8 - 0xd70e
int32_t malloc_register_buf(void) {
    int32_t *p_v1 = malloc(0x1410); // 0xd6c0
    i_g101 = (int32_t)p_v1;
    int32_t i_v2; // 0xd6b8
    if (p_v1 == NULL) {
        // 0xd6e0
        i_v2 = printf((char *)((int32_t)&p_g294 | 0x20000));
    } else {
        // 0xd6f6
        i_v2 = (int32_t)memset(p_v1, 0, 0x1410);
    }
    // 0xd70c
    return i_v2;
}

// Address range: 0xd710 - 0xd73c
int32_t configMiner(void) {
    // 0xd710
    read_config();
    uint32_t i_v1 = get_works(); // 0xd71a
    int32_t i_v2 = -14;          // 0xd724
    if (i_v1 >= 0) {
        // 0xd72c
        malloc_register_buf();
        i_v2 = 0;
    }
    // 0xd732
    return i_v2;
}

// Address range: 0xd73c - 0xd7f8
int32_t display_arguments(void) {
    // 0xd73c
    int32_t i_v1; // bp-72, 0xd73c
    memset(&i_v1, 0, 64);
    memset(&i_v1, 32, 64);
    memcpy(&i_v1, &i_g102, i_g196);
    int32_t i_v2; // bp-56, 0xd73c
    sprintf((char *)&i_v2, (char *)((int32_t)&p_g295 | 0x20000));
    int32_t i_v3; // bp-40, 0xd73c
    sprintf((char *)&i_v3, "FREQ: %d  CORE:%d", i_g112, i_g114);
    int32_t i_v4; // bp-24, 0xd73c
    sprintf((char *)&i_v4, "Voltage: %d", i_g117);
    return write_lcd(0, (int32_t)&i_v1, 64);
}

// Address range: 0xd7f8 - 0xd866
int32_t clear_register_value_buf(void) {
    // 0xd7f8
    pthread_mutex_lock((int32_t *)((int32_t) "ettimeofday" | (int32_t)&p_g94));
    *(int32_t *)i_g101 = 0;
    *(int32_t *)(i_g101 + 4) = 0;
    *(int32_t *)(i_g101 + 8) = 0;
    *(int32_t *)(i_g101 + 12) = 0;
    pthread_mutex_unlock(
        (int32_t *)((int32_t) "ettimeofday" | (int32_t)&p_g94));
    return (int32_t)memset((int32_t *)(i_g101 + 16), 0, 0x1400);
}

// Address range: 0xd868 - 0xd94e
int32_t calculate_core_number(uint32_t i_a1) {
    // 0xd868
    switch (i_a1) {
    case 1: {
        // 0xd944
        return 1;
    }
    case 2: {
        // 0xd944
        return 2;
    }
    }
    if (i_a1 < 2) {
        // 0xd926
        printf("%s: actual_core_number = %d, but it is error\n",
               "calculate_core_number", i_a1);
        // 0xd944
        return -1;
    }
    // 0xd892
    if (i_a1 >= 4 != i_a1 != 4) {
        // 0xd944
        return 4;
    }
    if (i_a1 != 4 && i_a1 >= 4) {
        // 0xd8a4
        if (i_a1 >= 8 != i_a1 != 8) {
            // 0xd944
            return 8;
        }
    }
    if (i_a1 != 8 && i_a1 >= 8) {
        // 0xd8b6
        if (i_a1 >= 16 != i_a1 != 16) {
            // 0xd944
            return 16;
        }
    }
    if (i_a1 != 16 && i_a1 >= 16) {
        // 0xd8c8
        if (i_a1 >= 32 != i_a1 != 32) {
            // 0xd944
            return 32;
        }
    }
    if (i_a1 != 32 && i_a1 >= 32) {
        // 0xd8da
        if (i_a1 >= 64 != i_a1 != 64) {
            // 0xd944
            return 64;
        }
    }
    if (i_a1 != 64 && i_a1 >= 64) {
        // 0xd8ec
        if (i_a1 >= 128 != i_a1 != 128) {
            // 0xd944
            return 128;
        }
    }
    if (i_a1 != 128 && i_a1 >= 128) {
        // 0xd8fe
        if (i_a1 >= 256 != i_a1 != 256) {
            // 0xd944
            return 256;
        }
    }
    if (i_a1 == 256 || i_a1 < 256) {
        // 0xd926
        printf("%s: actual_core_number = %d, but it is error\n",
               "calculate_core_number", i_a1);
        // 0xd944
        return -1;
    }
    // 0xd916
    if (i_a1 >= 512 != i_a1 != 512) {
        // 0xd944
        return 512;
    }
    // 0xd926
    printf("%s: actual_core_number = %d, but it is error\n",
           "calculate_core_number", i_a1);
    // 0xd944
    return -1;
}

// Address range: 0xd950 - 0xd9aa
int32_t calculate_how_many_nonce_per_asic_get(int32_t i_a1, uint32_t i_a2,
                                              uint32_t i_a3) {
    // 0xd950
    if (i_a3 == 0) {
        // 0xd99c
        return 0;
    }
    int32_t i_v1 = 512 * (256 * i_a1 & 0xff00 | i_a2 % 256); // 0xd97e
    int32_t i_v2 = 0;                                        // 0xd990
    int32_t i_v3 = 0;                                        // 0xd98a
    i_v3 += *(int32_t *)(4 * (i_v2 + i_v1) + (int32_t)&i_g202);
    i_v2++;
    while (i_v2 < i_a3) {
        // 0xd96e
        i_v3 += *(int32_t *)(4 * (i_v2 + i_v1) + (int32_t)&i_g202);
        i_v2++;
    }
    // 0xd99c
    return i_v3;
}

// Address range: 0xd9ac - 0xda3e
int32_t display_level_result_on_lcd(void) {
    char *p_v1 = (char *)0x20202020; // bp-20, 0xd9be
    sprintf((char *)&p_v1, "%2d", (int32_t)&i_g189);
    int32_t i_v2 = 0;                             // 0xda02
    char i_v3 = *(char *)(i_v2 + (int32_t)&p_v1); // 0xd9f4
    *(char *)(i_v2 + ((int32_t) "C_2.7" | (int32_t)&p_g94) + 10) = i_v3;
    i_v2++;
    while (i_v2 == 2 || i_v2 < 2) {
        // 0xd9e8
        i_v3 = *(char *)(i_v2 + (int32_t)&p_v1);
        *(char *)(i_v2 + ((int32_t) "C_2.7" | (int32_t)&p_g94) + 10) = i_v3;
        i_v2++;
    }
    // 0xda0c
    write_lcd(0, (int32_t) "C_2.7" | (int32_t)&p_g94, 16);
    return printf("Level: %d\n\n", (int32_t)&i_g189);
}

// Address range: 0xda40 - 0xddd6
int32_t reset_global_arg(void) {
    // 0xda40
    printf("\n--- %s\n", "reset_global_arg");
    memset((int32_t *)((int32_t) "qsort" | (int32_t)&p_g94), 32, 64);
    write_lcd(0, (int32_t) "qsort" | (int32_t)&p_g94, 64);
    memset(&i_g198, 0, 16);
    memset(&i_g199, 0, 16);
    memset(&i_g200, 0, 16);
    memset((int32_t *)i_g101, 0, 0x1410);
    memset(&i_g148, 0, 2040);
    pthread_mutex_init((int32_t *)((int32_t) "ettimeofday" | (int32_t)&p_g94),
                       NULL);
    int32_t i_v1 = 0;
    int32_t i_v2 = 4 * i_v1; // 0xdb02
    *(int32_t *)(i_v2 + (int32_t)&i_g190) = 0;
    *(char *)(i_v1 + (int32_t)&p_g8) = 0;
    *(char *)(i_v1 + (int32_t)&p_g192) = 0;
    *(char *)(i_v1 + (int32_t)&p_g191) = 0;
    if (*(char *)&p_g188 == 0) {
        // 0xdb44
        *(char *)(i_v1 + (int32_t)&p_g10) = 0;
        *(char *)(i_v1 + (int32_t)&p_g11) = 0;
        *(char *)(i_v1 + (int32_t)&p_g12) = 0;
    }
    // 0xdb74
    *(char *)(i_v1 + (int32_t)&p_g159) = 1;
    *(char *)(i_v1 + (int32_t)&p_g160) = 1;
    *(char *)(i_v1 + (int32_t)&p_g161) = 1;
    *(int32_t *)(i_v2 + (int32_t)&i_g13) = 0;
    *(int32_t *)(i_v2 + (int32_t)&i_g14) = 0;
    *(int32_t *)(i_v2 + (int32_t)&i_g15) = 0;
    *(int32_t *)(i_v2 + (int32_t)&i_g16) = 0;
    *(int32_t *)(i_v2 + (int32_t)&i_g17) = 0;
    *(int32_t *)(i_v2 + (int32_t)&i_g18) = 0;
    *(int32_t *)(i_v2 + (int32_t)&i_g19) = 0;
    *(int32_t *)(i_v2 + (int32_t)&i_g20) = 0;
    *(int32_t *)(i_v2 + (int32_t)&i_g21) = 0;
    *(int32_t *)(i_v2 + (int32_t)&i_g22) = 0;
    *(char *)(i_v1 + (int32_t)&p_g23) = 0;
    *(char *)(i_v1 + (int32_t)&p_g24) = 0;
    *(int32_t *)(i_v2 + (int32_t)&i_g25) = 0;
    *(char *)(i_v1 + (int32_t)&p_g26) = 1;
    *(char *)(i_v1 + (int32_t)&p_g27) = 0;
    *(char *)(i_v1 + (int32_t)&p_g9) = 0;
    pthread_mutex_init((int32_t *)(24 * i_v1 + (int32_t)&i_g147), NULL);
    *(char *)(i_v1 + (int32_t)&i_g76 + (int32_t)&i_g1 + 1208) = 0;
    *(int32_t *)(i_v2 + (int32_t)&i_g7) = 0;
    *(int32_t *)(i_v2 + (int32_t)&i_g199) = 0;
    *(int32_t *)(i_v2 + (int32_t)&i_g201) = 0;
    int32_t i_v3;  // 0xda40
    int32_t i_v4;  // 0xda40
    int32_t i_v5;  // 0xddb4
    int32_t i_v6;  // 0xda40
    int32_t i_v7;  // 0xda40
    int32_t i_v8;  // 0xda40
    int32_t i_v9;  // 0xda40
    int32_t i_v10; // 0xdd1e
    int32_t i_v11; // 0xdd3a
    int32_t i_v12; // 0xda40
    int32_t i_v13; // 0xdd92
    int32_t i_v14; // 0xdd9e
    int32_t i_v15; // 0xdd7c
    int32_t i_v16; // 0xdd88
    int32_t i_v17; // 0xda40
    int32_t i_v18; // 0xda40
    int32_t i_v19; // 0xdda8
    if (i_g113 != 0) {
        // 0xdd0e
        i_v17 = 256 * i_v1;
        i_v18 = i_v2 + 188;
        i_v7 = 0;
        i_v4 = 0;
        if (i_g114 != 0) {
            // 0xdd2a
            i_v10 = *(int32_t *)(4 * i_v7 + (int32_t)&i_g76 + 0x800a0);
            i_v11 = 512 * (i_v7 + i_v17);
            i_v12 = i_v18 + i_v10;
            i_v8 = 0;
            *(int32_t *)(4 * (i_v8 + i_v11) + (int32_t)&i_g202) = 0;
            i_v9 = 0;
            if (i_g110 != 0) {
                *(int32_t *)(i_v12 + 204 * (i_g110 * i_v8 + i_v9)) = 0;
                i_v15 = i_v9 + 1;
                i_v16 = i_g110;
                i_v9 = i_v15;
                while (i_v16 >= i_v15 == (i_v16 != i_v15)) {
                    // 0xdd4c
                    *(int32_t *)(i_v12 + 204 * (i_v16 * i_v8 + i_v9)) = 0;
                    i_v15 = i_v9 + 1;
                    i_v16 = i_g110;
                    i_v9 = i_v15;
                }
            }
            // 0xdd90
            i_v13 = i_v8 + 1;
            i_v14 = i_g114;
            while (i_v14 >= i_v13 == (i_v14 != i_v13)) {
                // 0xdd2a
                i_v8 = i_v13;
                *(int32_t *)(4 * (i_v8 + i_v11) + (int32_t)&i_g202) = 0;
                i_v9 = 0;
                if (i_g110 != 0) {
                    *(int32_t *)(i_v12 + 204 * (i_g110 * i_v8 + i_v9)) = 0;
                    i_v15 = i_v9 + 1;
                    i_v16 = i_g110;
                    i_v9 = i_v15;
                    while (i_v16 >= i_v15 == (i_v16 != i_v15)) {
                        // 0xdd4c
                        *(int32_t *)(i_v12 + 204 * (i_v16 * i_v8 + i_v9)) = 0;
                        i_v15 = i_v9 + 1;
                        i_v16 = i_g110;
                        i_v9 = i_v15;
                    }
                }
                // 0xdd90
                i_v13 = i_v8 + 1;
                i_v14 = i_g114;
            }
            // 0xdd96
            i_v4 = i_v14;
        }
        // 0xdda6
        i_v6 = i_v4;
        i_v5 = i_g113;
        i_v19 = i_v7 + 1;
        while (i_v5 >= i_v19 == (i_v5 != i_v19)) {
            // 0xdd0e
            i_v7 = i_v19;
            i_v3 = i_v5;
            i_v4 = 0;
            if (i_v6 != 0) {
                // 0xdd2a
                i_v10 = *(int32_t *)(4 * i_v7 + (int32_t)&i_g76 + 0x800a0);
                i_v11 = 512 * (i_v7 + i_v17);
                i_v12 = i_v18 + i_v10;
                i_v8 = 0;
                *(int32_t *)(4 * (i_v8 + i_v11) + (int32_t)&i_g202) = 0;
                i_v9 = 0;
                if (i_g110 != 0) {
                    *(int32_t *)(i_v12 + 204 * (i_g110 * i_v8 + i_v9)) = 0;
                    i_v15 = i_v9 + 1;
                    i_v16 = i_g110;
                    i_v9 = i_v15;
                    while (i_v16 >= i_v15 == (i_v16 != i_v15)) {
                        // 0xdd4c
                        *(int32_t *)(i_v12 + 204 * (i_v16 * i_v8 + i_v9)) = 0;
                        i_v15 = i_v9 + 1;
                        i_v16 = i_g110;
                        i_v9 = i_v15;
                    }
                }
                // 0xdd90
                i_v13 = i_v8 + 1;
                i_v14 = i_g114;
                while (i_v14 >= i_v13 == (i_v14 != i_v13)) {
                    // 0xdd2a
                    i_v8 = i_v13;
                    *(int32_t *)(4 * (i_v8 + i_v11) + (int32_t)&i_g202) = 0;
                    i_v9 = 0;
                    if (i_g110 != 0) {
                        *(int32_t *)(i_v12 + 204 * (i_g110 * i_v8 + i_v9)) = 0;
                        i_v15 = i_v9 + 1;
                        i_v16 = i_g110;
                        i_v9 = i_v15;
                        while (i_v16 >= i_v15 == (i_v16 != i_v15)) {
                            // 0xdd4c
                            *(int32_t *)(i_v12 + 204 * (i_v16 * i_v8 + i_v9)) =
                                0;
                            i_v15 = i_v9 + 1;
                            i_v16 = i_g110;
                            i_v9 = i_v15;
                        }
                    }
                    // 0xdd90
                    i_v13 = i_v8 + 1;
                    i_v14 = i_g114;
                }
                // 0xdd96
                i_v3 = i_g113;
                i_v4 = i_v14;
            }
            // 0xdda6
            i_v6 = i_v4;
            i_v5 = i_v3;
            i_v19 = i_v7 + 1;
        }
    }
    int32_t i_v20 = i_v1 + 1; // 0xddbe
    while (i_v20 == 3 || i_v20 < 3) {
        // 0xdaf6
        i_v1 = i_v20;
        i_v2 = 4 * i_v1;
        *(int32_t *)(i_v2 + (int32_t)&i_g190) = 0;
        *(char *)(i_v1 + (int32_t)&p_g8) = 0;
        *(char *)(i_v1 + (int32_t)&p_g192) = 0;
        *(char *)(i_v1 + (int32_t)&p_g191) = 0;
        if (*(char *)&p_g188 == 0) {
            // 0xdb44
            *(char *)(i_v1 + (int32_t)&p_g10) = 0;
            *(char *)(i_v1 + (int32_t)&p_g11) = 0;
            *(char *)(i_v1 + (int32_t)&p_g12) = 0;
        }
        // 0xdb74
        *(char *)(i_v1 + (int32_t)&p_g159) = 1;
        *(char *)(i_v1 + (int32_t)&p_g160) = 1;
        *(char *)(i_v1 + (int32_t)&p_g161) = 1;
        *(int32_t *)(i_v2 + (int32_t)&i_g13) = 0;
        *(int32_t *)(i_v2 + (int32_t)&i_g14) = 0;
        *(int32_t *)(i_v2 + (int32_t)&i_g15) = 0;
        *(int32_t *)(i_v2 + (int32_t)&i_g16) = 0;
        *(int32_t *)(i_v2 + (int32_t)&i_g17) = 0;
        *(int32_t *)(i_v2 + (int32_t)&i_g18) = 0;
        *(int32_t *)(i_v2 + (int32_t)&i_g19) = 0;
        *(int32_t *)(i_v2 + (int32_t)&i_g20) = 0;
        *(int32_t *)(i_v2 + (int32_t)&i_g21) = 0;
        *(int32_t *)(i_v2 + (int32_t)&i_g22) = 0;
        *(char *)(i_v1 + (int32_t)&p_g23) = 0;
        *(char *)(i_v1 + (int32_t)&p_g24) = 0;
        *(int32_t *)(i_v2 + (int32_t)&i_g25) = 0;
        *(char *)(i_v1 + (int32_t)&p_g26) = 1;
        *(char *)(i_v1 + (int32_t)&p_g27) = 0;
        *(char *)(i_v1 + (int32_t)&p_g9) = 0;
        pthread_mutex_init((int32_t *)(24 * i_v1 + (int32_t)&i_g147), NULL);
        *(char *)(i_v1 + (int32_t)&i_g76 + (int32_t)&i_g1 + 1208) = 0;
        *(int32_t *)(i_v2 + (int32_t)&i_g7) = 0;
        *(int32_t *)(i_v2 + (int32_t)&i_g199) = 0;
        *(int32_t *)(i_v2 + (int32_t)&i_g201) = 0;
        if (i_g113 != 0) {
            // 0xdd0e
            i_v17 = 256 * i_v1;
            i_v18 = i_v2 + 188;
            i_v7 = 0;
            i_v4 = 0;
            if (i_g114 != 0) {
                // 0xdd2a
                i_v10 = *(int32_t *)(4 * i_v7 + (int32_t)&i_g76 + 0x800a0);
                i_v11 = 512 * (i_v7 + i_v17);
                i_v12 = i_v18 + i_v10;
                i_v8 = 0;
                *(int32_t *)(4 * (i_v8 + i_v11) + (int32_t)&i_g202) = 0;
                i_v9 = 0;
                if (i_g110 != 0) {
                    *(int32_t *)(i_v12 + 204 * (i_g110 * i_v8 + i_v9)) = 0;
                    i_v15 = i_v9 + 1;
                    i_v16 = i_g110;
                    i_v9 = i_v15;
                    while (i_v16 >= i_v15 == (i_v16 != i_v15)) {
                        // 0xdd4c
                        *(int32_t *)(i_v12 + 204 * (i_v16 * i_v8 + i_v9)) = 0;
                        i_v15 = i_v9 + 1;
                        i_v16 = i_g110;
                        i_v9 = i_v15;
                    }
                }
                // 0xdd90
                i_v13 = i_v8 + 1;
                i_v14 = i_g114;
                while (i_v14 >= i_v13 == (i_v14 != i_v13)) {
                    // 0xdd2a
                    i_v8 = i_v13;
                    *(int32_t *)(4 * (i_v8 + i_v11) + (int32_t)&i_g202) = 0;
                    i_v9 = 0;
                    if (i_g110 != 0) {
                        *(int32_t *)(i_v12 + 204 * (i_g110 * i_v8 + i_v9)) = 0;
                        i_v15 = i_v9 + 1;
                        i_v16 = i_g110;
                        i_v9 = i_v15;
                        while (i_v16 >= i_v15 == (i_v16 != i_v15)) {
                            // 0xdd4c
                            *(int32_t *)(i_v12 + 204 * (i_v16 * i_v8 + i_v9)) =
                                0;
                            i_v15 = i_v9 + 1;
                            i_v16 = i_g110;
                            i_v9 = i_v15;
                        }
                    }
                    // 0xdd90
                    i_v13 = i_v8 + 1;
                    i_v14 = i_g114;
                }
                // 0xdd96
                i_v4 = i_v14;
            }
            // 0xdda6
            i_v6 = i_v4;
            i_v5 = i_g113;
            i_v19 = i_v7 + 1;
            while (i_v5 >= i_v19 == (i_v5 != i_v19)) {
                // 0xdd0e
                i_v7 = i_v19;
                i_v3 = i_v5;
                i_v4 = 0;
                if (i_v6 != 0) {
                    // 0xdd2a
                    i_v10 = *(int32_t *)(4 * i_v7 + (int32_t)&i_g76 + 0x800a0);
                    i_v11 = 512 * (i_v7 + i_v17);
                    i_v12 = i_v18 + i_v10;
                    i_v8 = 0;
                    *(int32_t *)(4 * (i_v8 + i_v11) + (int32_t)&i_g202) = 0;
                    i_v9 = 0;
                    if (i_g110 != 0) {
                        *(int32_t *)(i_v12 + 204 * (i_g110 * i_v8 + i_v9)) = 0;
                        i_v15 = i_v9 + 1;
                        i_v16 = i_g110;
                        i_v9 = i_v15;
                        while (i_v16 >= i_v15 == (i_v16 != i_v15)) {
                            // 0xdd4c
                            *(int32_t *)(i_v12 + 204 * (i_v16 * i_v8 + i_v9)) =
                                0;
                            i_v15 = i_v9 + 1;
                            i_v16 = i_g110;
                            i_v9 = i_v15;
                        }
                    }
                    // 0xdd90
                    i_v13 = i_v8 + 1;
                    i_v14 = i_g114;
                    while (i_v14 >= i_v13 == (i_v14 != i_v13)) {
                        // 0xdd2a
                        i_v8 = i_v13;
                        *(int32_t *)(4 * (i_v8 + i_v11) + (int32_t)&i_g202) = 0;
                        i_v9 = 0;
                        if (i_g110 != 0) {
                            *(int32_t *)(i_v12 + 204 * (i_g110 * i_v8 + i_v9)) =
                                0;
                            i_v15 = i_v9 + 1;
                            i_v16 = i_g110;
                            i_v9 = i_v15;
                            while (i_v16 >= i_v15 == (i_v16 != i_v15)) {
                                // 0xdd4c
                                *(int32_t *)(i_v12 +
                                             204 * (i_v16 * i_v8 + i_v9)) = 0;
                                i_v15 = i_v9 + 1;
                                i_v16 = i_g110;
                                i_v9 = i_v15;
                            }
                        }
                        // 0xdd90
                        i_v13 = i_v8 + 1;
                        i_v14 = i_g114;
                    }
                    // 0xdd96
                    i_v3 = i_g113;
                    i_v4 = i_v14;
                }
                // 0xdda6
                i_v6 = i_v4;
                i_v5 = i_v3;
                i_v19 = i_v7 + 1;
            }
        }
        // 0xddbc
        i_v20 = i_v1 + 1;
    }
    // 0xddca
    return clear_register_value_buf();
}

// Address range: 0xddd8 - 0xde32
int32_t rev(int32_t i_a1, int32_t i_a2) {
    char i_v1 = (char)i_a2 - 1;
    char i_v2 = i_v1; // 0xde26
    if (i_v1 == 0) {
        // 0xde28
        return i_a1;
    }
    char i_v3 = 0;                               // 0xde26
    char *p_v4 = (char *)((int32_t)i_v3 + i_a1); // 0xddf6
    char *p_v5 = (char *)((int32_t)i_v2 + i_a1); // 0xde06
    *p_v4 = *p_v5;
    *p_v5 = *p_v4;
    i_v3++;
    i_v2--;
    while (i_v3 < i_v2) {
        // 0xddf0
        p_v4 = (char *)((int32_t)i_v3 + i_a1);
        p_v5 = (char *)((int32_t)i_v2 + i_a1);
        *p_v4 = *p_v5;
        *p_v5 = *p_v4;
        i_v3++;
        i_v2--;
    }
    // 0xde28
    return i_a1;
}

// Address range: 0xde34 - 0xde96
int32_t target_to_dcrdiff(int32_t *p_a1) {
    int32_t i_v1 = 7;
    int32_t i_v2 = *(int32_t *)(4 * i_v1 + (int32_t)p_a1); // 0xde54
    char i_v3 = 0;                                         // 0xde34
    uint32_t i_v4 = 31;
    char i_v5 = i_v3; // 0xde62
    if ((1 << i_v4 & i_v2) != 0) {
        return i_v5;
    }
    char i_v6 = i_v3 + 1;    // 0xde66
    int32_t i_v7 = i_v4 - 1; // 0xde7a
    i_v3 = i_v6;
    while (i_v4 != 0) {
        // 0xde4c
        i_v4 = i_v7;
        i_v5 = i_v3;
        if ((1 << i_v4 & i_v2) != 0) {
            return i_v5;
        }
        // 0xde64
        i_v6 = i_v3 + 1;
        i_v7 = i_v4 - 1;
        i_v3 = i_v6;
    }
    int32_t i_v8 = i_v1 - 1; // 0xde86
    i_v5 = i_v6;
    while (i_v1 != 0) {
        // 0xde76
        i_v1 = i_v8;
        i_v2 = *(int32_t *)(4 * i_v1 + (int32_t)p_a1);
        i_v4 = 31;
        i_v5 = i_v6;
        if ((1 << i_v4 & i_v2) != 0) {
            return i_v5;
        }
        // 0xde64
        i_v6++;
        i_v7 = i_v4 - 1;
        i_v3 = i_v6;
        while (i_v4 != 0) {
            // 0xde4c
            i_v4 = i_v7;
            i_v5 = i_v3;
            if ((1 << i_v4 & i_v2) != 0) {
                return i_v5;
            }
            // 0xde64
            i_v6 = i_v3 + 1;
            i_v7 = i_v4 - 1;
            i_v3 = i_v6;
        }
        // 0xde7c
        i_v8 = i_v1 - 1;
        i_v5 = i_v6;
    }
lab_0xde8a:
    // 0xde8a
    return i_v5;
}

// Address range: 0xde98 - 0xdece
int32_t decred_hash_simple(int32_t *p_a1, int32_t *p_a2) {
    // 0xde98
    int32_t i_v1; // bp-132, 0xde98
    sph_blake256_init(&i_v1);
    sph_blake256(&i_v1, (int32_t)p_a2, 180);
    return sph_blake256_close(&i_v1, (int32_t)p_a1);
}

// Address range: 0xded0 - 0xdffc
int32_t check_hw(int32_t i_a1, int32_t i_a2, int32_t i_a3, uint32_t i_a4) {
    // 0xded0
    int32_t i_v1; // bp-196, 0xded0
    memset(&i_v1, 0, 180);
    memset(&i_v1, 0, 180);
    int32_t i_v2 = i_a1 + 8;
    memcpy(&i_v1, (int32_t *)i_v2, 180);
    int32_t i_v3; // bp-228, 0xded0
    decred_hash_simple(&i_v3, &i_v1);
    uint32_t i_v4 = target_to_dcrdiff(&i_v3) % 256; // 0xdf76
    if (i_v4 != 37 && i_v4 >= 37) {
        // 0xdff2
        return 0;
    }
    // 0xdf82
    if (i_a4 % 256 == 0) {
        // 0xdff2
        return 1;
    }
    // 0xdf88
    printf("\n%s: Got a HW!\n", "check_hw");
    printf("\tdata=");
    int32_t i_v5 = 0; // 0xdfce
    printf("%02x", (int32_t) * (char *)(i_v5 + i_v2));
    i_v5++;
    while (i_v5 == 179 || i_v5 < 179) {
        // 0xdfb0
        printf("%02x", (int32_t) * (char *)(i_v5 + i_v2));
        i_v5++;
    }
    // 0xdfdc
    printf("\treturn nonce=0x%08x, but it should be nonce=0x%08x\n", i_a2,
           *(int32_t *)(i_a1 + 4));
    // 0xdff2
    return 1;
}

// Address range: 0xdffc - 0xe132
int32_t calculate_timeout_and_baud(int32_t i_a1, int32_t i_a2, int32_t i_a3,
                                   int32_t i_a4) {
    // 0xdffc
    printf("\n%s\n", "calculate_timeout_and_baud");
    int32_t i_v1 = calculate_core_number(i_g114); // 0xe02e
    unsigned char i_v2 = *(char *)&p_g188;        // 0xe03e
    if (i_v2 >= 8 != i_v2 != 8) {
        // 0xe044
        __asm_adr(4);
        return i_v1;
    }
    int32_t i_v3 = i_v2; // 0xe0f6
    i_g111 = 0;
    i_g145 = 0;
    return __asm_nop(printf("%s: pattern_test_time = %d, error!!! \n",
                            "calculate_timeout_and_baud", i_v3),
                     (int32_t) "calculate_timeout_and_baud", i_v3, i_v3);
}

// Address range: 0xe134 - 0xe23e
int32_t show_status_func(int32_t i_a1) {
    // 0xe134
    int32_t i_v1;                                         // 0xe134
    uint32_t i_v2 = (uint32_t)i_v1 % 256;                 // 0xe142
    int32_t i_v3 = 4 * i_v2;                              // 0xe152
    int32_t *p_v4 = (int32_t *)(i_v3 + (int32_t)&i_g190); // 0xe152
    int32_t *p_v5 = (int32_t *)(i_v3 + (int32_t)&i_g199);
    int32_t *p_v6 = (int32_t *)(i_v3 + (int32_t)&i_g200);
    int32_t i_v7 = 0; // 0xe152
    while (true) {
        // 0xe156
        *p_v4 = i_v7;
        memset((int32_t *)((int32_t) "qsort" | (int32_t)&p_g94), 32, 64);
        int32_t i_v8 = *p_v4; // 0xe170
        sprintf((char *)((int32_t) "qsort" | (int32_t)&p_g94), "   time %ds",
                i_v8);
        sprintf((char *)&p_g149, "   nonce=%d", *p_v5);
        sprintf((char *)&p_g150, "   HW=%d", *p_v6);
        if (*(char *)(i_v2 + (int32_t)&p_g26) != 0) {
            // 0xe1d6
            if (*(char *)(i_v2 + (int32_t)&p_g192) != 0) {
                int32_t i_v9 = *(int32_t *)(i_v3 + (int32_t)&i_g19); // 0xe1f0
                sprintf((char *)&p_g151, "   temp %d `C", i_v9);
            }
        }
        // 0xe204
        write_lcd(0, (int32_t) "qsort" | (int32_t)&p_g94, 64);
        usleep((int32_t)&i_g307);
        i_v7 = *p_v4 + 1;
    }
}

// Address range: 0xe24c - 0xe400
int32_t set_voltage(int32_t i_a1, int32_t i_a2, uint32_t i_a3, int32_t i_a4) {
    unsigned char i_v1 = *(char *)&p_g188; // 0xe27a
    if (i_v1 >= 8 != i_v1 != 8) {
        // 0xe280
        __asm_adr(4);
        return i_a1;
    }
    int32_t i_v2 = i_v1; // 0xe352
    int32_t i_v3 =
        __asm_nop(printf("\n--- %s: Can't find voltage%d\n", (char *)i_v2, 0),
                  i_v2, 0, i_v2); // 0xe362
    i_g116 = i_g117;
    int32_t i_v4 = (i_a3 % 256 == 0 ? 0 : i_g138) + i_g117;
    switch (i_g115) {
    case 1722: {
        // 0xe39c
        __asm_vldr(i_v4);
        return i_v3;
    }
    case 1725: {
        // 0xe3d4
        __asm_vldr(i_v4);
        return i_v3;
    }
    }
    // 0xe3f8
    __asm_vldr_70(0);
    __asm_vldr_70(0x406fe000);
    return i_v3;
}

// Address range: 0xe400 - 0xe420
int32_t function_e400(void) {
    // 0xe400
    bool i_v1; // 0xe400
    if (i_v1) {
        // 0xe404
        function_ff209ed8();
        unknown_449fd0();
    } else {
        // .critedge
        unknown_449fd0();
        function_149a78();
        function_ff049ef4();
    }
    // 0xe41c
    return unknown_449fe8();
}

// Address range: 0xe420 - 0xe432
int32_t function_e420(void) {
    // 0xe420
    int32_t i_v1; // 0xe420
    int32_t *p_v2 = (int32_t *)(i_v1 + 16);
    bool i_v3; // 0xe420
    if (i_v3) {
        // 0xe422
        *p_v2 = 0;
        *(int32_t *)(i_v1 + 20) = 0;
    }
    // 0xe42e
    __asm_vldr_70(*p_v2);
    return i_v1;
}

// Address range: 0xe432 - 0xe4b0
int32_t function_e432(int32_t i_a1, int32_t i_a2) {
    // 0xe432
    bool i_v1; // 0xe432
    if (i_v1) {
        function_ff20a02a();
    }
    if (!i_v1) {
        function_fe449c96();
    }
    if (!i_v1) {
        function_ffe6b02e();
    }
    // 0xe43e
    int32_t i_v2;                                      // 0xe432
    int32_t i_v3 = (int32_t) * (int64_t *)(i_v2 + 16); // 0xe43e
    int32_t i_v4 = *(int32_t *)(i_v2 + 12);            // 0xe458
    printf(
        "\n--- %s: real voltage = %d, temp_voltage = %.6f, Pic_Voltage = %d\n",
        "set_voltage", i_v4, (float64_t)(int64_t)i_v3, i_v3);
    switch (i_g115) {
    case 1722: {
        unsigned char i_v5 = *(char *)(i_v2 + 7);  // 0xe470
        unsigned char i_v6 = *(char *)(i_v2 + 6);  // 0xe472
        unsigned char i_v7 = *(char *)(i_v2 + 11); // 0xe474
        set_PIC16F1704_voltage((int32_t)i_v5, (int32_t)i_v6, (int32_t)i_v7);
        // break -> 0xe49c
        break;
    }
    case 1725: {
        // 0xe494
        power_set_voltage((int32_t) * (char *)(i_v2 + 11));
        // break -> 0xe49c
        break;
    }
    }
    // 0xe49c
    return usleep((int32_t)&i_g239 | 0x10000);
}

// Address range: 0xe4b0 - 0xe4c0
int32_t _24_d(int32_t i_a1) {
    int32_t i_v1 = i_a1; // 0xe4b0
    bool i_v2;           // 0xe4b0
    if (!i_v2) {
        i_v1 = function_dc7064();
    }
    int32_t i_v3 = i_v1;
    int32_t i_v4; // 0xe4b0
    return i_v2 ? i_v4 - i_v3 : i_v3;
}

// Address range: 0xe4c2 - 0xe4dc
int32_t function_e4c2(int32_t i_a1, int32_t i_a2, int32_t i_a3, uint32_t i_a4) {
    int32_t i_v1 = i_a1; // 0xe4c2
    bool i_v2;           // 0xe4c2
    if (!i_v2) {
        i_v1 = function_fffccc36();
    }
    int32_t i_v3 = i_v1; // 0xe4c6
    if (i_v2) {
        i_v3 = function_145e726();
    }
    // 0xe4ca
    return (int32_t) * (char *)(i_v3 + i_a2) << i_a4;
}

// Address range: 0xe4e0 - 0xe590
int32_t set_baud(uint32_t i_a1, uint32_t i_a2) {
    uint32_t i_v1 = (int32_t)(0x1000000 * i_a1) >> 24; // 0xe4ea
    uint32_t i_v2 = i_a2 % 256;
    printf("\n--- %s: Chain : %d, baud = %d\n", "set_baud", i_a1 % 256, i_v2);
    int32_t i_v3; // 0xe4e0
    switch (i_g115) {
    case 1722: {
        int32_t i_v4 = i_v1 % 256;
        set_BM1722_asic_register(i_v4, 0, 28, 1,
                                 256 * i_a2 & 0xdf00 | 0x7002001);
        i_v3 = i_v4;
        // break -> 0xe574
        break;
    }
    case 1725: {
        int32_t i_v5 = i_v1 % 256;
        set_BM1725_asic_register(i_v5, 0, 28, 1,
                                 256 * i_a2 & 0xdf00 | 0x7002001);
        i_v3 = i_v5;
        // break -> 0xe574
        break;
    }
    default: {
        // 0xe4e0
        i_v3 = i_v1 % 256;
        // break -> 0xe574
        break;
    }
    }
    // 0xe574
    usleep(0xc350);
    return uart_set_baud(i_v3, i_v2);
}

// Address range: 0xe590 - 0xe5b4
int32_t is_nonce_or_reg_value(uint32_t i_a1) {
    // 0xe590
    return __asm_sxtb(i_a1 % 256) < 0;
}

// Address range: 0xe5b4 - 0xea02
int32_t check_nonce(uint32_t i_a1, int32_t i_a2) {
    // 0xe5b4
    int32_t i_v1; // 0xe5b4
    uint32_t i_v2 = i_v1;
    int32_t i_v3 = 0; // 0xe5b4
    int32_t i_v4 = 0; // 0xe5b4
    char i_v5 = 0;    // 0xe5b4
    int32_t i_v6 = 0; // 0xe5b4
    switch (i_g115) {
    case 1722: {
        unsigned char i_v7 = *(char *)(i_a2 + 1);       // 0xe604
        unsigned char i_v8 = *(char *)(i_a2 + 2);       // 0xe60e
        uint32_t i_v9 = (int32_t) * (char *)(i_a2 + 3); // 0xe618
        i_v3 = i_v9 / i_g195;
        i_v4 = i_v2 % 128;
        i_v5 = *(char *)(i_a2 + 5) % 128;
        i_v6 = 256 * (int32_t)i_v7 | i_v2 % 256 | 0x10000 * (int32_t)i_v8 |
               0x1000000 * i_v9;
        // break -> 0xe6d6
        break;
    }
    case 1725: {
        unsigned char i_v10 = *(char *)(i_a2 + 1);      // 0xe676
        unsigned char i_v11 = *(char *)(i_a2 + 2);      // 0xe680
        int32_t i_v12 = (int32_t) * (char *)(i_a2 + 3); // 0xe68a
        i_v3 = (int32_t) * (char *)(i_a2 + 4) / i_g195;
        i_v4 = 256 * (int32_t)(i_v11 % 2) | i_v12;
        i_v5 = *(char *)(i_a2 + 6) % 128;
        i_v6 = 256 * (int32_t)i_v10 | i_v2 % 256 | 0x10000 * (int32_t)i_v11 |
               0x1000000 * i_v12;
        // break -> 0xe6d6
        break;
    }
    }
    uint32_t i_v13 = i_v3;
    uint32_t i_v14 = i_g113; // 0xe6de
    if (i_v14 >= i_v13 != i_v14 != i_v13) {
        // 0xe6e6
        printf("%s: received ASIC%02d nonce. error!!!\t", "check_nonce", i_v13);
        unsigned char i_v15 = *(char *)(i_a2 + 1); // 0xe706
        unsigned char i_v16 = *(char *)(i_a2 + 2); // 0xe70e
        unsigned char i_v17 = *(char *)(i_a2 + 3); // 0xe714
        unsigned char i_v18 = *(char *)(i_a2 + 4); // 0xe71c
        printf(",received data is : 0x%02x%02x%02x%02x%02x\n", i_v2 % 256,
               (int32_t)i_v15, (int32_t)i_v16, (int32_t)i_v17, (int32_t)i_v18);
        // 0xe9f8
        return -1;
    }
    uint32_t i_v19 = i_v4;
    uint32_t i_v20 = i_g114; // 0xe73c
    if (i_v20 >= i_v19 != i_v20 != i_v19) {
        // 0xe744
        printf("%s: received core%02d nonce. error!!!\t", "check_nonce", i_v19);
        unsigned char i_v21 = *(char *)(i_a2 + 1); // 0xe764
        unsigned char i_v22 = *(char *)(i_a2 + 2); // 0xe76c
        unsigned char i_v23 = *(char *)(i_a2 + 3); // 0xe772
        unsigned char i_v24 = *(char *)(i_a2 + 4); // 0xe77a
        unsigned char i_v25 = *(char *)(i_a2 + 5); // 0xe782
        printf(",received data is : 0x%02x%02x%02x%02x%02x%02x\n", i_v2 % 256,
               (int32_t)i_v21, (int32_t)i_v22, (int32_t)i_v23, (int32_t)i_v24,
               (int32_t)i_v25);
        // 0xe9f8
        return -1;
    }
    uint32_t i_v26 = (int32_t)i_v5;
    uint32_t i_v27 = i_g110; // 0xe7a4
    if (i_v27 >= i_v26 != i_v27 != i_v26) {
        // 0xe7ac
        printf("%s: received work_id = %02d nonce. error!!!\t", "check_nonce",
               i_v26);
        unsigned char i_v28 = *(char *)(i_a2 + 1); // 0xe7cc
        unsigned char i_v29 = *(char *)(i_a2 + 2); // 0xe7d4
        unsigned char i_v30 = *(char *)(i_a2 + 3); // 0xe7da
        unsigned char i_v31 = *(char *)(i_a2 + 4); // 0xe7e2
        unsigned char i_v32 = *(char *)(i_a2 + 5); // 0xe7ea
        printf(",received data is : 0x%02x%02x%02x%02x%02x%02x\n", i_v2 % 256,
               (int32_t)i_v28, (int32_t)i_v29, (int32_t)i_v30, (int32_t)i_v31,
               (int32_t)i_v32);
        // 0xe9f8
        return -1;
    }
    int32_t i_v33 =
        *(int32_t *)(4 * i_v13 + (int32_t)&i_g76 + 0x800a0); // 0xe814
    int32_t i_v34 = i_v33 + 204 * (i_v27 * i_v19 + i_v26);   // 0xe836
    int32_t i_v35 = 4 * i_a1 & 1020;
    int32_t *p_v36 = (int32_t *)(i_v35 + (int32_t)&i_g198); // 0xe84a
    *p_v36 = *p_v36 + 1;
    if (i_v6 == *(int32_t *)(i_v34 + 4)) {
        int32_t *p_v37 = (int32_t *)(i_v35 + 188 + i_v34);
        if (*p_v37 == 0) {
            // 0xe8ae
            *p_v37 = 1;
            int32_t *p_v38 = (int32_t *)(i_v35 + (int32_t)&i_g199); // 0xe8d4
            *p_v38 = *p_v38 + 1;
            int32_t *p_v39 =
                (int32_t *)(4 * (512 * (i_v13 + (256 * i_a1 & 0xff00)) +
                                 i_v19) +
                            (int32_t)&i_g202); // 0xe8fc
            *p_v39 = *p_v39 + 1;
        } else {
            int32_t *p_v40 = (int32_t *)(i_v35 + (int32_t)&i_g7); // 0xe87e
            *p_v40 = *p_v40 + 1;
            *p_v37 = *p_v37 + 1;
        }
    lab_0xe9f8:
        // 0xe9f8
        return 0;
    }
    uint32_t i_v41 = i_a1 % 256;
    int32_t *p_v42 = (int32_t *)(24 * i_v41 + (int32_t)&i_g147); // 0xe932
    pthread_mutex_lock(p_v42);
    char *p_v43 = (char *)(i_v41 + (int32_t)&p_g8); // 0xe986
    if (*p_v43 == 0) {
        // 0xe994
        pthread_mutex_unlock(p_v42);
        // 0xe9f8
        return 0;
    }
    int32_t i_v44 = 0;                              // 0xe978
    int32_t i_v45 = (int32_t) * (char *)(i_a2 + 4); // 0xe960
    int32_t i_v46 = check_hw(2040 * i_v41 + (int32_t)&i_g148 + 204 * i_v44,
                             i_v6, i_v45, 0); // 0xe96a
    while (i_v46 != 0) {
        // 0xe97c
        i_v44++;
        if (i_v44 >= (int32_t)*p_v43) {
            // 0xe994
            pthread_mutex_unlock(p_v42);
            if (i_v46 == 1) {
                int32_t *p_v47 =
                    (int32_t *)(i_v35 + (int32_t)&i_g200); // 0xe9c2
                *p_v47 = *p_v47 + 1;
                printf(
                    "%s: Find a HW. Chain%d ASIC%d Core%d : nonce = 0x%08x.\n",
                    "check_nonce", i_v41, i_v13, i_v19, i_v6);
                return 0;
            } else {
                return 0;
            }
        }
        i_v45 = (int32_t) * (char *)(i_a2 + 4);
        i_v46 = check_hw(2040 * i_v41 + (int32_t)&i_g148 + 204 * i_v44, i_v6,
                         i_v45, 0);
    }
    // 0xe994
    __asm_nop(0, i_v6, i_v45, 0);
    pthread_mutex_unlock(p_v42);
    // 0xe9f8
    return 0;
}

// Address range: 0xea04 - 0xeb44
int32_t check_register_value(int32_t i_a1, int32_t i_a2) {
    uint32_t i_v1 = *(int32_t *)(i_g101 + 8); // 0xea4c
    if (i_v1 >= 511 == (i_v1 != 511)) {
        // 0xeb22
        printf("%s: reg_value_buf buffer is full!\n", "check_register_value");
        // 0xeb3a
        return -1;
    }
    int32_t i_v2 = i_g115; // 0xea1c
    int32_t i_v3 = i_v2 == 1722 ? 7 : i_v2 == 1725 ? 8 : 0;
    int32_t i_v4 = *(int32_t *)i_g101; // 0xea6a
    memcpy((int32_t *)(i_g101 + 16 + 10 * i_v4), (int32_t *)i_a2, i_v3);
    int32_t i_v5 = i_g101;
    unsigned char i_v6 = *(char *)(i_a2 - 1 + i_v3); // 0xeaa0
    *(char *)(i_v5 + 24 + 10 * *(int32_t *)i_v5) = i_v6 % 32;
    int32_t i_v7 = i_g101;
    *(char *)(i_v7 + 25 + 10 * *(int32_t *)i_v7) = (char)i_a1;
    int32_t *p_v8 = (int32_t *)i_g101; // 0xeae8
    *p_v8 = *p_v8 + 1;
    int32_t *p_v9 = (int32_t *)(i_g101 + 8); // 0xeaf8
    *p_v9 = *p_v9 + 1;
    int32_t *p_v10 = (int32_t *)i_g101; // 0xeb08
    uint32_t i_v11 = *p_v10;            // 0xeb08
    if (i_v11 != 512 && i_v11 >= 512) {
        // 0xeb10
        *p_v10 = 0;
    }
    // 0xeb3a
    return 0;
}

// Address range: 0xeb44 - 0xeb72
int32_t add_point(int32_t *p_a1, uint32_t i_a2) {
    uint32_t i_v1 = (int32_t)p_a1;
    *p_a1 = i_v1 < i_a2 ? i_v1 + 1 : 0;
    return i_v1;
}

// Address range: 0xeb74 - 0xeb9a
int32_t use_point_sub_1(int32_t i_a1, int32_t i_a2) {
    // 0xeb74
    return (i_a1 == 0 ? i_a2 : i_a1) - 1;
}

// Address range: 0xeb9c - 0xebc4
int32_t use_point_add_1(uint32_t i_a1, int32_t i_a2) {
    uint32_t i_v1 = i_a2 - 1; // 0xeba8
    return i_v1 == i_a1 | i_v1 < i_a1 ? 0 : i_a1 + 1;
}

// Address range: 0xebc4 - 0xef58
int32_t receive_func(int32_t i_a1) {
    unsigned char i_v1 = *(char *)(i_a1 + 1); // 0xebda
    int32_t i_v2 = 0;                         // bp-68, 0xebea
    int32_t i_v3 = 0;                         // bp-72, 0xebee
    int32_t i_v4 = i_g115;                    // 0xec0c
    uint32_t i_v5 = i_v4 == 1722 ? 9 : i_v4 == 1725 ? 10 : 0;
    int32_t *p_v6 = malloc(200 * i_v5); // 0xec3c
    int32_t i_v7 = (int32_t)p_v6;       // 0xec3c
    if (p_v6 == NULL) {
        // 0xec4a
        printf("%s, malloc buffer error!\n", "receive_func");
        // 0xef4e
        return i_v7;
    }
    int32_t i_v8 = 100 * i_v5;     // 0xec64
    int32_t *p_v9 = malloc(i_v8);  // 0xec6a
    int32_t i_v10 = (int32_t)p_v9; // 0xec6a
    if (p_v9 == NULL) {
        // 0xec78
        printf("%s, malloc buffer error!\n", "receive_func");
        free(p_v6);
        // 0xef4e
        return i_v10;
    }
    int32_t *p_v11 = malloc(i_v5);  // 0xec96
    int32_t i_v12 = (int32_t)p_v11; // 0xec96
    if (p_v11 == NULL) {
        // 0xeca4
        printf("%s, malloc buffer error!\n", "receive_func");
        free(p_v9);
        free(p_v6);
        // 0xef4e
        return i_v12;
    }
    // 0xecc6
    int32_t i_v13;                          // 0xebc4
    uint32_t i_v14 = (uint32_t)i_v13 % 256; // 0xecd0
    printf("%s: which_chain = %d, which_i2c = %d\n", "receive_func", i_v14,
           (int32_t)i_v1);
    int32_t i_v15 = uart_flush_rx(i_v14);             // 0xecf2
    char *p_v16 = (char *)(i_v14 + (int32_t)&p_g194); // 0xef22
    char i_v17 = *p_v16;                              // 0xef22
    int32_t i_v18;                                    // 0xebc4
    int32_t i_v19;                                    // 0xebc4
    int32_t i_v20;                                    // 0xebc4
    int32_t i_v21;                                    // 0xebc4
    int32_t i_v22;                                    // 0xebc4
    int32_t i_v23;                                    // 0xebc4
    int32_t i_v24;                                    // 0xebc4
    int32_t i_v25;                                    // 0xebc4
    int32_t i_v26;                                    // 0xebc4
    int32_t i_v27;                                    // 0xebc4
    int32_t i_v28;                                    // 0xebc4
    int32_t i_v29;                                    // 0xebc4
    int32_t i_v30;                                    // 0xebc4
    int32_t i_v31;                                    // 0xebc4
    int32_t i_v32;                                    // 0xebc4
    uint32_t i_v33;                                   // 0xebc4
    int32_t i_v34;                                    // 0xebc4
    int32_t i_v35;                                    // 0xee88
    if (i_v17 != 0) {
        char *p_v36 = (char *)(i_v14 + (int32_t)&p_g193);
        i_v33 = i_v5 - 1;
        i_v34 = i_v12 + 2;
        int32_t i_v37 = i_v15;
        char i_v38 = i_v17;                       // 0xef22
        int32_t i_v39 = (int32_t) "receive_func"; // 0xebc4
        while (true) {
            // 0xed02
            __asm_nop(i_v37, i_v39, i_v14, (int32_t)i_v38);
            if (*p_v36 != 0) {
                usleep(2000);
                while (*p_v36 != 0) {
                    // 0xecf8
                    usleep(2000);
                }
            }
            // 0xed16
            usleep(300);
            uint32_t i_v40 = uart_receive(i_v14, i_v7, i_v5, i_v14); // 0xed28
            int32_t i_v41 = 0;                                       // 0xed5e
            int32_t i_v42 = 0;                                       // 0xed5e
            int32_t i_v43 = i_v7;                                    // 0xed5e
            int32_t i_v44;                                           // 0xed4e
            int32_t i_v45;                                           // 0xed54
            if (i_v40 != 0) {
                *(char *)(i_v2 + i_v10) = *(char *)(i_v41 + i_v7);
                i_v44 = add_point(&i_v2, i_v8);
                i_v45 = i_v41 + 1;
                i_v41 = i_v45;
                i_v42 = i_v44;
                i_v43 = i_v8;
                while (i_v45 < i_v40) {
                    // 0xed36
                    *(char *)(i_v2 + i_v10) = *(char *)(i_v41 + i_v7);
                    i_v44 = add_point(&i_v2, i_v8);
                    i_v45 = i_v41 + 1;
                    i_v41 = i_v45;
                    i_v42 = i_v44;
                    i_v43 = i_v8;
                }
            }
            int32_t i_v46 = i_v43;
            int32_t i_v47 = i_v42; // 0xef14
            uint32_t i_v48 = i_v3; // 0xed60
            uint32_t i_v49 = i_v2; // 0xed62
            while (i_v49 == i_v48) {
                int32_t i_v50 = __asm_nop(i_v47, i_v46, i_v48, i_v48); // 0xef14
                char i_v51 = *p_v16;                                   // 0xef22
                if (i_v51 == 0) {
                    // break (via goto) -> 0xef30
                    goto lab_0xef30;
                }
                __asm_nop(i_v50, i_v46, i_v14, (int32_t)i_v51);
                if (*p_v36 != 0) {
                    usleep(2000);
                    while (*p_v36 != 0) {
                        // 0xecf8
                        usleep(2000);
                    }
                }
                // 0xed16
                usleep(300);
                i_v40 = uart_receive(i_v14, i_v7, i_v5, i_v14);
                i_v41 = 0;
                i_v42 = 0;
                i_v43 = i_v7;
                if (i_v40 != 0) {
                    *(char *)(i_v2 + i_v10) = *(char *)(i_v41 + i_v7);
                    i_v44 = add_point(&i_v2, i_v8);
                    i_v45 = i_v41 + 1;
                    i_v41 = i_v45;
                    i_v42 = i_v44;
                    i_v43 = i_v8;
                    while (i_v45 < i_v40) {
                        // 0xed36
                        *(char *)(i_v2 + i_v10) = *(char *)(i_v41 + i_v7);
                        i_v44 = add_point(&i_v2, i_v8);
                        i_v45 = i_v41 + 1;
                        i_v41 = i_v45;
                        i_v42 = i_v44;
                        i_v43 = i_v8;
                    }
                }
                // 0xed60
                i_v46 = i_v43;
                i_v47 = i_v42;
                i_v48 = i_v3;
                i_v49 = i_v2;
            }
            int32_t i_v52 = (i_v49 < i_v48 ? i_v8 : 0) + i_v49 - i_v48;
            i_v21 = i_v47;
            i_v27 = i_v46;
            i_v31 = i_v52;
            i_v22 = i_v47;
            i_v26 = i_v46;
            if (i_v52 >= i_v5) {
                while (true) {
                lab_0xed8e_2:
                    // 0xed8e
                    i_v18 = i_v21;
                    i_v24 = i_v27;
                    i_v28 = i_v31;
                    while (true) {
                    lab_0xed8e:
                        // 0xed8e
                        i_v29 = i_v28;
                        i_v19 = i_v18;
                        i_v23 = i_v24;
                        if (*(char *)(i_v3 + i_v10) == -86) {
                            int32_t i_v53 =
                                use_point_add_1(i_v3, i_v8); // 0xeda0
                            i_v19 = i_v53;
                            i_v23 = i_v8;
                            if (*(char *)(i_v53 + i_v10) == 85) {
                                int32_t i_v54 = 0; // 0xedde
                                if (i_v5 != 0) {
                                    *(char *)(i_v54 + i_v12) =
                                        *(char *)(i_v3 + i_v10);
                                    add_point(&i_v3, i_v8);
                                    int32_t i_v55 = i_v54 + 1; // 0xedd4
                                    i_v54 = i_v55;
                                    while (i_v55 < i_v5) {
                                        // 0xedb6
                                        *(char *)(i_v54 + i_v12) =
                                            *(char *)(i_v3 + i_v10);
                                        add_point(&i_v3, i_v8);
                                        i_v55 = i_v54 + 1;
                                        i_v54 = i_v55;
                                    }
                                }
                                // 0xee84
                                i_v35 = i_v29 - i_v5;
                                int32_t i_v56 = is_nonce_or_reg_value(
                                    (int32_t) *
                                    (char *)(i_v33 + i_v12)); // 0xee98
                                if (i_v56 == 0) {
                                    // break -> 0xeee8
                                    break;
                                }
                                // 0xeea2
                                i_v20 = i_v56;
                                i_v30 = i_v35;
                                i_v25 = i_v8;
                                if (*(char *)(i_v14 + (int32_t)&p_g191) != 0) {
                                    // 0xeeb4
                                    i_v20 = i_v56;
                                    i_v30 = i_v35;
                                    i_v25 = i_v8;
                                    if (*(char *)(i_v14 + (int32_t)&p_g192) !=
                                        0) {
                                        // 0xeec6
                                        i_v32 = check_nonce(i_v14, i_v34);
                                        goto lab_0xef08_2;
                                    }
                                }
                                goto lab_0xef08;
                            } else {
                                goto lab_0xede2;
                            }
                        } else {
                            goto lab_0xede2;
                        }
                    }
                    // 0xeee8
                    i_v32 = check_register_value(i_v14, i_v34);
                    goto lab_0xef08_2;
                }
            }
        lab_0xef16_2:
            // 0xef16
            i_v37 = i_v22;
            i_v38 = *p_v16;
            i_v39 = i_v26;
            if (i_v38 == 0) {
                // break -> 0xef30
                break;
            }
        }
    }
lab_0xef30:
    // 0xef30
    free(p_v11);
    free(p_v9);
    free(p_v6);
    // 0xef4e
    return i_v7;
lab_0xede2:
    // 0xede2
    if (i_v33 != 0) {
        int32_t i_v57; // 0xebc4
        int32_t i_v58 = i_v57;
        int32_t i_v59 = i_v3;                  // 0xede8
        char i_v60 = *(char *)(i_v59 + i_v10); // 0xedee
        int32_t i_v61;                         // 0xebc4
        int32_t i_v62;                         // 0xedfa
        char i_v63;                            // 0xee04
        if (i_v60 == -86) {
            // 0xedf4
            i_v62 = use_point_add_1(i_v59, i_v8);
            i_v63 = *(char *)(i_v62 + i_v10);
            i_v61 = i_v62;
            if (i_v63 == 85) {
                // break -> 0xee7a
                break;
            }
        }
        // 0xee0a
        add_point(&i_v3, i_v8);
        int32_t i_v64 = i_v3;                           // 0xee16
        int32_t i_v65 = use_point_sub_1(i_v64, i_v8);   // 0xee20
        unsigned char i_v66 = *(char *)(i_v65 + i_v10); // 0xee2a
        int32_t i_v67 = i_v3;
        unsigned char i_v68 = *(char *)(i_v67 + i_v10); // 0xee34
        int32_t i_v69 = use_point_add_1(i_v67, i_v8);   // 0xee3e
        unsigned char i_v70 = *(char *)(i_v69 + i_v10); // 0xee48
        int32_t i_v71 = i_v3;                           // 0xee4c
        int32_t i_v72 = i_v58 + 1;                      // 0xee6c
        i_v57 = i_v72;
        i_v61 = printf("%s: Headers are not corret! Header0 = 0x%02x, Header1 "
                       "= 0x%02x, Header2 = 0x%02x rp = %d\n",
                       "receive_func", (int32_t)i_v66, (int32_t)i_v68,
                       (int32_t)i_v70, i_v71);
        while (i_v33 >= i_v72 == (i_v33 != i_v72)) {
            // 0xede8
            i_v58 = i_v57;
            i_v59 = i_v3;
            i_v60 = *(char *)(i_v59 + i_v10);
            if (i_v60 == -86) {
                // 0xedf4
                i_v62 = use_point_add_1(i_v59, i_v8);
                i_v63 = *(char *)(i_v62 + i_v10);
                i_v61 = i_v62;
                if (i_v63 == 85) {
                    // break -> 0xee7a
                    break;
                }
            }
            // 0xee0a
            add_point(&i_v3, i_v8);
            i_v64 = i_v3;
            i_v65 = use_point_sub_1(i_v64, i_v8);
            i_v66 = *(char *)(i_v65 + i_v10);
            i_v67 = i_v3;
            i_v68 = *(char *)(i_v67 + i_v10);
            i_v69 = use_point_add_1(i_v67, i_v8);
            i_v70 = *(char *)(i_v69 + i_v10);
            i_v71 = i_v3;
            i_v72 = i_v58 + 1;
            i_v57 = i_v72;
            i_v61 = printf("%s: Headers are not corret! Header0 = 0x%02x, "
                           "Header1 = 0x%02x, Header2 = 0x%02x rp = %d\n",
                           "receive_func", (int32_t)i_v66, (int32_t)i_v68,
                           (int32_t)i_v70, i_v71);
        }
    }
    // 0xee7a
    i_v20 = i_v19;
    i_v30 = i_v29;
    i_v25 = i_v23;
    goto lab_0xef08;
lab_0xef08:
    // 0xef08
    i_v18 = i_v20;
    i_v24 = i_v25;
    i_v28 = i_v30;
    i_v22 = i_v20;
    i_v26 = i_v25;
    if (i_v30 < i_v5) {
        // break (via goto) -> 0xef16
        goto lab_0xef16_2;
    }
    goto lab_0xed8e;
lab_0xef08_2:
    // 0xef08
    i_v21 = i_v32;
    i_v27 = i_v34;
    i_v31 = i_v35;
    i_v22 = i_v32;
    i_v26 = i_v34;
    if (i_v35 < i_v5) {
        // break -> 0xef16
        goto lab_0xef16_2;
    }
    goto lab_0xed8e_2;
}

// Address range: 0xef58 - 0xf348
int32_t send_func(int32_t i_a1) {
    // 0xef58
    int32_t i_v1; // 0xef58
    uint32_t i_v2 = i_v1;
    int32_t i_v3; // bp-244, 0xef58
    memset(&i_v3, 0, 184);
    int32_t *p_v4; // 0xef58
    int32_t i_v5;  // 0xef58
    int32_t i_v6;  // 0xef58
    int32_t i_v7;  // 0xef58
    if (i_g113 == 0) {
        int32_t i_v8 = i_v2 % 256; // 0xf250
        p_v4 = (int32_t *)(4 * i_v8 + (int32_t)&i_g201);
        i_v5 = i_v8;
        i_v6 = 0;
        i_v7 = i_g114;
    } else {
        int32_t i_v9 = i_v2 % 256;
        char *p_v10 = (char *)(i_v9 + (int32_t)&p_g8);
        int32_t *p_v11 = (int32_t *)(24 * i_v9 + (int32_t)&i_g147);
        int32_t i_v12 = 2040 * i_v9;
        int32_t *p_v13 = (int32_t *)(4 * i_v9 + (int32_t)&i_g201);
        int32_t i_v14 = 0; // 0xf236
        int32_t i_v15 =
            *(int32_t *)(4 * i_v14 + (int32_t)&i_g76 + 0x800a0); // 0xefbc
        int32_t i_v16 = i_g114;                                  // 0xf22e
        int32_t i_v17 = 0;                                       // 0xf22e
        int32_t i_v18;                                           // 0xef58
        int32_t i_v19;                                           // 0xef58
        int32_t i_v20;                                           // 0xef58
        int32_t i_v21;                                           // 0xf226
        int32_t i_v22;                                           // 0xef58
        int32_t i_v23;       // bp-16, 0xef58
        int32_t i_v24;       // 0xef58
        uint32_t i_v25;      // 0xef58
        int32_t i_v26;       // 0xef58
        int32_t i_v27;       // 0xef58
        int32_t i_v28;       // 0xf218
        int32_t i_v29;       // 0xeff6
        char i_v30;          // 0xf056
        int32_t i_v31;       // 0xf0f8
        unsigned char i_v32; // 0xef58
        int32_t i_v33;       // 0xf1fa
        int32_t i_v34;       // 0xf208
        if (i_g114 != 0) {
            // 0xf200
            i_v24 = 0;
            i_v20 = 0;
            if (i_g110 != 0) {
                i_v25 = 0;
                i_v3 = 48;
                if (i_g115 == 1725) {
                    // 0xf02e
                    __asm_orn(i_v25 % 256, 127);
                }
                // 0xf03c
                i_v29 = 204 * (i_g110 * i_v24 + i_v25) + i_v15;
                for (int32_t i_v35 = 0; i_v35 < 180; i_v35++) {
                    // 0xf044
                    i_v30 = *(char *)(i_v29 + 8 + i_v35);
                    *(char *)((int32_t)&i_v23 - 226 + i_v35) = i_v30;
                }
                // 0xf074
                CRC16(&i_v3, 182);
                dcr_uart_send(i_v9, (char *)&i_v3, 184);
                pthread_mutex_lock(p_v11);
                i_v27 = 8;
                i_v31 = 204 * i_v27 + i_v12;
                memcpy((int32_t *)(i_v31 + (int32_t)&i_g148 + 204),
                       (int32_t *)(i_v31 + (int32_t)&i_g148), 204);
                i_v26 = i_v27 - 1;
                while (i_v27 != 0) {
                    // 0xf0e0
                    i_v27 = i_v26;
                    i_v31 = 204 * i_v27 + i_v12;
                    memcpy((int32_t *)(i_v31 + (int32_t)&i_g148 + 204),
                           (int32_t *)(i_v31 + (int32_t)&i_g148), 204);
                    i_v26 = i_v27 - 1;
                }
                // 0xf148
                i_v32 = *p_v10 + 1;
                *p_v10 = i_v32 == 8 | i_v32 < 8 ? i_v32 : 9;
                memcpy((int32_t *)(i_v12 + (int32_t)&i_g148), (int32_t *)i_v29,
                       204);
                pthread_mutex_unlock(p_v11);
                *p_v13 = *p_v13 + 1;
                usleep(i_g127);
                i_v33 = i_v25 + 1;
                i_v34 = i_g110;
                i_v18 = i_v34;
                while (i_v34 >= i_v33 == (i_v34 != i_v33)) {
                    // 0xefd4
                    i_v25 = i_v33;
                    i_v3 = 48;
                    if (i_g115 == 1725) {
                        // 0xf02e
                        __asm_orn(i_v25 % 256, 127);
                    }
                    // 0xf03c
                    i_v29 = 204 * (i_v18 * i_v24 + i_v25) + i_v15;
                    for (int32_t i_v35 = 0; i_v35 < 180; i_v35++) {
                        // 0xf044
                        i_v30 = *(char *)(i_v29 + 8 + i_v35);
                        *(char *)((int32_t)&i_v23 - 226 + i_v35) = i_v30;
                    }
                    // 0xf074
                    CRC16(&i_v3, 182);
                    dcr_uart_send(i_v9, (char *)&i_v3, 184);
                    pthread_mutex_lock(p_v11);
                    i_v27 = 8;
                    i_v31 = 204 * i_v27 + i_v12;
                    memcpy((int32_t *)(i_v31 + (int32_t)&i_g148 + 204),
                           (int32_t *)(i_v31 + (int32_t)&i_g148), 204);
                    i_v26 = i_v27 - 1;
                    while (i_v27 != 0) {
                        // 0xf0e0
                        i_v27 = i_v26;
                        i_v31 = 204 * i_v27 + i_v12;
                        memcpy((int32_t *)(i_v31 + (int32_t)&i_g148 + 204),
                               (int32_t *)(i_v31 + (int32_t)&i_g148), 204);
                        i_v26 = i_v27 - 1;
                    }
                    // 0xf148
                    i_v32 = *p_v10 + 1;
                    *p_v10 = i_v32 == 8 | i_v32 < 8 ? i_v32 : 9;
                    memcpy((int32_t *)(i_v12 + (int32_t)&i_g148),
                           (int32_t *)i_v29, 204);
                    pthread_mutex_unlock(p_v11);
                    *p_v13 = *p_v13 + 1;
                    usleep(i_g127);
                    i_v33 = i_v25 + 1;
                    i_v34 = i_g110;
                    i_v18 = i_v34;
                }
                // 0xf200
                i_v20 = i_v34;
            }
            // 0xf214
            i_v22 = i_v20;
            i_v21 = i_g114;
            i_v28 = i_v24 + 1;
            while (i_v21 >= i_v28 == (i_v21 != i_v28)) {
                // 0xf200
                i_v24 = i_v28;
                i_v18 = i_v22;
                i_v19 = i_v21;
                i_v20 = 0;
                if (i_v22 != 0) {
                    i_v25 = 0;
                    i_v3 = 48;
                    if (i_g115 == 1725) {
                        // 0xf02e
                        __asm_orn(i_v25 % 256, 127);
                    }
                    // 0xf03c
                    i_v29 = 204 * (i_v18 * i_v24 + i_v25) + i_v15;
                    for (int32_t i_v35 = 0; i_v35 < 180; i_v35++) {
                        // 0xf044
                        i_v30 = *(char *)(i_v29 + 8 + i_v35);
                        *(char *)((int32_t)&i_v23 - 226 + i_v35) = i_v30;
                    }
                    // 0xf074
                    CRC16(&i_v3, 182);
                    dcr_uart_send(i_v9, (char *)&i_v3, 184);
                    pthread_mutex_lock(p_v11);
                    i_v27 = 8;
                    i_v31 = 204 * i_v27 + i_v12;
                    memcpy((int32_t *)(i_v31 + (int32_t)&i_g148 + 204),
                           (int32_t *)(i_v31 + (int32_t)&i_g148), 204);
                    i_v26 = i_v27 - 1;
                    while (i_v27 != 0) {
                        // 0xf0e0
                        i_v27 = i_v26;
                        i_v31 = 204 * i_v27 + i_v12;
                        memcpy((int32_t *)(i_v31 + (int32_t)&i_g148 + 204),
                               (int32_t *)(i_v31 + (int32_t)&i_g148), 204);
                        i_v26 = i_v27 - 1;
                    }
                    // 0xf148
                    i_v32 = *p_v10 + 1;
                    *p_v10 = i_v32 == 8 | i_v32 < 8 ? i_v32 : 9;
                    memcpy((int32_t *)(i_v12 + (int32_t)&i_g148),
                           (int32_t *)i_v29, 204);
                    pthread_mutex_unlock(p_v11);
                    *p_v13 = *p_v13 + 1;
                    usleep(i_g127);
                    i_v33 = i_v25 + 1;
                    i_v34 = i_g110;
                    i_v18 = i_v34;
                    while (i_v34 >= i_v33 == (i_v34 != i_v33)) {
                        // 0xefd4
                        i_v25 = i_v33;
                        i_v3 = 48;
                        if (i_g115 == 1725) {
                            // 0xf02e
                            __asm_orn(i_v25 % 256, 127);
                        }
                        // 0xf03c
                        i_v29 = 204 * (i_v18 * i_v24 + i_v25) + i_v15;
                        for (int32_t i_v35 = 0; i_v35 < 180; i_v35++) {
                            // 0xf044
                            i_v30 = *(char *)(i_v29 + 8 + i_v35);
                            *(char *)((int32_t)&i_v23 - 226 + i_v35) = i_v30;
                        }
                        // 0xf074
                        CRC16(&i_v3, 182);
                        dcr_uart_send(i_v9, (char *)&i_v3, 184);
                        pthread_mutex_lock(p_v11);
                        i_v27 = 8;
                        i_v31 = 204 * i_v27 + i_v12;
                        memcpy((int32_t *)(i_v31 + (int32_t)&i_g148 + 204),
                               (int32_t *)(i_v31 + (int32_t)&i_g148), 204);
                        i_v26 = i_v27 - 1;
                        while (i_v27 != 0) {
                            // 0xf0e0
                            i_v27 = i_v26;
                            i_v31 = 204 * i_v27 + i_v12;
                            memcpy((int32_t *)(i_v31 + (int32_t)&i_g148 + 204),
                                   (int32_t *)(i_v31 + (int32_t)&i_g148), 204);
                            i_v26 = i_v27 - 1;
                        }
                        // 0xf148
                        i_v32 = *p_v10 + 1;
                        *p_v10 = i_v32 == 8 | i_v32 < 8 ? i_v32 : 9;
                        memcpy((int32_t *)(i_v12 + (int32_t)&i_g148),
                               (int32_t *)i_v29, 204);
                        pthread_mutex_unlock(p_v11);
                        *p_v13 = *p_v13 + 1;
                        usleep(i_g127);
                        i_v33 = i_v25 + 1;
                        i_v34 = i_g110;
                        i_v18 = i_v34;
                    }
                    // 0xf200
                    i_v19 = i_g114;
                    i_v20 = i_v34;
                }
                // 0xf214
                i_v22 = i_v20;
                i_v21 = i_v19;
                i_v28 = i_v24 + 1;
            }
            // 0xf21e
            i_v16 = i_v21;
            i_v17 = i_v21;
        }
        int32_t i_v36 = i_v17;
        int32_t i_v37 = i_v16;
        int32_t i_v38 = i_g113; // 0xf244
        i_v14++;
        p_v4 = p_v13;
        i_v5 = i_v9;
        i_v6 = i_v38;
        i_v7 = i_v37;
        while (i_v38 >= i_v14 == (i_v38 != i_v14)) {
            int32_t i_v39 = i_v37;
            i_v15 = *(int32_t *)(4 * i_v14 + (int32_t)&i_g76 + 0x800a0);
            int32_t i_v40 = i_v38; // 0xf22e
            i_v16 = i_v39;
            i_v17 = 0;
            if (i_v36 != 0) {
                // 0xf200
                i_v24 = 0;
                i_v19 = i_v39;
                i_v20 = 0;
                if (i_g110 != 0) {
                    i_v25 = 0;
                    i_v3 = 48;
                    if (i_g115 == 1725) {
                        // 0xf02e
                        __asm_orn(i_v25 % 256, 127);
                    }
                    // 0xf03c
                    i_v29 = 204 * (i_g110 * i_v24 + i_v25) + i_v15;
                    for (int32_t i_v35 = 0; i_v35 < 180; i_v35++) {
                        // 0xf044
                        i_v30 = *(char *)(i_v29 + 8 + i_v35);
                        *(char *)((int32_t)&i_v23 - 226 + i_v35) = i_v30;
                    }
                    // 0xf074
                    CRC16(&i_v3, 182);
                    dcr_uart_send(i_v9, (char *)&i_v3, 184);
                    pthread_mutex_lock(p_v11);
                    i_v27 = 8;
                    i_v31 = 204 * i_v27 + i_v12;
                    memcpy((int32_t *)(i_v31 + (int32_t)&i_g148 + 204),
                           (int32_t *)(i_v31 + (int32_t)&i_g148), 204);
                    i_v26 = i_v27 - 1;
                    while (i_v27 != 0) {
                        // 0xf0e0
                        i_v27 = i_v26;
                        i_v31 = 204 * i_v27 + i_v12;
                        memcpy((int32_t *)(i_v31 + (int32_t)&i_g148 + 204),
                               (int32_t *)(i_v31 + (int32_t)&i_g148), 204);
                        i_v26 = i_v27 - 1;
                    }
                    // 0xf148
                    i_v32 = *p_v10 + 1;
                    *p_v10 = i_v32 == 8 | i_v32 < 8 ? i_v32 : 9;
                    memcpy((int32_t *)(i_v12 + (int32_t)&i_g148),
                           (int32_t *)i_v29, 204);
                    pthread_mutex_unlock(p_v11);
                    *p_v13 = *p_v13 + 1;
                    usleep(i_g127);
                    i_v33 = i_v25 + 1;
                    i_v34 = i_g110;
                    i_v18 = i_v34;
                    while (i_v34 >= i_v33 == (i_v34 != i_v33)) {
                        // 0xefd4
                        i_v25 = i_v33;
                        i_v3 = 48;
                        if (i_g115 == 1725) {
                            // 0xf02e
                            __asm_orn(i_v25 % 256, 127);
                        }
                        // 0xf03c
                        i_v29 = 204 * (i_v18 * i_v24 + i_v25) + i_v15;
                        for (int32_t i_v35 = 0; i_v35 < 180; i_v35++) {
                            // 0xf044
                            i_v30 = *(char *)(i_v29 + 8 + i_v35);
                            *(char *)((int32_t)&i_v23 - 226 + i_v35) = i_v30;
                        }
                        // 0xf074
                        CRC16(&i_v3, 182);
                        dcr_uart_send(i_v9, (char *)&i_v3, 184);
                        pthread_mutex_lock(p_v11);
                        i_v27 = 8;
                        i_v31 = 204 * i_v27 + i_v12;
                        memcpy((int32_t *)(i_v31 + (int32_t)&i_g148 + 204),
                               (int32_t *)(i_v31 + (int32_t)&i_g148), 204);
                        i_v26 = i_v27 - 1;
                        while (i_v27 != 0) {
                            // 0xf0e0
                            i_v27 = i_v26;
                            i_v31 = 204 * i_v27 + i_v12;
                            memcpy((int32_t *)(i_v31 + (int32_t)&i_g148 + 204),
                                   (int32_t *)(i_v31 + (int32_t)&i_g148), 204);
                            i_v26 = i_v27 - 1;
                        }
                        // 0xf148
                        i_v32 = *p_v10 + 1;
                        *p_v10 = i_v32 == 8 | i_v32 < 8 ? i_v32 : 9;
                        memcpy((int32_t *)(i_v12 + (int32_t)&i_g148),
                               (int32_t *)i_v29, 204);
                        pthread_mutex_unlock(p_v11);
                        *p_v13 = *p_v13 + 1;
                        usleep(i_g127);
                        i_v33 = i_v25 + 1;
                        i_v34 = i_g110;
                        i_v18 = i_v34;
                    }
                    // 0xf200
                    i_v19 = i_g114;
                    i_v20 = i_v34;
                }
                // 0xf214
                i_v22 = i_v20;
                i_v21 = i_v19;
                i_v28 = i_v24 + 1;
                while (i_v21 >= i_v28 == (i_v21 != i_v28)) {
                    // 0xf200
                    i_v24 = i_v28;
                    i_v18 = i_v22;
                    i_v19 = i_v21;
                    i_v20 = 0;
                    if (i_v22 != 0) {
                        i_v25 = 0;
                        i_v3 = 48;
                        if (i_g115 == 1725) {
                            // 0xf02e
                            __asm_orn(i_v25 % 256, 127);
                        }
                        // 0xf03c
                        i_v29 = 204 * (i_v18 * i_v24 + i_v25) + i_v15;
                        for (int32_t i_v35 = 0; i_v35 < 180; i_v35++) {
                            // 0xf044
                            i_v30 = *(char *)(i_v29 + 8 + i_v35);
                            *(char *)((int32_t)&i_v23 - 226 + i_v35) = i_v30;
                        }
                        // 0xf074
                        CRC16(&i_v3, 182);
                        dcr_uart_send(i_v9, (char *)&i_v3, 184);
                        pthread_mutex_lock(p_v11);
                        i_v27 = 8;
                        i_v31 = 204 * i_v27 + i_v12;
                        memcpy((int32_t *)(i_v31 + (int32_t)&i_g148 + 204),
                               (int32_t *)(i_v31 + (int32_t)&i_g148), 204);
                        i_v26 = i_v27 - 1;
                        while (i_v27 != 0) {
                            // 0xf0e0
                            i_v27 = i_v26;
                            i_v31 = 204 * i_v27 + i_v12;
                            memcpy((int32_t *)(i_v31 + (int32_t)&i_g148 + 204),
                                   (int32_t *)(i_v31 + (int32_t)&i_g148), 204);
                            i_v26 = i_v27 - 1;
                        }
                        // 0xf148
                        i_v32 = *p_v10 + 1;
                        *p_v10 = i_v32 == 8 | i_v32 < 8 ? i_v32 : 9;
                        memcpy((int32_t *)(i_v12 + (int32_t)&i_g148),
                               (int32_t *)i_v29, 204);
                        pthread_mutex_unlock(p_v11);
                        *p_v13 = *p_v13 + 1;
                        usleep(i_g127);
                        i_v33 = i_v25 + 1;
                        i_v34 = i_g110;
                        i_v18 = i_v34;
                        while (i_v34 >= i_v33 == (i_v34 != i_v33)) {
                            // 0xefd4
                            i_v25 = i_v33;
                            i_v3 = 48;
                            if (i_g115 == 1725) {
                                // 0xf02e
                                __asm_orn(i_v25 % 256, 127);
                            }
                            // 0xf03c
                            i_v29 = 204 * (i_v18 * i_v24 + i_v25) + i_v15;
                            for (int32_t i_v35 = 0; i_v35 < 180; i_v35++) {
                                // 0xf044
                                i_v30 = *(char *)(i_v29 + 8 + i_v35);
                                *(char *)((int32_t)&i_v23 - 226 + i_v35) =
                                    i_v30;
                            }
                            // 0xf074
                            CRC16(&i_v3, 182);
                            dcr_uart_send(i_v9, (char *)&i_v3, 184);
                            pthread_mutex_lock(p_v11);
                            i_v27 = 8;
                            i_v31 = 204 * i_v27 + i_v12;
                            memcpy((int32_t *)(i_v31 + (int32_t)&i_g148 + 204),
                                   (int32_t *)(i_v31 + (int32_t)&i_g148), 204);
                            i_v26 = i_v27 - 1;
                            while (i_v27 != 0) {
                                // 0xf0e0
                                i_v27 = i_v26;
                                i_v31 = 204 * i_v27 + i_v12;
                                memcpy(
                                    (int32_t *)(i_v31 + (int32_t)&i_g148 + 204),
                                    (int32_t *)(i_v31 + (int32_t)&i_g148), 204);
                                i_v26 = i_v27 - 1;
                            }
                            // 0xf148
                            i_v32 = *p_v10 + 1;
                            *p_v10 = i_v32 == 8 | i_v32 < 8 ? i_v32 : 9;
                            memcpy((int32_t *)(i_v12 + (int32_t)&i_g148),
                                   (int32_t *)i_v29, 204);
                            pthread_mutex_unlock(p_v11);
                            *p_v13 = *p_v13 + 1;
                            usleep(i_g127);
                            i_v33 = i_v25 + 1;
                            i_v34 = i_g110;
                            i_v18 = i_v34;
                        }
                        // 0xf200
                        i_v19 = i_g114;
                        i_v20 = i_v34;
                    }
                    // 0xf214
                    i_v22 = i_v20;
                    i_v21 = i_v19;
                    i_v28 = i_v24 + 1;
                }
                // 0xf21e
                i_v40 = i_g113;
                i_v16 = i_v21;
                i_v17 = i_v21;
            }
            // 0xf232
            i_v36 = i_v17;
            i_v37 = i_v16;
            i_v38 = i_v40;
            i_v14++;
            p_v4 = p_v13;
            i_v5 = i_v9;
            i_v6 = i_v38;
            i_v7 = i_v37;
        }
    }
    int32_t i_v41 = i_v5;
    int32_t i_v42 = *p_v4; // 0xf25c
    int32_t i_v43 = i_v42; // 0xf288
    if (i_v42 < i_v7 * i_v6 * i_g110) {
        printf("\n\n---%s: Chain%d send work num : %d, less than %d\n",
               "send_func", i_v41, i_v42, 276 * i_v6 * i_g110);
        int32_t i_v44 = *p_v4;  // 0xf25c
        int32_t i_v45 = i_g110; // 0xf268
        int32_t i_v46 = i_g113; // 0xf280
        i_v43 = i_v44;
        while (i_v44 < i_g114 * i_v45 * i_v46) {
            // 0xf2f0
            printf("\n\n---%s: Chain%d send work num : %d, less than %d\n",
                   "send_func", i_v41, i_v44, 276 * i_v46 * i_v45);
            i_v44 = *p_v4;
            i_v45 = i_g110;
            i_v46 = i_g113;
            i_v43 = i_v44;
        }
    }
    int32_t i_v47 = i_v43;
    __asm_nop(printf("\n\n---%s: Chain%d send work num : %d\n", "send_func",
                     i_v41, i_v47),
              (int32_t) "send_func", i_v41, i_v47);
    puts((char *)((int32_t) "{r" | 0x20000));
    system("date");
    putchar(10);
    *(char *)(i_v41 + (int32_t)&p_g194) = 0;
    puts("to stop receive");
    return (int32_t)&p_g194;
}

// Address range: 0xf348 - 0xf408
int32_t read_temp_func(int32_t i_a1) {
    // 0xf348
    int32_t i_v1;                         // 0xf348
    uint32_t i_v2 = (uint32_t)i_v1 % 256; // 0xf35a
    char *p_v3 = (char *)(i_v2 + (int32_t)&p_g27);
    while (true) {
        // 0xf35a
        if (*(char *)(i_v2 + (int32_t)&p_g26) != 0) {
            // 0xf36a
            if (*(char *)(i_v2 + (int32_t)&p_g192) != 0) {
                // 0xf37a
                *p_v3 = 1;
                usleep(15 * i_g127);
                if (i_g144 == 1) {
                    // 0xf3b0
                    read_asic_temperature(i_v2);
                } else {
                    // 0xf3ba
                    printf("\n%s: please config sensor_model in Config.ini\n",
                           "read_temp_func");
                }
                // 0xf3ce
                if (*(char *)(i_v2 + (int32_t)&p_g9) != 1) {
                    // 0xf3e4
                    set_PWM_according_to_temperature();
                }
                // 0xf3ec
                *p_v3 = 0;
            }
        }
        // 0xf3fa
        usleep((int32_t)&i_g307);
    }
}

// Address range: 0xf408 - 0xf49e
int32_t single_asic_print_lcd(int32_t i_a1, uint32_t i_a2) {
    char *p_v1 = (char *)0x20202020; // bp-32, 0xf428
    display_level_result_on_lcd();
    if (i_a2 % 2 == 0) {
        // 0xf44a
        write_lcd_no_memset(2, (int32_t *)"   Pattern NG   ", 16);
    } else {
        // 0xf438
        write_lcd_no_memset(2, (int32_t *)"   Pattern OK   ", 16);
    }
    unsigned char i_v2 = *(char *)&p_g155;                             // 0xf462
    int32_t i_v3 = *(int32_t *)(4 * (int32_t)i_v2 + (int32_t)&i_g200); // 0xf46e
    int32_t i_v4; // bp-22, 0xf408
    sprintf((char *)&i_v4, "%d", i_v3);
    return write_lcd_no_memset(1, (int32_t *)&p_v1, 16);
}

// Address range: 0xf4a0 - 0xf578
int32_t single_board_print_lcd(uint32_t i_a1) {
    // 0xf4a0
    display_level_result_on_lcd();
    char i_v1; // 0xf4a0
    if (i_a1 % 2 == 0) {
        // 0xf4d4
        write_lcd_no_memset(1, (int32_t *)"   Pattern NG   ", 16);
        i_v1 = (int32_t)&i_g189 & 255;
    } else {
        // 0xf4b6
        write_lcd_no_memset(1, (int32_t *)"   Pattern OK   ", 16);
        i_v1 = 0;
    }
    // 0xf4fc
    *(char *)&p_g188 = i_v1;
    if (*(char *)&p_g34 == 0) {
        // 0xf528
        puts("eeprom NG");
        write_lcd_no_memset(2, (int32_t *)"   epprom NG\t", 16);
    } else {
        // 0xf50a
        puts("eeprom OK");
        write_lcd_no_memset(2, (int32_t *)"   epprom OK\t", 16);
    }
    int32_t i_v2; // 0xf4a0
    if ((i_a1 & 4) == 0) {
        // 0xf560
        i_v2 = write_lcd_no_memset(3, (int32_t *)" Temperature NG ", 16);
    } else {
        // 0xf54e
        i_v2 = write_lcd_no_memset(3, (int32_t *)" Temperature OK ", 16);
    }
    // 0xf570
    return i_v2;
}

// Address range: 0xf578 - 0xf94e
int32_t single_asic_get_result(uint32_t i_a1) {
    // 0xf578
    puts("\n\n-----------------------------------------------------------------"
         "-------------------------------------\n");
    printf("every CORE require nonce number: %lu\n\n", i_g110);
    puts((char *)((int32_t)&p_g296 | 0x20000));
    if (i_g114 != 0) {
        int32_t i_v1 = 0x20000 * i_a1 & 0x1fe0000;
        int32_t i_v2 = 0;  // 0xf62a
        uint64_t i_v3 = 0; // 0xf5e4
        if (2 * (4 * (int32_t)i_v3 + (int32_t)i_v3) == i_v2) {
            // 0xf5f8
            putchar(10);
        }
        int32_t i_v4 =
            *(int32_t *)(4 * (i_v2 + i_v1) + (int32_t)&i_g202); // 0xf614
        printf("core[%02d]=%02d\t", i_v2, i_v4);
        i_v2++;
        uint32_t i_v5 = i_g114; // 0xf636
        while (i_v5 >= i_v2 == (i_v5 != i_v2)) {
            // 0xf5da
            i_v3 = 0xcccccccd * ((int64_t)i_v2 & 0xffffffff) / 0x800000000;
            if (2 * (4 * (int32_t)i_v3 + (int32_t)i_v3) == i_v2) {
                // 0xf5f8
                putchar(10);
            }
            // 0xf5fe
            i_v4 = *(int32_t *)(4 * (i_v2 + i_v1) + (int32_t)&i_g202);
            printf("core[%02d]=%02d\t", i_v2, i_v4);
            i_v2++;
            i_v5 = i_g114;
        }
    }
    // 0xf63e
    puts("\n\n");
    int32_t i_v6 = 1; // 0xf71e
    if (i_g114 != 0) {
        int32_t i_v7 = 0x20000 * i_a1 & 0x1fe0000;
        int32_t i_v8 = i_g87 + 188 + (4 * i_a1 & 1020);
        int32_t i_v9 = 1;
        int32_t i_v10 = 0;
        uint32_t i_v11 =
            *(int32_t *)(4 * (i_v10 + i_v7) + (int32_t)&i_g202); // 0xf666
        int32_t i_v12 = i_v9;                                    // 0xf676
        int32_t i_v13;                                           // 0xf578
        int32_t i_v14;                                           // 0xf578
        int32_t i_v15;                                           // 0xf6fc
        int32_t i_v16;                                           // 0xf578
        int32_t i_v17;                                           // 0xf6f0
        if (i_v11 < i_g110) {
            // 0xf678
            printf("core[%02d] = %d,      lost these pattern's nonce : ", i_v10,
                   i_v11);
            if (i_g110 != 0) {
                i_v16 = 0;
                if (*(int32_t *)(i_v8 + 204 * (i_g110 * i_v10 + i_v16)) == 0) {
                    // 0xf6e0
                    printf("%d  ", i_v16);
                }
                // 0xf6ee
                i_v15 = i_g110;
                i_v17 = i_v16 + 1;
                i_v13 = i_v15;
                while (i_v15 >= i_v17 == (i_v15 != i_v17)) {
                    // 0xf6b0
                    i_v16 = i_v17;
                    i_v14 = i_v13;
                    if (*(int32_t *)(i_v8 + 204 * (i_v13 * i_v10 + i_v16)) ==
                        0) {
                        // 0xf6e0
                        printf("%d  ", i_v16);
                        i_v14 = i_g110;
                    }
                    // 0xf6ee
                    i_v15 = i_v14;
                    i_v17 = i_v16 + 1;
                    i_v13 = i_v15;
                }
            }
            // 0xf704
            putchar(10);
            i_v12 = i_v9 & -2;
        }
        int32_t i_v18 = i_v12;
        int32_t i_v19 = i_g114;    // 0xf718
        int32_t i_v20 = i_v10 + 1; // 0xf70c
        i_v6 = i_v18;
        while (i_v19 >= i_v20 == (i_v19 != i_v20)) {
            // 0xf650
            i_v9 = i_v18;
            i_v10 = i_v20;
            i_v11 = *(int32_t *)(4 * (i_v10 + i_v7) + (int32_t)&i_g202);
            int32_t i_v21 = i_v19; // 0xf676
            i_v12 = i_v9;
            if (i_v11 < i_g110) {
                // 0xf678
                printf("core[%02d] = %d,      lost these pattern's nonce : ",
                       i_v10, i_v11);
                if (i_g110 != 0) {
                    i_v16 = 0;
                    if (*(int32_t *)(i_v8 + 204 * (i_g110 * i_v10 + i_v16)) ==
                        0) {
                        // 0xf6e0
                        printf("%d  ", i_v16);
                    }
                    // 0xf6ee
                    i_v15 = i_g110;
                    i_v17 = i_v16 + 1;
                    i_v13 = i_v15;
                    while (i_v15 >= i_v17 == (i_v15 != i_v17)) {
                        // 0xf6b0
                        i_v16 = i_v17;
                        i_v14 = i_v13;
                        if (*(int32_t *)(i_v8 +
                                         204 * (i_v13 * i_v10 + i_v16)) == 0) {
                            // 0xf6e0
                            printf("%d  ", i_v16);
                            i_v14 = i_g110;
                        }
                        // 0xf6ee
                        i_v15 = i_v14;
                        i_v17 = i_v16 + 1;
                        i_v13 = i_v15;
                    }
                }
                // 0xf704
                putchar(10);
                i_v21 = i_g114;
                i_v12 = i_v9 & -2;
            }
            // 0xf70a
            i_v18 = i_v12;
            i_v19 = i_v21;
            i_v20 = i_v10 + 1;
            i_v6 = i_v18;
        }
    }
    // 0xf720
    puts("\n\nevery core returned all nonce count:");
    int32_t i_v22 = 4 * i_a1 & 1020;
    if (i_g114 != 0) {
        int32_t i_v23 = 0;
        uint64_t i_v24 = 0; // 0xf740
        if (2 * (4 * (int32_t)i_v24 + (int32_t)i_v24) == i_v23) {
            // 0xf754
            putchar(10);
        }
        uint32_t i_v25 = i_g110; // 0xf7a0
        int32_t i_v26 = 0;       // 0xf7a6
        int32_t i_v27;           // 0xf78e
        int32_t i_v28;           // 0xf794
        if (i_v25 != 0) {
            // 0xf760
            i_v28 = 0;
            i_v27 = 0;
            i_v27 += *(int32_t *)(i_g87 + 188 + i_v22 +
                                  204 * (i_v28 + i_v25 * i_v23));
            i_v28++;
            i_v26 = i_v27;
            while (i_v25 >= i_v28 == (i_v25 != i_v28)) {
                // 0xf760
                i_v27 += *(int32_t *)(i_g87 + 188 + i_v22 +
                                      204 * (i_v28 + i_v25 * i_v23));
                i_v28++;
                i_v26 = i_v27;
            }
        }
        // 0xf7a8
        printf("core[%02d]=%02d\t", i_v23, i_v26);
        int32_t i_v29 = i_v23 + 1; // 0xf7ba
        uint32_t i_v30 = i_g114;   // 0xf7c6
        while (i_v30 >= i_v29 == (i_v30 != i_v29)) {
            // 0xf732
            i_v23 = i_v29;
            i_v24 = 0xcccccccd * ((int64_t)i_v29 & 0xffffffff) / 0x800000000;
            if (2 * (4 * (int32_t)i_v24 + (int32_t)i_v24) == i_v23) {
                // 0xf754
                putchar(10);
            }
            // 0xf75a
            i_v25 = i_g110;
            i_v26 = 0;
            if (i_v25 != 0) {
                // 0xf760
                i_v28 = 0;
                i_v27 = 0;
                i_v27 += *(int32_t *)(i_g87 + 188 + i_v22 +
                                      204 * (i_v28 + i_v25 * i_v23));
                i_v28++;
                i_v26 = i_v27;
                while (i_v25 >= i_v28 == (i_v25 != i_v28)) {
                    // 0xf760
                    i_v27 += *(int32_t *)(i_g87 + 188 + i_v22 +
                                          204 * (i_v28 + i_v25 * i_v23));
                    i_v28++;
                    i_v26 = i_v27;
                }
            }
            // 0xf7a8
            printf("core[%02d]=%02d\t", i_v23, i_v26);
            i_v29 = i_v23 + 1;
            i_v30 = i_g114;
        }
    }
    // 0xf7ce
    puts("\n\nevery core returned repeated nonce count:");
    if (i_g114 != 0) {
        int32_t i_v31 = 0;
        uint64_t i_v32 = 0; // 0xf7ee
        if (2 * (4 * (int32_t)i_v32 + (int32_t)i_v32) == i_v31) {
            // 0xf802
            putchar(10);
        }
        uint32_t i_v33 = i_g110; // 0xf864
        int32_t i_v34 = 0;       // 0xf86a
        int32_t i_v35;           // 0xf838
        int32_t i_v36;           // 0xf852
        int32_t i_v37;           // 0xf858
        if (i_v33 != 0) {
            // 0xf80e
            i_v37 = 0;
            i_v36 = 0;
            i_v35 = *(int32_t *)(i_g87 + 188 + i_v22 +
                                 204 * (i_v37 + i_v33 * i_v31));
            i_v36 += (i_v35 == 0 ? 0 : i_v35 - 1);
            i_v37++;
            i_v34 = i_v36;
            while (i_v33 >= i_v37 == (i_v33 != i_v37)) {
                // 0xf80e
                i_v35 = *(int32_t *)(i_g87 + 188 + i_v22 +
                                     204 * (i_v37 + i_v33 * i_v31));
                i_v36 += (i_v35 == 0 ? 0 : i_v35 - 1);
                i_v37++;
                i_v34 = i_v36;
            }
        }
        // 0xf86c
        printf("core[%02d]=%02d\t", i_v31, i_v34);
        int32_t i_v38 = i_v31 + 1; // 0xf87e
        uint32_t i_v39 = i_g114;   // 0xf88a
        while (i_v39 >= i_v38 == (i_v39 != i_v38)) {
            // 0xf7e0
            i_v31 = i_v38;
            i_v32 = 0xcccccccd * ((int64_t)i_v38 & 0xffffffff) / 0x800000000;
            if (2 * (4 * (int32_t)i_v32 + (int32_t)i_v32) == i_v31) {
                // 0xf802
                putchar(10);
            }
            // 0xf808
            i_v33 = i_g110;
            i_v34 = 0;
            if (i_v33 != 0) {
                // 0xf80e
                i_v37 = 0;
                i_v36 = 0;
                i_v35 = *(int32_t *)(i_g87 + 188 + i_v22 +
                                     204 * (i_v37 + i_v33 * i_v31));
                i_v36 += (i_v35 == 0 ? 0 : i_v35 - 1);
                i_v37++;
                i_v34 = i_v36;
                while (i_v33 >= i_v37 == (i_v33 != i_v37)) {
                    // 0xf80e
                    i_v35 = *(int32_t *)(i_g87 + 188 + i_v22 +
                                         204 * (i_v37 + i_v33 * i_v31));
                    i_v36 += (i_v35 == 0 ? 0 : i_v35 - 1);
                    i_v37++;
                    i_v34 = i_v36;
                }
            }
            // 0xf86c
            printf("core[%02d]=%02d\t", i_v31, i_v34);
            i_v38 = i_v31 + 1;
            i_v39 = i_g114;
        }
    }
    uint32_t i_v40 = i_a1 % 256;
    puts("\n-------------------------------------------------------------------"
         "-----------------------------------\n");
    int32_t i_v41 = *(int32_t *)(i_v22 + (int32_t)&i_g199); // 0xf8aa
    printf("Chain%d total valid nonce number: %d\n\n", i_v40, i_v41);
    int32_t i_v42 = *(int32_t *)(i_v22 + (int32_t)&i_g198); // 0xf8ca
    printf("Chain%d total receive nonce number: %d\n\n", i_v40, i_v42);
    int32_t i_v43 = *(int32_t *)(i_v22 + (int32_t)&i_g7); // 0xf8ea
    printf("Chain%d total repeate nonce number: %d\n\n", i_v40, i_v43);
    int32_t i_v44 = *(int32_t *)(i_v22 + (int32_t)&i_g200); // 0xf90a
    printf("Chain%d HW number = %d\n\n", i_v40, i_v44);
    if (i_v6 % 2 == 0) {
        // 0xf936
        puts("Pattern NG\n");
    } else {
        // 0xf928
        puts("Pattern OK\n");
    }
    // 0xf942
    return i_v6;
}

// Address range: 0xf950 - 0xffee
int32_t single_board_get_result(int32_t i_a1) {
    uint32_t i_v1 = 0x1000000 * i_a1 >> 24; // 0xf958
    puts("\n\n-----------------------------------------------------------------"
         "-------------------------------------\n");
    printf("every ASIC require nonce number: %lu\n", i_g114 * i_g110);
    puts("\n\nevery asic returned valid nonce count:");
    int32_t i_v2 = 0; // 0xfa86
    int32_t i_v3 = 7; // 0xfa86
    if (i_g113 != 0) {
        int32_t i_v4 = 0; // 0xfa74
        int32_t i_v5 = 0;
        int32_t i_v6 = 7;
        uint64_t i_v7 = 0; // 0xf9f0
        if (8 * (int32_t)i_v7 + (int32_t)i_v7 == i_v4) {
            // 0xfa02
            putchar(10);
        }
        uint32_t i_v8 = calculate_how_many_nonce_per_asic_get(
            i_v1 % 256, i_v4 % 256, i_g114); // 0xfa1e
        printf("asic[%02d]=%d\t", i_v4, i_v8);
        uint32_t i_v9 = i_g114 * i_g110; // 0xfa48
        int32_t i_v10 = i_v5;            // 0xfa50
        int32_t i_v11 = i_v6;            // 0xfa50
        if (i_v9 != i_v8 && i_v9 >= i_v8) {
            // 0xfa52
            i_v10 = i_v5 + 1;
            i_v11 = i_g139 < i_v10 ? i_v6 & -2 : i_v6;
        }
        int32_t i_v12 = i_v11;
        int32_t i_v13 = i_v10;
        i_v4++;
        uint32_t i_v14 = i_g113; // 0xfa80
        i_v2 = i_v13;
        i_v3 = i_v12;
        while (i_v14 >= i_v4 == (i_v14 != i_v4)) {
            // 0xf9e6
            i_v5 = i_v13;
            i_v6 = i_v12;
            i_v7 = 0x38e38e39 * ((int64_t)i_v4 & 0xffffffff) / 0x200000000;
            if (8 * (int32_t)i_v7 + (int32_t)i_v7 == i_v4) {
                // 0xfa02
                putchar(10);
            }
            // 0xfa08
            i_v8 = calculate_how_many_nonce_per_asic_get(i_v1 % 256, i_v4 % 256,
                                                         i_g114);
            printf("asic[%02d]=%d\t", i_v4, i_v8);
            i_v9 = i_g114 * i_g110;
            i_v10 = i_v5;
            i_v11 = i_v6;
            if (i_v9 != i_v8 && i_v9 >= i_v8) {
                // 0xfa52
                i_v10 = i_v5 + 1;
                i_v11 = i_g139 < i_v10 ? i_v6 & -2 : i_v6;
            }
            // 0xfa72
            i_v12 = i_v11;
            i_v13 = i_v10;
            i_v4++;
            i_v14 = i_g113;
            i_v2 = i_v13;
            i_v3 = i_v12;
        }
    }
    // 0xfa88
    puts("\n\nevery asic returned all nonce count:");
    int32_t i_v15 = 0; // 0xfb70
    if (i_g113 != 0) {
        int32_t i_v16 = 0; // 0xfb58
        int32_t i_v17 = 0;
        uint64_t i_v18 = 0; // 0xfaa8
        if (8 * (int32_t)i_v18 + (int32_t)i_v18 == i_v17) {
            // 0xfaba
            putchar(10);
        }
        uint32_t i_v19 = i_g114; // 0xfb3c
        int32_t i_v20 = 0;       // 0xfb42
        int32_t i_v21;           // 0xf950
        int32_t i_v22;           // 0xf950
        int32_t i_v23;           // 0xf950
        int32_t i_v24;           // 0xf950
        int32_t i_v25;           // 0xfad4
        uint32_t i_v26;          // 0xf950
        int32_t i_v27;           // 0xf950
        int32_t i_v28;           // 0xfb30
        int32_t i_v29;           // 0xfb14
        int32_t i_v30;           // 0xfb1a
        if (i_v19 != 0) {
            // 0xfb1e
            i_v25 = *(int32_t *)(4 * i_v17 + (int32_t)&i_g76 + 0x800a0);
            i_v26 = i_g110;
            i_v27 = (4 * i_a1 & 1020) + 188 + i_v25;
            i_v23 = 0;
            i_v24 = 0;
            i_v21 = i_v23;
            if (i_v26 != 0) {
                // 0xfae6
                i_v30 = 0;
                i_v29 = i_v23;
                i_v29 += *(int32_t *)(i_v27 + 204 * (i_v30 + i_v24 * i_v26));
                i_v30++;
                i_v21 = i_v29;
                while (i_v26 >= i_v30 == (i_v26 != i_v30)) {
                    // 0xfae6
                    i_v29 +=
                        *(int32_t *)(i_v27 + 204 * (i_v30 + i_v24 * i_v26));
                    i_v30++;
                    i_v21 = i_v29;
                }
            }
            // 0xfb2e
            i_v22 = i_v21;
            i_v28 = i_v24 + 1;
            i_v20 = i_v22;
            while (i_v19 >= i_v28 == (i_v19 != i_v28)) {
                // 0xfb1e
                i_v23 = i_v22;
                i_v24 = i_v28;
                i_v21 = i_v23;
                if (i_v26 != 0) {
                    // 0xfae6
                    i_v30 = 0;
                    i_v29 = i_v23;
                    i_v29 +=
                        *(int32_t *)(i_v27 + 204 * (i_v30 + i_v24 * i_v26));
                    i_v30++;
                    i_v21 = i_v29;
                    while (i_v26 >= i_v30 == (i_v26 != i_v30)) {
                        // 0xfae6
                        i_v29 +=
                            *(int32_t *)(i_v27 + 204 * (i_v30 + i_v24 * i_v26));
                        i_v30++;
                        i_v21 = i_v29;
                    }
                }
                // 0xfb2e
                i_v22 = i_v21;
                i_v28 = i_v24 + 1;
                i_v20 = i_v22;
            }
        }
        // 0xfb44
        printf("asic[%02d]=%d\t", i_v17, i_v20);
        i_v16 += i_v20;
        int32_t i_v31 = i_v17 + 1; // 0xfb5e
        uint32_t i_v32 = i_g113;   // 0xfb6a
        i_v15 = i_v16;
        while (i_v32 >= i_v31 == (i_v32 != i_v31)) {
            // 0xfa9e
            i_v17 = i_v31;
            i_v18 = 0x38e38e39 * ((int64_t)i_v31 & 0xffffffff) / 0x200000000;
            if (8 * (int32_t)i_v18 + (int32_t)i_v18 == i_v17) {
                // 0xfaba
                putchar(10);
            }
            // 0xfac0
            i_v19 = i_g114;
            i_v20 = 0;
            if (i_v19 != 0) {
                // 0xfb1e
                i_v25 = *(int32_t *)(4 * i_v17 + (int32_t)&i_g76 + 0x800a0);
                i_v26 = i_g110;
                i_v27 = (4 * i_a1 & 1020) + 188 + i_v25;
                i_v23 = 0;
                i_v24 = 0;
                i_v21 = i_v23;
                if (i_v26 != 0) {
                    // 0xfae6
                    i_v30 = 0;
                    i_v29 = i_v23;
                    i_v29 +=
                        *(int32_t *)(i_v27 + 204 * (i_v30 + i_v24 * i_v26));
                    i_v30++;
                    i_v21 = i_v29;
                    while (i_v26 >= i_v30 == (i_v26 != i_v30)) {
                        // 0xfae6
                        i_v29 +=
                            *(int32_t *)(i_v27 + 204 * (i_v30 + i_v24 * i_v26));
                        i_v30++;
                        i_v21 = i_v29;
                    }
                }
                // 0xfb2e
                i_v22 = i_v21;
                i_v28 = i_v24 + 1;
                i_v20 = i_v22;
                while (i_v19 >= i_v28 == (i_v19 != i_v28)) {
                    // 0xfb1e
                    i_v23 = i_v22;
                    i_v24 = i_v28;
                    i_v21 = i_v23;
                    if (i_v26 != 0) {
                        // 0xfae6
                        i_v30 = 0;
                        i_v29 = i_v23;
                        i_v29 +=
                            *(int32_t *)(i_v27 + 204 * (i_v30 + i_v24 * i_v26));
                        i_v30++;
                        i_v21 = i_v29;
                        while (i_v26 >= i_v30 == (i_v26 != i_v30)) {
                            // 0xfae6
                            i_v29 +=
                                *(int32_t *)(i_v27 +
                                             204 * (i_v30 + i_v24 * i_v26));
                            i_v30++;
                            i_v21 = i_v29;
                        }
                    }
                    // 0xfb2e
                    i_v22 = i_v21;
                    i_v28 = i_v24 + 1;
                    i_v20 = i_v22;
                }
            }
            // 0xfb44
            printf("asic[%02d]=%d\t", i_v17, i_v20);
            i_v16 += i_v20;
            i_v31 = i_v17 + 1;
            i_v32 = i_g113;
            i_v15 = i_v16;
        }
    }
    // 0xfb72
    puts("\n\nevery asic returned repeated nonce count:");
    if (i_g113 != 0) {
        int32_t i_v33 = 0;
        uint64_t i_v34 = 0; // 0xfb8e
        if (8 * (int32_t)i_v34 + (int32_t)i_v34 == i_v33) {
            // 0xfba0
            putchar(10);
        }
        uint32_t i_v35 = i_g114; // 0xfc38
        int32_t i_v36 = 0;       // 0xfc3e
        int32_t i_v37;           // 0xf950
        int32_t i_v38;           // 0xf950
        int32_t i_v39;           // 0xf950
        int32_t i_v40;           // 0xf950
        int32_t i_v41;           // 0xfbba
        uint32_t i_v42;          // 0xf950
        int32_t i_v43;           // 0xf950
        int32_t i_v44;           // 0xfc2c
        int32_t i_v45;           // 0xfbf6
        int32_t i_v46;           // 0xfc10
        int32_t i_v47;           // 0xfc16
        if (i_v35 != 0) {
            // 0xfc1a
            i_v41 = *(int32_t *)(4 * i_v33 + (int32_t)&i_g76 + 0x800a0);
            i_v42 = i_g110;
            i_v43 = (4 * i_a1 & 1020) + 188 + i_v41;
            i_v39 = 0;
            i_v40 = 0;
            i_v37 = i_v39;
            if (i_v42 != 0) {
                // 0xfbcc
                i_v47 = 0;
                i_v46 = i_v39;
                i_v45 = *(int32_t *)(i_v43 + 204 * (i_v47 + i_v40 * i_v42));
                i_v46 += (i_v45 == 0 ? 0 : i_v45 - 1);
                i_v47++;
                i_v37 = i_v46;
                while (i_v42 >= i_v47 == (i_v42 != i_v47)) {
                    // 0xfbcc
                    i_v45 = *(int32_t *)(i_v43 + 204 * (i_v47 + i_v40 * i_v42));
                    i_v46 += (i_v45 == 0 ? 0 : i_v45 - 1);
                    i_v47++;
                    i_v37 = i_v46;
                }
            }
            // 0xfc2a
            i_v38 = i_v37;
            i_v44 = i_v40 + 1;
            i_v36 = i_v38;
            while (i_v35 >= i_v44 == (i_v35 != i_v44)) {
                // 0xfc1a
                i_v39 = i_v38;
                i_v40 = i_v44;
                i_v37 = i_v39;
                if (i_v42 != 0) {
                    // 0xfbcc
                    i_v47 = 0;
                    i_v46 = i_v39;
                    i_v45 = *(int32_t *)(i_v43 + 204 * (i_v47 + i_v40 * i_v42));
                    i_v46 += (i_v45 == 0 ? 0 : i_v45 - 1);
                    i_v47++;
                    i_v37 = i_v46;
                    while (i_v42 >= i_v47 == (i_v42 != i_v47)) {
                        // 0xfbcc
                        i_v45 =
                            *(int32_t *)(i_v43 + 204 * (i_v47 + i_v40 * i_v42));
                        i_v46 += (i_v45 == 0 ? 0 : i_v45 - 1);
                        i_v47++;
                        i_v37 = i_v46;
                    }
                }
                // 0xfc2a
                i_v38 = i_v37;
                i_v44 = i_v40 + 1;
                i_v36 = i_v38;
            }
        }
        // 0xfc40
        printf("asic[%02d]=%d\t", i_v33, i_v36);
        int32_t i_v48 = i_v33 + 1; // 0xfc52
        uint32_t i_v49 = i_g113;   // 0xfc5e
        while (i_v49 >= i_v48 == (i_v49 != i_v48)) {
            // 0xfb84
            i_v33 = i_v48;
            i_v34 = 0x38e38e39 * ((int64_t)i_v48 & 0xffffffff) / 0x200000000;
            if (8 * (int32_t)i_v34 + (int32_t)i_v34 == i_v33) {
                // 0xfba0
                putchar(10);
            }
            // 0xfba6
            i_v35 = i_g114;
            i_v36 = 0;
            if (i_v35 != 0) {
                // 0xfc1a
                i_v41 = *(int32_t *)(4 * i_v33 + (int32_t)&i_g76 + 0x800a0);
                i_v42 = i_g110;
                i_v43 = (4 * i_a1 & 1020) + 188 + i_v41;
                i_v39 = 0;
                i_v40 = 0;
                i_v37 = i_v39;
                if (i_v42 != 0) {
                    // 0xfbcc
                    i_v47 = 0;
                    i_v46 = i_v39;
                    i_v45 = *(int32_t *)(i_v43 + 204 * (i_v47 + i_v40 * i_v42));
                    i_v46 += (i_v45 == 0 ? 0 : i_v45 - 1);
                    i_v47++;
                    i_v37 = i_v46;
                    while (i_v42 >= i_v47 == (i_v42 != i_v47)) {
                        // 0xfbcc
                        i_v45 =
                            *(int32_t *)(i_v43 + 204 * (i_v47 + i_v40 * i_v42));
                        i_v46 += (i_v45 == 0 ? 0 : i_v45 - 1);
                        i_v47++;
                        i_v37 = i_v46;
                    }
                }
                // 0xfc2a
                i_v38 = i_v37;
                i_v44 = i_v40 + 1;
                i_v36 = i_v38;
                while (i_v35 >= i_v44 == (i_v35 != i_v44)) {
                    // 0xfc1a
                    i_v39 = i_v38;
                    i_v40 = i_v44;
                    i_v37 = i_v39;
                    if (i_v42 != 0) {
                        // 0xfbcc
                        i_v47 = 0;
                        i_v46 = i_v39;
                        i_v45 =
                            *(int32_t *)(i_v43 + 204 * (i_v47 + i_v40 * i_v42));
                        i_v46 += (i_v45 == 0 ? 0 : i_v45 - 1);
                        i_v47++;
                        i_v37 = i_v46;
                        while (i_v42 >= i_v47 == (i_v42 != i_v47)) {
                            // 0xfbcc
                            i_v45 = *(int32_t *)(i_v43 +
                                                 204 * (i_v47 + i_v40 * i_v42));
                            i_v46 += (i_v45 == 0 ? 0 : i_v45 - 1);
                            i_v47++;
                            i_v37 = i_v46;
                        }
                    }
                    // 0xfc2a
                    i_v38 = i_v37;
                    i_v44 = i_v40 + 1;
                    i_v36 = i_v38;
                }
            }
            // 0xfc40
            printf("asic[%02d]=%d\t", i_v33, i_v36);
            i_v48 = i_v33 + 1;
            i_v49 = i_g113;
        }
    }
    // 0xfc66
    puts("\n");
    int32_t i_v50; // 0xf950
    int32_t i_v51; // 0xf950
    int32_t i_v52; // 0xf950
    if (i_g113 == 0) {
        // 0xfc66
        i_v50 = 4 * i_a1 & 1020;
        i_v51 = i_v3;
        i_v52 = 0;
    } else {
        int32_t i_v53 = 4 * i_a1 & 1020;
        int32_t i_v54 = 0;
        uint32_t i_v55 = 0;
        uint32_t i_v56 = calculate_how_many_nonce_per_asic_get(
            i_v1 % 256, i_v55 % 256, i_g114); // 0xfc8e
        uint32_t i_v57 = i_g114 * i_g110;     // 0xfca8
        int32_t i_v58 = i_v3;                 // 0xfcb0
        int32_t i_v59 = i_v54;                // 0xfcb0
        int32_t i_v60;                        // 0xf950
        int32_t i_v61;                        // 0xf950
        int32_t i_v62;                        // 0xf950
        int32_t i_v63;                        // 0xfde2
        int32_t i_v64;                        // 0xfdfe
        int32_t i_v65;                        // 0xf950
        int32_t i_v66;                        // 0xf950
        int32_t i_v67;                        // 0xf950
        int32_t i_v68;                        // 0xf950
        int32_t i_v69;                        // 0xf950
        int32_t i_v70;                        // 0xf950
        int32_t i_v71;                        // 0xf950
        int32_t i_v72;                        // 0xf950
        int32_t i_v73;                        // 0xf950
        int32_t i_v74;                        // 0xf950
        int32_t i_v75;                        // 0xf950
        int32_t i_v76;                        // 0xfcd4
        int32_t i_v77;                        // 0xfcf4
        int32_t i_v78;                        // 0xf950
        uint32_t i_v79;                       // 0xfcfa
        int32_t i_v80;                        // 0xfdf2
        int32_t i_v81;                        // 0xfd0e
        int32_t i_v82;                        // 0xfdd6
        if (i_v57 != i_v56 && i_v57 >= i_v56) {
            // 0xfcb4
            printf("asic[%02d] = %d\n", i_v55, i_v56);
            i_v69 = i_v3;
            i_v73 = i_v54;
            if (i_g114 != 0) {
                // 0xfce4
                i_v76 = *(int32_t *)(4 * i_v55 + (int32_t)&i_g76 + 0x800a0);
                i_v77 = 512 * (i_v55 + (256 * i_a1 & 0xff00));
                i_v78 = i_v53 + 188 + i_v76;
                i_v65 = 0;
                i_v68 = i_v3;
                i_v72 = i_v54;
                i_v74 = 0;
                i_v79 = *(int32_t *)(4 * (i_v74 + i_v77) + (int32_t)&i_g202);
                i_v81 = i_v65;
                i_v66 = i_v68;
                i_v70 = i_v72;
                if (i_v79 < i_g110) {
                    // 0xfd0c
                    printf("core[%02d] = %d,      lost these nonce : ", i_v74,
                           i_v79);
                    if (i_g110 != 0) {
                        i_v75 = 0;
                        if (*(int32_t *)(i_v78 +
                                         204 * (i_g110 * i_v74 + i_v75)) == 0) {
                            // 0xfdc6
                            printf("%d  ", i_v75);
                        }
                        // 0xfdd4
                        i_v63 = i_g110;
                        i_v82 = i_v75 + 1;
                        i_v60 = i_v63;
                        while (i_v63 >= i_v82 == (i_v63 != i_v82)) {
                            // 0xfd96
                            i_v75 = i_v82;
                            i_v61 = i_v60;
                            if (*(int32_t *)(i_v78 + 204 * (i_v60 * i_v74 +
                                                            i_v75)) == 0) {
                                // 0xfdc6
                                printf("%d  ", i_v75);
                                i_v61 = i_g110;
                            }
                            // 0xfdd4
                            i_v63 = i_v61;
                            i_v82 = i_v75 + 1;
                            i_v60 = i_v63;
                        }
                    }
                    // 0xfdea
                    i_v81 = i_v65 + 1;
                    i_v66 =
                        i_g140 < i_v81 | i_v79 < i_g141 ? i_v68 & -2 : i_v68;
                    putchar(10);
                    i_v70 = i_v81 + i_v72;
                }
                // 0xfdf0
                i_v71 = i_v70;
                i_v67 = i_v66;
                i_v64 = i_g114;
                i_v80 = i_v74 + 1;
                i_v69 = i_v67;
                i_v73 = i_v71;
                while (i_v64 >= i_v80 == (i_v64 != i_v80)) {
                    // 0xfce4
                    i_v65 = i_v81;
                    i_v68 = i_v67;
                    i_v72 = i_v71;
                    i_v74 = i_v80;
                    i_v79 =
                        *(int32_t *)(4 * (i_v74 + i_v77) + (int32_t)&i_g202);
                    i_v62 = i_v64;
                    i_v81 = i_v65;
                    i_v66 = i_v68;
                    i_v70 = i_v72;
                    if (i_v79 < i_g110) {
                        // 0xfd0c
                        printf("core[%02d] = %d,      lost these nonce : ",
                               i_v74, i_v79);
                        if (i_g110 != 0) {
                            i_v75 = 0;
                            if (*(int32_t *)(i_v78 + 204 * (i_g110 * i_v74 +
                                                            i_v75)) == 0) {
                                // 0xfdc6
                                printf("%d  ", i_v75);
                            }
                            // 0xfdd4
                            i_v63 = i_g110;
                            i_v82 = i_v75 + 1;
                            i_v60 = i_v63;
                            while (i_v63 >= i_v82 == (i_v63 != i_v82)) {
                                // 0xfd96
                                i_v75 = i_v82;
                                i_v61 = i_v60;
                                if (*(int32_t *)(i_v78 + 204 * (i_v60 * i_v74 +
                                                                i_v75)) == 0) {
                                    // 0xfdc6
                                    printf("%d  ", i_v75);
                                    i_v61 = i_g110;
                                }
                                // 0xfdd4
                                i_v63 = i_v61;
                                i_v82 = i_v75 + 1;
                                i_v60 = i_v63;
                            }
                        }
                        // 0xfdea
                        i_v81 = i_v65 + 1;
                        i_v66 = i_g140 < i_v81 | i_v79 < i_g141 ? i_v68 & -2
                                                                : i_v68;
                        putchar(10);
                        i_v62 = i_g114;
                        i_v70 = i_v81 + i_v72;
                    }
                    // 0xfdf0
                    i_v71 = i_v70;
                    i_v67 = i_v66;
                    i_v64 = i_v62;
                    i_v80 = i_v74 + 1;
                    i_v69 = i_v67;
                    i_v73 = i_v71;
                }
            }
            // 0xfe08
            puts("\n");
            i_v58 = i_v69;
            i_v59 = i_v73;
        }
        int32_t i_v83 = i_v59;
        int32_t i_v84 = i_v58;
        int32_t i_v85 = i_v55 + 1; // 0xfe16
        uint32_t i_v86 = i_g113;   // 0xfe22
        i_v50 = i_v53;
        i_v51 = i_v84;
        i_v52 = i_v83;
        while (i_v86 >= i_v85 == (i_v86 != i_v85)) {
            int32_t i_v87 = i_v84;
            i_v54 = i_v83;
            i_v55 = i_v85;
            i_v56 = calculate_how_many_nonce_per_asic_get(i_v1 % 256,
                                                          i_v55 % 256, i_g114);
            i_v57 = i_g114 * i_g110;
            i_v58 = i_v87;
            i_v59 = i_v54;
            if (i_v57 != i_v56 && i_v57 >= i_v56) {
                // 0xfcb4
                printf("asic[%02d] = %d\n", i_v55, i_v56);
                i_v69 = i_v87;
                i_v73 = i_v54;
                if (i_g114 != 0) {
                    // 0xfce4
                    i_v76 = *(int32_t *)(4 * i_v55 + (int32_t)&i_g76 + 0x800a0);
                    i_v77 = 512 * (i_v55 + (256 * i_a1 & 0xff00));
                    i_v78 = i_v53 + 188 + i_v76;
                    i_v65 = 0;
                    i_v68 = i_v87;
                    i_v72 = i_v54;
                    i_v74 = 0;
                    i_v79 =
                        *(int32_t *)(4 * (i_v74 + i_v77) + (int32_t)&i_g202);
                    i_v81 = i_v65;
                    i_v66 = i_v68;
                    i_v70 = i_v72;
                    if (i_v79 < i_g110) {
                        // 0xfd0c
                        printf("core[%02d] = %d,      lost these nonce : ",
                               i_v74, i_v79);
                        if (i_g110 != 0) {
                            i_v75 = 0;
                            if (*(int32_t *)(i_v78 + 204 * (i_g110 * i_v74 +
                                                            i_v75)) == 0) {
                                // 0xfdc6
                                printf("%d  ", i_v75);
                            }
                            // 0xfdd4
                            i_v63 = i_g110;
                            i_v82 = i_v75 + 1;
                            i_v60 = i_v63;
                            while (i_v63 >= i_v82 == (i_v63 != i_v82)) {
                                // 0xfd96
                                i_v75 = i_v82;
                                i_v61 = i_v60;
                                if (*(int32_t *)(i_v78 + 204 * (i_v60 * i_v74 +
                                                                i_v75)) == 0) {
                                    // 0xfdc6
                                    printf("%d  ", i_v75);
                                    i_v61 = i_g110;
                                }
                                // 0xfdd4
                                i_v63 = i_v61;
                                i_v82 = i_v75 + 1;
                                i_v60 = i_v63;
                            }
                        }
                        // 0xfdea
                        i_v81 = i_v65 + 1;
                        i_v66 = i_g140 < i_v81 | i_v79 < i_g141 ? i_v68 & -2
                                                                : i_v68;
                        putchar(10);
                        i_v70 = i_v81 + i_v72;
                    }
                    // 0xfdf0
                    i_v71 = i_v70;
                    i_v67 = i_v66;
                    i_v64 = i_g114;
                    i_v80 = i_v74 + 1;
                    i_v69 = i_v67;
                    i_v73 = i_v71;
                    while (i_v64 >= i_v80 == (i_v64 != i_v80)) {
                        // 0xfce4
                        i_v65 = i_v81;
                        i_v68 = i_v67;
                        i_v72 = i_v71;
                        i_v74 = i_v80;
                        i_v79 = *(int32_t *)(4 * (i_v74 + i_v77) +
                                             (int32_t)&i_g202);
                        i_v62 = i_v64;
                        i_v81 = i_v65;
                        i_v66 = i_v68;
                        i_v70 = i_v72;
                        if (i_v79 < i_g110) {
                            // 0xfd0c
                            printf("core[%02d] = %d,      lost these nonce : ",
                                   i_v74, i_v79);
                            if (i_g110 != 0) {
                                i_v75 = 0;
                                if (*(int32_t *)(i_v78 + 204 * (i_g110 * i_v74 +
                                                                i_v75)) == 0) {
                                    // 0xfdc6
                                    printf("%d  ", i_v75);
                                }
                                // 0xfdd4
                                i_v63 = i_g110;
                                i_v82 = i_v75 + 1;
                                i_v60 = i_v63;
                                while (i_v63 >= i_v82 == (i_v63 != i_v82)) {
                                    // 0xfd96
                                    i_v75 = i_v82;
                                    i_v61 = i_v60;
                                    if (*(int32_t *)(i_v78 +
                                                     204 * (i_v60 * i_v74 +
                                                            i_v75)) == 0) {
                                        // 0xfdc6
                                        printf("%d  ", i_v75);
                                        i_v61 = i_g110;
                                    }
                                    // 0xfdd4
                                    i_v63 = i_v61;
                                    i_v82 = i_v75 + 1;
                                    i_v60 = i_v63;
                                }
                            }
                            // 0xfdea
                            i_v81 = i_v65 + 1;
                            i_v66 = i_g140 < i_v81 | i_v79 < i_g141 ? i_v68 & -2
                                                                    : i_v68;
                            putchar(10);
                            i_v62 = i_g114;
                            i_v70 = i_v81 + i_v72;
                        }
                        // 0xfdf0
                        i_v71 = i_v70;
                        i_v67 = i_v66;
                        i_v64 = i_v62;
                        i_v80 = i_v74 + 1;
                        i_v69 = i_v67;
                        i_v73 = i_v71;
                    }
                }
                // 0xfe08
                puts("\n");
                i_v58 = i_v69;
                i_v59 = i_v73;
            }
            // 0xfe14
            i_v83 = i_v59;
            i_v84 = i_v58;
            i_v85 = i_v55 + 1;
            i_v86 = i_g113;
            i_v50 = i_v53;
            i_v51 = i_v84;
            i_v52 = i_v83;
        }
    }
    int32_t *p_v88 = (int32_t *)(i_v50 + (int32_t)&i_g200); // 0xfe36
    uint32_t i_v89 = *p_v88;                                // 0xfe36
    uint32_t i_v90 = i_g143;                                // 0xfe42
    int32_t i_v91 = i_v51;                                  // 0xfe48
    if (i_v89 != i_v90 && i_v89 >= i_v90) {
        // 0xfe4a
        i_v91 = i_v51 & -2;
        printf("ret = %d\n", i_v91);
    }
    int32_t i_v92 = i_g110 * i_g113 * i_g114;               // 0xf9ce
    int32_t *p_v93 = (int32_t *)(i_v50 + (int32_t)&i_g199); // 0xfe6a
    uint32_t i_v94 = i_v92 - *p_v93;                        // 0xfe70
    uint32_t i_v95 = i_g142;                                // 0xfe7a
    int32_t i_v96 = i_v91;                                  // 0xfe80
    if (i_v94 != i_v95 && i_v94 >= i_v95) {
        // 0xfe82
        i_v96 = i_v91 & -2;
        printf("ret = %d\n", i_v96);
    }
    int32_t i_v97 = i_v96;
    puts("\n-------------------------------------------------------------------"
         "-----------------------------------\n");
    uint32_t i_v98 = i_v1 % 256;                     // 0xfea4
    char i_v99 = *(char *)(i_v98 + (int32_t)&p_g23); // 0xfeae
    uint32_t i_v100 = i_v99 == 0 ? i_v97 : i_v97 & -5;
    printf("Chain%d total valid nonce number: %d\n\n", i_v98, *p_v93);
    printf("Chain%d total returned nonce number: %d\n\n", i_v98, i_v15);
    int32_t i_v101 = *(int32_t *)(i_v50 + (int32_t)&i_g7); // 0xfefa
    printf("Chain%d total repeated nonce number: %d\n\n", i_v98, i_v101);
    printf("Chain%d HW number = %d\n\n", i_v98, *p_v88);
    printf("total invalid asic number %d\n", i_v2);
    printf("total invalid core number %d\n", i_v52);
    printf("total nonce expected %d lost %d allow most %d\n", i_v92,
           i_v92 - *p_v93, i_g142);
    if (i_v100 % 2 == 0) {
        // 0xff8e
        puts("Pattern NG\n");
    } else {
        // 0xff80
        puts("Pattern OK\n");
    }
    if ((i_v100 & 2) == 0) {
        // 0xffb2
        puts("Sensor NG\n");
    } else {
        // 0xffa4
        puts("Sensor OK\n");
    }
    if ((i_v100 & 4) == 0) {
        // 0xffd6
        puts("Temperature NG\n");
    } else {
        // 0xffc8
        puts("Temperature OK\n");
    }
    // 0xffe2
    return i_v100;
}

// Address range: 0xfff0 - 0x10566
int32_t get_pllparam_divider(int32_t i_a1, int32_t i_a2, int32_t i_a3,
                             int32_t i_a4) {
    // 0xfff0
    float32_t f_v1; // 0xfff0
    int32_t i_v2;   // 0xfff0
    __asm_vstr(f_v1, i_v2);
    while (true) {
        // 0x1008a
        __asm_vcmpe_f32(__asm_vldr(0x451c4000), __asm_vldr(0x204ef897));
        __asm_vmrs(i_v2, i_v2);
        float32_t f_v3 = __asm_vdiv_f32(__asm_vmov_f32(25.0f),
                                        __asm_vldr(0x41c80000)); // 0x10092
        float32_t f_v4 = __asm_vcvt_f32_s32(__asm_vmov_72(
            __asm_vmov(__asm_vcvt_u32_f32(f_v3)) % 256)); // 0x100aa
        __asm_vmov(__asm_vcvt_u32_f32(
            __asm_vdiv_f32(__asm_vmul_f32(f_v4, __asm_vldr(0x451c4000)),
                           __asm_vmov_f32(25.0f))));
        __asm_vstr(__asm_vdiv_f32(__asm_vldr(0x451c4000), __asm_vldr(i_v2)),
                   i_v2);
        __asm_vstr(__asm_vcvt_u32_f32(__asm_vldr(i_v2)), i_v2);
        __asm_vstr(__asm_vsub_f32(__asm_vldr(i_v2),
                                  __asm_vcvt_f32_u32(__asm_vldr(i_v2))),
                   i_v2);
        __asm_vcmpe_f32(__asm_vldr(i_v2), __asm_vldr(0x41c80000));
        __asm_vmrs(i_v2, i_v2);
        __asm_vstr(
            __asm_vsub_f32(__asm_vldr(0x451c4000), __asm_vldr(0x41c80000)),
            0x451c4000);
        __asm_vcmpe_f32(__asm_vldr(0x451c4000), __asm_vldr(0x44af0000));
        __asm_vmrs(i_v2, i_v2);
    }
}

// Address range: 0x10568 - 0x10604
int32_t enable_read_temperature_from_asic_chain(int32_t i_a1, int32_t i_a2) {
    uint32_t i_v1 = 0x1000000 * i_a1 >> 24; // 0x10572
    uint32_t i_v2 = 0x1000000 * i_a2 >> 24; // 0x10574
    int32_t i_v3 = i_a1;                    // 0x10568
    switch (i_g115) {
    case 1722: {
        // 0x1058c
        i_v3 = set_BM1722_asic_register(i_v1 % 256, i_v2 % 256, 28, 0,
                                        256 * i_g145 | 0x7006061);
        // break -> 0x105fc
        break;
    }
    case 1725: {
        // 0x105ce
        i_v3 = set_BM1725_asic_register(i_v1 % 256, i_v2 % 256, 28, 0,
                                        256 * i_g145 | 0x7006061);
        // break -> 0x105fc
        break;
    }
    }
    // 0x105fc
    return i_v3;
}

// Address range: 0x10604 - 0x108d2
int32_t enable_extended_mode_of_temperature_sensor_chain(uint32_t i_a1) {
    uint32_t i_v1 = i_a1 % 256;
    int32_t i_v2 =
        printf("\n--- %s\n",
               "enable_extended_mode_of_temperature_sensor_chain"); // 0x1064e
    char *p_v3 = (char *)(i_v1 + (int32_t)&p_g9);
    bool i_v4 = false; // 0x10604
    int32_t i_v5 = 0;  // 0x108be
    int32_t i_v6 = i_v2;
    int32_t i_v7;  // 0x10604
    int32_t i_v8;  // 0x10604
    int32_t i_v9;  // 0x10604
    char i_v10;    // 0x10604
    int32_t i_v11; // 0x10604
    int32_t i_v12; // 0x10604
    int32_t i_v13; // 0x10604
    int32_t i_v14; // 0x10604
    char i_v15;    // 0x10604
    int32_t i_v16; // 0x10604
    int32_t i_v17; // 0x10604
    int32_t i_v18; // 0x10604
    while (true) {
    lab_0x10658:;
        int32_t i_v19 = i_v14;
        char i_v20 = i_v5 == 0 ? i_g128 : i_v15;
        i_v10 = i_v4 ? i_g130 : i_v5 == 1 ? i_g129 : i_v20;
        i_v13 = i_v19;
        i_v9 = i_v6;
        if (i_v10 == 0) {
            goto lab_0x108bc;
        } else {
            int32_t i_v21 = enable_read_temperature_from_asic_chain(
                i_v1, i_g195 % 256 * (int32_t)(i_v10 - 1) % 256); // 0x106ba
            i_v18 = (int32_t)i_v10 - 1;
            uint32_t i_v22 = 1;
            int32_t i_v23 = i_v19; // 0x10604
            int32_t i_v24 = i_v21; // 0x10604
            int32_t i_v25;         // 0x106ec
            int32_t i_v26;         // 0x10724
            switch (i_g115) {
            case 1722: {
                // 0x106d0
                i_v25 = check_BM1722_asic_reg(i_v1, i_g195 * i_v18, 32, 0);
                i_v23 = i_v25;
                i_v24 = i_v25;
                // break -> 0x1072c
                break;
            }
            case 1725: {
                // 0x10708
                i_v26 = check_BM1725_asic_reg(i_v1, i_g195 * i_v18, 32, 0);
                i_v23 = i_v26;
                i_v24 = i_v26;
                // break -> 0x1072c
                break;
            }
            }
            int32_t i_v27 = i_v24;
            int32_t i_v28 = i_v23;
            while (i_v22 < 2 == i_v28 > 0x3fffffff) {
                // 0x106be
                i_v22 = 2;
                i_v23 = i_v28;
                i_v24 = i_v27;
                switch (i_g115) {
                case 1722: {
                    // 0x106d0
                    i_v25 = check_BM1722_asic_reg(i_v1, i_g195 * i_v18, 32, 0);
                    i_v23 = i_v25;
                    i_v24 = i_v25;
                    // break -> 0x1072c
                    break;
                }
                case 1725: {
                    // 0x10708
                    i_v26 = check_BM1725_asic_reg(i_v1, i_g195 * i_v18, 32, 0);
                    i_v23 = i_v26;
                    i_v24 = i_v26;
                    // break -> 0x1072c
                    break;
                }
                }
                // 0x1072c
                i_v27 = i_v24;
                i_v28 = i_v23;
            }
            if (i_v28 < 0x40000000) {
                // 0x1075c
                i_v17 = 0;
                i_v12 = i_v28;
                i_v8 = i_v27;
                switch (i_g115) {
                case 1722: {
                    // 0x1076e
                    i_v16 = 0;
                    i_v11 = i_v28;
                    i_v7 = set_BM1722_asic_register(i_v1, i_g195 * i_v18, 32, 0,
                                                    0x1990904);
                    goto lab_0x107d6_2;
                }
                case 1725: {
                    // 0x107ac
                    i_v16 = 0;
                    i_v11 = i_v28;
                    i_v7 = set_BM1725_asic_register(i_v1, i_g195 * i_v18, 32, 0,
                                                    0x1990904);
                    goto lab_0x107d6_2;
                }
                default: {
                    goto lab_0x107d6;
                }
                }
            } else {
                // 0x10898
                *p_v3 = 1;
                int32_t i_v29 = printf(
                    "%s: Can't read out GENERAL_I2C_COMMAND. ret = 0x%08x\n",
                    "enable_extended_mode_of_temperature_sensor_chain",
                    i_v28); // 0x108b8
                i_v13 = i_v28;
                i_v9 = i_v29;
                goto lab_0x108bc;
            }
        }
    }
    // 0x108ca
    return i_v6;
lab_0x108bc:
    // 0x108bc
    i_v6 = i_v9;
    i_v5++;
    i_v4 = i_v5 == 2;
    i_v14 = i_v13;
    i_v15 = i_v10;
    if (i_v5 != 2 && i_v5 >= 2) {
        return i_v6;
    }
    goto lab_0x10658;
lab_0x107d6:;
    int32_t i_v30 = i_v12; // 0x10604
    int32_t i_v31 = i_v8;  // 0x10604
    switch (i_g115) {
    case 1722: {
        int32_t i_v32 =
            check_BM1722_asic_reg(i_v1, i_g195 * i_v18, 32, 0); // 0x10804
        i_v30 = i_v32;
        i_v31 = i_v32;
        // break -> 0x10844
        break;
    }
    case 1725: {
        int32_t i_v33 =
            check_BM1725_asic_reg(i_v1, i_g195 * i_v18, 32, 0); // 0x1083c
        i_v30 = i_v33;
        i_v31 = i_v33;
        // break -> 0x10844
        break;
    }
    }
    int32_t i_v34 = i_v31;
    int32_t i_v35 = i_v30;
    int32_t i_v36 = i_v17 + 1; // 0x10846
    i_v16 = i_v36;
    i_v11 = i_v35;
    i_v7 = i_v34;
    if (i_v36 < 2 == i_v35 > 0x3fffffff) {
        goto lab_0x107d6_2;
    } else {
        // 0x10864
        i_v13 = i_v35;
        i_v9 = i_v34;
        if (i_v35 >= 0x40000000) {
            // 0x10872
            *p_v3 = 1;
            int32_t i_v37 =
                printf("%s: Can't set extended mode. ret = 0x%08x\n",
                       "enable_extended_mode_of_temperature_sensor_chain",
                       i_v35); // 0x10892
            i_v13 = i_v35;
            i_v9 = i_v37;
        }
        goto lab_0x108bc;
    }
lab_0x107d6_2:
    // 0x107d6
    i_v17 = i_v16;
    i_v12 = i_v11;
    i_v8 = i_v7;
    goto lab_0x107d6;
}

// Address range: 0x108d4 - 0x10e92
int32_t get_temperature_offset_value_from_asic_chain(uint32_t i_a1) {
    uint32_t i_v1 = i_a1 % 256;
    char i_v2 = 0; // bp-44, 0x108ea
    int32_t i_v3 =
        printf("\n--- %s\n",
               "get_temperature_offset_value_from_asic_chain"); // 0x10924
    char *p_v4 = (char *)(i_v1 + (int32_t)&p_g9);
    int32_t i_v5; // bp-8, 0x108d4
    int32_t i_v6 = &i_v5;
    bool i_v7 = false; // 0x108d4
    int32_t i_v8 = 0;  // 0x10e16
    int32_t i_v9 = i_v3;
    int32_t i_v10 = 0;  // 0x108d4
    int32_t i_v11 = 0;  // 0x108d4
    int32_t i_v12 = -1; // 0x108d4
    int32_t i_v13;      // 0x108d4
    char i_v14;         // 0x108d4
    int32_t i_v15;      // 0x108d4
    int32_t i_v16;      // 0x108d4
    char i_v17;         // 0x108d4
    int32_t i_v18;      // 0x108d4
    int32_t i_v19;      // 0x108d4
    int32_t i_v20;      // 0x108d4
    int32_t i_v21;      // 0x108d4
    int32_t i_v22;      // 0x108d4
    int32_t i_v23;      // 0x108d4
    while (true) {
    lab_0x1092e:;
        int32_t i_v24 = i_v12;
        i_v20 = i_v11;
        i_v21 = i_v10;
        i_v22 = i_v8;
        char i_v25 = i_v22 == 0 ? i_g128 : i_v17;
        i_v14 = i_v7 ? i_g130 : i_v22 == 1 ? i_g129 : i_v25;
        i_v12 = i_v24;
        i_v11 = i_v20;
        i_v10 = i_v21;
        i_v13 = i_v9;
        if (i_v14 == 0) {
            goto lab_0x10e14;
        } else {
            // 0x10972
            enable_read_temperature_from_asic_chain(
                i_v1, i_g195 % 256 * (int32_t)(i_v14 - 1) % 256);
            i_v23 = (int32_t)i_v14 - 1;
            uint32_t i_v26 = 1;
            int32_t i_v27 = i_v24; // 0x108d4
            switch (i_g115) {
            case 1722: {
                // 0x109a6
                i_v27 = check_BM1722_asic_reg(i_v1, i_g195 * i_v23, 32, 0);
                // break -> 0x10a02
                break;
            }
            case 1725: {
                // 0x109de
                i_v27 = check_BM1725_asic_reg(i_v1, i_g195 * i_v23, 32, 0);
                // break -> 0x10a02
                break;
            }
            }
            int32_t i_v28 = i_v27;
            while (i_v26 < 2 == i_v28 > 0x3fffffff) {
                // 0x10994
                i_v26 = 2;
                i_v27 = i_v28;
                switch (i_g115) {
                case 1722: {
                    // 0x109a6
                    i_v27 = check_BM1722_asic_reg(i_v1, i_g195 * i_v23, 32, 0);
                    // break -> 0x10a02
                    break;
                }
                case 1725: {
                    // 0x109de
                    i_v27 = check_BM1725_asic_reg(i_v1, i_g195 * i_v23, 32, 0);
                    // break -> 0x10a02
                    break;
                }
                }
                // 0x10a02
                i_v28 = i_v27;
            }
            // 0x10a22
            i_v16 = i_v28;
            i_v19 = 0;
            switch (i_g115) {
            case 1722: {
                // 0x10a38
                set_BM1722_asic_register(i_v1, i_g195 * i_v23, 32, 0,
                                         0x1980100);
                i_v15 = i_v28;
                i_v18 = 0;
                goto lab_0x10aa0_2;
            }
            case 1725: {
                // 0x10a76
                set_BM1725_asic_register(i_v1, i_g195 * i_v23, 32, 0,
                                         0x1980100);
                i_v15 = i_v28;
                i_v18 = 0;
                goto lab_0x10aa0_2;
            }
            default: {
                goto lab_0x10aa0;
            }
            }
        }
    }
lab_0x10e22:;
    int32_t i_v29 = i_g113; // 0x10e50
    if (i_v29 == 1 || i_v29 == 0) {
        // 0x10e8a
        return i_v9;
    }
    // 0x10e56
    putchar(10);
    int32_t i_v30 = 0;                                       // 0x108d4
    unsigned char i_v31 = *(char *)(i_v30 + (int32_t)&i_v2); // 0x10e6a
    int32_t i_v32 = printf("offset_value[%d] = %d\n", i_v30,
                           __asm_sxtb((int32_t)i_v31)); // 0x10e7a
    int32_t i_v33 = i_v30 + 1;                          // 0x10e80
    i_v30 = i_v33;
    while (i_v33 == 7 || i_v33 < 7) {
        // 0x10e62
        i_v31 = *(char *)(i_v30 + (int32_t)&i_v2);
        i_v32 = printf("offset_value[%d] = %d\n", i_v30,
                       __asm_sxtb((int32_t)i_v31));
        i_v33 = i_v30 + 1;
        i_v30 = i_v33;
    }
    // 0x10e8a
    return i_v32;
lab_0x10e14:
    // 0x10e14
    i_v9 = i_v13;
    i_v8 = i_v22 + 1;
    i_v7 = i_v8 == 2;
    i_v17 = i_v14;
    if (i_v8 != 2 && i_v8 >= 2) {
        // break -> 0x10e22
        goto lab_0x10e22;
    }
    goto lab_0x1092e;
lab_0x10aa0:;
    int32_t i_v34 = i_v16; // 0x108d4
    switch (i_g115) {
    case 1722: {
        // 0x10ab2
        i_v34 = check_BM1722_asic_reg(i_v1, i_g195 * i_v23, 32, 0);
        // break -> 0x10b0e
        break;
    }
    case 1725: {
        // 0x10aea
        i_v34 = check_BM1725_asic_reg(i_v1, i_g195 * i_v23, 32, 0);
        // break -> 0x10b0e
        break;
    }
    }
    uint32_t i_v35 = i_v34;
    int32_t i_v36 = i_v19 + 1; // 0x10b10
    i_v15 = i_v35;
    i_v18 = i_v36;
    int32_t i_v37; // 0x108d4
    int32_t i_v38; // 0x108d4
    int32_t i_v39; // 0x108d4
    int32_t i_v40; // 0x108d4
    int32_t i_v41; // 0x108d4
    if (i_v36 < 2 == i_v35 > 0x3fffffff) {
        goto lab_0x10aa0_2;
    } else {
        if (i_v35 < 0x40000000) {
            int32_t i_v42 = i_v35 % 256; // 0x10b3e
            printf("ASIC temperature is %d\n", i_v42);
            i_v41 = i_v42;
        } else {
            // 0x10b52
            *p_v4 = 1;
            printf("%s: Can't read out ASIC TEMP. ret = 0x%08x\n",
                   "get_temperature_offset_value_from_asic_chain", i_v35);
            i_v41 = i_v21;
        }
        // 0x10b76
        i_v38 = -1;
        i_v40 = 0;
        switch (i_g115) {
        case 1722: {
            // 0x10b8e
            set_BM1722_asic_register(i_v1, i_g195 * i_v23, 32, 0, 0x1980000);
            i_v37 = -1;
            i_v39 = 0;
            goto lab_0x10bee_2;
        }
        case 1725: {
            // 0x10bc8
            set_BM1725_asic_register(i_v1, i_g195 * i_v23, 32, 0, 0x1980000);
            i_v37 = -1;
            i_v39 = 0;
            goto lab_0x10bee_2;
        }
        default: {
            goto lab_0x10bee;
        }
        }
    }
lab_0x10aa0_2:
    // 0x10aa0
    i_v16 = i_v15;
    i_v19 = i_v18;
    goto lab_0x10aa0;
lab_0x10bee:;
    int32_t i_v43 = i_v38; // 0x108d4
    switch (i_g115) {
    case 1722: {
        // 0x10c00
        i_v43 = check_BM1722_asic_reg(i_v1, i_g195 * i_v23, 32, 0);
        // break -> 0x10c5c
        break;
    }
    case 1725: {
        // 0x10c38
        i_v43 = check_BM1725_asic_reg(i_v1, i_g195 * i_v23, 32, 0);
        // break -> 0x10c5c
        break;
    }
    }
    uint32_t i_v44 = i_v43;
    int32_t i_v45 = i_v40 + 1; // 0x10c5e
    i_v37 = i_v44;
    i_v39 = i_v45;
    if (i_v45 < 2 == i_v44 > 0x3fffffff) {
        goto lab_0x10bee_2;
    } else {
        int32_t i_v46; // 0x108d4
        if (i_v44 < 0x40000000) {
            int32_t i_v47 = i_v44 % 256; // 0x10c8c
            printf("local_temp is %d\n", i_v47);
            i_v46 = i_v47;
        } else {
            // 0x10ca0
            *p_v4 = 1;
            printf("%s: Can't read out HASH BOARD TEMP. ret = 0x%08x\n",
                   "get_temperature_offset_value_from_asic_chain", i_v44);
            i_v46 = i_v20;
        }
        char i_v48 = *p_v4 == 0 ? (char)(i_v46 - i_v41) : 0;
        switch (i_v22) {
        case 0: {
            // 0x10cee
            *(char *)&p_g97 = i_v48;
            *(char *)(i_v6 - 36) = i_v14;
            *(char *)(i_v6 - 35) = *(char *)&p_g97;
            *(char *)(i_v1 + (int32_t)&p_g10) = i_v48;
            // break -> 0x10e02
            break;
        }
        case 1: {
            // 0x10d4c
            *(char *)&p_g98 = i_v48;
            *(char *)(i_v6 - 34) = i_v14;
            *(char *)(i_v6 - 33) = *(char *)&p_g98;
            *(char *)(i_v1 + (int32_t)&p_g11) = i_v48;
            // break -> 0x10e02
            break;
        }
        case 2: {
            // 0x10daa
            *(char *)&p_g99 = i_v48;
            *(char *)(i_v6 - 32) = i_v14;
            *(char *)(i_v6 - 31) = *(char *)&p_g99;
            *(char *)(i_v1 + (int32_t)&p_g12) = i_v48;
            // break -> 0x10e02
            break;
        }
        }
        // 0x10e02
        i_v12 = i_v44;
        i_v11 = i_v46;
        i_v10 = i_v41;
        i_v13 = printf("temp_offset_value = %d\n", (int32_t)i_v48);
        goto lab_0x10e14;
    }
lab_0x10bee_2:
    // 0x10bee
    i_v38 = i_v37;
    i_v40 = i_v39;
    goto lab_0x10bee;
}

// Address range: 0x10e94 - 0x112ec
int32_t set_default_temperature_offset_value_chain(uint32_t i_a1) {
    uint32_t i_v1 = i_a1 % 256;
    int32_t i_v2 =
        printf("\n--- %s\n", (char *)((int32_t)&p_g297 | 0x20000)); // 0x10eca
    bool i_v3 = false;                                              // 0x10e94
    int32_t i_v4 = 0;                                               // 0x112d8
    int32_t i_v5 = i_v2;
    char i_v6 = 0; // 0x10e94
    char i_v7 = 0; // 0x10e94
    char i_v8 = 0; // 0x10e94
    bool i_v9;     // 0x10e94
    bool i_v10;    // 0x10e94
    int32_t i_v11; // 0x10e94
    int32_t i_v12; // 0x10e94
    int32_t i_v13; // 0x10e94
    char i_v14;    // 0x10e94
    int32_t i_v15; // 0x10e94
    int32_t i_v16; // 0x10e94
    char i_v17;    // 0x10e94
    char i_v18;    // 0x10e94
    char i_v19;    // 0x10e94
    int32_t i_v20; // 0x10e94
    int32_t i_v21; // 0x10e94
    while (true) {
    lab_0x10ed4:;
        char i_v22 = i_v7;
        i_v20 = i_v4;
        i_v9 = i_v3;
        bool i_v23;    // 0x10e94
        char i_v24;    // 0x10e94
        int32_t i_v25; // 0x10e94
        char i_v26;    // 0x10e94
        if (i_v20 == 0) {
            unsigned char i_v27 = *(char *)(i_v1 + (int32_t)&p_g10);
            i_v23 = false;
            i_v24 = i_g128;
            i_v25 = __asm_sxtb((int32_t)i_v27) % 256 | 0x1991100;
            i_v26 = i_v27;
        } else {
            // 0x10f1a
            i_v23 = false;
            i_v24 = i_v8;
            i_v25 = 0;
            i_v26 = i_v6;
            if (i_v20 == 1) {
                unsigned char i_v28 = *(char *)(i_v1 + (int32_t)&p_g11);
                i_v23 = true;
                i_v24 = i_g129;
                i_v25 = __asm_sxtb((int32_t)i_v28) % 256 | 0x1991100;
                i_v26 = i_v28;
            }
        }
        // 0x10f5c
        i_v10 = i_v23;
        char i_v29 = i_v24;          // 0x10f60
        int32_t i_v30 = i_v25;       // 0x10f60
        unsigned char i_v31 = i_v26; // 0x10f60
        if (i_v9) {
            // 0x10f62
            i_v29 = i_g130;
            i_v31 = *(char *)(i_v1 + (int32_t)&p_g12);
            i_v30 = __asm_sxtb((int32_t)i_v31) % 256 | 0x1991100;
        }
        // 0x10f9e
        i_v19 = i_v31;
        i_v14 = i_v29;
        i_v7 = i_v22;
        i_v13 = i_v5;
        if (i_v14 == 0) {
            goto lab_0x112d6;
        } else {
            int32_t i_v32 = i_v30;
            int32_t i_v33 = enable_read_temperature_from_asic_chain(
                i_v1, i_g195 % 256 * (int32_t)(i_v14 - 1) % 256); // 0x10fc4
            i_v21 = (int32_t)i_v14 - 1;
            uint32_t i_v34 = 1;
            char i_v35 = i_v22;    // 0x10e94
            int32_t i_v36 = i_v33; // 0x10e94
            int32_t i_v37;         // 0x10ff6
            int32_t i_v38;         // 0x1102e
            switch (i_g115) {
            case 1722: {
                // 0x10fda
                i_v37 = check_BM1722_asic_reg(i_v1, i_g195 * i_v21, 32, 0);
                i_v35 = i_v37;
                i_v36 = i_v37;
                // break -> 0x11036
                break;
            }
            case 1725: {
                // 0x11012
                i_v38 = check_BM1725_asic_reg(i_v1, i_g195 * i_v21, 32, 0);
                i_v35 = i_v38;
                i_v36 = i_v38;
                // break -> 0x11036
                break;
            }
            }
            int32_t i_v39 = i_v36;
            char i_v40 = i_v35;
            while (i_v34 < 2 == i_v40 < 0) {
                // 0x10fc8
                i_v34 = 2;
                i_v35 = i_v40;
                i_v36 = i_v39;
                switch (i_g115) {
                case 1722: {
                    // 0x10fda
                    i_v37 = check_BM1722_asic_reg(i_v1, i_g195 * i_v21, 32, 0);
                    i_v35 = i_v37;
                    i_v36 = i_v37;
                    // break -> 0x11036
                    break;
                }
                case 1725: {
                    // 0x11012
                    i_v38 = check_BM1725_asic_reg(i_v1, i_g195 * i_v21, 32, 0);
                    i_v35 = i_v38;
                    i_v36 = i_v38;
                    // break -> 0x11036
                    break;
                }
                }
                // 0x11036
                i_v39 = i_v36;
                i_v40 = i_v35;
            }
            // 0x11056
            i_v16 = 0;
            i_v18 = i_v40;
            i_v12 = i_v39;
            switch (i_g115) {
            case 1722: {
                // 0x1106c
                i_v15 = 0;
                i_v17 = i_v40;
                i_v11 = set_BM1722_asic_register(i_v1, i_g195 * i_v21, 32, 0,
                                                 i_v32);
                goto lab_0x110c8_2;
            }
            case 1725: {
                // 0x110a4
                i_v15 = 0;
                i_v17 = i_v40;
                i_v11 = set_BM1725_asic_register(i_v1, i_g195 * i_v21, 32, 0,
                                                 i_v32);
                goto lab_0x110c8_2;
            }
            default: {
                goto lab_0x110c8;
            }
            }
        }
    }
    // 0x112e4
    return i_v5;
lab_0x112d6:
    // 0x112d6
    i_v5 = i_v13;
    i_v4 = i_v20 + 1;
    i_v3 = i_v4 == 2;
    i_v6 = i_v19;
    i_v8 = i_v14;
    if (i_v4 != 2 && i_v4 >= 2) {
        return i_v5;
    }
    goto lab_0x10ed4;
lab_0x110c8:;
    char i_v41 = i_v18;    // 0x10e94
    int32_t i_v42 = i_v12; // 0x10e94
    switch (i_g115) {
    case 1722: {
        int32_t i_v43 =
            check_BM1722_asic_reg(i_v1, i_g195 * i_v21, 32, 0); // 0x110f6
        i_v41 = i_v43;
        i_v42 = i_v43;
        // break -> 0x11136
        break;
    }
    case 1725: {
        int32_t i_v44 =
            check_BM1725_asic_reg(i_v1, i_g195 * i_v21, 32, 0); // 0x1112e
        i_v41 = i_v44;
        i_v42 = i_v44;
        // break -> 0x11136
        break;
    }
    }
    int32_t i_v45 = i_v42;
    char i_v46 = i_v41;
    int32_t i_v47 = i_v16 + 1; // 0x11138
    i_v15 = i_v47;
    i_v17 = i_v46;
    i_v11 = i_v45;
    int32_t i_v48; // 0x10e94
    int32_t i_v49; // 0x10e94
    int32_t i_v50; // 0x10e94
    int32_t i_v51; // 0x10e94
    char i_v52;    // 0x10e94
    char i_v53;    // 0x10e94
    if (i_v47 < 2 == i_v46 < 0) {
        goto lab_0x110c8_2;
    } else {
        // 0x11156
        i_v51 = 0;
        i_v53 = i_v46;
        i_v49 = i_v45;
        switch (i_g115) {
        case 1722: {
            // 0x1116c
            i_v50 = 0;
            i_v52 = i_v46;
            i_v48 = set_BM1722_asic_register(i_v1, i_g195 * i_v21, 32, 0,
                                             0x1981100);
            goto lab_0x111d4_2;
        }
        case 1725: {
            // 0x111aa
            i_v50 = 0;
            i_v52 = i_v46;
            i_v48 = set_BM1725_asic_register(i_v1, i_g195 * i_v21, 32, 0,
                                             0x1981100);
            goto lab_0x111d4_2;
        }
        default: {
            goto lab_0x111d4;
        }
        }
    }
lab_0x110c8_2:
    // 0x110c8
    i_v16 = i_v15;
    i_v18 = i_v17;
    i_v12 = i_v11;
    goto lab_0x110c8;
lab_0x111d4:;
    char i_v54 = i_v53;    // 0x10e94
    int32_t i_v55 = i_v49; // 0x10e94
    switch (i_g115) {
    case 1722: {
        int32_t i_v56 =
            check_BM1722_asic_reg(i_v1, i_g195 * i_v21, 32, 0); // 0x11202
        i_v54 = i_v56;
        i_v55 = i_v56;
        // break -> 0x11242
        break;
    }
    case 1725: {
        int32_t i_v57 =
            check_BM1725_asic_reg(i_v1, i_g195 * i_v21, 32, 0); // 0x1123a
        i_v54 = i_v57;
        i_v55 = i_v57;
        // break -> 0x11242
        break;
    }
    }
    int32_t i_v58 = i_v55;
    char i_v59 = i_v54;
    int32_t i_v60 = i_v51 + 1; // 0x11244
    i_v50 = i_v60;
    i_v52 = i_v59;
    i_v48 = i_v58;
    if (i_v60 < 2 == i_v59 < 0) {
        goto lab_0x111d4_2;
    } else {
        // 0x11262
        i_v7 = i_v19;
        i_v13 = i_v58;
        if (i_v59 != i_v19) {
            int32_t i_v61 = i_v58; // 0x1127a
            if (i_v20 == 0) {
                // 0x1127c
                *(char *)(i_v1 + (int32_t)&p_g159) = 0;
                i_v61 = puts("!!! sensor1 is error!\n");
            }
            int32_t i_v62 = i_v61; // 0x1129a
            if (i_v10) {
                // 0x1129c
                *(char *)(i_v1 + (int32_t)&p_g160) = 0;
                i_v62 = puts("!!! sensor2 is error!\n");
            }
            // 0x112b6
            i_v7 = i_v59;
            i_v13 = i_v62;
            if (i_v9) {
                // 0x112bc
                *(char *)(i_v1 + (int32_t)&p_g161) = 0;
                i_v7 = i_v59;
                i_v13 = puts("!!! sensor3 is error!\n");
            }
        }
        goto lab_0x112d6;
    }
lab_0x111d4_2:
    // 0x111d4
    i_v51 = i_v50;
    i_v53 = i_v52;
    i_v49 = i_v48;
    goto lab_0x111d4;
}

// Address range: 0x112ec - 0x11afe
int32_t read_asic_temperature(uint32_t i_a1) {
    uint32_t i_v1 = i_a1 % 256;
    char *p_v2 = (char *)(i_v1 + (int32_t)&p_g9); // 0x11320
    *p_v2 = 0;
    int32_t i_v3 = 4 * i_a1 & 1020;
    int32_t *p_v4 = (int32_t *)(i_v3 + (int32_t)&i_g15);
    int32_t *p_v5 = (int32_t *)(i_v3 + (int32_t)&i_g14);
    int32_t *p_v6 = (int32_t *)(i_v3 + (int32_t)&i_g13);
    char *p_v7 = (char *)(i_v1 + (int32_t)&p_g191);
    bool i_v8 = false;  // 0x112ec
    int32_t i_v9 = 0;   // 0x1179e
    int32_t i_v10 = -1; // 0x112ec
    char i_v11;         // 0x112ec
    int32_t i_v12;      // 0x112ec
    int32_t i_v13;      // 0x112ec
    char i_v14;         // 0x112ec
    int32_t i_v15;      // 0x112ec
    int32_t i_v16;      // 0x112ec
    int32_t i_v17;      // 0x112ec
    int32_t i_v18;      // 0x112ec
    int32_t i_v19;      // 0x112ec
    while (true) {
    lab_0x11328:;
        int32_t i_v20 = i_v10;
        i_v17 = i_v9;
        char i_v21 = i_v17 == 0 ? i_g128 : i_v14;
        i_v11 = i_v8 ? i_g130 : i_v17 == 1 ? i_g129 : i_v21;
        i_v10 = i_v20;
        if (i_v11 == 0) {
            goto lab_0x1179c;
        } else {
            // 0x1136c
            enable_read_temperature_from_asic_chain(
                i_v1, i_g195 % 256 * (int32_t)(i_v11 - 1) % 256);
            i_v18 = i_v11;
            i_v19 = i_v18 - 1;
            uint32_t i_v22 = 1;
            int32_t i_v23 = i_v20; // 0x112ec
            switch (i_g115) {
            case 1722: {
                // 0x113a0
                i_v23 = check_BM1722_asic_reg(i_v1, i_g195 * i_v19, 32, 0);
                // break -> 0x113fc
                break;
            }
            case 1725: {
                // 0x113d8
                i_v23 = check_BM1725_asic_reg(i_v1, i_g195 * i_v19, 32, 0);
                // break -> 0x113fc
                break;
            }
            }
            int32_t i_v24 = i_v23;
            while (i_v22 < 2 == i_v24 > 0x3fffffff) {
                // 0x1138e
                i_v22 = 2;
                i_v23 = i_v24;
                switch (i_g115) {
                case 1722: {
                    // 0x113a0
                    i_v23 = check_BM1722_asic_reg(i_v1, i_g195 * i_v19, 32, 0);
                    // break -> 0x113fc
                    break;
                }
                case 1725: {
                    // 0x113d8
                    i_v23 = check_BM1725_asic_reg(i_v1, i_g195 * i_v19, 32, 0);
                    // break -> 0x113fc
                    break;
                }
                }
                // 0x113fc
                i_v24 = i_v23;
            }
            // 0x1141c
            i_v13 = i_v24;
            i_v16 = 0;
            switch (i_g115) {
            case 1722: {
                // 0x11432
                set_BM1722_asic_register(i_v1, i_g195 * i_v19, 32, 0,
                                         0x1980100);
                i_v12 = i_v24;
                i_v15 = 0;
                goto lab_0x1149a_2;
            }
            case 1725: {
                // 0x11470
                set_BM1725_asic_register(i_v1, i_g195 * i_v19, 32, 0,
                                         0x1980100);
                i_v12 = i_v24;
                i_v15 = 0;
                goto lab_0x1149a_2;
            }
            default: {
                goto lab_0x1149a;
            }
            }
        }
    }
lab_0x117aa:;
    int32_t *p_v25 = (int32_t *)(i_v3 + (int32_t)&i_g16); // 0x117e4
    int32_t *p_v26 = (int32_t *)(i_v3 + (int32_t)&i_g17); // 0x117f4
    int32_t *p_v27 = (int32_t *)(i_v3 + (int32_t)&i_g18); // 0x11804
    uint32_t i_v28 =
        *p_v5 + *p_v6 + *p_v4 - *p_v25 - *p_v26 - *p_v27; // 0x11808
    *(int32_t *)(i_v3 + (int32_t)&i_g22) = i_v28 / i_g197;
    if (i_g197 <= i_v28) {
        // 0x11852
        *p_v25 = *p_v6;
        *p_v26 = *p_v5;
        *p_v27 = *p_v4;
    }
    int32_t i_v29 = *p_v6;                                // 0x118b2
    int32_t *p_v30 = (int32_t *)(i_v3 + (int32_t)&i_g19); // 0x118be
    *p_v30 = i_v29;
    int32_t i_v31 = *p_v5; // 0x118cc
    int32_t i_v32 = i_v31 > i_v29 ? i_v31 : i_v29;
    *p_v30 = i_v32;
    int32_t i_v33 = *p_v4; // 0x11908
    *p_v30 = i_v33 > i_v32 ? i_v33 : i_v32;
    int32_t i_v34 = *p_v6;                                // 0x11946
    int32_t *p_v35 = (int32_t *)(i_v3 + (int32_t)&i_g20); // 0x11952
    *p_v35 = i_v34;
    int32_t i_v36 = *p_v5; // 0x11960
    int32_t i_v37 = i_v36 >= i_v34 | i_v36 == 0 ? i_v34 : i_v36;
    *p_v35 = i_v37;
    int32_t i_v38 = *p_v4; // 0x119ae
    *p_v35 = i_v38 == 0 | i_v38 >= i_v37 ? i_v37 : i_v38;
    int32_t i_v39 = *p_v30;                               // 0x119fc
    int32_t *p_v40 = (int32_t *)(i_v3 + (int32_t)&i_g21); // 0x11a0a
    int32_t i_v41 = *p_v40;                               // 0x11a0a
    int32_t i_v42 = i_v41;                                // 0x11a10
    if (i_v39 > i_v41) {
        // 0x11a12
        *p_v40 = i_v39;
        i_v42 = i_v39;
    }
    int32_t i_v43 = printf("\ngGlobalHighestTemp is %d\n\n", i_v42); // 0x11a46
    int32_t i_v44 = *p_v30;                                          // 0x11a54
    int32_t i_v45 = i_v44;                                           // 0x11a66
    if (i_v44 > (int32_t)i_g134) {
        // 0x11a68
        *(char *)(i_v1 + (int32_t)&p_g23) = 1;
        i_v45 = *p_v30;
    }
    int32_t i_v46 = i_v45 - *p_v35; // 0x11a92
    uint32_t i_v47 = i_g136;        // 0x11aa0
    if (i_v46 == i_v47 || i_v46 < i_v47) {
        // 0x11af6
        return i_v43;
    }
    // 0x11aa8
    *(char *)(i_v1 + (int32_t)&p_g24) = 1;
    int32_t *p_v48 = (int32_t *)(i_v3 + (int32_t)&i_g25); // 0x11ac0
    int32_t i_v49 = i_v43;                                // 0x11ac8
    if (*p_v48 < i_v46) {
        // 0x11aca
        *p_v48 = i_v46;
        i_v49 = printf("gMaxTempGap_value is %d\n\n", i_v46);
    }
    // 0x11af6
    return i_v49;
lab_0x1179c:
    // 0x1179c
    i_v9 = i_v17 + 1;
    i_v8 = i_v9 == 2;
    i_v14 = i_v11;
    if (i_v9 != 2 && i_v9 >= 2) {
        // break -> 0x117aa
        goto lab_0x117aa;
    }
    goto lab_0x11328;
lab_0x1149a:;
    int32_t i_v50 = i_v13; // 0x112ec
    switch (i_g115) {
    case 1722: {
        // 0x114ac
        i_v50 = check_BM1722_asic_reg(i_v1, i_g195 * i_v19, 32, 0);
        // break -> 0x11508
        break;
    }
    case 1725: {
        // 0x114e4
        i_v50 = check_BM1725_asic_reg(i_v1, i_g195 * i_v19, 32, 0);
        // break -> 0x11508
        break;
    }
    }
    int32_t i_v51 = i_v50;
    int32_t i_v52 = i_v16 + 1; // 0x1150a
    i_v12 = i_v51;
    i_v15 = i_v52;
    int32_t i_v53; // 0x112ec
    int32_t i_v54; // 0x112ec
    int32_t i_v55; // 0x112ec
    int32_t i_v56; // 0x112ec
    if (i_v52 < 2 == i_v51 > 0x3fffffff) {
        goto lab_0x1149a_2;
    } else {
        if (i_v51 < 0x40000000) {
            uint32_t i_v57 = i_v51 % 256; // 0x11538
            printf("\n\nASIC %d TEMP is : %d\n", i_v18, i_v57);
            switch (i_v17) {
            case 0: {
                // 0x11552
                *p_v6 = i_v57;
                // break -> 0x1158e
                break;
            }
            case 1: {
                // 0x11568
                *p_v5 = i_v57;
                // break -> 0x1158e
                break;
            }
            case 2: {
                // 0x1157e
                *p_v4 = i_v57;
                // break -> 0x1158e
                break;
            }
            }
            // 0x1158e
            if ((int32_t)i_g131 == i_v18) {
                uint32_t i_v58 = (int32_t)i_g132; // 0x115aa
                char i_v59 = *p_v7;
                if (i_v57 < i_v58) {
                    if (i_v59 != 1) {
                        // 0x11602
                        printf("\nASIC %d temperature is %d, waiting it raise "
                               "to start temperature %d\n\n",
                               i_v18, i_v57, i_v58);
                    }
                } else {
                    if (i_v59 != 1) {
                        // 0x115cc
                        printf("\nBegin test!!! Start sensor is %d, ASIC "
                               "temperature is %d\n\n",
                               i_v18, i_v57);
                    }
                    // 0x115dc
                    *p_v7 = 1;
                }
            }
        } else {
            // 0x11620
            printf("%s: do not read out ASIC %d temperature\n\n",
                   "read_asic_temperature", i_v18);
            *p_v2 = 1;
        }
        // 0x11644
        i_v54 = i_v51;
        i_v56 = 0;
        switch (i_g115) {
        case 1722: {
            // 0x11656
            set_BM1722_asic_register(i_v1, i_g195 * i_v19, 32, 0, 0x1980000);
            i_v53 = i_v51;
            i_v55 = 0;
            goto lab_0x116b6_2;
        }
        case 1725: {
            // 0x11690
            set_BM1725_asic_register(i_v1, i_g195 * i_v19, 32, 0, 0x1980000);
            i_v53 = i_v51;
            i_v55 = 0;
            goto lab_0x116b6_2;
        }
        default: {
            goto lab_0x116b6;
        }
        }
    }
lab_0x1149a_2:
    // 0x1149a
    i_v13 = i_v12;
    i_v16 = i_v15;
    goto lab_0x1149a;
lab_0x116b6:;
    int32_t i_v60 = i_v54; // 0x112ec
    switch (i_g115) {
    case 1722: {
        // 0x116c8
        i_v60 = check_BM1722_asic_reg(i_v1, i_g195 * i_v19, 32, 0);
        // break -> 0x11724
        break;
    }
    case 1725: {
        // 0x11700
        i_v60 = check_BM1725_asic_reg(i_v1, i_g195 * i_v19, 32, 0);
        // break -> 0x11724
        break;
    }
    }
    int32_t i_v61 = i_v60;
    int32_t i_v62 = i_v56 + 1; // 0x11726
    i_v53 = i_v61;
    i_v55 = i_v62;
    if (i_v62 < 2 == i_v61 > 0x3fffffff) {
        goto lab_0x116b6_2;
    } else {
        if (i_v61 < 0x40000000) {
            // 0x11752
            printf("ASIC %d Hash Board temperature is %d\n\n", i_v18,
                   i_v61 % 256);
            i_v10 = i_v61;
        } else {
            // 0x11778
            printf("%s: do not read out ASIC %d Hash Board temperature\n\n",
                   "read_asic_temperature", i_v18);
            *p_v2 = 1;
            i_v10 = i_v61;
        }
        goto lab_0x1179c;
    }
lab_0x116b6_2:
    // 0x116b6
    i_v54 = i_v53;
    i_v56 = i_v55;
    goto lab_0x116b6;
}

// Address range: 0x11b00 - 0x11b9e
int32_t test_eeprom(void) {
    char i_v1 = -112; // bp-13, 0x11b08
    char i_v2 = 90;   // bp-14, 0x11b0c
    char i_v3 = -91;  // bp-15, 0x11b10
    printf("test_set_eeprom_val = %x\n", 90);
    iic_write_reg(i_g37, &i_v1, 1, &i_v2, 1);
    usleep((int32_t)&i_g239 | 0x10000);
    int32_t i_v4 = iic_read_reg(i_g37, &i_v1, 1, &i_v3, 1); // 0x11b66
    int32_t i_v5 = 0;                                       // 0x11b70
    if (i_v4 == 1) {
        // 0x11b72
        printf("test_get_eeprom_val = %x\n", (int32_t)i_v3);
        i_v5 = i_v3 == i_v2;
    }
    // 0x11b94
    return i_v5;
}

// Address range: 0x11ba0 - 0x11bd8
int32_t save_eeprom_N(int32_t i_a1, int32_t i_a2) {
    int32_t i_v1 = 0x1000000 * i_a1 >> 24; // bp-17, 0x11baa
    char i_v2 = i_a2;                      // bp-9, 0x11bb0
    return iic_write_reg(i_g37, (char *)&i_v1, 1, &i_v2, 1);
}

// Address range: 0x11bd8 - 0x11c1c
int32_t get_eeprom_N(int32_t i_a1, int32_t *p_a2) {
    int32_t i_v1 = 0x1000000 * i_a1 >> 24; // bp-17, 0x11be2
    int32_t i_v2 =
        iic_read_reg(i_g37, (char *)&i_v1, 1, (char *)p_a2, 1); // 0x11c00
    return i_v2 == 1;
}

// Address range: 0x11c1c - 0x11cb0
int32_t save_byte_to_eeprom(uint32_t i_a1, uint32_t i_a2) {
    uint32_t i_v1 = i_a1 % 256; // 0x11c2e
    save_eeprom_N(i_v1, i_a2 % 256);
    usleep((int32_t)&i_g207);
    int32_t i_v2; // bp-10, 0x11c1c
    if (get_eeprom_N(i_v1, &i_v2) == 0) {
        // 0x11c94
        puts("Get value from eeprom Error");
        // 0x11ca4
        return 0;
    }
    uint32_t i_v3 = 0x1000000 * i_a2 / 0x1000000; // 0x11c28
    printf("The value write to eeprom : 0x%02X\n", i_v3 % 256);
    printf("The value get from eeprom : 0x%02X\n", i_v2 % 256);
    int32_t i_v4 = 1; // 0x11c80
    if ((i_v2 ^ i_v3) % 256 != 0) {
        // 0x11c82
        puts("Save eeprom Error");
        i_v4 = 0;
    }
    // 0x11ca4
    return i_v4;
}

// Address range: 0x11cb0 - 0x11d74
int32_t save_voltage_info_to_eeprom(int32_t i_a1, int32_t i_a2) {
    int32_t i_v1 = 85; // bp-24, 0x11cd0
    CRC5((char *)&i_v1, 40);
    if (test_eeprom() == 0) {
        // 0x11d68
        return 0;
    }
    int32_t i_v2 = 0;                                               // 0x11d5e
    unsigned char i_v3 = *(char *)(i_v2 + (int32_t)&i_v1);          // 0x11d34
    uint32_t i_v4 = save_byte_to_eeprom(i_v2 + 154, (int32_t)i_v3); // 0x11d3a
    while (i_v4 % 256 == 1) {
        // 0x11d62
        i_v2++;
        if (i_v2 >= 6) {
            return i_v4;
        }
        i_v3 = *(char *)(i_v2 + (int32_t)&i_v1);
        i_v4 = save_byte_to_eeprom(i_v2 + 154, (int32_t)i_v3);
    }
    // 0x11d4e
    puts("save_voltage_info_to_eeprom failed!");
lab_0x11d68_2:
    // 0x11d68
    return i_v4;
}

// Address range: 0x11d74 - 0x11d78
int32_t function_11d74(void) {
    // 0x11d74
    int32_t i_v1; // 0x11d74
    return i_v1;
}

// Address range: 0x11d78 - 0x11e78
int32_t open_i2c(void) {
    int32_t i_v1 = (int32_t) * (char *)&p_g155; // 0x11d86
    char *p_v2 = (char *)i_v1;                  // bp-16, 0x11d88
    printf("--- %s on 7007, slave high = 0x%x, low = 0x%x\n", "open_i2c", 4,
           i_v1);
    i_g35 = iic_init((int32_t *)&p_v2);
    char *p_v3 = (char *)(int32_t) * (char *)&p_g155; // bp-24, 0x11dd8
    printf("--- %s on 7007, slave high = 0x%x, low = 0x%x\n", "open_i2c", 2, 0);
    i_g36 = iic_init((int32_t *)&p_v3);
    int32_t i_v4 = (int32_t) * (char *)&p_g155; // 0x11e1e
    char *p_v5 = (char *)i_v4;                  // bp-32, 0x11e20
    printf("--- %s on 7007, slave high = 0x%x, low = 0x%x\n", "open_i2c", 10,
           i_v4);
    i_g37 = iic_init((int32_t *)&p_v5);
    return i_g35;
}

// Address range: 0x11e78 - 0x11ec6
int32_t close_i2c(void) {
    // 0x11e78
    printf("--- %s\n", "close_i2c");
    iic_uninit(i_g37);
    iic_uninit(i_g36);
    iic_uninit(i_g35);
    return 0;
}

// Address range: 0x11ec8 - 0x11ef2
int32_t iic_i2c_write(char *p_a1, int32_t i_a2) {
    // 0x11ec8
    return iic_write(i_g35, (int32_t)p_a1, i_a2);
}

// Address range: 0x11ef4 - 0x11f1e
int32_t iic_i2c_read(char *p_a1, int32_t i_a2) {
    // 0x11ef4
    return iic_read(i_g35, (int32_t)p_a1, i_a2);
}

// Address range: 0x11f20 - 0x11f58
int32_t iic_i2c_write_reg(int32_t i_a1, int32_t *p_a2, int32_t i_a3) {
    int32_t i_v1 = 0x1000000 * i_a1 >> 24; // bp-9, 0x11f2c
    return iic_write_reg(i_g36, (char *)&i_v1, 1, (char *)p_a2, i_a3);
}

// Address range: 0x11f58 - 0x11f90
int32_t iic_i2c_read_reg(int32_t i_a1, int32_t *p_a2, int32_t i_a3) {
    int32_t i_v1 = 0x1000000 * i_a1 >> 24; // bp-9, 0x11f64
    return iic_read_reg(i_g36, (char *)&i_v1, 1, (char *)p_a2, i_a3);
}

// Address range: 0x11f90 - 0x12034
int32_t dcr_uart_send(uint32_t i_a1, char *p_a2, int32_t i_a3) {
    uint32_t i_v1 = i_a1 % 256;
    int32_t i_v2; // 0x11f90
    if (i_v1 == 255) {
        // 0x11fba
        printf("%s: invalid chain id\n", "dcr_uart_send");
        i_v2 = -1;
    } else {
        // 0x11fd4
        int32_t i_v3; // bp-524, 0x11f90
        memset(&i_v3, 0, 512);
        i_v3 = 85;
        int32_t i_v4; // bp-522, 0x11f90
        memcpy(&i_v4, (int32_t *)p_a2, i_a3);
        i_v2 = uart_send(i_v1, &i_v3, i_a3 + 2);
    }
    // 0x1202a
    return i_v2;
}

// Address range: 0x12034 - 0x12068
int32_t uart_set_baud(uint32_t i_a1, int32_t i_a2) {
    int32_t i_v1 = i_a2; // bp-16, 0x1203c
    printf("uart_set_config %d \n", i_a2);
    return uart_set_config(i_a1 % 256, 0, &i_v1, 4);
}

// Address range: 0x12068 - 0x12108
int32_t key_callback(int32_t i_a1, int32_t i_a2) {
    char **p_v1 = (char **)"reset"; // bp-16, 0x12082
    int32_t i_v2;                   // 0x12068
    int32_t i_v3;                   // bp-8, 0x12068
    switch (i_a2) {
    case 0: {
        int32_t i_v4 =
            *(int32_t *)(4 * i_a1 - 1032 + (int32_t)&i_v3); // 0x120a0
        i_g38 = 1;
        i_v2 = printf("%s key pressed\n", (char *)i_v4);
        // break -> 0x120f0
        break;
    }
    case 1: {
        int32_t i_v5 =
            *(int32_t *)(4 * i_a1 - 1032 + (int32_t)&i_v3); // 0x120ce
        i_g38 = 0;
        i_v2 = printf("%s key up\n", (char *)i_v5);
        // break -> 0x120f0
        break;
    }
    default: {
        int32_t i_v6 = __asm_nop((int32_t) "reset", (int32_t) "ipreport",
                                 (int32_t)&p_v1, i_a2); // 0x120ee
        i_v2 = i_v6;
        // break -> 0x120f0
        break;
    }
    }
    int32_t i_v7 = i_v2; // 0x120f6
    if (i_a1 == 256) {
        // 0x120f8
        i_v7 = green_led_off(red_led_off());
    }
    // 0x12100
    return i_v7;
}

// Address range: 0x12108 - 0x1211e
int32_t open_key(void) {
    // 0x12108
    reg_key_callback(0x12069);
    return 1;
}

// Address range: 0x12120 - 0x12134
int32_t close_key(void) {
    // 0x12120
    int32_t i_v1; // 0x12120
    return __asm_nop(unreg_key_callback(0x12069), i_v1, i_v1, i_v1);
}

// Address range: 0x12134 - 0x1215a
int32_t read_key(int32_t *p_a1) {
    // 0x12134
    *(char *)p_a1 = (char)i_g38;
    return 1;
}

// Address range: 0x1215c - 0x12180
int32_t write_lcd(int32_t i_a1, int32_t i_a2, int32_t i_a3) {
    // 0x1215c
    lcd_clear_result();
    return lcd_show_result(i_a1, i_a2, i_a3);
}

// Address range: 0x12180 - 0x121a0
int32_t write_lcd_no_memset(int32_t i_a1, int32_t *p_a2, int32_t i_a3) {
    // 0x12180
    return lcd_show_result(i_a1, (int32_t)p_a2, i_a3);
}

// Address range: 0x121a0 - 0x1224c
int32_t c2hex(uint32_t i_a1) {
    uint32_t i_v1 = (int32_t)(0x1000000 * i_a1) >> 24; // 0x121a8
    uint32_t i_v2 = i_a1 % 256;                        // 0x121ae
    if (i_v2 != 47 && i_v2 >= 47) {
        uint32_t i_v3 = i_v1 % 256; // 0x121b4
        if (i_v3 >= 57 != i_v3 != 57) {
            // 0x12240
            return i_v1 % 16;
        }
    }
    char i_v4 = i_v1;
    switch (i_v4) {
    case 97: {
    }
    case 65: {
        // 0x12240
        return 10;
    }
    case 98: {
    }
    case 66: {
        // 0x12240
        return 11;
    }
    case 99: {
    }
    case 67: {
        // 0x12240
        return 12;
    }
    case 100: {
    }
    case 68: {
        // 0x12240
        return 13;
    }
    case 101: {
    }
    case 69: {
        // 0x12240
        return 14;
    }
    case 102: {
    }
    case 70: {
        // 0x12240
        return 15;
    }
    }
    // 0x12230
    printf("input value error: %c\n", i_v4);
    // 0x12240
    return 255;
}

// Address range: 0x1224c - 0x12290
int32_t twoc2hex(uint32_t i_a1, uint32_t i_a2) {
    int32_t i_v1 = c2hex(i_a1 % 256); // 0x12262
    return c2hex(i_a2 % 256) % 256 ^ 16 * i_v1 & 240;
}

// Address range: 0x12290 - 0x12366
int32_t s2hex(int32_t i_a1, int32_t i_a2, int32_t i_a3) {
    if (i_a1 == 0 || i_a2 == 0 || i_a3 < 1) {
        // 0x122ba
        printf("s2hex para error dst(%p), src(%p), inlen(%d)\n",
               (int32_t *)i_a1, (int32_t *)i_a2, i_a3);
        // 0x1235c
        return -1;
    }
    int32_t i_v1 = i_a3 % 2; // 0x122e8
    if (i_v1 != 0) {
        // 0x12336
        *(char *)i_a1 = (char)twoc2hex((int32_t) * (char *)i_a2, 0);
    }
    // 0x1235c
    return i_v1;
}

// Address range: 0x12368 - 0x12562
int32_t print_works(void) {
    // 0x12368
    printf("\n%s begin\n\n", "print_works");
    int32_t i_v1; // 0x12368
    switch (i_g113) {
    case 1: {
        // 0x1243a
        i_v1 = 0;
        if (i_g114 != 0) {
            int32_t i_v2 = 0;
            int32_t i_v3 =
                *(int32_t *)(4 * i_v2 + (int32_t)&i_g76 + 0x800a0); // 0x123b2
            int32_t i_v4 = 0;                                       // 0x1242c
            int32_t i_v5;                                           // 0x123c8
            int32_t i_v6;                                           // 0x1241a
            uint32_t i_v7;                                          // 0x12426
            if (i_g110 != 0) {
                i_v5 = 204 * i_v4 + i_v3;
                printf("core[%02d][%02d].work=0x", i_v2, i_v4);
                for (int32_t i_v8 = 0; i_v8 < 180; i_v8++) {
                    // 0x123e2
                    printf("%02x", (int32_t) * (char *)(i_v5 + 8 + i_v8));
                }
                // 0x12406
                printf(" nonce=0x%08x\n", *(int32_t *)(i_v5 + 4));
                i_v6 = i_v4 + 1;
                i_v7 = i_g110;
                i_v4 = i_v6;
                while (i_v7 >= i_v6 == (i_v7 != i_v6)) {
                    // 0x123be
                    i_v5 = 204 * i_v4 + i_v3;
                    printf("core[%02d][%02d].work=0x", i_v2, i_v4);
                    for (int32_t i_v8 = 0; i_v8 < 180; i_v8++) {
                        // 0x123e2
                        printf("%02x", (int32_t) * (char *)(i_v5 + 8 + i_v8));
                    }
                    // 0x12406
                    printf(" nonce=0x%08x\n", *(int32_t *)(i_v5 + 4));
                    i_v6 = i_v4 + 1;
                    i_v7 = i_g110;
                    i_v4 = i_v6;
                }
            }
            // 0x1242e
            putchar(10);
            int32_t i_v9 = i_v2 + 1; // 0x12436
            uint32_t i_v10 = i_g114; // 0x12442
            i_v1 = i_v9;
            while (i_v10 >= i_v9 == (i_v10 != i_v9)) {
                // 0x123a2
                i_v2 = i_v9;
                i_v3 = *(int32_t *)(4 * i_v2 + (int32_t)&i_g76 + 0x800a0);
                i_v4 = 0;
                if (i_g110 != 0) {
                    i_v5 = 204 * i_v4 + i_v3;
                    printf("core[%02d][%02d].work=0x", i_v2, i_v4);
                    for (int32_t i_v8 = 0; i_v8 < 180; i_v8++) {
                        // 0x123e2
                        printf("%02x", (int32_t) * (char *)(i_v5 + 8 + i_v8));
                    }
                    // 0x12406
                    printf(" nonce=0x%08x\n", *(int32_t *)(i_v5 + 4));
                    i_v6 = i_v4 + 1;
                    i_v7 = i_g110;
                    i_v4 = i_v6;
                    while (i_v7 >= i_v6 == (i_v7 != i_v6)) {
                        // 0x123be
                        i_v5 = 204 * i_v4 + i_v3;
                        printf("core[%02d][%02d].work=0x", i_v2, i_v4);
                        for (int32_t i_v8 = 0; i_v8 < 180; i_v8++) {
                            // 0x123e2
                            printf("%02x",
                                   (int32_t) * (char *)(i_v5 + 8 + i_v8));
                        }
                        // 0x12406
                        printf(" nonce=0x%08x\n", *(int32_t *)(i_v5 + 4));
                        i_v6 = i_v4 + 1;
                        i_v7 = i_g110;
                        i_v4 = i_v6;
                    }
                }
                // 0x1242e
                putchar(10);
                i_v9 = i_v2 + 1;
                i_v10 = i_g114;
                i_v1 = i_v9;
            }
        }
        // break -> 0x1244a
        break;
    }
    case 0: {
        // 0x12544
        printf("\n%s end\n\n", "print_works");
        // 0x12558
        return 0;
    }
    default: {
        int32_t i_v11 = 0;
        int32_t i_v12 =
            *(int32_t *)(4 * i_v11 + (int32_t)&i_g76 + 0x800a0); // 0x12476
        int32_t i_v13;                                           // 0x12368
        int32_t i_v14;                                           // 0x12368
        int32_t i_v15;                                           // 0x12514
        uint32_t i_v16;                                          // 0x12520
        int32_t i_v17;                                           // 0x124a4
        int32_t i_v18;                                           // 0x124f8
        int32_t i_v19;                                           // 0x12504
        if (i_g114 != 0) {
            i_v13 = 0;
            i_v14 = 0;
            if (i_g110 != 0) {
                i_v17 = 204 * (i_g110 * i_v13 + i_v14) + i_v12;
                printf("asic[%02d][%02d][%02d].work=0x", i_v11, i_v13, i_v14);
                for (int32_t i_v20 = 0; i_v20 < 180; i_v20++) {
                    // 0x124c0
                    printf("%02x", (int32_t) * (char *)(i_v17 + 8 + i_v20));
                }
                // 0x124e4
                printf(" nonce=0x%08x\n", *(int32_t *)(i_v17 + 4));
                i_v18 = i_v14 + 1;
                i_v19 = i_g110;
                i_v14 = i_v18;
                while (i_v19 >= i_v18 == (i_v19 != i_v18)) {
                    // 0x12488
                    i_v17 = 204 * (i_v19 * i_v13 + i_v14) + i_v12;
                    printf("asic[%02d][%02d][%02d].work=0x", i_v11, i_v13,
                           i_v14);
                    for (int32_t i_v20 = 0; i_v20 < 180; i_v20++) {
                        // 0x124c0
                        printf("%02x", (int32_t) * (char *)(i_v17 + 8 + i_v20));
                    }
                    // 0x124e4
                    printf(" nonce=0x%08x\n", *(int32_t *)(i_v17 + 4));
                    i_v18 = i_v14 + 1;
                    i_v19 = i_g110;
                    i_v14 = i_v18;
                }
            }
            // 0x1250c
            putchar(10);
            i_v15 = i_v13 + 1;
            i_v16 = i_g114;
            while (i_v16 >= i_v15 == (i_v16 != i_v15)) {
                // 0x124fc
                i_v13 = i_v15;
                i_v14 = 0;
                if (i_g110 != 0) {
                    i_v17 = 204 * (i_g110 * i_v13 + i_v14) + i_v12;
                    printf("asic[%02d][%02d][%02d].work=0x", i_v11, i_v13,
                           i_v14);
                    for (int32_t i_v20 = 0; i_v20 < 180; i_v20++) {
                        // 0x124c0
                        printf("%02x", (int32_t) * (char *)(i_v17 + 8 + i_v20));
                    }
                    // 0x124e4
                    printf(" nonce=0x%08x\n", *(int32_t *)(i_v17 + 4));
                    i_v18 = i_v14 + 1;
                    i_v19 = i_g110;
                    i_v14 = i_v18;
                    while (i_v19 >= i_v18 == (i_v19 != i_v18)) {
                        // 0x12488
                        i_v17 = 204 * (i_v19 * i_v13 + i_v14) + i_v12;
                        printf("asic[%02d][%02d][%02d].work=0x", i_v11, i_v13,
                               i_v14);
                        for (int32_t i_v20 = 0; i_v20 < 180; i_v20++) {
                            // 0x124c0
                            printf("%02x",
                                   (int32_t) * (char *)(i_v17 + 8 + i_v20));
                        }
                        // 0x124e4
                        printf(" nonce=0x%08x\n", *(int32_t *)(i_v17 + 4));
                        i_v18 = i_v14 + 1;
                        i_v19 = i_g110;
                        i_v14 = i_v18;
                    }
                }
                // 0x1250c
                putchar(10);
                i_v15 = i_v13 + 1;
                i_v16 = i_g114;
            }
        }
        // 0x12528
        putchar(10);
        int32_t i_v21 = i_v11 + 1; // 0x12530
        uint32_t i_v22 = i_g113;   // 0x1253c
        int32_t i_v23 = i_v21;     // 0x12542
        while (i_v22 >= i_v21 == (i_v22 != i_v21)) {
            // 0x12466
            i_v11 = i_v21;
            i_v12 = *(int32_t *)(4 * i_v11 + (int32_t)&i_g76 + 0x800a0);
            if (i_g114 != 0) {
                i_v13 = 0;
                i_v14 = 0;
                if (i_g110 != 0) {
                    i_v17 = 204 * (i_g110 * i_v13 + i_v14) + i_v12;
                    printf("asic[%02d][%02d][%02d].work=0x", i_v11, i_v13,
                           i_v14);
                    for (int32_t i_v20 = 0; i_v20 < 180; i_v20++) {
                        // 0x124c0
                        printf("%02x", (int32_t) * (char *)(i_v17 + 8 + i_v20));
                    }
                    // 0x124e4
                    printf(" nonce=0x%08x\n", *(int32_t *)(i_v17 + 4));
                    i_v18 = i_v14 + 1;
                    i_v19 = i_g110;
                    i_v14 = i_v18;
                    while (i_v19 >= i_v18 == (i_v19 != i_v18)) {
                        // 0x12488
                        i_v17 = 204 * (i_v19 * i_v13 + i_v14) + i_v12;
                        printf("asic[%02d][%02d][%02d].work=0x", i_v11, i_v13,
                               i_v14);
                        for (int32_t i_v20 = 0; i_v20 < 180; i_v20++) {
                            // 0x124c0
                            printf("%02x",
                                   (int32_t) * (char *)(i_v17 + 8 + i_v20));
                        }
                        // 0x124e4
                        printf(" nonce=0x%08x\n", *(int32_t *)(i_v17 + 4));
                        i_v18 = i_v14 + 1;
                        i_v19 = i_g110;
                        i_v14 = i_v18;
                    }
                }
                // 0x1250c
                putchar(10);
                i_v15 = i_v13 + 1;
                i_v16 = i_g114;
                while (i_v16 >= i_v15 == (i_v16 != i_v15)) {
                    // 0x124fc
                    i_v13 = i_v15;
                    i_v14 = 0;
                    if (i_g110 != 0) {
                        i_v17 = 204 * (i_g110 * i_v13 + i_v14) + i_v12;
                        printf("asic[%02d][%02d][%02d].work=0x", i_v11, i_v13,
                               i_v14);
                        for (int32_t i_v20 = 0; i_v20 < 180; i_v20++) {
                            // 0x124c0
                            printf("%02x",
                                   (int32_t) * (char *)(i_v17 + 8 + i_v20));
                        }
                        // 0x124e4
                        printf(" nonce=0x%08x\n", *(int32_t *)(i_v17 + 4));
                        i_v18 = i_v14 + 1;
                        i_v19 = i_g110;
                        i_v14 = i_v18;
                        while (i_v19 >= i_v18 == (i_v19 != i_v18)) {
                            // 0x12488
                            i_v17 = 204 * (i_v19 * i_v13 + i_v14) + i_v12;
                            printf("asic[%02d][%02d][%02d].work=0x", i_v11,
                                   i_v13, i_v14);
                            for (int32_t i_v20 = 0; i_v20 < 180; i_v20++) {
                                // 0x124c0
                                printf("%02x",
                                       (int32_t) * (char *)(i_v17 + 8 + i_v20));
                            }
                            // 0x124e4
                            printf(" nonce=0x%08x\n", *(int32_t *)(i_v17 + 4));
                            i_v18 = i_v14 + 1;
                            i_v19 = i_g110;
                            i_v14 = i_v18;
                        }
                    }
                    // 0x1250c
                    putchar(10);
                    i_v15 = i_v13 + 1;
                    i_v16 = i_g114;
                }
            }
            // 0x12528
            putchar(10);
            i_v21 = i_v11 + 1;
            i_v22 = i_g113;
            i_v23 = i_v21;
        }
        // 0x12544
        printf("\n%s end\n\n", "print_works");
        // 0x12558
        return i_v23;
    }
    }
    // 0x1244a
    printf("\n%s end\n\n", "print_works");
    // 0x12558
    return i_v1;
}

// Address range: 0x12564 - 0x1271c
int32_t get_work(int32_t i_a1, int32_t i_a2, int32_t i_a3, uint32_t i_a4) {
    // 0x12564
    int32_t i_v1; // bp-1056, 0x12564
    memset(&i_v1, 0, 1024);
    struct _IO_FILE *p_v2 = (struct _IO_FILE *)i_a3; // 0x126da
    char *p_v3 = fgets((char *)&i_v1, 1023, p_v2);   // 0x126da
    if (p_v3 == NULL) {
        // 0x1270e
        return 0;
    }
    char *p_v4 = p_v3; // 0x125ac
    int32_t i_v5 = 0;  // 0x125ac
    if (i_a4 == 0) {
    lab_0x126e8:
        // 0x126e8
        __asm_nop((int32_t)p_v4, 1023, i_a4, i_v5);
        // 0x1270e
        return i_v5;
    }
    int32_t i_v6 = 0;
    int32_t i_v7 =
        *(int32_t *)(4 * i_a1 + (int32_t)&i_g76 + 0x800a0); // 0x125c4
    int32_t i_v8 = i_v7 + 204 * (i_v6 + i_a4 * i_a2);       // 0x125e4
    char *p_v9 =
        strstr((char *)&i_v1, (char *)((int32_t)&p_g298 | 0x20000)); // 0x125f8
    int32_t i_v10 = (int32_t)p_v9;                                   // 0x125f8
    while (p_v9 != NULL) {
        int32_t i_v11 = i_v10 + 5;
        int32_t i_v12 = i_v11 + 1; // 0x12626
        while (*(char *)i_v11 == 32) {
            // 0x1261e
            i_v11 = i_v12;
            i_v12 = i_v11 + 1;
        }
        // 0x12628
        s2hex(i_v8 + 4, i_v11, 8);
        char *p_v13 = strstr((char *)&i_v1, "work"); // 0x12648
        int32_t i_v14 = (int32_t)p_v13;              // 0x12648
        if (p_v13 == NULL) {
            // 0x126f4
            __asm_nop(i_v14, (int32_t) "work", 8, i_v14);
            goto lab_0x126f6;
        }
        int32_t i_v15 = i_v14 + 4;
        int32_t i_v16 = i_v15 + 1; // 0x12676
        while (*(char *)i_v15 == 32) {
            // 0x1266e
            i_v15 = i_v16;
            i_v16 = i_v15 + 1;
        }
        // 0x12678
        s2hex(i_v8 + 8, i_v15, 360);
        for (int32_t i_v17 = 0; i_v17 < 4; i_v17++) {
            // 0x12694
            *(int32_t *)(i_v8 + 188 + 4 * i_v17) = 0;
        }
        // 0x126b8
        *(int32_t *)i_v8 = i_v6;
        int32_t i_v18 = i_v6 + 1;                       // 0x126c6
        char *p_v19 = fgets((char *)&i_v1, 1023, p_v2); // 0x126da
        int32_t i_v20 = i_v18;                          // 0x126e2
        if (p_v19 == NULL) {
            // 0x1270e
            return i_v20;
        }
        // 0x125a2
        p_v4 = p_v19;
        i_v5 = i_v18;
        if (i_v18 == i_a4 || i_v6 >= i_a4) {
            goto lab_0x126e8;
        }
        i_v6 = i_v18;
        i_v7 = *(int32_t *)(4 * i_a1 + (int32_t)&i_g76 + 0x800a0);
        i_v8 = i_v7 + 204 * (i_v6 + i_a4 * i_a2);
        p_v9 = strstr((char *)&i_v1, (char *)((int32_t)&p_g298 | 0x20000));
        i_v10 = (int32_t)p_v9;
    }
    // 0x126f0
    __asm_nop(i_v10, (int32_t)&p_g298 | 0x20000, i_v7, i_v10);
lab_0x126f6:
    // 0x126f6
    free((int32_t *)i_v8);
    puts("get work err");
    // 0x1270e
    return i_v6;
}

// Address range: 0x1271c - 0x12a34
int32_t get_works(void) {
    // 0x1271c
    int32_t i_v1; // bp-100, 0x1271c
    memset(&i_v1, 0, 64);
    printf("%s, Conf.AsicNum %d, Conf.CoreNum %d\n", "get_works", i_g113,
           i_g114);
    int32_t i_v2; // 0x1271c
    int32_t i_v3; // 0x1271c
    int32_t i_v4; // 0x1271c
    if (i_g113 == 0) {
        // 0x1271c
        i_v2 = i_g114;
        i_v3 = 0;
    lab_0x12920:
        // 0x12920
        i_g95 = i_g88;
        uint32_t i_v5 = i_v3 * i_v2;
        int32_t i_v6 = i_g88; // 0x129c8
        int32_t i_v7 = 0;     // 0x129c8
        if (i_v5 != 0) {
            int32_t i_v8 = 0;
            int32_t i_v9 =
                *(int32_t *)(4 * i_v8 + (int32_t)&i_g76 + 0x804a0); // 0x12972
            int32_t i_v10 = i_g88;                                  // 0x12978
            int32_t i_v11 = 0;                                      // 0x12978
            if (i_g88 > i_v9) {
                // 0x1297a
                i_g95 = i_v9;
                i_v10 = i_v9;
                i_v11 = i_v8;
            }
            int32_t i_v12 = i_v8 + 1; // 0x129a8
            int32_t i_v13 = i_v10;    // 0x129c8
            int32_t i_v14 = i_v11;    // 0x129c8
            i_v6 = i_v10;
            i_v7 = i_v11;
            while (i_v12 < i_v5) {
                // 0x1294e
                i_v8 = i_v12;
                i_v9 = *(int32_t *)(4 * i_v8 + (int32_t)&i_g76 + 0x804a0);
                i_v10 = i_v13;
                i_v11 = i_v14;
                if (i_v13 > i_v9) {
                    // 0x1297a
                    i_g95 = i_v9;
                    i_v10 = i_v9;
                    i_v11 = i_v8;
                }
                // 0x129a6
                i_v12 = i_v8 + 1;
                i_v13 = i_v10;
                i_v14 = i_v11;
                i_v6 = i_v10;
                i_v7 = i_v11;
            }
        }
        uint32_t i_v15 = i_v6;   // 0x129e4
        uint32_t i_v16 = i_g110; // 0x129d2
        i_v4 = 0;
        if (i_v16 != i_v15 && i_v16 >= i_v15) {
            // 0x129ea
            write_lcd(1, (int32_t) "Get Less Work", 13);
            printf("%s: cgpu.subid[%d] = %d, is the least pattern number\n",
                   "get_works", i_v7, i_g95);
            i_v4 = -1;
        }
    lab_0x12a2a:
        // 0x12a2a
        return i_v4;
    }
    int32_t i_v17 = 0;
    int32_t *p_v18 = malloc(204 * i_g114 * i_g110); // 0x1278a
    *(int32_t *)(4 * i_v17 + (int32_t)&i_g76 + 0x800a0) = (int32_t)p_v18;
    while (p_v18 != NULL) {
        int32_t i_v19 = 0; // 0x12904
        int32_t i_v20 = 0; // 0x12904
        if (i_g114 != 0) {
            sprintf((char *)&i_v1, "%s%02d%s%03d.txt", (char *)&p_g85, i_v17,
                    (char *)&p_g86, i_v19);
            struct _IO_FILE *p_v21 = fopen((char *)&i_v1, "r"); // 0x1281a
            *(int32_t *)(4 * (i_g114 * i_v17 + i_v19) + (int32_t)&i_g76) =
                (int32_t)p_v21;
            int32_t i_v22 = 4 * (i_g114 * i_v17 + i_v19);          // 0x12848
            int32_t i_v23 = *(int32_t *)(i_v22 + (int32_t)&i_g76); // 0x12848
            if (i_v23 == 0) {
                // 0x12850
                printf("%s: Open test file %s error\n", "get_works", &i_v1);
                i_v4 = -1;
                return i_v4;
            }
            int32_t i_v24 = get_work(i_v17, i_v19, i_v23, i_g110); // 0x128b0
            *(int32_t *)(i_v22 + (int32_t)&i_g76 + 0x804a0) = i_v24;
            int32_t i_v25 = *(int32_t *)(4 * (i_g114 * i_v17 + i_v19) +
                                         (int32_t)&i_g76); // 0x128e6
            fclose((struct _IO_FILE *)i_v25);
            int32_t i_v26 = i_v19 + 1; // 0x128f2
            int32_t i_v27 = i_g114;    // 0x128fe
            i_v19 = i_v26;
            i_v20 = i_v27;
            while (i_v27 >= i_v26 == (i_v27 != i_v26)) {
                // 0x127de
                sprintf((char *)&i_v1, "%s%02d%s%03d.txt", (char *)&p_g85,
                        i_v17, (char *)&p_g86, i_v19);
                p_v21 = fopen((char *)&i_v1, "r");
                *(int32_t *)(4 * (i_g114 * i_v17 + i_v19) + (int32_t)&i_g76) =
                    (int32_t)p_v21;
                i_v22 = 4 * (i_g114 * i_v17 + i_v19);
                i_v23 = *(int32_t *)(i_v22 + (int32_t)&i_g76);
                if (i_v23 == 0) {
                    // 0x12850
                    printf("%s: Open test file %s error\n", "get_works", &i_v1);
                    i_v4 = -1;
                    return i_v4;
                }
                // 0x1286e
                i_v24 = get_work(i_v17, i_v19, i_v23, i_g110);
                *(int32_t *)(i_v22 + (int32_t)&i_g76 + 0x804a0) = i_v24;
                i_v25 = *(int32_t *)(4 * (i_g114 * i_v17 + i_v19) +
                                     (int32_t)&i_g76);
                fclose((struct _IO_FILE *)i_v25);
                i_v26 = i_v19 + 1;
                i_v27 = i_g114;
                i_v19 = i_v26;
                i_v20 = i_v27;
            }
        }
        int32_t i_v28 = i_v17 + 1; // 0x1290a
        int32_t i_v29 = i_g113;    // 0x12916
        i_v2 = i_v20;
        i_v3 = i_v29;
        if (i_v29 >= i_v28 != i_v29 != i_v28) {
            goto lab_0x12920;
        }
        i_v17 = i_v28;
        p_v18 = malloc(204 * i_v20 * i_g110);
        *(int32_t *)(4 * i_v17 + (int32_t)&i_g76 + 0x800a0) = (int32_t)p_v18;
    }
    // 0x127be
    printf("%s: malloc struct work err!\n", "get_works");
    // 0x12a2a
    return -1;
}

// Address range: 0x12a3c - 0x12a60
int32_t write_pic(int32_t i_a1, int32_t i_a2, int32_t i_a3) {
    int32_t i_v1 = 0x1000000 * i_a3 >> 24; // bp-11, 0x12a4c
    return iic_i2c_write((char *)&i_v1, 1);
}

// Address range: 0x12a60 - 0x12a8c
int32_t read_pic(int32_t i_a1, int32_t i_a2) {
    char i_v1 = 0; // bp-9, 0x12a70
    iic_i2c_read(&i_v1, 1);
    return i_v1;
}

// Address range: 0x12a8c - 0x12bce
int32_t set_PIC16F1704_flash_point32_ter(uint32_t i_a1, uint32_t i_a2,
                                         int32_t i_a3, int32_t i_a4) {
    uint32_t i_v1 = i_a2 % 256;
    pthread_mutex_lock(&i_g186);
    uint32_t i_v2 = i_a1 % 256;
    int32_t i_v3; // bp-16, 0x12a8c
    int32_t i_v4 = &i_v3;
    char i_v5 = 0; // 0x12b32
    write_pic(i_v2, i_v1, (int32_t) * (char *)(i_v4 - 20 + (int32_t)i_v5));
    i_v5++;
    while (i_v5 == 7 || i_v5 < 7) {
        // 0x12b14
        write_pic(i_v2, i_v1, (int32_t) * (char *)(i_v4 - 20 + (int32_t)i_v5));
        i_v5++;
    }
    // 0x12b3c
    usleep((int32_t)&i_g239 | 0x10000);
    int32_t i_v6 = i_v4 - 12;
    unsigned char i_v7 = 0;
    *(char *)(i_v6 + (int32_t)i_v7) = (char)read_pic(i_v2, i_v1);
    char i_v8 = i_v7 + 1; // 0x12b6e
    while (i_v7 == 0 || i_v8 == 0) {
        // 0x12b4e
        i_v7 = i_v8;
        *(char *)(i_v6 + (int32_t)i_v7) = (char)read_pic(i_v2, i_v1);
        i_v8 = i_v7 + 1;
    }
    // 0x12b78
    pthread_mutex_unlock(&i_g186);
    char i_v9; // 0x12a8c
    printf("\n--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = "
           "0x%02x\n\n",
           "set_PIC16F1704_flash_point32_ter", 255,
           (int32_t)(unsigned char)i_v9);
    return 0;
}

// Address range: 0x12bd0 - 0x12dac
int32_t send_data_to_PIC16F1704(uint32_t i_a1, uint32_t i_a2, int32_t *p_a3) {
    unsigned char i_v1 = 0; // 0x12c34
    while (i_v1 == 15 || i_v1 < 15) {
        // 0x12c52
        i_v1++;
    }
    // 0x12cac
    int32_t i_v2; // bp-16, 0x12bd0
    int32_t i_v3 = &i_v2;
    char i_v4 = 0;       // 0x12ca6
    int32_t i_v5 = i_v4; // 0x12c88
    *(char *)(i_v3 - 32 + i_v5) = *(char *)(i_v5 + (int32_t)p_a3);
    i_v4++;
    while (i_v4 == 15 || i_v4 < 15) {
        // 0x12c88
        i_v5 = i_v4;
        *(char *)(i_v3 - 32 + i_v5) = *(char *)(i_v5 + (int32_t)p_a3);
        i_v4++;
    }
    uint32_t i_v6 = i_a2 % 256;
    pthread_mutex_lock(&i_g186);
    uint32_t i_v7 = i_a1 % 256;
    char i_v8 = 0; // 0x12cfa
    write_pic(i_v7, i_v6, (int32_t) * (char *)(i_v3 - 36 + (int32_t)i_v8));
    i_v8++;
    while (i_v8 == 21 || i_v8 < 21) {
        // 0x12cd8
        write_pic(i_v7, i_v6, (int32_t) * (char *)(i_v3 - 36 + (int32_t)i_v8));
        i_v8++;
    }
    // 0x12d08
    usleep((int32_t)&i_g239 | 0x10000);
    unsigned char i_v9 = 0;
    int32_t i_v10 = read_pic(i_v7, i_v6); // 0x12d2a
    *(char *)(i_v3 - 12 + (int32_t)i_v9) = (char)i_v10;
    char i_v11 = i_v9 + 1; // 0x12d40
    while (i_v9 == 0 || i_v11 == 0) {
        // 0x12d1c
        i_v9 = i_v11;
        i_v10 = read_pic(i_v7, i_v6);
        *(char *)(i_v3 - 12 + (int32_t)i_v9) = (char)i_v10;
        i_v11 = i_v9 + 1;
    }
    // 0x12d4e
    pthread_mutex_unlock(&i_g186);
    char i_v12; // 0x12bd0
    printf("\n--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = "
           "0x%02x\n\n",
           "send_data_to_PIC16F1704", 255, (int32_t)(unsigned char)i_v12);
    return 0;
}

// Address range: 0x12dac - 0x12f8e
int32_t read_PIC16F1704_flash_point32_ter(uint32_t i_a1, uint32_t i_a2,
                                          int32_t i_a3, int32_t i_a4) {
    uint32_t i_v1 = i_a2 % 256;
    pthread_mutex_lock(&i_g186);
    uint32_t i_v2 = i_a1 % 256;
    int32_t i_v3; // bp-16, 0x12dac
    int32_t i_v4 = &i_v3;
    char i_v5 = 0; // 0x12e56
    write_pic(i_v2, i_v1, (int32_t) * (char *)(i_v4 - 24 + (int32_t)i_v5));
    i_v5++;
    while (i_v5 == 5 || i_v5 < 5) {
        // 0x12e34
        write_pic(i_v2, i_v1, (int32_t) * (char *)(i_v4 - 24 + (int32_t)i_v5));
        i_v5++;
    }
    // 0x12e64
    usleep((int32_t)&i_g239 | 0x10000);
    char i_v6 = 0; // 0x12e9c
    *(char *)(i_v4 - 16 + (int32_t)i_v6) = (char)read_pic(i_v2, i_v1);
    i_v6++;
    while (i_v6 == 5 || i_v6 < 5) {
        // 0x12e78
        *(char *)(i_v4 - 16 + (int32_t)i_v6) = (char)read_pic(i_v2, i_v1);
        i_v6++;
    }
    // 0x12eaa
    pthread_mutex_unlock(&i_g186);
    char i_v7; // 0x12dac
    printf("\n--- %s failed! read_back_data[0] = 0x%x, read_back_data[1] = "
           "0x%x, read_back_data[2] = 0x%x, read_back_data[3] = 0x%x, "
           "read_back_data[4] = 0x%x, read_back_data[5] = 0x%x\n\n",
           "read_PIC16F1704_flash_point32_ter", 255, (int32_t)i_v7,
           (int32_t)i_v7, (int32_t)i_v7, 0, (int32_t)(unsigned char)i_v7);
    return 0;
}

// Address range: 0x12f90 - 0x132f2
int32_t read_PIC16F1704_flash_data(uint32_t i_a1, uint32_t i_a2, int32_t i_a3) {
    uint32_t i_v1 = i_a2 % 256;
    pthread_mutex_lock(&i_g186);
    uint32_t i_v2 = i_a1 % 256;
    int32_t i_v3; // bp-40, 0x12f90
    int32_t i_v4 = &i_v3;
    char i_v5 = 0; // 0x13070
    write_pic(i_v2, i_v1, (int32_t) * (char *)(i_v4 - 36 + (int32_t)i_v5));
    i_v5++;
    while (i_v5 == 5 || i_v5 < 5) {
        // 0x1304c
        write_pic(i_v2, i_v1, (int32_t) * (char *)(i_v4 - 36 + (int32_t)i_v5));
        i_v5++;
    }
    // 0x1307e
    usleep((int32_t)&i_g204);
    char i_v6 = 0; // 0x130b8
    *(char *)(i_v4 - 28 + (int32_t)i_v6) = (char)read_pic(i_v2, i_v1);
    i_v6++;
    while (i_v6 == 19 || i_v6 < 19) {
        // 0x13092
        *(char *)(i_v4 - 28 + (int32_t)i_v6) = (char)read_pic(i_v2, i_v1);
        i_v6++;
    }
    // 0x130c6
    pthread_mutex_unlock(&i_g186);
    char i_v7; // 0x12f90
    printf("--- %s: read_back_data[0] = 0x%x, read_back_data[1] = 0x%x, "
           "read_back_data[2] = 0x%x, read_back_data[3] = 0x%x,         "
           "read_back_data[4] = 0x%x, read_back_data[5] = 0x%x, "
           "read_back_data[6] = 0x%x, read_back_data[7] = 0x%x,         "
           "read_back_data[8] = 0x%x, read_back_data[9] = 0x%x, "
           "read_back_data[10] = 0x%x, read_back_data[11] = 0x%x,         "
           "read_back_data[12] = 0x%x, read_back_data[13] = 0x%x, "
           "read_back_data[14] = 0x%x, read_back_data[15] = 0x%x,         "
           "read_back_data[16] = 0x%x, read_back_data[17] = 0x%x, "
           "read_back_data[18] = 0x%x, read_back_data[19] = 0x%x\n",
           "read_PIC16F1704_flash_data", 255, (int32_t)i_v7, (int32_t)i_v7,
           (int32_t)i_v7, 0, (int32_t)i_v7, (int32_t)i_v7, (int32_t)i_v7, 0,
           (int32_t)i_v7, (int32_t)i_v7, (int32_t)i_v7, 0, (int32_t)i_v7,
           (int32_t)i_v7, (int32_t)i_v7, 0, (int32_t)i_v7, (int32_t)i_v7,
           (int32_t)(unsigned char)i_v7);
    usleep((int32_t)&i_g239 | 0x10000);
    printf("\n--- %s failed!\n\n", "read_PIC16F1704_flash_data");
    return 0;
}

// Address range: 0x132f4 - 0x13428
int32_t erase_PIC16F1704_flash(uint32_t i_a1, uint32_t i_a2) {
    uint32_t i_v1 = i_a2 % 256;
    pthread_mutex_lock(&i_g186);
    uint32_t i_v2 = i_a1 % 256;
    int32_t i_v3; // bp-16, 0x132f4
    int32_t i_v4 = &i_v3;
    char i_v5 = 0; // 0x13380
    write_pic(i_v2, i_v1, (int32_t) * (char *)(i_v4 - 20 + (int32_t)i_v5));
    i_v5++;
    while (i_v5 == 5 || i_v5 < 5) {
        // 0x13362
        write_pic(i_v2, i_v1, (int32_t) * (char *)(i_v4 - 20 + (int32_t)i_v5));
        i_v5++;
    }
    // 0x1338a
    usleep((int32_t)&i_g239 | 0x10000);
    int32_t i_v6 = i_v4 - 12;
    unsigned char i_v7 = 0;
    *(char *)(i_v6 + (int32_t)i_v7) = (char)read_pic(i_v2, i_v1);
    char i_v8 = i_v7 + 1; // 0x133bc
    while (i_v7 == 0 || i_v8 == 0) {
        // 0x1339c
        i_v7 = i_v8;
        *(char *)(i_v6 + (int32_t)i_v7) = (char)read_pic(i_v2, i_v1);
        i_v8 = i_v7 + 1;
    }
    // 0x133c6
    pthread_mutex_unlock(&i_g186);
    usleep(0x30d40);
    char i_v9; // 0x132f4
    printf("\n--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = "
           "0x%02x\n\n",
           "erase_PIC16F1704_flash", 255, (int32_t)(unsigned char)i_v9);
    return 0;
}

// Address range: 0x13428 - 0x1355c
int32_t write_data_int32_to_PIC16F1704_flash(uint32_t i_a1, uint32_t i_a2) {
    uint32_t i_v1 = i_a2 % 256;
    pthread_mutex_lock(&i_g186);
    uint32_t i_v2 = i_a1 % 256;
    int32_t i_v3; // bp-16, 0x13428
    int32_t i_v4 = &i_v3;
    char i_v5 = 0; // 0x134b4
    write_pic(i_v2, i_v1, (int32_t) * (char *)(i_v4 - 20 + (int32_t)i_v5));
    i_v5++;
    while (i_v5 == 5 || i_v5 < 5) {
        // 0x13496
        write_pic(i_v2, i_v1, (int32_t) * (char *)(i_v4 - 20 + (int32_t)i_v5));
        i_v5++;
    }
    // 0x134be
    usleep(0x30d40);
    int32_t i_v6 = i_v4 - 12;
    unsigned char i_v7 = 0;
    *(char *)(i_v6 + (int32_t)i_v7) = (char)read_pic(i_v2, i_v1);
    char i_v8 = i_v7 + 1; // 0x134f0
    while (i_v7 == 0 || i_v8 == 0) {
        // 0x134d0
        i_v7 = i_v8;
        *(char *)(i_v6 + (int32_t)i_v7) = (char)read_pic(i_v2, i_v1);
        i_v8 = i_v7 + 1;
    }
    // 0x134fa
    pthread_mutex_unlock(&i_g186);
    usleep(0x30d40);
    char i_v9; // 0x13428
    printf("\n--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = "
           "0x%02x\n\n",
           "write_data_int32_to_PIC16F1704_flash", 255,
           (int32_t)(unsigned char)i_v9);
    return 0;
}

// Address range: 0x1355c - 0x13690
int32_t jump_from_loader_to_app_PIC16F1704(uint32_t i_a1, uint32_t i_a2) {
    uint32_t i_v1 = i_a2 % 256;
    pthread_mutex_lock(&i_g186);
    uint32_t i_v2 = i_a1 % 256;
    int32_t i_v3; // bp-16, 0x1355c
    int32_t i_v4 = &i_v3;
    char i_v5 = 0; // 0x135e8
    write_pic(i_v1, i_v2, (int32_t) * (char *)(i_v4 - 20 + (int32_t)i_v5));
    i_v5++;
    while (i_v5 == 5 || i_v5 < 5) {
        // 0x135ca
        write_pic(i_v1, i_v2, (int32_t) * (char *)(i_v4 - 20 + (int32_t)i_v5));
        i_v5++;
    }
    // 0x135f2
    usleep((int32_t)&i_g239 | 0x10000);
    int32_t i_v6 = i_v4 - 12;
    unsigned char i_v7 = 0;
    *(char *)(i_v6 + (int32_t)i_v7) = (char)read_pic(i_v1, i_v2);
    char i_v8 = i_v7 + 1; // 0x13624
    while (i_v7 == 0 || i_v8 == 0) {
        // 0x13604
        i_v7 = i_v8;
        *(char *)(i_v6 + (int32_t)i_v7) = (char)read_pic(i_v1, i_v2);
        i_v8 = i_v7 + 1;
    }
    // 0x1362e
    pthread_mutex_unlock(&i_g186);
    usleep((int32_t)&i_g204);
    char i_v9; // 0x1355c
    printf("\n--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = "
           "0x%02x\n\n",
           "jump_from_loader_to_app_PIC16F1704", 255,
           (int32_t)(unsigned char)i_v9);
    return 0;
}

// Address range: 0x13690 - 0x137c4
int32_t reset_PIC16F1704_pic(uint32_t i_a1, uint32_t i_a2) {
    uint32_t i_v1 = i_a2 % 256;
    pthread_mutex_lock(&i_g186);
    uint32_t i_v2 = i_a1 % 256;
    int32_t i_v3; // bp-16, 0x13690
    int32_t i_v4 = &i_v3;
    char i_v5 = 0; // 0x1371c
    write_pic(i_v1, i_v2, (int32_t) * (char *)(i_v4 - 20 + (int32_t)i_v5));
    i_v5++;
    while (i_v5 == 5 || i_v5 < 5) {
        // 0x136fe
        write_pic(i_v1, i_v2, (int32_t) * (char *)(i_v4 - 20 + (int32_t)i_v5));
        i_v5++;
    }
    // 0x13726
    usleep((int32_t)&i_g239 | 0x10000);
    int32_t i_v6 = i_v4 - 12;
    unsigned char i_v7 = 0;
    *(char *)(i_v6 + (int32_t)i_v7) = (char)read_pic(i_v1, i_v2);
    char i_v8 = i_v7 + 1; // 0x13758
    while (i_v7 == 0 || i_v8 == 0) {
        // 0x13738
        i_v7 = i_v8;
        *(char *)(i_v6 + (int32_t)i_v7) = (char)read_pic(i_v1, i_v2);
        i_v8 = i_v7 + 1;
    }
    // 0x13762
    pthread_mutex_unlock(&i_g186);
    usleep((int32_t)&i_g307);
    char i_v9; // 0x13690
    printf("\n--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = "
           "0x%02x\n\n",
           "reset_PIC16F1704_pic", 255, (int32_t)(unsigned char)i_v9);
    return 0;
}

// Address range: 0x137c4 - 0x1392a
int32_t set_PIC16F1704_voltage(uint32_t i_a1, uint32_t i_a2, int32_t i_a3) {
    uint32_t i_v1 = i_a2 % 256;
    printf("\n--- %s\n", "set_PIC16F1704_voltage");
    pthread_mutex_lock(&i_g186);
    uint32_t i_v2 = i_a1 % 256;
    int32_t i_v3; // bp-16, 0x137c4
    int32_t i_v4 = &i_v3;
    char i_v5 = 0; // 0x13882
    write_pic(i_v1, i_v2, (int32_t) * (char *)(i_v4 - 20 + (int32_t)i_v5));
    i_v5++;
    while (i_v5 == 6 || i_v5 < 6) {
        // 0x13864
        write_pic(i_v1, i_v2, (int32_t) * (char *)(i_v4 - 20 + (int32_t)i_v5));
        i_v5++;
    }
    // 0x1388c
    usleep(0x30d40);
    int32_t i_v6 = i_v4 - 12;
    unsigned char i_v7 = 0;
    *(char *)(i_v6 + (int32_t)i_v7) = (char)read_pic(i_v1, i_v2);
    char i_v8 = i_v7 + 1; // 0x138be
    while (i_v7 == 0 || i_v8 == 0) {
        // 0x1389e
        i_v7 = i_v8;
        *(char *)(i_v6 + (int32_t)i_v7) = (char)read_pic(i_v1, i_v2);
        i_v8 = i_v7 + 1;
    }
    // 0x138c8
    pthread_mutex_unlock(&i_g186);
    usleep(0x30d40);
    char i_v9; // 0x137c4
    printf("\n--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = "
           "0x%02x\n\n",
           "set_PIC16F1704_voltage", 255, (int32_t)(unsigned char)i_v9);
    return 0;
}

// Address range: 0x1392c - 0x13b0e
int32_t write_hash_ID_PIC16F1704(uint32_t i_a1, uint32_t i_a2, int32_t i_a3) {
    unsigned char i_v1 = 0; // 0x1398a
    while (i_v1 == 11 || i_v1 < 11) {
        // 0x139a8
        i_v1++;
    }
    // 0x13a02
    int32_t i_v2; // bp-16, 0x1392c
    int32_t i_v3 = &i_v2;
    char i_v4 = 0;       // 0x139fc
    int32_t i_v5 = i_v4; // 0x139de
    *(char *)(i_v3 - 28 + i_v5) = *(char *)(i_v5 + i_a3);
    i_v4++;
    while (i_v4 == 11 || i_v4 < 11) {
        // 0x139de
        i_v5 = i_v4;
        *(char *)(i_v3 - 28 + i_v5) = *(char *)(i_v5 + i_a3);
        i_v4++;
    }
    uint32_t i_v6 = i_a2 % 256;
    pthread_mutex_lock(&i_g186);
    uint32_t i_v7 = i_a1 % 256;
    char i_v8 = 0; // 0x13a50
    write_pic(i_v6, i_v7, (int32_t) * (char *)(i_v3 - 32 + (int32_t)i_v8));
    i_v8++;
    while (i_v8 == 17 || i_v8 < 17) {
        // 0x13a2e
        write_pic(i_v6, i_v7, (int32_t) * (char *)(i_v3 - 32 + (int32_t)i_v8));
        i_v8++;
    }
    // 0x13a5e
    usleep((int32_t)&i_g206);
    unsigned char i_v9 = 0;
    int32_t i_v10 = read_pic(i_v6, i_v7); // 0x13a80
    *(char *)(i_v3 - 12 + (int32_t)i_v9) = (char)i_v10;
    char i_v11 = i_v9 + 1; // 0x13a96
    while (i_v9 == 0 || i_v11 == 0) {
        // 0x13a72
        i_v9 = i_v11;
        i_v10 = read_pic(i_v6, i_v7);
        *(char *)(i_v3 - 12 + (int32_t)i_v9) = (char)i_v10;
        i_v11 = i_v9 + 1;
    }
    // 0x13aa4
    pthread_mutex_unlock(&i_g186);
    usleep(0x30d40);
    char i_v12; // 0x1392c
    printf("\n--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = "
           "0x%02x\n\n",
           "write_hash_ID_PIC16F1704", 255, (int32_t)(unsigned char)i_v12);
    return 0;
}

// Address range: 0x13b10 - 0x13df8
int32_t read_hash_id_PIC16F1704(uint32_t i_a1, uint32_t i_a2, int32_t i_a3) {
    uint32_t i_v1 = i_a2 % 256;
    pthread_mutex_lock(&i_g186);
    uint32_t i_v2 = i_a1 % 256;
    int32_t i_v3; // bp-40, 0x13b10
    int32_t i_v4 = &i_v3;
    char i_v5 = 0; // 0x13bd0
    write_pic(i_v2, i_v1, (int32_t) * (char *)(i_v4 - 32 + (int32_t)i_v5));
    i_v5++;
    while (i_v5 == 5 || i_v5 < 5) {
        // 0x13bae
        write_pic(i_v2, i_v1, (int32_t) * (char *)(i_v4 - 32 + (int32_t)i_v5));
        i_v5++;
    }
    // 0x13bde
    usleep(0x30d40);
    char i_v6 = 0; // 0x13c16
    *(char *)(i_v4 - 24 + (int32_t)i_v6) = (char)read_pic(i_v2, i_v1);
    i_v6++;
    while (i_v6 == 15 || i_v6 < 15) {
        // 0x13bf2
        *(char *)(i_v4 - 24 + (int32_t)i_v6) = (char)read_pic(i_v2, i_v1);
        i_v6++;
    }
    // 0x13c24
    pthread_mutex_unlock(&i_g186);
    char i_v7; // 0x13b10
    printf("--- %s: read_back_data[0] = 0x%x, read_back_data[1] = 0x%x, "
           "read_back_data[2] = 0x%x, read_back_data[3] = 0x%x,        "
           "read_back_data[4] = 0x%x, read_back_data[5] = 0x%x, "
           "read_back_data[6] = 0x%x, read_back_data[7] = 0x%x,        "
           "read_back_data[8] = 0x%x, read_back_data[9] = 0x%x, "
           "read_back_data[10] = 0x%x, read_back_data[11] = 0x%x,        "
           "read_back_data[12] = 0x%x, read_back_data[13] = 0x%x, "
           "read_back_data[14] = 0x%x, read_back_data[15] = 0x%x\n",
           "read_hash_id_PIC16F1704", 255, (int32_t)i_v7, (int32_t)i_v7,
           (int32_t)i_v7, 0, (int32_t)i_v7, (int32_t)i_v7, (int32_t)i_v7, 0,
           (int32_t)i_v7, (int32_t)i_v7, (int32_t)i_v7, 0, (int32_t)i_v7,
           (int32_t)i_v7, (int32_t)(unsigned char)i_v7);
    printf("\n--- %s failed!\n\n", "read_hash_id_PIC16F1704");
    return 0;
}

// Address range: 0x13df8 - 0x13f5e
int32_t enable_PIC16F1704_dc_dc(uint32_t i_a1, uint32_t i_a2, int32_t i_a3) {
    uint32_t i_v1 = i_a2 % 256;
    printf("\n--- %s\n", "enable_PIC16F1704_dc_dc");
    pthread_mutex_lock(&i_g186);
    uint32_t i_v2 = i_a1 % 256;
    int32_t i_v3; // bp-16, 0x13df8
    int32_t i_v4 = &i_v3;
    char i_v5 = 0; // 0x13eb6
    write_pic(i_v1, i_v2, (int32_t) * (char *)(i_v4 - 20 + (int32_t)i_v5));
    i_v5++;
    while (i_v5 == 6 || i_v5 < 6) {
        // 0x13e98
        write_pic(i_v1, i_v2, (int32_t) * (char *)(i_v4 - 20 + (int32_t)i_v5));
        i_v5++;
    }
    // 0x13ec0
    usleep((int32_t)&i_g239 | 0x10000);
    int32_t i_v6 = i_v4 - 12;
    unsigned char i_v7 = 0;
    *(char *)(i_v6 + (int32_t)i_v7) = (char)read_pic(i_v1, i_v2);
    char i_v8 = i_v7 + 1; // 0x13ef2
    while (i_v7 == 0 || i_v8 == 0) {
        // 0x13ed2
        i_v7 = i_v8;
        *(char *)(i_v6 + (int32_t)i_v7) = (char)read_pic(i_v1, i_v2);
        i_v8 = i_v7 + 1;
    }
    // 0x13efc
    pthread_mutex_unlock(&i_g186);
    char i_v9; // 0x13df8
    printf("\n--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = "
           "0x%02x\n\n",
           "enable_PIC16F1704_dc_dc", 255, (int32_t)(unsigned char)i_v9);
    return 0;
}

// Address range: 0x13f60 - 0x14086
int32_t heart_beat_PIC16F1704(uint32_t i_a1, uint32_t i_a2) {
    uint32_t i_v1 = i_a2 % 256;
    pthread_mutex_lock(&i_g186);
    uint32_t i_v2 = i_a1 % 256;
    int32_t i_v3; // bp-16, 0x13f60
    int32_t i_v4 = &i_v3;
    char i_v5 = 0; // 0x13ff0
    write_pic(i_v1, i_v2, (int32_t) * (char *)(i_v4 - 24 + (int32_t)i_v5));
    i_v5++;
    while (i_v5 == 5 || i_v5 < 5) {
        // 0x13fd2
        write_pic(i_v1, i_v2, (int32_t) * (char *)(i_v4 - 24 + (int32_t)i_v5));
        i_v5++;
    }
    // 0x13ffa
    usleep((int32_t)&i_g239 | 0x10000);
    char i_v6 = 0; // 0x1402c
    *(char *)(i_v4 - 16 + (int32_t)i_v6) = (char)read_pic(i_v1, i_v2);
    i_v6++;
    while (i_v6 == 5 || i_v6 < 5) {
        // 0x1400c
        *(char *)(i_v4 - 16 + (int32_t)i_v6) = (char)read_pic(i_v1, i_v2);
        i_v6++;
    }
    // 0x14036
    pthread_mutex_unlock(&i_g186);
    int32_t i_v7; // 0x13f60
    char i_v8;    // 0x13f60
    if (i_v8 == 1 == i_v8 == 22) {
        // 0x14066
        printf("\n--- %s ok\n\n", "heart_beat_PIC16F1704");
        i_v7 = 1;
    } else {
        // 0x1404e
        printf("\n--- %s failed!\n\n", "heart_beat_PIC16F1704");
        i_v7 = 0;
    }
    // 0x1407c
    return i_v7;
}

// Address range: 0x14088 - 0x140b4
int32_t pic_heart_beat_func(int32_t i_a1) {
    // 0x14088
    while (true) {
        // 0x140a0
        int32_t i_v1; // 0x14088
        heart_beat_PIC16F1704((uint32_t)i_v1 % 256,
                              (int32_t) * (char *)(i_a1 + 1));
        sleep(10);
    }
}

// Address range: 0x140b4 - 0x14286
int32_t get_PIC16F1704_software_version(uint32_t i_a1, uint32_t i_a2,
                                        int32_t i_a3) {
    uint32_t i_v1 = i_a2 % 256;
    pthread_mutex_lock(&i_g186);
    uint32_t i_v2 = i_a1 % 256;
    int32_t i_v3; // bp-16, 0x140b4
    int32_t i_v4 = &i_v3;
    char i_v5 = 0; // 0x1415c
    write_pic(i_v2, i_v1, (int32_t) * (char *)(i_v4 - 24 + (int32_t)i_v5));
    i_v5++;
    while (i_v5 == 5 || i_v5 < 5) {
        // 0x1413a
        write_pic(i_v2, i_v1, (int32_t) * (char *)(i_v4 - 24 + (int32_t)i_v5));
        i_v5++;
    }
    // 0x1416a
    usleep(0x30d40);
    char i_v6 = 0; // 0x141a2
    *(char *)(i_v4 - 16 + (int32_t)i_v6) = (char)read_pic(i_v2, i_v1);
    i_v6++;
    while (i_v6 == 4 || i_v6 < 4) {
        // 0x1417e
        *(char *)(i_v4 - 16 + (int32_t)i_v6) = (char)read_pic(i_v2, i_v1);
        i_v6++;
    }
    // 0x141b0
    pthread_mutex_unlock(&i_g186);
    usleep(0x30d40);
    char i_v7; // 0x140b4
    printf("--- %s: read_back_data[0] = 0x%x, read_back_data[1] = 0x%x, "
           "read_back_data[2] = 0x%x, read_back_data[3] = 0x%x, "
           "read_back_data[4] = 0x%x\n",
           "get_PIC16F1704_software_version", 255, (int32_t)i_v7, (int32_t)i_v7,
           (int32_t)(unsigned char)i_v7, 0);
    printf("\n--- %s failed!\n\n", "get_PIC16F1704_software_version");
    return 0;
}

// Address range: 0x14288 - 0x1444e
int32_t get_PIC16F1704_voltage(uint32_t i_a1, uint32_t i_a2, int32_t i_a3) {
    uint32_t i_v1 = i_a2 % 256;
    pthread_mutex_lock(&i_g186);
    uint32_t i_v2 = i_a1 % 256;
    int32_t i_v3; // bp-16, 0x14288
    int32_t i_v4 = &i_v3;
    char i_v5 = 0; // 0x14330
    write_pic(i_v2, i_v1, (int32_t) * (char *)(i_v4 - 24 + (int32_t)i_v5));
    i_v5++;
    while (i_v5 == 5 || i_v5 < 5) {
        // 0x1430e
        write_pic(i_v2, i_v1, (int32_t) * (char *)(i_v4 - 24 + (int32_t)i_v5));
        i_v5++;
    }
    // 0x1433e
    usleep(0x30d40);
    char i_v6 = 0; // 0x14376
    *(char *)(i_v4 - 16 + (int32_t)i_v6) = (char)read_pic(i_v2, i_v1);
    i_v6++;
    while (i_v6 == 4 || i_v6 < 4) {
        // 0x14352
        *(char *)(i_v4 - 16 + (int32_t)i_v6) = (char)read_pic(i_v2, i_v1);
        i_v6++;
    }
    // 0x14384
    pthread_mutex_unlock(&i_g186);
    char i_v7; // 0x14288
    printf("--- %s: read_back_data[0] = 0x%x, read_back_data[1] = 0x%x, "
           "read_back_data[2] = 0x%x, read_back_data[3] = 0x%x, "
           "read_back_data[4] = 0x%x\n",
           "get_PIC16F1704_voltage", 255, (int32_t)i_v7, (int32_t)i_v7,
           (int32_t)(unsigned char)i_v7, 0);
    printf("\n--- %s failed!\n\n", "get_PIC16F1704_voltage");
    return 0;
}

// Address range: 0x14450 - 0x1462c
int32_t write_temperature_offset_PIC16F1704(uint32_t i_a1, uint32_t i_a2,
                                            int32_t i_a3) {
    unsigned char i_v1 = 0; // 0x144a8
    while (i_v1 == 7 || i_v1 < 7) {
        // 0x144c6
        i_v1++;
    }
    // 0x14520
    int32_t i_v2; // bp-16, 0x14450
    int32_t i_v3 = &i_v2;
    char i_v4 = 0;       // 0x1451a
    int32_t i_v5 = i_v4; // 0x144fc
    *(char *)(i_v3 - 24 + i_v5) = *(char *)(i_v5 + i_a3);
    i_v4++;
    while (i_v4 == 7 || i_v4 < 7) {
        // 0x144fc
        i_v5 = i_v4;
        *(char *)(i_v3 - 24 + i_v5) = *(char *)(i_v5 + i_a3);
        i_v4++;
    }
    uint32_t i_v6 = i_a2 % 256;
    pthread_mutex_lock(&i_g186);
    uint32_t i_v7 = i_a1 % 256;
    char i_v8 = 0; // 0x1456e
    write_pic(i_v7, i_v6, (int32_t) * (char *)(i_v3 - 28 + (int32_t)i_v8));
    i_v8++;
    while (i_v8 == 13 || i_v8 < 13) {
        // 0x1454c
        write_pic(i_v7, i_v6, (int32_t) * (char *)(i_v3 - 28 + (int32_t)i_v8));
        i_v8++;
    }
    // 0x1457c
    usleep(0x30d40);
    unsigned char i_v9 = 0;
    int32_t i_v10 = read_pic(i_v7, i_v6); // 0x1459e
    *(char *)(i_v3 - 12 + (int32_t)i_v9) = (char)i_v10;
    char i_v11 = i_v9 + 1; // 0x145b4
    while (i_v9 == 0 || i_v11 == 0) {
        // 0x14590
        i_v9 = i_v11;
        i_v10 = read_pic(i_v7, i_v6);
        *(char *)(i_v3 - 12 + (int32_t)i_v9) = (char)i_v10;
        i_v11 = i_v9 + 1;
    }
    // 0x145c2
    pthread_mutex_unlock(&i_g186);
    usleep(0x30d40);
    char i_v12; // 0x14450
    printf("\n--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = "
           "0x%02x\n\n",
           "write_temperature_offset_PIC16F1704", 255,
           (int32_t)(unsigned char)i_v12);
    return 0;
}

// Address range: 0x1462c - 0x148b0
int32_t read_temperature_offset_PIC16F1704(uint32_t i_a1, uint32_t i_a2,
                                           int32_t i_a3) {
    uint32_t i_v1 = i_a2 % 256;
    pthread_mutex_lock(&i_g186);
    uint32_t i_v2 = i_a1 % 256;
    int32_t i_v3; // bp-32, 0x1462c
    int32_t i_v4 = &i_v3;
    char i_v5 = 0; // 0x146ea
    write_pic(i_v2, i_v1, (int32_t) * (char *)(i_v4 - 28 + (int32_t)i_v5));
    i_v5++;
    while (i_v5 == 5 || i_v5 < 5) {
        // 0x146c8
        write_pic(i_v2, i_v1, (int32_t) * (char *)(i_v4 - 28 + (int32_t)i_v5));
        i_v5++;
    }
    // 0x146f8
    usleep(0x30d40);
    char i_v6 = 0; // 0x14730
    *(char *)(i_v4 - 20 + (int32_t)i_v6) = (char)read_pic(i_v2, i_v1);
    i_v6++;
    while (i_v6 == 11 || i_v6 < 11) {
        // 0x1470c
        *(char *)(i_v4 - 20 + (int32_t)i_v6) = (char)read_pic(i_v2, i_v1);
        i_v6++;
    }
    // 0x1473e
    pthread_mutex_unlock(&i_g186);
    char i_v7; // 0x1462c
    printf("--- %s: read_back_data[0] = 0x%x, read_back_data[1] = 0x%x, "
           "read_back_data[2] = 0x%x, read_back_data[3] = 0x%x,         "
           "read_back_data[4] = 0x%x, read_back_data[5] = 0x%x, "
           "read_back_data[6] = 0x%x, read_back_data[7] = 0x%x,         "
           "read_back_data[8] = 0x%x, read_back_data[9] = 0x%x, "
           "read_back_data[10] = 0x%x, read_back_data[11] = 0x%x\n",
           "read_temperature_offset_PIC16F1704", 255, (int32_t)i_v7,
           (int32_t)i_v7, (int32_t)i_v7, 0, (int32_t)i_v7, (int32_t)i_v7,
           (int32_t)i_v7, 0, (int32_t)i_v7, (int32_t)i_v7,
           (int32_t)(unsigned char)i_v7);
    printf("\n--- %s failed!\n\n", "read_temperature_offset_PIC16F1704");
    return 0;
}

// Address range: 0x148b0 - 0x14944
int32_t erase_PIC16F1704_app_flash(int32_t i_a1, uint32_t i_a2) {
    uint32_t i_v1 = i_a2 % 256;
    set_PIC16F1704_flash_point32_ter(i_a1, i_v1, 6, 0);
    printf("%s: erase_loop = %d\n", "erase_PIC16F1704_app_flash", 76);
    for (int32_t i_v2 = 0; i_v2 < 76; i_v2++) {
        // 0x14922
        erase_PIC16F1704_flash(i_a1, i_v1);
    }
    // 0x1493a
    return 76;
}

// Address range: 0x14944 - 0x14ddc
int32_t PIC1704_update_pic_app_program(int32_t i_a1, uint32_t i_a2) {
    // 0x14944
    int32_t i_v1; // bp-5048, 0x14944
    memset(&i_v1, 0, 0x1388);
    int32_t i_v2 = 0; // bp-5056, 0x14996
    int32_t i_v3 = 0; // bp-5072, 0x149c6
    puts("\n--- update pic program");
    struct _IO_FILE *p_v4 =
        fopen("/mnt/card/pic16f1704_app.txt", "r"); // 0x14a4c
    if (p_v4 == NULL) {
        // 0x14a60
        printf("\n%s: open pic16f1704_app.txt failed\n",
               "PIC1704_update_pic_app_program");
        // 0x14dce
        return 0;
    }
    uint32_t i_v5 = i_a2 % 256;
    fseek(p_v4, 0, SEEK_SET);
    memset(&i_v1, 0, 0x1388);
    printf("pic_flash_length = %d\n", 2432);
    int32_t i_v6 = &i_v1;
    for (int32_t i_v7 = 0; i_v7 < 2432; i_v7++) {
        // 0x14af8
        fgets((char *)&i_v2, 1023, p_v4);
        uint32_t i_v8 = strtoul((char *)&i_v2, NULL, 16); // 0x14b1a
        int32_t i_v9 = 2 * i_v7;                          // 0x14b32
        *(char *)(i_v9 + i_v6) = (char)(i_v8 / 256);
        *(char *)((i_v9 | 1) + i_v6) = (char)i_v8;
    }
    // 0x14b9a
    fclose(p_v4);
    if (reset_PIC16F1704_pic(i_a1, i_v5) == 0) {
        // 0x14bd2
        printf("!!! %s: reset pic error!\n\n",
               "PIC1704_update_pic_app_program");
        // 0x14dce
        return 0;
    }
    // 0x14bea
    if (erase_PIC16F1704_app_flash(i_a1, i_v5) == 0) {
        // 0x14c1a
        printf("!!! %s: erase flash error!\n\n",
               "PIC1704_update_pic_app_program");
        // 0x14dce
        return 0;
    }
    // 0x14c32
    if (set_PIC16F1704_flash_point32_ter(i_a1, i_v5, 6, 0) == 0) {
        // 0x14c64
        printf("!!! %s: set flash point32_ter error!\n\n",
               "PIC1704_update_pic_app_program");
        // 0x14dce
        return 0;
    }
    int32_t i_v10 = &i_v3;
    int32_t i_v11 = 0; // 0x14d5e
    i_v3 = *(int32_t *)(16 * i_v11 + i_v6);
    printf("send pic program time: %d\n", i_v11);
    int32_t i_v12 = 0; // 0x14d06
    printf("buf[%d] = 0x%02x\n", i_v12, (int32_t) * (char *)(i_v12 + i_v10));
    i_v12++;
    while (i_v12 == 15 || i_v12 < 15) {
        // 0x14cd2
        printf("buf[%d] = 0x%02x\n", i_v12,
               (int32_t) * (char *)(i_v12 + i_v10));
        i_v12++;
    }
    // 0x14d20
    putchar(10);
    send_data_to_PIC16F1704(i_a1, i_v5, &i_v3);
    write_data_int32_to_PIC16F1704_flash(i_a1, i_v5);
    i_v11++;
    while (i_v11 <= 304 == (i_v11 != 304)) {
        // 0x14c8a
        i_v3 = *(int32_t *)(16 * i_v11 + i_v6);
        printf("send pic program time: %d\n", i_v11);
        i_v12 = 0;
        printf("buf[%d] = 0x%02x\n", i_v12,
               (int32_t) * (char *)(i_v12 + i_v10));
        i_v12++;
        while (i_v12 == 15 || i_v12 < 15) {
            // 0x14cd2
            printf("buf[%d] = 0x%02x\n", i_v12,
                   (int32_t) * (char *)(i_v12 + i_v10));
            i_v12++;
        }
        // 0x14d20
        putchar(10);
        send_data_to_PIC16F1704(i_a1, i_v5, &i_v3);
        write_data_int32_to_PIC16F1704_flash(i_a1, i_v5);
        i_v11++;
    }
    int32_t i_v13 = 1; // 0x14db2
    if (reset_PIC16F1704_pic(i_a1, i_v5) == 0) {
        // 0x14db4
        printf("!!! %s: reset pic error!\n\n",
               "PIC1704_update_pic_app_program");
        i_v13 = 0;
    }
    // 0x14dce
    return i_v13;
}

// Address range: 0x14ddc - 0x14f38
int32_t save_freq_PIC16F1704(uint32_t i_a1, uint32_t i_a2, int32_t i_a3) {
    uint32_t i_v1 = i_a2 % 256;
    pthread_mutex_lock(&i_g186);
    uint32_t i_v2 = i_a1 % 256;
    int32_t i_v3; // bp-16, 0x14ddc
    int32_t i_v4 = &i_v3;
    char i_v5 = 0; // 0x14e90
    write_pic(i_v1, i_v2, (int32_t) * (char *)(i_v4 - 20 + (int32_t)i_v5));
    i_v5++;
    while (i_v5 == 7 || i_v5 < 7) {
        // 0x14e72
        write_pic(i_v1, i_v2, (int32_t) * (char *)(i_v4 - 20 + (int32_t)i_v5));
        i_v5++;
    }
    // 0x14e9a
    usleep((int32_t)&i_g204);
    int32_t i_v6 = i_v4 - 12;
    unsigned char i_v7 = 0;
    *(char *)(i_v6 + (int32_t)i_v7) = (char)read_pic(i_v1, i_v2);
    char i_v8 = i_v7 + 1; // 0x14ecc
    while (i_v7 == 0 || i_v8 == 0) {
        // 0x14eac
        i_v7 = i_v8;
        *(char *)(i_v6 + (int32_t)i_v7) = (char)read_pic(i_v1, i_v2);
        i_v8 = i_v7 + 1;
    }
    // 0x14ed6
    pthread_mutex_unlock(&i_g186);
    usleep(0x30d40);
    char i_v9; // 0x14ddc
    printf("\n--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = "
           "0x%02x\n\n",
           "save_freq_PIC16F1704", 255, (int32_t)(unsigned char)i_v9);
    return 0;
}

// Address range: 0x14f38 - 0x15122
int32_t get_PIC16F1704_freq(uint32_t i_a1, uint32_t i_a2, int32_t i_a3) {
    uint32_t i_v1 = i_a2 % 256;
    pthread_mutex_lock(&i_g186);
    uint32_t i_v2 = i_a1 % 256;
    int32_t i_v3; // bp-16, 0x14f38
    int32_t i_v4 = &i_v3;
    char i_v5 = 0; // 0x14fe0
    write_pic(i_v1, i_v2, (int32_t) * (char *)(i_v4 - 24 + (int32_t)i_v5));
    i_v5++;
    while (i_v5 == 5 || i_v5 < 5) {
        // 0x14fbe
        write_pic(i_v1, i_v2, (int32_t) * (char *)(i_v4 - 24 + (int32_t)i_v5));
        i_v5++;
    }
    // 0x14fee
    usleep((int32_t)&i_g204);
    char i_v6 = 0; // 0x15026
    *(char *)(i_v4 - 16 + (int32_t)i_v6) = (char)read_pic(i_v1, i_v2);
    i_v6++;
    while (i_v6 == 5 || i_v6 < 5) {
        // 0x15002
        *(char *)(i_v4 - 16 + (int32_t)i_v6) = (char)read_pic(i_v1, i_v2);
        i_v6++;
    }
    // 0x15034
    pthread_mutex_unlock(&i_g186);
    usleep(0x30d40);
    char i_v7; // 0x14f38
    printf("--- %s: read_back_data[0] = 0x%x, read_back_data[1] = 0x%x, "
           "read_back_data[2] = 0x%x, read_back_data[3] = 0x%x, "
           "read_back_data[4] = 0x%x, read_back_data[5] = 0x%x\n",
           "get_PIC16F1704_freq", 255, (int32_t)i_v7, (int32_t)i_v7,
           (int32_t)i_v7, 0, (int32_t)(unsigned char)i_v7);
    printf("\n--- %s failed!\n\n", "get_PIC16F1704_freq");
    return 0;
}

// Address range: 0x15124 - 0x15166
int32_t set_temperature_offset_value(int32_t i_a1, uint32_t i_a2, char *p_a3) {
    // 0x15124
    printf("\n--- %s\n", (char *)((int32_t) "{y" | 0x20000));
    write_temperature_offset_PIC16F1704(i_a1, i_a2 % 256, (int32_t)p_a3);
    return usleep((int32_t)&i_g239 | 0x10000);
}

// Address range: 0x15168 - 0x1521a
int32_t write_sensor_info_int32_to_pic(int32_t i_a1, uint32_t i_a2) {
    // 0x15168
    printf("\n--- %s\n", "write_sensor_info_int32_to_pic");
    char i_v1 = i_g128; // bp-16, 0x151b4
    return set_temperature_offset_value(i_a1, i_a2 % 256, &i_v1);
}

// Address range: 0x1521c - 0x152fe
int32_t check_chain(void) {
    // 0x1521c
    printf("--- %s\n", "check_chain");
    if (platform_init() != 0) {
        // 0x15240
        puts("platform init failed!");
        // 0x152f4
        return -1;
    }
    // 0x15252
    int32_t i_v1; // bp-300, 0x1521c
    get_system_capability(&i_v1);
    int32_t i_v2; // 0x1521c
    switch (i_v1) {
    case 1: {
        // 0x15262
        int32_t i_v3;     // 0x1521c
        char i_v4 = i_v3; // 0x15270
        *(char *)&p_g155 = i_v4;
        *(char *)((2 * i_v3 & 510) + (int32_t)&i_g100) = i_v4;
        unsigned char i_v5 = *(char *)&p_g155; // 0x1529c
        *(char *)(2 * (int32_t)i_v5 + (int32_t)&i_g100 + 1) = 0;
        printf("gChain = %d\n", (int32_t) * (char *)&p_g155);
        i_v2 = 0;
        // break -> 0x152f4
        break;
    }
    case 0: {
        // 0x152e4
        puts("no hash board inserted");
        i_v2 = -1;
        // break -> 0x152f4
        break;
    }
    default: {
        // 0x152d2
        puts("test zhiju only support 1 plug");
        i_v2 = -1;
        // break -> 0x152f4
        break;
    }
    }
    // 0x152f4
    return i_v2;
}

// Address range: 0x15300 - 0x1535c
int32_t fan_control(uint32_t i_a1) {
    // 0x15300
    if (i_g39 == 0) {
        // 0x15318
        i_g39 = pwm_init(0, 100);
    }
    // 0x1532c
    printf((char *)((int32_t)&p_g299 | 0x20000));
    return pwm_set(i_g39, i_a1 % 256);
}

// Address range: 0x1535c - 0x1542e
int32_t set_PWM_according_to_temperature(void) {
    unsigned char i_v1 = *(char *)&p_g155;                            // 0x15368
    int32_t i_v2 = *(int32_t *)(4 * (int32_t)i_v1 + (int32_t)&i_g19); // 0x15374
    if (i_v2 < (int32_t)i_g132) {
        // 0x1542c
        return fan_control(0);
    }
    if (i_v2 <= 49) {
        // 0x1542c
        return fan_control(40);
    }
    int32_t i_v3 = i_g133; // 0x153d4
    int32_t i_v4;          // 0x1535c
    if (i_v2 < i_v3) {
        // 0x153e4
        i_v4 = fan_control(((60 * i_v2 - 3000) / (i_v3 - 50) + 40) % 256);
    } else {
        // 0x153dc
        i_v4 = fan_control(100);
    }
    // 0x1542c
    return i_v4;
}

// Address range: 0x15430 - 0x15476
int32_t znyq_set_iic(int32_t i_a1, int32_t i_a2, uint32_t i_a3, int32_t i_a4,
                     uint32_t i_a5) {
    uint32_t i_v1 = i_a5 % 256;
    int32_t i_v2; // 0x15430
    if (i_a3 % 256 == 0) {
        // 0x15458
        int32_t i_v3; // 0x15430
        i_v2 = iic_i2c_write_reg(i_v1, &i_v3, 1);
    } else {
        // 0x15444
        int32_t i_v4; // bp-9, 0x15430
        iic_i2c_read_reg(i_v1, &i_v4, 1);
        i_v2 = i_v4;
    }
    // 0x1546c
    return i_v2 % 256;
}

// Address range: 0x15478 - 0x154ca
int32_t power_on(void) {
    // 0x15478
    if (access("/sys/class/gpio/gpio907", F_OK) == -1) {
        // 0x15492
        system("echo 907 > /sys/class/gpio/export");
        system("echo out > /sys/class/gpio/gpio907/direction");
        puts("init gpio907");
    }
    // 0x154b6
    system("echo 0 > /sys/class/gpio/gpio907/value");
    return sleep(1);
}

// Address range: 0x154cc - 0x1551e
int32_t power_off(void) {
    // 0x154cc
    if (access("/sys/class/gpio/gpio907", F_OK) == -1) {
        // 0x154e6
        system("echo 907 > /sys/class/gpio/export");
        system("echo out > /sys/class/gpio/gpio907/direction");
        puts("init gpio907");
    }
    // 0x1550a
    system("echo 1 > /sys/class/gpio/gpio907/value");
    return sleep(1);
}

// Address range: 0x15520 - 0x155b6
int32_t power_check_protocal_type(void) {
    // 0x15520
    pthread_mutex_lock(&i_g186);
    uint32_t i_v1 =
        znyq_set_iic((int32_t)(unsigned char)i_g163, (int32_t)i_g164, 1, 1, 0) %
        256;      // 0x15562
    int16_t i_v2; // 0x15520
    if (i_v1 == 245) {
        // 0x15568
        printf("power protocal %02x, using package cmd\n", 245);
        i_v2 = 2;
    } else {
        // 0x15586
        printf("power protocal %02x, using simple cmd\n", i_v1);
        i_v2 = 1;
    }
    // 0x155a2
    *(int16_t *)&p_g162 = i_v2;
    return pthread_mutex_unlock(&i_g186);
}

// Address range: 0x155b8 - 0x155d2
int32_t power_init(void) {
    // 0x155b8
    puts("power init ... ");
    power_check_protocal_type();
    return power_on();
}

// Address range: 0x155d4 - 0x1570e
int32_t power_check_reply(int32_t i_a1, int32_t i_a2, int32_t i_a3) {
    uint32_t i_v1 = 0x1000000 * i_a3 >> 24; // 0x155e0
    int32_t i_v2;                           // 0x155d4
    if ((char)i_v2 == (char)i_v2) {
        // 0x15602
        if (*(char *)(i_a1 + 1) == *(char *)(i_a2 + 1)) {
            // 0x15612
            if (*(char *)(i_a1 + 3) == *(char *)(i_a2 + 3)) {
                unsigned char i_v3 = *(char *)(i_a2 + 2); // 0x155f2
                uint32_t i_v4 = (int32_t)i_v3;            // 0x15622
                uint32_t i_v5 = i_v4 + 2;                 // 0x15624
                if (i_v5 == i_v1 % 256) {
                    int32_t i_v6 = 0; // 0x15692
                    if (i_v3 > 2) {
                        int16_t i_v7 =
                            (int16_t) * (char *)(2 + i_a2); // 0x15680
                        int16_t i_v8 = 3;                   // 0x15686
                        int32_t i_v9 = i_v8;                // 0x1568a
                        int16_t i_v10 = i_v8;               // 0x15692
                        int16_t i_v11 = i_v7;               // 0x15692
                        while (i_v4 > i_v9) {
                            // 0x15674
                            i_v7 = i_v11 + (int16_t) * (char *)(i_v9 + i_a2);
                            i_v8 = i_v10 + 1;
                            i_v9 = i_v8;
                            i_v10 = i_v8;
                            i_v11 = i_v7;
                        }
                        // 0x1568a
                        i_v6 = i_v7;
                    }
                    unsigned char i_v12 = *(char *)(i_v4 + i_a2); // 0x156aa
                    int32_t i_v13 =
                        256 * (int32_t) * (char *)(i_a2 - 1 + i_v5) |
                        (int32_t)i_v12; // 0x156ac
                    if (i_v13 == i_v6) {
                        // 0x15704
                        return 1;
                    }
                    // 0x156d2
                    printf(
                        "power reply crc error, crc %04x != crc_reply %04x:\n",
                        i_v6, i_v13);
                    int16_t i_v14 = 0; // 0x156ea
                    printf("%02x ", (int32_t) * (char *)i_a2);
                    i_v14++;
                    int32_t i_v15 = i_v14; // 0x156f2
                    while (i_v5 > i_v15) {
                        // 0x156d2
                        printf("%02x ", (int32_t) * (char *)(i_v15 + i_a2));
                        i_v14++;
                        i_v15 = i_v14;
                    }
                    // 0x156f8
                    putchar(10);
                    // 0x15704
                    return 0;
                }
            }
        }
    }
    // 0x1562c
    puts("power reply data error:");
    uint32_t i_v16 = i_v1 % 256; // 0x1565a
    int16_t i_v17 = 0;           // 0x15662
    if (i_v16 != 0) {
        printf("%02x ", (int32_t) * (char *)i_a2);
        i_v17++;
        int32_t i_v18 = i_v17; // 0x1565e
        while (i_v16 > i_v18) {
            // 0x1563e
            printf("%02x ", (int32_t) * (char *)(i_v18 + i_a2));
            i_v17++;
            i_v18 = i_v17;
        }
    }
    // 0x15664
    putchar(10);
    // 0x15704
    return 0;
}

// Address range: 0x15710 - 0x15832
int32_t power_send_cmd(int32_t *p_a1, uint32_t i_a2, int32_t *p_a3,
                       uint32_t i_a4) {
    int32_t i_v1 = (int32_t)p_a3;
    int32_t i_v2 = (int32_t)p_a1;
    uint32_t i_v3 = i_a2 % 256;
    uint32_t i_v4 = i_a4 % 256;
    pthread_mutex_lock(&i_g186);
    char *p_v5 = (char *)(i_v2 + 3);
    unsigned char i_v6 = 0; // 0x157e8
    bool i_v7 = false;
    bool i_v8 = false;
    char i_v9;  // 0x15710
    char i_v10; // 0x15768
    if (i_v3 != 0) {
        znyq_set_iic(16, 1, 0, 1, 17);
        i_v10 = 1;
        i_v9 = i_v10;
        while (i_v3 > (int32_t)i_v10) {
            // 0x15748
            znyq_set_iic(16, 1, 0, 1, 17);
            i_v10 = i_v9 + 1;
            i_v9 = i_v10;
        }
    }
    // 0x15774
    usleep((int32_t)&i_g207);
    int32_t i_v11 = 0; // 0x157d2
    char i_v12;        // 0x15710
    int32_t i_v13;     // 0x157cc
    uint32_t i_v14;    // 0x157a0
    char i_v15;        // 0x157c8
    if (i_v4 != 0) {
        i_v14 = znyq_set_iic(16, 1, 1, 0, 17);
        *(char *)(i_v11 + i_v1) = (char)i_v14;
        printf("%s, reply_buf[%d]=%02x\n", "power_send_cmd", i_v11,
               i_v14 % 256);
        i_v15 = 1;
        i_v13 = i_v15;
        i_v11 = i_v13;
        i_v12 = i_v15;
        while (i_v4 > i_v13) {
            // 0x15786
            i_v14 = znyq_set_iic(16, 1, 1, 0, 17);
            *(char *)(i_v11 + i_v1) = (char)i_v14;
            printf("%s, reply_buf[%d]=%02x\n", "power_send_cmd", i_v11,
                   i_v14 % 256);
            i_v15 = i_v12 + 1;
            i_v13 = i_v15;
            i_v11 = i_v13;
            i_v12 = i_v15;
        }
    }
    int32_t i_v16 = power_check_reply(i_v2, i_v1, i_v4); // 0x157dc
    while (i_v16 == 0) {
        // 0x157e6
        i_v6++;
        printf("power send cmd 0x%02x failed, retry for %d times\n",
               (int32_t)*p_v5, (int32_t)i_v6);
        if (i_v6 != 2 && i_v6 >= 2) {
            // 0x15810
            pthread_mutex_unlock(&i_g186);
            return false;
        }
        i_v7 = i_v6 >= 2;
        i_v8 = i_v6 == 2;
        if (i_v3 != 0) {
            znyq_set_iic(16, 1, 0, 1, 17);
            i_v10 = 1;
            i_v9 = i_v10;
            while (i_v3 > (int32_t)i_v10) {
                // 0x15748
                znyq_set_iic(16, 1, 0, 1, 17);
                i_v10 = i_v9 + 1;
                i_v9 = i_v10;
            }
        }
        // 0x15774
        usleep((int32_t)&i_g207);
        i_v11 = 0;
        if (i_v4 != 0) {
            i_v14 = znyq_set_iic(16, 1, 1, 0, 17);
            *(char *)(i_v11 + i_v1) = (char)i_v14;
            printf("%s, reply_buf[%d]=%02x\n", "power_send_cmd", i_v11,
                   i_v14 % 256);
            i_v15 = 1;
            i_v13 = i_v15;
            i_v11 = i_v13;
            i_v12 = i_v15;
            while (i_v4 > i_v13) {
                // 0x15786
                i_v14 = znyq_set_iic(16, 1, 1, 0, 17);
                *(char *)(i_v11 + i_v1) = (char)i_v14;
                printf("%s, reply_buf[%d]=%02x\n", "power_send_cmd", i_v11,
                       i_v14 % 256);
                i_v15 = i_v12 + 1;
                i_v13 = i_v15;
                i_v11 = i_v13;
                i_v12 = i_v15;
            }
        }
        // 0x157d4
        i_v16 = power_check_reply(i_v2, i_v1, i_v4);
    }
    // 0x1580e
    __asm_nop(i_v16, i_v1, i_v4, i_v16);
    // 0x15810
    pthread_mutex_unlock(&i_g186);
    return i_v7 != !i_v8;
}

// Address range: 0x15834 - 0x158b6
int32_t power_get_firmware_version(void) {
    int32_t i_v1 = 0x104aa55;                          // bp-16, 0x15848
    int32_t i_v2 = 0;                                  // bp-48, 0x15852
    int32_t i_v3 = power_send_cmd(&i_v1, 6, &i_v2, 8); // 0x1588e
    int32_t i_v4 = 0;                                  // 0x15896
    if (i_v3 != 0) {
        // 0x15898
        char i_v5; // 0x15834
        i_v4 = printf("power firmware version is %02x %02x\n",
                      (int32_t)(unsigned char)i_v5, 0);
    }
    // 0x158ae
    return i_v4;
}

// Address range: 0x158b8 - 0x1593a
int32_t power_get_device_no(void) {
    int32_t i_v1 = 0x204aa55;                          // bp-16, 0x158cc
    int32_t i_v2 = 0;                                  // bp-48, 0x158d6
    int32_t i_v3 = power_send_cmd(&i_v1, 6, &i_v2, 8); // 0x15912
    int32_t i_v4 = 0;                                  // 0x1591a
    if (i_v3 != 0) {
        // 0x1591c
        char i_v5; // 0x158b8
        i_v4 = printf("power device no is %02x %02x\n",
                      (int32_t)(unsigned char)i_v5, 0);
    }
    // 0x15932
    return i_v4;
}

// Address range: 0x1593c - 0x159be
int32_t power_get_da_value(void) {
    int32_t i_v1 = 0x304aa55; // bp-16, 0x15950
    int32_t i_v2 = 0;         // bp-48, 0x1595a
    if (power_send_cmd(&i_v1, 6, &i_v2, 8) != 0) {
        // 0x159a0
        printf("power get da value is %02x\n", 0);
    }
    // 0x159b4
    return 0;
}

// Address range: 0x159c0 - 0x15a2a
int32_t power_get_da_value_simple(void) {
    // 0x159c0
    pthread_mutex_lock(&i_g186);
    uint32_t i_v1 =
        znyq_set_iic((int32_t)(unsigned char)i_g163, (int32_t)i_g164, 1, 1, 2) %
        256; // 0x15a02
    printf("power da value is %d\n", i_v1);
    pthread_mutex_unlock(&i_g186);
    return i_v1;
}

// Address range: 0x15a2c - 0x15aa8
int32_t power_get_adc_value(void) {
    int32_t i_v1 = 0x404aa55;                          // bp-16, 0x15a40
    int32_t i_v2 = 0;                                  // bp-48, 0x15a4a
    int32_t i_v3 = power_send_cmd(&i_v1, 6, &i_v2, 8); // 0x15a86
    int32_t i_v4 = 0;                                  // 0x15a8e
    if (i_v3 != 0) {
        // 0x15a90
        i_v4 = printf("power get adc value is %02x\n", 0);
    }
    // 0x15aa0
    return i_v4;
}

// Address range: 0x15aa8 - 0x15ba6
int32_t power_set_da_value(uint32_t i_a1) {
    uint32_t i_v1 = *(int32_t *)((int32_t)&i_g300 | (int32_t)&i_g5); // 0x15abe
    int32_t i_v2 = i_v1; // bp-36, 0x15ac2
    int32_t i_v3 = 0;    // bp-68, 0x15aca
    uint16_t i_v4 = 2;   // 0x15b20
    uint16_t i_v5 = 0;   // 0x15b18
    int32_t i_v6;        // bp-24, 0x15aa8
    i_v5 += (int16_t) * (char *)((int32_t)&i_v6 - 10);
    i_v4++;
    while (i_v4 == 5 || i_v4 < 5) {
        unsigned char i_v7 =
            *(char *)((int32_t)&i_v6 - 12 + (int32_t)i_v4); // 0x15b10
        i_v5 += (int16_t)i_v7;
        i_v4++;
    }
    // 0x15b28
    char i_v8; // 0x15aa8
    printf("%s, %02x, %02x, %02x, %02x, %02x, %02x, %02x, %02x\n",
           "power_set_da_value", i_v1 % 256, (int32_t)i_v8, (int32_t)i_v8,
           (int32_t)i_v8, i_a1 % 256, (int32_t)(unsigned char)i_v8,
           (int32_t)(i_v5 % 256), (int32_t)(i_v5 / 256));
    return power_send_cmd(&i_v2, 8, &i_v3, 8);
}

// Address range: 0x15ba8 - 0x15c1a
int32_t power_set_da_value_simple(int32_t i_a1) {
    // 0x15ba8
    pthread_mutex_lock(&i_g186);
    usleep((int32_t)&i_g239 | 0x10000);
    uint32_t i_v1 = znyq_set_iic((int32_t)(unsigned char)i_g163,
                                 (int32_t)i_g164, 0, 1, 2); // 0x15bfa
    pthread_mutex_unlock(&i_g186);
    return i_v1 % 256;
}

// Address range: 0x15c1c - 0x15de0
int32_t power_save_eeprom_data(uint32_t i_a1, int32_t i_a2, int32_t i_a3) {
    uint32_t i_v1 = i_a1 % 256;
    uint32_t i_v2 = 0x1000000 * i_a3 >> 24; // 0x15c2e
    int32_t i_v3;                           // bp-276, 0x15c1c
    memset(&i_v3, 0, 256);
    int32_t i_v4 = 0;           // bp-308, 0x15c4a
    uint32_t i_v5 = i_v2 % 256; // 0x15c80
    if (__asm_sxtb(i_v1) < 0) {
        // 0x15c9a
        printf("invalid param addr 0x%02x, len %d\n", i_v1, i_v5);
        // 0x15dd6
        return 0;
    }
    if (i_v5 != 32 && i_v5 >= 32) {
        // 0x15c9a
        printf("invalid param addr 0x%02x, len %d\n", i_v1, i_v5);
        // 0x15dd6
        return 0;
    }
    // 0x15cb6
    i_v3 = 85;
    int32_t i_v6 = &i_v3;
    if (i_v5 != 0) {
        int16_t i_v7 = 0; // 0x15d0a
        int32_t i_v8 = 0;
        *(char *)(i_v6 + 5 + i_v8) = *(char *)(i_v8 + i_a2);
        i_v7++;
        int32_t i_v9 = i_v7; // 0x15d16
        while (i_v5 > i_v9) {
            // 0x15cee
            i_v8 = i_v9;
            *(char *)(i_v6 + 5 + i_v8) = *(char *)(i_v8 + i_a2);
            i_v7++;
            i_v9 = i_v7;
        }
    }
    uint32_t i_v10 = i_v5 + 5; // 0x15d4e
    int16_t i_v11 = 2;         // 0x15d40
    int16_t i_v12 = 0;         // 0x15d36
    i_v12 += (int16_t) * (char *)(2 + i_v6);
    i_v11++;
    int32_t i_v13 = i_v11; // 0x15d46
    while (i_v10 > i_v13) {
        // 0x15d26
        i_v12 += (int16_t) * (char *)(i_v13 + i_v6);
        i_v11++;
        i_v13 = i_v11;
    }
    // 0x15d54
    *(char *)(i_v10 + i_v6) = (char)i_v12;
    *(char *)(i_v5 + 6 + i_v6) = (char)(i_v12 / 256);
    if (power_send_cmd(&i_v3, (i_v2 + 7) % 256, &i_v4, 8) % 256 != 1) {
        // 0x15dd6
        return 0;
    }
    int32_t i_v14; // 0x15c1c
    char i_v15;    // 0x15c1c
    if (i_v15 == 1) {
        // 0x15db8
        puts("save eeprom data success ");
        i_v14 = 1;
    } else {
        // 0x15dc8
        puts("save eeprom data failed ");
        i_v14 = 0;
    }
    // 0x15dd6
    return i_v14;
}

// Address range: 0x15de0 - 0x15f4a
int32_t power_read_eeprom_data(uint32_t i_a1, int32_t i_a2, int32_t i_a3) {
    uint32_t i_v1 = i_a1 % 256;
    uint32_t i_v2 = 0x1000000 * i_a3 >> 24; // 0x15df2
    int32_t i_v3 = 0x606aa55;               // bp-24, 0x15e04
    int32_t i_v4;                           // bp-280, 0x15de0
    memset(&i_v4, 0, 256);
    uint32_t i_v5 = i_v2 % 256;
    if (__asm_sxtb(i_v1) < 0) {
        // 0x15e32
        printf("invalid param addr 0x%02x, len %d\n", i_v1, i_v5);
        // 0x15f40
        return 0;
    }
    uint16_t i_v6 = 2; // 0x15e30
    if (i_v5 != 32 && i_v5 >= 32) {
        // 0x15e32
        printf("invalid param addr 0x%02x, len %d\n", i_v1, i_v5);
        // 0x15f40
        return 0;
    }
    while (i_v6 == 5 || i_v6 < 5) {
        // 0x15e8a
        i_v6++;
    }
    // 0x15e92
    if (power_send_cmd(&i_v3, 8, &i_v4, (i_v2 + 7) % 256) % 256 != 1) {
        // 0x15f40
        return 0;
    }
    // 0x15eda
    printf("read eeprom data:");
    if (i_v5 != 0) {
        int32_t i_v7 = 0;                                          // 0x15f30
        int16_t i_v8 = 0;                                          // 0x15f24
        unsigned char i_v9 = *(char *)((int32_t)&i_v4 + 5 + i_v7); // 0x15f02
        *(char *)(i_v7 + i_a2) = i_v9;
        printf("%02x ", (int32_t)i_v9);
        i_v8++;
        i_v7 = i_v8;
        while (i_v5 > i_v7) {
            // 0x15eee
            i_v9 = *(char *)((int32_t)&i_v4 + 5 + i_v7);
            *(char *)(i_v7 + i_a2) = i_v9;
            printf("%02x ", (int32_t)i_v9);
            i_v8++;
            i_v7 = i_v8;
        }
    }
    // 0x15f38
    putchar(10);
    // 0x15f40
    return 1;
}

// Address range: 0x15f4c - 0x15f6c
int32_t power_is_support_cmd_package(void) {
    int16_t i_v1 = *(int16_t *)&p_g162; // 0x15f58
    if (i_v1 != 2) {
        __asm_ite();
    }
    return i_v1 == 2;
}

// Address range: 0x15f6c - 0x15fa2
int32_t power_get_voltage(int32_t i_a1) {
    // 0x15f6c
    if (power_is_support_cmd_package() == 0) {
        // 0x15f8c
        *(char *)i_a1 = (char)power_get_da_value_simple();
    } else {
        // 0x15f7e
        *(char *)i_a1 = (char)power_get_da_value();
    }
    // 0x15f98
    return i_a1;
}

// Address range: 0x15fa4 - 0x15fd4
int32_t power_set_voltage(uint32_t i_a1) {
    uint32_t i_v1 = i_a1 % 256;
    if (power_is_support_cmd_package() == 0) {
        // 0x15fc2
        power_set_da_value_simple(i_v1);
    } else {
        // 0x15fb8
        power_set_da_value(i_v1);
    }
    // 0x15fca
    return i_v1;
}

// Address range: 0x15fd8 - 0x1600a
int32_t sph_bswap32(int32_t i_a1) {
    // 0x15fd8
    return llvm_bswap_i32(i_a1);
}

// Address range: 0x1600c - 0x160da
int32_t sph_bswap64(int64_t i_a1, int32_t i_a2) {
    // 0x1600c
    __asm_adr(172);
    return i_a2 >> 31;
}

// Address range: 0x160dc - 0x160e0
int32_t function_160dc(void) {
    // 0x160dc
    int32_t i_v1; // 0x160dc
    return i_v1;
}

// Address range: 0x160e8 - 0x16128
int32_t sph_enc32be(int32_t i_a1, uint32_t i_a2) {
    // 0x160e8
    *(char *)i_a1 = (char)(i_a2 / 0x1000000);
    *(char *)(i_a1 + 1) = (char)(i_a2 / 0x10000);
    *(char *)(i_a1 + 2) = (char)(i_a2 / 256);
    *(char *)(i_a1 + 3) = (char)i_a2;
    return i_a1;
}

// Address range: 0x16128 - 0x16146
int32_t sph_enc32be_aligned(int32_t *p_a1, int32_t i_a2) {
    int32_t i_v1 = sph_bswap32(i_a2); // 0x16134
    *p_a1 = i_v1;
    return i_v1;
}

// Address range: 0x16148 - 0x16166
int32_t sph_dec32be_aligned(int32_t i_a1) {
    // 0x16148
    return sph_bswap32(i_a1);
}

// Address range: 0x16168 - 0x16222
int32_t sph_enc64be(int32_t i_a1, int32_t i_a2, int64_t i_a3, int64_t i_a4) {
    uint32_t i_v1 = (int32_t)i_a3;
    *(char *)i_a1 = (char)(i_v1 / 0x1000000);
    *(char *)(i_a1 + 1) = (char)(i_v1 / 0x10000);
    *(char *)(i_a1 + 2) = (char)(i_v1 / 256);
    char i_v2 = i_a3; // 0x161c2
    *(char *)(i_a1 + 3) = i_v2;
    uint32_t i_v3 = i_v1 / 0x80000000;
    *(char *)(i_a1 + 4) = (char)(i_v3 / 0x1000000);
    *(char *)(i_a1 + 5) = (char)(i_v3 / 0x10000);
    *(char *)(i_a1 + 6) = (char)(i_v3 / 256);
    *(char *)(i_a1 + 7) = i_v2;
    return i_v1;
}

// Address range: 0x16224 - 0x1624a
int32_t sph_enc64be_aligned(int32_t *p_a1, int32_t i_a2, int64_t i_a3,
                            int32_t i_a4) {
    int32_t i_v1 = i_a3;                                        // 0x16230
    int32_t i_v2 = sph_bswap64(0x100000000 * i_a3 >> 63, i_v1); // 0x16234
    *p_a1 = i_v2;
    *(int32_t *)((int32_t)p_a1 + 4) = i_v1;
    return i_v2;
}

// Address range: 0x1624c - 0x16272
int32_t sph_dec64be_aligned(int32_t i_a1) {
    // 0x1624c
    int32_t i_v1;                     // 0x1624c
    int64_t i_v2 = *(int64_t *)&i_v1; // 0x16256
    return sph_bswap64(i_v2 >> 32, (int32_t)i_v2);
}

// Address range: 0x16274 - 0x162b8
int32_t blake32_init(int32_t i_a1, int32_t i_a2, int32_t i_a3) {
    // 0x16274
    memcpy((int32_t *)(i_a1 + 68), (int32_t *)i_a2, 32);
    int32_t *p_v1 =
        memcpy((int32_t *)(i_a1 + 100), (int32_t *)i_a3, 16); // 0x16298
    *(int32_t *)(i_a1 + 120) = 0;
    *(int32_t *)(i_a1 + 116) = 0;
    *(int32_t *)(i_a1 + 64) = 0;
    return (int32_t)p_v1;
}

// Address range: 0x162b8 - 0x19cae
int32_t blake32(int32_t i_a1, int32_t i_a2, uint32_t i_a3) {
    int32_t *p_v1 = (int32_t *)(i_a1 + 64); // 0x162cc
    int32_t i_v2 = *p_v1;                   // 0x162cc
    uint32_t i_v3 = 64 - i_v2;              // 0x162d6
    if (i_v3 != i_a3 && i_v3 >= i_a3) {
        int32_t *p_v4 =
            memcpy((int32_t *)(i_v2 + i_a1), (int32_t *)i_a2, i_a3); // 0x162f0
        // 0x19ca6
        *p_v1 = i_v2 + i_a3;
        return (int32_t)p_v4;
    }
    int32_t *p_v5 = (int32_t *)(i_a1 + 68);   // 0x1630e
    int32_t i_v6 = *p_v5;                     // 0x1630e
    int32_t *p_v7 = (int32_t *)(i_a1 + 72);   // 0x16316
    int32_t i_v8 = *p_v7;                     // 0x16316
    int32_t *p_v9 = (int32_t *)(i_a1 + 76);   // 0x1631e
    int32_t i_v10 = *p_v9;                    // 0x1631e
    int32_t *p_v11 = (int32_t *)(i_a1 + 80);  // 0x16326
    int32_t i_v12 = *p_v11;                   // 0x16326
    int32_t *p_v13 = (int32_t *)(i_a1 + 84);  // 0x1632e
    int32_t i_v14 = *p_v13;                   // 0x1632e
    int32_t *p_v15 = (int32_t *)(i_a1 + 88);  // 0x16336
    int32_t i_v16 = *p_v15;                   // 0x16336
    int32_t *p_v17 = (int32_t *)(i_a1 + 92);  // 0x1633e
    int32_t i_v18 = *p_v17;                   // 0x1633e
    int32_t *p_v19 = (int32_t *)(i_a1 + 96);  // 0x16346
    int32_t i_v20 = *p_v19;                   // 0x16346
    int32_t *p_v21 = (int32_t *)(i_a1 + 100); // 0x1634e
    int32_t i_v22 = *p_v21;                   // 0x1634e
    int32_t *p_v23 = (int32_t *)(i_a1 + 104); // 0x16356
    int32_t i_v24 = *p_v23;                   // 0x16356
    int32_t *p_v25 = (int32_t *)(i_a1 + 108); // 0x1635e
    int32_t i_v26 = *p_v25;                   // 0x1635e
    int32_t *p_v27 = (int32_t *)(i_a1 + 112); // 0x16366
    int32_t i_v28 = *p_v27;                   // 0x16366
    int32_t *p_v29 = (int32_t *)(i_a1 + 116); // 0x1636e
    int32_t i_v30 = *p_v29;                   // 0x1636e
    int32_t *p_v31 = (int32_t *)(i_a1 + 120); // 0x16376
    int32_t i_v32 = *p_v31;                   // 0x16376
    int32_t i_v33 = i_v6;                     // 0x19c2a
    int32_t i_v34 = i_v8;                     // 0x19c2a
    int32_t i_v35 = i_v10;                    // 0x19c2a
    int32_t i_v36 = i_v12;                    // 0x19c2a
    int32_t i_v37 = i_v14;                    // 0x19c2a
    int32_t i_v38 = i_v16;                    // 0x19c2a
    int32_t i_v39 = i_v18;                    // 0x19c2a
    int32_t i_v40 = i_v20;                    // 0x19c2a
    int32_t i_v41 = i_v30;                    // 0x19c2a
    int32_t i_v42 = i_v32;                    // 0x19c2a
    int32_t i_v43 = i_v2;                     // 0x19c2a
    int32_t i_v44 = i_a1;                     // 0x19c2a
    if (i_a3 != 0) {
        uint32_t i_v45 = i_a3;
        uint32_t i_v46 = 64 - i_v2; // 0x16384
        int32_t i_v47 = i_v46 == i_v45 | i_v46 < i_v45 ? i_v46 : i_v45;
        int32_t *p_v48 =
            memcpy((int32_t *)(i_v2 + i_a1), (int32_t *)i_a2, i_v47); // 0x163ae
        int32_t i_v49 = i_v47 + i_v2;                                 // 0x163ba
        int32_t i_v50 = i_v47 + i_a2;                                 // 0x163c6
        int32_t i_v51 = i_v45 - i_v47;                                // 0x163d0
        while (i_v49 != 64) {
            // 0x19c26
            if (i_v51 == 0) {
                // 0x19c26
                i_v33 = i_v6;
                i_v34 = i_v8;
                i_v35 = i_v10;
                i_v36 = i_v12;
                i_v37 = i_v14;
                i_v38 = i_v16;
                i_v39 = i_v18;
                i_v40 = i_v20;
                i_v41 = i_v30;
                i_v42 = i_v32;
                i_v43 = i_v49;
                i_v44 = (int32_t)p_v48;
                goto lab_0x19c2e;
            }
            i_v45 = i_v51;
            i_v46 = 64 - i_v49;
            i_v47 = i_v46 == i_v45 | i_v46 < i_v45 ? i_v46 : i_v45;
            p_v48 = memcpy((int32_t *)(i_v49 + i_a1), (int32_t *)i_v50, i_v47);
            i_v49 += i_v47;
            i_v50 += i_v47;
            i_v51 = i_v45 - i_v47;
        }
        int32_t i_v52 = i_v30 + 512; // 0x163e2
        int32_t i_v53 = i_v32 + (int32_t)(i_v52 >= 511 != i_v52 != 511);
        int32_t i_v54 = sph_dec32be_aligned(i_a1);               // 0x164be
        int32_t i_v55 = sph_dec32be_aligned(i_a1 + 4);           // 0x164cc
        int32_t i_v56 = sph_dec32be_aligned(i_a1 + 8);           // 0x164da
        int32_t i_v57 = sph_dec32be_aligned(i_a1 + 12);          // 0x164e8
        int32_t i_v58 = sph_dec32be_aligned(i_a1 + 16);          // 0x164f6
        int32_t i_v59 = sph_dec32be_aligned(i_a1 + 20);          // 0x16504
        int32_t i_v60 = sph_dec32be_aligned(i_a1 + 24);          // 0x16512
        int32_t i_v61 = sph_dec32be_aligned(i_a1 + 28);          // 0x16520
        int32_t i_v62 = sph_dec32be_aligned(i_a1 + 32);          // 0x1652e
        int32_t i_v63 = sph_dec32be_aligned(i_a1 + 36);          // 0x1653c
        int32_t i_v64 = sph_dec32be_aligned(i_a1 + 40);          // 0x1654a
        int32_t i_v65 = sph_dec32be_aligned(i_a1 + 44);          // 0x16558
        int32_t i_v66 = sph_dec32be_aligned(i_a1 + 48);          // 0x16566
        int32_t i_v67 = sph_dec32be_aligned(i_a1 + 52);          // 0x16574
        int32_t i_v68 = sph_dec32be_aligned(i_a1 + 56);          // 0x16582
        int32_t i_v69 = sph_dec32be_aligned(i_a1 + 60);          // 0x16590
        int32_t i_v70 = i_v54 ^ -0x7a5cf72d;                     // 0x165aa
        int32_t i_v71 = i_v6 + i_v14 + i_v70;                    // 0x165ac
        uint32_t i_v72 = i_v52 ^ -0x5bf6c7de ^ i_v71;            // 0x165b8
        int32_t i_v73 = i_v72 / 0x10000 | 0x10000 * i_v72;       // 0x165ba
        int32_t i_v74 = i_v73 + (i_v22 ^ 0x243f6a88);            // 0x165c4
        uint32_t i_v75 = i_v74 ^ i_v14;                          // 0x165ce
        int32_t i_v76 = i_v75 / 0x1000 | 0x100000 * i_v75;       // 0x165d0
        int32_t i_v77 = i_v55 ^ 0x243f6a88;                      // 0x165ec
        int32_t i_v78 = i_v77 + i_v71 + i_v76;                   // 0x165ee
        uint32_t i_v79 = i_v78 ^ i_v73;                          // 0x165fa
        int32_t i_v80 = i_v79 / 256 | 0x1000000 * i_v79;         // 0x165fc
        int32_t i_v81 = i_v80 + i_v74;                           // 0x16606
        uint32_t i_v82 = i_v81 ^ i_v76;                          // 0x16610
        int32_t i_v83 = i_v82 / 128 | 0x2000000 * i_v82;         // 0x16612
        int32_t i_v84 = i_v56 ^ 0x3707344;                       // 0x1662c
        int32_t i_v85 = i_v8 + i_v16 + i_v84;                    // 0x1662e
        uint32_t i_v86 = i_v52 ^ 0x299f31d0 ^ i_v85;             // 0x1663a
        int32_t i_v87 = i_v86 / 0x10000 | 0x10000 * i_v86;       // 0x1663c
        int32_t i_v88 = i_v87 + (i_v24 ^ -0x7a5cf72d);           // 0x16646
        uint32_t i_v89 = i_v88 ^ i_v16;                          // 0x1664e
        int32_t i_v90 = i_v89 / 0x1000 | 0x100000 * i_v89;       // 0x16650
        int32_t i_v91 = i_v57 ^ ((int32_t)&p_g248 | 0x13190000); // 0x16668
        int32_t i_v92 = i_v91 + i_v85 + i_v90;                   // 0x1666a
        uint32_t i_v93 = i_v92 ^ i_v87;                          // 0x16676
        int32_t i_v94 = i_v93 / 256 | 0x1000000 * i_v93;         // 0x16678
        int32_t i_v95 = i_v94 + i_v88;                           // 0x16682
        uint32_t i_v96 = i_v95 ^ i_v90;                          // 0x1668a
        int32_t i_v97 = i_v96 / 128 | 0x2000000 * i_v96;         // 0x1668c
        int32_t i_v98 = i_v58 ^ 0x299f31d0;                      // 0x166a4
        int32_t i_v99 = i_v10 + i_v18 + i_v98;                   // 0x166a6
        uint32_t i_v100 = i_v53 ^ 0x82efa98 ^ i_v99;             // 0x166b2
        int32_t i_v101 = i_v100 / 0x10000 | 0x10000 * i_v100;    // 0x166b4
        int32_t i_v102 =
            i_v101 + (i_v26 ^ ((int32_t)&p_g248 | 0x13190000));   // 0x166be
        uint32_t i_v103 = i_v102 ^ i_v18;                         // 0x166c6
        int32_t i_v104 = i_v103 / 0x1000 | 0x100000 * i_v103;     // 0x166c8
        int32_t i_v105 = i_v59 ^ -0x5bf6c7de;                     // 0x166e0
        int32_t i_v106 = i_v105 + i_v99 + i_v104;                 // 0x166e2
        uint32_t i_v107 = i_v106 ^ i_v101;                        // 0x166ee
        int32_t i_v108 = i_v107 / 256 | 0x1000000 * i_v107;       // 0x166f0
        int32_t i_v109 = i_v108 + i_v102;                         // 0x166fa
        uint32_t i_v110 = i_v109 ^ i_v104;                        // 0x16702
        int32_t i_v111 = i_v110 / 128 | 0x2000000 * i_v110;       // 0x16704
        int32_t i_v112 = i_v60 ^ -0x13b19377;                     // 0x1671c
        int32_t i_v113 = i_v12 + i_v20 + i_v112;                  // 0x1671e
        uint32_t i_v114 = i_v53 ^ -0x13b19377 ^ i_v113;           // 0x1672a
        int32_t i_v115 = i_v114 / 0x10000 | 0x10000 * i_v114;     // 0x1672c
        int32_t i_v116 = i_v115 + (i_v28 ^ 0x3707344);            // 0x16736
        uint32_t i_v117 = i_v116 ^ i_v20;                         // 0x1673e
        int32_t i_v118 = i_v117 / 0x1000 | 0x100000 * i_v117;     // 0x16740
        int32_t i_v119 = i_v61 ^ 0x82efa98;                       // 0x16758
        int32_t i_v120 = i_v119 + i_v113 + i_v118;                // 0x1675a
        uint32_t i_v121 = i_v120 ^ i_v115;                        // 0x16766
        int32_t i_v122 = i_v121 / 256 | 0x1000000 * i_v121;       // 0x16768
        int32_t i_v123 = i_v122 + i_v116;                         // 0x16772
        uint32_t i_v124 = i_v123 ^ i_v118;                        // 0x1677a
        int32_t i_v125 = i_v124 / 128 | 0x2000000 * i_v124;       // 0x1677c
        int32_t i_v126 = i_v62 ^ 0x38d01377;                      // 0x16794
        int32_t i_v127 = i_v78 + i_v126 + i_v97;                  // 0x16796
        uint32_t i_v128 = i_v127 ^ i_v122;                        // 0x167a2
        int32_t i_v129 = i_v128 / 0x10000 | 0x10000 * i_v128;     // 0x167a4
        int32_t i_v130 = i_v129 + i_v109;                         // 0x167ae
        uint32_t i_v131 = i_v130 ^ i_v97;                         // 0x167b6
        int32_t i_v132 = i_v131 / 0x1000 | 0x100000 * i_v131;     // 0x167b8
        int32_t i_v133 = i_v63 ^ 0x452821e6;                      // 0x167d0
        int32_t i_v134 = i_v127 + i_v133 + i_v132;                // 0x167d2
        uint32_t i_v135 = i_v134 ^ i_v129;                        // 0x167de
        int32_t i_v136 = i_v135 / 256 | 0x1000000 * i_v135;       // 0x167e0
        int32_t i_v137 = i_v136 + i_v130;                         // 0x167ea
        uint32_t i_v138 = i_v137 ^ i_v132;                        // 0x167f2
        int32_t i_v139 = i_v138 / 128 | 0x2000000 * i_v138;       // 0x167f4
        int32_t i_v140 = i_v64 ^ 0x34e90c6c;                      // 0x1680c
        int32_t i_v141 = i_v92 + i_v140 + i_v111;                 // 0x1680e
        uint32_t i_v142 = i_v141 ^ i_v80;                         // 0x1681a
        int32_t i_v143 = i_v142 / 0x10000 | 0x10000 * i_v142;     // 0x1681c
        int32_t i_v144 = i_v143 + i_v123;                         // 0x16826
        uint32_t i_v145 = i_v144 ^ i_v111;                        // 0x1682e
        int32_t i_v146 = i_v145 / 0x1000 | 0x100000 * i_v145;     // 0x16830
        int32_t i_v147 = i_v65 ^ -0x41ab9931;                     // 0x16848
        int32_t i_v148 = i_v141 + i_v147 + i_v146;                // 0x1684a
        uint32_t i_v149 = i_v148 ^ i_v143;                        // 0x16856
        int32_t i_v150 = i_v149 / 256 | 0x1000000 * i_v149;       // 0x16858
        int32_t i_v151 = i_v150 + i_v144;                         // 0x16862
        uint32_t i_v152 = i_v151 ^ i_v146;                        // 0x1686a
        int32_t i_v153 = i_v152 / 128 | 0x2000000 * i_v152;       // 0x1686c
        int32_t i_v154 = i_v66 ^ -0x3683af23;                     // 0x16884
        int32_t i_v155 = i_v106 + i_v154 + i_v125;                // 0x16886
        uint32_t i_v156 = i_v155 ^ i_v94;                         // 0x16892
        int32_t i_v157 = i_v156 / 0x10000 | 0x10000 * i_v156;     // 0x16894
        int32_t i_v158 = i_v157 + i_v81;                          // 0x1689e
        uint32_t i_v159 = i_v158 ^ i_v125;                        // 0x168a6
        int32_t i_v160 = i_v159 / 0x1000 | 0x100000 * i_v159;     // 0x168a8
        int32_t i_v161 = i_v67 ^ -0x3f53d649;                     // 0x168c0
        int32_t i_v162 = i_v155 + i_v161 + i_v160;                // 0x168c2
        uint32_t i_v163 = i_v162 ^ i_v157;                        // 0x168ce
        int32_t i_v164 = i_v163 / 256 | 0x1000000 * i_v163;       // 0x168d0
        int32_t i_v165 = i_v164 + i_v158;                         // 0x168da
        uint32_t i_v166 = i_v165 ^ i_v160;                        // 0x168e2
        int32_t i_v167 = i_v166 / 128 | 0x2000000 * i_v166;       // 0x168e4
        int32_t i_v168 = i_v68 ^ -0x4ab8f6e9;                     // 0x168fe
        int32_t i_v169 = i_v120 + i_v168 + i_v83;                 // 0x16900
        uint32_t i_v170 = i_v169 ^ i_v108;                        // 0x1690c
        int32_t i_v171 = i_v170 / 0x10000 | 0x10000 * i_v170;     // 0x1690e
        int32_t i_v172 = i_v171 + i_v95;                          // 0x16918
        uint32_t i_v173 = i_v172 ^ i_v83;                         // 0x16922
        int32_t i_v174 = i_v173 / 0x1000 | 0x100000 * i_v173;     // 0x16924
        int32_t i_v175 = i_v69 ^ 0x3f84d5b5;                      // 0x16940
        int32_t i_v176 = i_v169 + i_v175 + i_v174;                // 0x16942
        uint32_t i_v177 = i_v176 ^ i_v171;                        // 0x1694e
        int32_t i_v178 = i_v177 / 256 | 0x1000000 * i_v177;       // 0x16950
        int32_t i_v179 = i_v178 + i_v172;                         // 0x1695a
        uint32_t i_v180 = i_v179 ^ i_v174;                        // 0x16964
        int32_t i_v181 = i_v180 / 128 | 0x2000000 * i_v180;       // 0x16966
        int32_t i_v182 = i_v68 ^ -0x41ab9931;                     // 0x16982
        int32_t i_v183 = i_v134 + i_v182 + i_v181;                // 0x16984
        uint32_t i_v184 = i_v183 ^ i_v150;                        // 0x16990
        int32_t i_v185 = i_v184 / 0x10000 | 0x10000 * i_v184;     // 0x16992
        int32_t i_v186 = i_v185 + i_v165;                         // 0x1699c
        uint32_t i_v187 = i_v186 ^ i_v181;                        // 0x169a6
        int32_t i_v188 = i_v187 / 0x1000 | 0x100000 * i_v187;     // 0x169a8
        int32_t i_v189 = i_v64 ^ 0x3f84d5b5;                      // 0x169c4
        int32_t i_v190 = i_v183 + i_v189 + i_v188;                // 0x169c6
        uint32_t i_v191 = i_v190 ^ i_v185;                        // 0x169d2
        int32_t i_v192 = i_v191 / 256 | 0x1000000 * i_v191;       // 0x169d4
        int32_t i_v193 = i_v192 + i_v186;                         // 0x169de
        uint32_t i_v194 = i_v193 ^ i_v188;                        // 0x169e8
        int32_t i_v195 = i_v194 / 128 | 0x2000000 * i_v194;       // 0x169ea
        int32_t i_v196 = i_v58 ^ 0x452821e6;                      // 0x16a04
        int32_t i_v197 = i_v148 + i_v196 + i_v139;                // 0x16a06
        uint32_t i_v198 = i_v197 ^ i_v164;                        // 0x16a12
        int32_t i_v199 = i_v198 / 0x10000 | 0x10000 * i_v198;     // 0x16a14
        int32_t i_v200 = i_v199 + i_v179;                         // 0x16a1e
        uint32_t i_v201 = i_v200 ^ i_v139;                        // 0x16a26
        int32_t i_v202 = i_v201 / 0x1000 | 0x100000 * i_v201;     // 0x16a28
        int32_t i_v203 = i_v62 ^ -0x5bf6c7de;                     // 0x16a40
        int32_t i_v204 = i_v197 + i_v203 + i_v202;                // 0x16a42
        uint32_t i_v205 = i_v204 ^ i_v199;                        // 0x16a4e
        int32_t i_v206 = i_v205 / 256 | 0x1000000 * i_v205;       // 0x16a50
        int32_t i_v207 = i_v206 + i_v200;                         // 0x16a5a
        uint32_t i_v208 = i_v207 ^ i_v202;                        // 0x16a62
        int32_t i_v209 = i_v208 / 128 | 0x2000000 * i_v208;       // 0x16a64
        int32_t i_v210 = i_v63 ^ -0x4ab8f6e9;                     // 0x16a7c
        int32_t i_v211 = i_v162 + i_v210 + i_v153;                // 0x16a7e
        uint32_t i_v212 = i_v211 ^ i_v178;                        // 0x16a8a
        int32_t i_v213 = i_v212 / 0x10000 | 0x10000 * i_v212;     // 0x16a8c
        int32_t i_v214 = i_v213 + i_v137;                         // 0x16a96
        uint32_t i_v215 = i_v214 ^ i_v153;                        // 0x16a9e
        int32_t i_v216 = i_v215 / 0x1000 | 0x100000 * i_v215;     // 0x16aa0
        int32_t i_v217 = i_v69 ^ 0x38d01377;                      // 0x16ab8
        int32_t i_v218 = i_v211 + i_v217 + i_v216;                // 0x16aba
        uint32_t i_v219 = i_v218 ^ i_v213;                        // 0x16ac6
        int32_t i_v220 = i_v219 / 256 | 0x1000000 * i_v219;       // 0x16ac8
        int32_t i_v221 = i_v220 + i_v214;                         // 0x16ad2
        uint32_t i_v222 = i_v221 ^ i_v216;                        // 0x16ada
        int32_t i_v223 = i_v222 / 128 | 0x2000000 * i_v222;       // 0x16adc
        int32_t i_v224 = i_v67 ^ 0x82efa98;                       // 0x16af4
        int32_t i_v225 = i_v176 + i_v224 + i_v167;                // 0x16af6
        uint32_t i_v226 = i_v225 ^ i_v136;                        // 0x16b02
        int32_t i_v227 = i_v226 / 0x10000 | 0x10000 * i_v226;     // 0x16b04
        int32_t i_v228 = i_v227 + i_v151;                         // 0x16b0e
        uint32_t i_v229 = i_v228 ^ i_v167;                        // 0x16b16
        int32_t i_v230 = i_v229 / 0x1000 | 0x100000 * i_v229;     // 0x16b18
        int32_t i_v231 = i_v60 ^ -0x3683af23;                     // 0x16b30
        int32_t i_v232 = i_v225 + i_v231 + i_v230;                // 0x16b32
        uint32_t i_v233 = i_v232 ^ i_v227;                        // 0x16b3e
        int32_t i_v234 = i_v233 / 256 | 0x1000000 * i_v233;       // 0x16b40
        int32_t i_v235 = i_v234 + i_v228;                         // 0x16b4a
        uint32_t i_v236 = i_v235 ^ i_v230;                        // 0x16b52
        int32_t i_v237 = i_v236 / 128 | 0x2000000 * i_v236;       // 0x16b54
        int32_t i_v238 = i_v55 ^ -0x3f53d649;                     // 0x16b6c
        int32_t i_v239 = i_v190 + i_v238 + i_v209;                // 0x16b6e
        uint32_t i_v240 = i_v239 ^ i_v234;                        // 0x16b7a
        int32_t i_v241 = i_v240 / 0x10000 | 0x10000 * i_v240;     // 0x16b7c
        int32_t i_v242 = i_v241 + i_v221;                         // 0x16b86
        uint32_t i_v243 = i_v242 ^ i_v209;                        // 0x16b8e
        int32_t i_v244 = i_v243 / 0x1000 | 0x100000 * i_v243;     // 0x16b90
        int32_t i_v245 = i_v66 ^ -0x7a5cf72d;                     // 0x16ba8
        int32_t i_v246 = i_v239 + i_v245 + i_v244;                // 0x16baa
        uint32_t i_v247 = i_v246 ^ i_v241;                        // 0x16bb6
        int32_t i_v248 = i_v247 / 256 | 0x1000000 * i_v247;       // 0x16bb8
        int32_t i_v249 = i_v248 + i_v242;                         // 0x16bc2
        uint32_t i_v250 = i_v249 ^ i_v244;                        // 0x16bca
        int32_t i_v251 = i_v250 / 128 | 0x2000000 * i_v250;       // 0x16bcc
        int32_t i_v252 = i_v54 ^ ((int32_t)&p_g248 | 0x13190000); // 0x16be4
        int32_t i_v253 = i_v204 + i_v252 + i_v223;                // 0x16be6
        uint32_t i_v254 = i_v253 ^ i_v192;                        // 0x16bf2
        int32_t i_v255 = i_v254 / 0x10000 | 0x10000 * i_v254;     // 0x16bf4
        int32_t i_v256 = i_v255 + i_v235;                         // 0x16bfe
        uint32_t i_v257 = i_v256 ^ i_v223;                        // 0x16c06
        int32_t i_v258 = i_v257 / 0x1000 | 0x100000 * i_v257;     // 0x16c08
        int32_t i_v259 = i_v56 ^ 0x243f6a88;                      // 0x16c20
        int32_t i_v260 = i_v253 + i_v259 + i_v258;                // 0x16c22
        uint32_t i_v261 = i_v260 ^ i_v255;                        // 0x16c2e
        int32_t i_v262 = i_v261 / 256 | 0x1000000 * i_v261;       // 0x16c30
        int32_t i_v263 = i_v262 + i_v256;                         // 0x16c3a
        uint32_t i_v264 = i_v263 ^ i_v258;                        // 0x16c42
        int32_t i_v265 = i_v264 / 128 | 0x2000000 * i_v264;       // 0x16c44
        int32_t i_v266 = i_v65 ^ -0x13b19377;                     // 0x16c5c
        int32_t i_v267 = i_v218 + i_v266 + i_v237;                // 0x16c5e
        uint32_t i_v268 = i_v267 ^ i_v206;                        // 0x16c6a
        int32_t i_v269 = i_v268 / 0x10000 | 0x10000 * i_v268;     // 0x16c6c
        int32_t i_v270 = i_v269 + i_v193;                         // 0x16c76
        uint32_t i_v271 = i_v270 ^ i_v237;                        // 0x16c7e
        int32_t i_v272 = i_v271 / 0x1000 | 0x100000 * i_v271;     // 0x16c80
        int32_t i_v273 = i_v61 ^ 0x34e90c6c;                      // 0x16c98
        int32_t i_v274 = i_v267 + i_v273 + i_v272;                // 0x16c9a
        uint32_t i_v275 = i_v274 ^ i_v269;                        // 0x16ca6
        int32_t i_v276 = i_v275 / 256 | 0x1000000 * i_v275;       // 0x16ca8
        int32_t i_v277 = i_v276 + i_v270;                         // 0x16cb2
        uint32_t i_v278 = i_v277 ^ i_v272;                        // 0x16cba
        int32_t i_v279 = i_v278 / 128 | 0x2000000 * i_v278;       // 0x16cbc
        int32_t i_v280 = i_v59 ^ 0x3707344;                       // 0x16cd6
        int32_t i_v281 = i_v232 + i_v280 + i_v195;                // 0x16cd8
        uint32_t i_v282 = i_v281 ^ i_v220;                        // 0x16ce4
        int32_t i_v283 = i_v282 / 0x10000 | 0x10000 * i_v282;     // 0x16ce6
        int32_t i_v284 = i_v283 + i_v207;                         // 0x16cf0
        uint32_t i_v285 = i_v284 ^ i_v195;                        // 0x16cfa
        int32_t i_v286 = i_v285 / 0x1000 | 0x100000 * i_v285;     // 0x16cfc
        int32_t i_v287 = i_v57 ^ 0x299f31d0;                      // 0x16d18
        int32_t i_v288 = i_v281 + i_v287 + i_v286;                // 0x16d1a
        uint32_t i_v289 = i_v288 ^ i_v283;                        // 0x16d26
        int32_t i_v290 = i_v289 / 256 | 0x1000000 * i_v289;       // 0x16d28
        int32_t i_v291 = i_v290 + i_v284;                         // 0x16d32
        uint32_t i_v292 = i_v291 ^ i_v286;                        // 0x16d3c
        int32_t i_v293 = i_v292 / 128 | 0x2000000 * i_v292;       // 0x16d3e
        int32_t i_v294 = i_v65 ^ 0x452821e6;                      // 0x16d5a
        int32_t i_v295 = i_v246 + i_v294 + i_v293;                // 0x16d5c
        uint32_t i_v296 = i_v295 ^ i_v262;                        // 0x16d68
        int32_t i_v297 = i_v296 / 0x10000 | 0x10000 * i_v296;     // 0x16d6a
        int32_t i_v298 = i_v297 + i_v277;                         // 0x16d74
        uint32_t i_v299 = i_v298 ^ i_v293;                        // 0x16d7e
        int32_t i_v300 = i_v299 / 0x1000 | 0x100000 * i_v299;     // 0x16d80
        int32_t i_v301 = i_v62 ^ 0x34e90c6c;                      // 0x16d9c
        int32_t i_v302 = i_v295 + i_v301 + i_v300;                // 0x16d9e
        uint32_t i_v303 = i_v302 ^ i_v297;                        // 0x16daa
        int32_t i_v304 = i_v303 / 256 | 0x1000000 * i_v303;       // 0x16dac
        int32_t i_v305 = i_v304 + i_v298;                         // 0x16db6
        uint32_t i_v306 = i_v305 ^ i_v300;                        // 0x16dc0
        int32_t i_v307 = i_v306 / 128 | 0x2000000 * i_v306;       // 0x16dc2
        int32_t i_v308 = i_v66 ^ 0x243f6a88;                      // 0x16ddc
        int32_t i_v309 = i_v260 + i_v308 + i_v251;                // 0x16dde
        uint32_t i_v310 = i_v309 ^ i_v276;                        // 0x16dea
        int32_t i_v311 = i_v310 / 0x10000 | 0x10000 * i_v310;     // 0x16dec
        int32_t i_v312 = i_v311 + i_v291;                         // 0x16df6
        uint32_t i_v313 = i_v312 ^ i_v251;                        // 0x16dfe
        int32_t i_v314 = i_v313 / 0x1000 | 0x100000 * i_v313;     // 0x16e00
        int32_t i_v315 = i_v54 ^ -0x3f53d649;                     // 0x16e18
        int32_t i_v316 = i_v309 + i_v315 + i_v314;                // 0x16e1a
        uint32_t i_v317 = i_v316 ^ i_v311;                        // 0x16e26
        int32_t i_v318 = i_v317 / 256 | 0x1000000 * i_v317;       // 0x16e28
        int32_t i_v319 = i_v318 + i_v312;                         // 0x16e32
        uint32_t i_v320 = i_v319 ^ i_v314;                        // 0x16e3a
        int32_t i_v321 = i_v320 / 128 | 0x2000000 * i_v320;       // 0x16e3c
        int32_t i_v322 = i_v59 ^ ((int32_t)&p_g248 | 0x13190000); // 0x16e54
        int32_t i_v323 = i_v274 + i_v322 + i_v265;                // 0x16e56
        uint32_t i_v324 = i_v323 ^ i_v290;                        // 0x16e62
        int32_t i_v325 = i_v324 / 0x10000 | 0x10000 * i_v324;     // 0x16e64
        int32_t i_v326 = i_v325 + i_v249;                         // 0x16e6e
        uint32_t i_v327 = i_v326 ^ i_v265;                        // 0x16e76
        int32_t i_v328 = i_v327 / 0x1000 | 0x100000 * i_v327;     // 0x16e78
        int32_t i_v329 = i_v56 ^ 0x299f31d0;                      // 0x16e90
        int32_t i_v330 = i_v323 + i_v329 + i_v328;                // 0x16e92
        uint32_t i_v331 = i_v330 ^ i_v325;                        // 0x16e9e
        int32_t i_v332 = i_v331 / 256 | 0x1000000 * i_v331;       // 0x16ea0
        int32_t i_v333 = i_v332 + i_v326;                         // 0x16eaa
        uint32_t i_v334 = i_v333 ^ i_v328;                        // 0x16eb2
        int32_t i_v335 = i_v334 / 128 | 0x2000000 * i_v334;       // 0x16eb4
        int32_t i_v336 = i_v69 ^ -0x3683af23;                     // 0x16ecc
        int32_t i_v337 = i_v288 + i_v336 + i_v279;                // 0x16ece
        uint32_t i_v338 = i_v337 ^ i_v248;                        // 0x16eda
        int32_t i_v339 = i_v338 / 0x10000 | 0x10000 * i_v338;     // 0x16edc
        int32_t i_v340 = i_v339 + i_v263;                         // 0x16ee6
        uint32_t i_v341 = i_v340 ^ i_v279;                        // 0x16eee
        int32_t i_v342 = i_v341 / 0x1000 | 0x100000 * i_v341;     // 0x16ef0
        int32_t i_v343 = i_v67 ^ -0x4ab8f6e9;                     // 0x16f08
        int32_t i_v344 = i_v337 + i_v343 + i_v342;                // 0x16f0a
        uint32_t i_v345 = i_v344 ^ i_v339;                        // 0x16f16
        int32_t i_v346 = i_v345 / 256 | 0x1000000 * i_v345;       // 0x16f18
        int32_t i_v347 = i_v346 + i_v340;                         // 0x16f22
        uint32_t i_v348 = i_v347 ^ i_v342;                        // 0x16f2a
        int32_t i_v349 = i_v348 / 128 | 0x2000000 * i_v348;       // 0x16f2c
        int32_t i_v350 = i_v302 + i_v189 + i_v321;                // 0x16f46
        uint32_t i_v351 = i_v350 ^ i_v346;                        // 0x16f52
        int32_t i_v352 = i_v351 / 0x10000 | 0x10000 * i_v351;     // 0x16f54
        int32_t i_v353 = i_v352 + i_v333;                         // 0x16f5e
        uint32_t i_v354 = i_v353 ^ i_v321;                        // 0x16f66
        int32_t i_v355 = i_v354 / 0x1000 | 0x100000 * i_v354;     // 0x16f68
        int32_t i_v356 = i_v350 + i_v182 + i_v355;                // 0x16f82
        uint32_t i_v357 = i_v356 ^ i_v352;                        // 0x16f8e
        int32_t i_v358 = i_v357 / 256 | 0x1000000 * i_v357;       // 0x16f90
        int32_t i_v359 = i_v358 + i_v353;                         // 0x16f9a
        uint32_t i_v360 = i_v359 ^ i_v355;                        // 0x16fa2
        int32_t i_v361 = i_v360 / 128 | 0x2000000 * i_v360;       // 0x16fa4
        int32_t i_v362 = i_v57 ^ 0x82efa98;                       // 0x16fbc
        int32_t i_v363 = i_v316 + i_v362 + i_v335;                // 0x16fbe
        uint32_t i_v364 = i_v363 ^ i_v304;                        // 0x16fca
        int32_t i_v365 = i_v364 / 0x10000 | 0x10000 * i_v364;     // 0x16fcc
        int32_t i_v366 = i_v365 + i_v347;                         // 0x16fd6
        uint32_t i_v367 = i_v366 ^ i_v335;                        // 0x16fde
        int32_t i_v368 = i_v367 / 0x1000 | 0x100000 * i_v367;     // 0x16fe0
        int32_t i_v369 = i_v60 ^ 0x3707344;                       // 0x16ff8
        int32_t i_v370 = i_v363 + i_v369 + i_v368;                // 0x16ffa
        uint32_t i_v371 = i_v370 ^ i_v365;                        // 0x17006
        int32_t i_v372 = i_v371 / 256 | 0x1000000 * i_v371;       // 0x17008
        int32_t i_v373 = i_v372 + i_v366;                         // 0x17012
        uint32_t i_v374 = i_v373 ^ i_v368;                        // 0x1701a
        int32_t i_v375 = i_v374 / 128 | 0x2000000 * i_v374;       // 0x1701c
        int32_t i_v376 = i_v61 ^ -0x7a5cf72d;                     // 0x17034
        int32_t i_v377 = i_v330 + i_v376 + i_v349;                // 0x17036
        uint32_t i_v378 = i_v377 ^ i_v318;                        // 0x17042
        int32_t i_v379 = i_v378 / 0x10000 | 0x10000 * i_v378;     // 0x17044
        int32_t i_v380 = i_v379 + i_v305;                         // 0x1704e
        uint32_t i_v381 = i_v380 ^ i_v349;                        // 0x17056
        int32_t i_v382 = i_v381 / 0x1000 | 0x100000 * i_v381;     // 0x17058
        int32_t i_v383 = i_v55 ^ -0x13b19377;                     // 0x17070
        int32_t i_v384 = i_v377 + i_v383 + i_v382;                // 0x17072
        uint32_t i_v385 = i_v384 ^ i_v379;                        // 0x1707e
        int32_t i_v386 = i_v385 / 256 | 0x1000000 * i_v385;       // 0x17080
        int32_t i_v387 = i_v386 + i_v380;                         // 0x1708a
        uint32_t i_v388 = i_v387 ^ i_v382;                        // 0x17092
        int32_t i_v389 = i_v388 / 128 | 0x2000000 * i_v388;       // 0x17094
        int32_t i_v390 = i_v63 ^ -0x5bf6c7de;                     // 0x170ae
        int32_t i_v391 = i_v344 + i_v390 + i_v307;                // 0x170b0
        uint32_t i_v392 = i_v391 ^ i_v332;                        // 0x170bc
        int32_t i_v393 = i_v392 / 0x10000 | 0x10000 * i_v392;     // 0x170be
        int32_t i_v394 = i_v393 + i_v319;                         // 0x170c8
        uint32_t i_v395 = i_v394 ^ i_v307;                        // 0x170d2
        int32_t i_v396 = i_v395 / 0x1000 | 0x100000 * i_v395;     // 0x170d4
        int32_t i_v397 = i_v58 ^ 0x38d01377;                      // 0x170f0
        int32_t i_v398 = i_v391 + i_v397 + i_v396;                // 0x170f2
        uint32_t i_v399 = i_v398 ^ i_v393;                        // 0x170fe
        int32_t i_v400 = i_v399 / 256 | 0x1000000 * i_v399;       // 0x17100
        int32_t i_v401 = i_v400 + i_v394;                         // 0x1710a
        uint32_t i_v402 = i_v401 ^ i_v396;                        // 0x17114
        int32_t i_v403 = i_v402 / 128 | 0x2000000 * i_v402;       // 0x17116
        int32_t i_v404 = i_v61 ^ 0x38d01377;                      // 0x17132
        int32_t i_v405 = i_v356 + i_v404 + i_v403;                // 0x17134
        uint32_t i_v406 = i_v405 ^ i_v372;                        // 0x17140
        int32_t i_v407 = i_v406 / 0x10000 | 0x10000 * i_v406;     // 0x17142
        int32_t i_v408 = i_v407 + i_v387;                         // 0x1714c
        uint32_t i_v409 = i_v408 ^ i_v403;                        // 0x17156
        int32_t i_v410 = i_v409 / 0x1000 | 0x100000 * i_v409;     // 0x17158
        int32_t i_v411 = i_v63 ^ -0x13b19377;                     // 0x17174
        int32_t i_v412 = i_v405 + i_v411 + i_v410;                // 0x17176
        uint32_t i_v413 = i_v412 ^ i_v407;                        // 0x17182
        int32_t i_v414 = i_v413 / 256 | 0x1000000 * i_v413;       // 0x17184
        int32_t i_v415 = i_v414 + i_v408;                         // 0x1718e
        uint32_t i_v416 = i_v415 ^ i_v410;                        // 0x17198
        int32_t i_v417 = i_v416 / 128 | 0x2000000 * i_v416;       // 0x1719a
        int32_t i_v418 = i_v57 ^ -0x7a5cf72d;                     // 0x171b4
        int32_t i_v419 = i_v370 + i_v418 + i_v361;                // 0x171b6
        uint32_t i_v420 = i_v419 ^ i_v386;                        // 0x171c2
        int32_t i_v421 = i_v420 / 0x10000 | 0x10000 * i_v420;     // 0x171c4
        int32_t i_v422 = i_v421 + i_v401;                         // 0x171ce
        uint32_t i_v423 = i_v422 ^ i_v361;                        // 0x171d6
        int32_t i_v424 = i_v423 / 0x1000 | 0x100000 * i_v423;     // 0x171d8
        int32_t i_v425 = i_v55 ^ 0x3707344;                       // 0x171f0
        int32_t i_v426 = i_v419 + i_v425 + i_v424;                // 0x171f2
        uint32_t i_v427 = i_v426 ^ i_v421;                        // 0x171fe
        int32_t i_v428 = i_v427 / 256 | 0x1000000 * i_v427;       // 0x17200
        int32_t i_v429 = i_v428 + i_v422;                         // 0x1720a
        uint32_t i_v430 = i_v429 ^ i_v424;                        // 0x17212
        int32_t i_v431 = i_v430 / 128 | 0x2000000 * i_v430;       // 0x17214
        int32_t i_v432 = i_v384 + i_v161 + i_v375;                // 0x1722e
        uint32_t i_v433 = i_v432 ^ i_v400;                        // 0x1723a
        int32_t i_v434 = i_v433 / 0x10000 | 0x10000 * i_v433;     // 0x1723c
        int32_t i_v435 = i_v434 + i_v359;                         // 0x17246
        uint32_t i_v436 = i_v435 ^ i_v375;                        // 0x1724e
        int32_t i_v437 = i_v436 / 0x1000 | 0x100000 * i_v436;     // 0x17250
        int32_t i_v438 = i_v432 + i_v154 + i_v437;                // 0x1726a
        uint32_t i_v439 = i_v438 ^ i_v434;                        // 0x17276
        int32_t i_v440 = i_v439 / 256 | 0x1000000 * i_v439;       // 0x17278
        int32_t i_v441 = i_v440 + i_v435;                         // 0x17282
        uint32_t i_v442 = i_v441 ^ i_v437;                        // 0x1728a
        int32_t i_v443 = i_v442 / 128 | 0x2000000 * i_v442;       // 0x1728c
        int32_t i_v444 = i_v65 ^ 0x3f84d5b5;                      // 0x172a4
        int32_t i_v445 = i_v398 + i_v444 + i_v389;                // 0x172a6
        uint32_t i_v446 = i_v445 ^ i_v358;                        // 0x172b2
        int32_t i_v447 = i_v446 / 0x10000 | 0x10000 * i_v446;     // 0x172b4
        int32_t i_v448 = i_v447 + i_v373;                         // 0x172be
        uint32_t i_v449 = i_v448 ^ i_v389;                        // 0x172c6
        int32_t i_v450 = i_v449 / 0x1000 | 0x100000 * i_v449;     // 0x172c8
        int32_t i_v451 = i_v68 ^ 0x34e90c6c;                      // 0x172e0
        int32_t i_v452 = i_v445 + i_v451 + i_v450;                // 0x172e2
        uint32_t i_v453 = i_v452 ^ i_v447;                        // 0x172ee
        int32_t i_v454 = i_v453 / 256 | 0x1000000 * i_v453;       // 0x172f0
        int32_t i_v455 = i_v454 + i_v448;                         // 0x172fa
        uint32_t i_v456 = i_v455 ^ i_v450;                        // 0x17302
        int32_t i_v457 = i_v456 / 128 | 0x2000000 * i_v456;       // 0x17304
        int32_t i_v458 = i_v56 ^ 0x82efa98;                       // 0x1731c
        int32_t i_v459 = i_v412 + i_v458 + i_v431;                // 0x1731e
        uint32_t i_v460 = i_v459 ^ i_v454;                        // 0x1732a
        int32_t i_v461 = i_v460 / 0x10000 | 0x10000 * i_v460;     // 0x1732c
        int32_t i_v462 = i_v461 + i_v441;                         // 0x17336
        uint32_t i_v463 = i_v462 ^ i_v431;                        // 0x1733e
        int32_t i_v464 = i_v463 / 0x1000 | 0x100000 * i_v463;     // 0x17340
        int32_t i_v465 = i_v60 ^ ((int32_t)&p_g248 | 0x13190000); // 0x17358
        int32_t i_v466 = i_v459 + i_v465 + i_v464;                // 0x1735a
        uint32_t i_v467 = i_v466 ^ i_v461;                        // 0x17366
        int32_t i_v468 = i_v467 / 256 | 0x1000000 * i_v467;       // 0x17368
        int32_t i_v469 = i_v468 + i_v462;                         // 0x17372
        uint32_t i_v470 = i_v469 ^ i_v464;                        // 0x1737a
        int32_t i_v471 = i_v470 / 128 | 0x2000000 * i_v470;       // 0x1737c
        int32_t i_v472 = i_v59 ^ -0x41ab9931;                     // 0x17394
        int32_t i_v473 = i_v426 + i_v472 + i_v443;                // 0x17396
        uint32_t i_v474 = i_v473 ^ i_v414;                        // 0x173a2
        int32_t i_v475 = i_v474 / 0x10000 | 0x10000 * i_v474;     // 0x173a4
        int32_t i_v476 = i_v475 + i_v455;                         // 0x173ae
        uint32_t i_v477 = i_v476 ^ i_v443;                        // 0x173b6
        int32_t i_v478 = i_v477 / 0x1000 | 0x100000 * i_v477;     // 0x173b8
        int32_t i_v479 = i_v64 ^ 0x299f31d0;                      // 0x173d0
        int32_t i_v480 = i_v473 + i_v479 + i_v478;                // 0x173d2
        uint32_t i_v481 = i_v480 ^ i_v475;                        // 0x173de
        int32_t i_v482 = i_v481 / 256 | 0x1000000 * i_v481;       // 0x173e0
        int32_t i_v483 = i_v482 + i_v476;                         // 0x173ea
        uint32_t i_v484 = i_v483 ^ i_v478;                        // 0x173f2
        int32_t i_v485 = i_v484 / 128 | 0x2000000 * i_v484;       // 0x173f4
        int32_t i_v486 = i_v58 ^ 0x243f6a88;                      // 0x1740c
        int32_t i_v487 = i_v438 + i_v486 + i_v457;                // 0x1740e
        uint32_t i_v488 = i_v487 ^ i_v428;                        // 0x1741a
        int32_t i_v489 = i_v488 / 0x10000 | 0x10000 * i_v488;     // 0x1741c
        int32_t i_v490 = i_v489 + i_v415;                         // 0x17426
        uint32_t i_v491 = i_v490 ^ i_v457;                        // 0x1742e
        int32_t i_v492 = i_v491 / 0x1000 | 0x100000 * i_v491;     // 0x17430
        int32_t i_v493 = i_v54 ^ -0x5bf6c7de;                     // 0x17448
        int32_t i_v494 = i_v487 + i_v493 + i_v492;                // 0x1744a
        uint32_t i_v495 = i_v494 ^ i_v489;                        // 0x17456
        int32_t i_v496 = i_v495 / 256 | 0x1000000 * i_v495;       // 0x17458
        int32_t i_v497 = i_v496 + i_v490;                         // 0x17462
        uint32_t i_v498 = i_v497 ^ i_v492;                        // 0x1746a
        int32_t i_v499 = i_v498 / 128 | 0x2000000 * i_v498;       // 0x1746c
        int32_t i_v500 = i_v69 ^ 0x452821e6;                      // 0x17486
        int32_t i_v501 = i_v452 + i_v500 + i_v417;                // 0x17488
        uint32_t i_v502 = i_v501 ^ i_v440;                        // 0x17494
        int32_t i_v503 = i_v502 / 0x10000 | 0x10000 * i_v502;     // 0x17496
        int32_t i_v504 = i_v503 + i_v429;                         // 0x174a0
        uint32_t i_v505 = i_v504 ^ i_v417;                        // 0x174aa
        int32_t i_v506 = i_v505 / 0x1000 | 0x100000 * i_v505;     // 0x174ac
        int32_t i_v507 = i_v62 ^ -0x4ab8f6e9;                     // 0x174c8
        int32_t i_v508 = i_v501 + i_v507 + i_v506;                // 0x174ca
        uint32_t i_v509 = i_v508 ^ i_v503;                        // 0x174d6
        int32_t i_v510 = i_v509 / 256 | 0x1000000 * i_v509;       // 0x174d8
        int32_t i_v511 = i_v510 + i_v504;                         // 0x174e2
        uint32_t i_v512 = i_v511 ^ i_v506;                        // 0x174ec
        int32_t i_v513 = i_v512 / 128 | 0x2000000 * i_v512;       // 0x174ee
        int32_t i_v514 = i_v466 + (i_v63 ^ 0x243f6a88) + i_v513;  // 0x1750c
        uint32_t i_v515 = i_v514 ^ i_v482;                        // 0x17518
        int32_t i_v516 = i_v515 / 0x10000 | 0x10000 * i_v515;     // 0x1751a
        int32_t i_v517 = i_v516 + i_v497;                         // 0x17524
        uint32_t i_v518 = i_v517 ^ i_v513;                        // 0x1752e
        int32_t i_v519 = i_v518 / 0x1000 | 0x100000 * i_v518;     // 0x17530
        int32_t i_v520 = i_v514 + (i_v54 ^ 0x38d01377) + i_v519;  // 0x1754e
        uint32_t i_v521 = i_v520 ^ i_v516;                        // 0x1755a
        int32_t i_v522 = i_v521 / 256 | 0x1000000 * i_v521;       // 0x1755c
        int32_t i_v523 = i_v522 + i_v517;                         // 0x17566
        uint32_t i_v524 = i_v523 ^ i_v519;                        // 0x17570
        int32_t i_v525 = i_v524 / 128 | 0x2000000 * i_v524;       // 0x17572
        int32_t i_v526 = i_v59 ^ -0x13b19377;                     // 0x1758c
        int32_t i_v527 = i_v480 + i_v526 + i_v471;                // 0x1758e
        uint32_t i_v528 = i_v527 ^ i_v496;                        // 0x1759a
        int32_t i_v529 = i_v528 / 0x10000 | 0x10000 * i_v528;     // 0x1759c
        int32_t i_v530 = i_v529 + i_v511;                         // 0x175a6
        uint32_t i_v531 = i_v530 ^ i_v471;                        // 0x175ae
        int32_t i_v532 = i_v531 / 0x1000 | 0x100000 * i_v531;     // 0x175b0
        int32_t i_v533 = i_v61 ^ 0x299f31d0;                      // 0x175c8
        int32_t i_v534 = i_v527 + i_v533 + i_v532;                // 0x175ca
        uint32_t i_v535 = i_v534 ^ i_v529;                        // 0x175d6
        int32_t i_v536 = i_v535 / 256 | 0x1000000 * i_v535;       // 0x175d8
        int32_t i_v537 = i_v536 + i_v530;                         // 0x175e2
        uint32_t i_v538 = i_v537 ^ i_v532;                        // 0x175ea
        int32_t i_v539 = i_v538 / 128 | 0x2000000 * i_v538;       // 0x175ec
        int32_t i_v540 = i_v494 + (i_v56 ^ -0x5bf6c7de) + i_v485; // 0x17606
        uint32_t i_v541 = i_v540 ^ i_v510;                        // 0x17612
        int32_t i_v542 = i_v541 / 0x10000 | 0x10000 * i_v541;     // 0x17614
        int32_t i_v543 = i_v542 + i_v469;                         // 0x1761e
        uint32_t i_v544 = i_v543 ^ i_v485;                        // 0x17626
        int32_t i_v545 = i_v544 / 0x1000 | 0x100000 * i_v544;     // 0x17628
        int32_t i_v546 = i_v540 + (i_v58 ^ ((int32_t)&p_g248 | 0x13190000)) +
                         i_v545;                                  // 0x17642
        uint32_t i_v547 = i_v546 ^ i_v542;                        // 0x1764e
        int32_t i_v548 = i_v547 / 256 | 0x1000000 * i_v547;       // 0x17650
        int32_t i_v549 = i_v548 + i_v543;                         // 0x1765a
        uint32_t i_v550 = i_v549 ^ i_v545;                        // 0x17662
        int32_t i_v551 = i_v550 / 128 | 0x2000000 * i_v550;       // 0x17664
        int32_t i_v552 = i_v508 + (i_v64 ^ -0x4ab8f6e9) + i_v499; // 0x1767e
        uint32_t i_v553 = i_v552 ^ i_v468;                        // 0x1768a
        int32_t i_v554 = i_v553 / 0x10000 | 0x10000 * i_v553;     // 0x1768c
        int32_t i_v555 = i_v554 + i_v483;                         // 0x17696
        uint32_t i_v556 = i_v555 ^ i_v499;                        // 0x1769e
        int32_t i_v557 = i_v556 / 0x1000 | 0x100000 * i_v556;     // 0x176a0
        int32_t i_v558 = i_v552 + (i_v69 ^ -0x41ab9931) + i_v557; // 0x176ba
        uint32_t i_v559 = i_v558 ^ i_v554;                        // 0x176c6
        int32_t i_v560 = i_v559 / 256 | 0x1000000 * i_v559;       // 0x176c8
        int32_t i_v561 = i_v560 + i_v555;                         // 0x176d2
        uint32_t i_v562 = i_v561 ^ i_v557;                        // 0x176da
        int32_t i_v563 = i_v562 / 128 | 0x2000000 * i_v562;       // 0x176dc
        int32_t i_v564 = i_v520 + (i_v68 ^ -0x7a5cf72d) + i_v539; // 0x176f6
        uint32_t i_v565 = i_v564 ^ i_v560;                        // 0x17702
        int32_t i_v566 = i_v565 / 0x10000 | 0x10000 * i_v565;     // 0x17704
        int32_t i_v567 = i_v566 + i_v549;                         // 0x1770e
        uint32_t i_v568 = i_v567 ^ i_v539;                        // 0x17716
        int32_t i_v569 = i_v568 / 0x1000 | 0x100000 * i_v568;     // 0x17718
        int32_t i_v570 = i_v564 + (i_v55 ^ 0x3f84d5b5) + i_v569;  // 0x17732
        uint32_t i_v571 = i_v570 ^ i_v566;                        // 0x1773e
        int32_t i_v572 = i_v571 / 256 | 0x1000000 * i_v571;       // 0x17740
        int32_t i_v573 = i_v572 + i_v567;                         // 0x1774a
        uint32_t i_v574 = i_v573 ^ i_v569;                        // 0x17752
        int32_t i_v575 = i_v574 / 128 | 0x2000000 * i_v574;       // 0x17754
        int32_t i_v576 = i_v534 + (i_v65 ^ -0x3f53d649) + i_v551; // 0x1776e
        uint32_t i_v577 = i_v576 ^ i_v522;                        // 0x1777a
        int32_t i_v578 = i_v577 / 0x10000 | 0x10000 * i_v577;     // 0x1777c
        int32_t i_v579 = i_v578 + i_v561;                         // 0x17786
        uint32_t i_v580 = i_v579 ^ i_v551;                        // 0x1778e
        int32_t i_v581 = i_v580 / 0x1000 | 0x100000 * i_v580;     // 0x17790
        int32_t i_v582 = i_v576 + (i_v66 ^ 0x34e90c6c) + i_v581;  // 0x177aa
        uint32_t i_v583 = i_v582 ^ i_v578;                        // 0x177b6
        int32_t i_v584 = i_v583 / 256 | 0x1000000 * i_v583;       // 0x177b8
        int32_t i_v585 = i_v584 + i_v579;                         // 0x177c2
        uint32_t i_v586 = i_v585 ^ i_v581;                        // 0x177ca
        int32_t i_v587 = i_v586 / 128 | 0x2000000 * i_v586;       // 0x177cc
        int32_t i_v588 = i_v60 ^ 0x452821e6;                      // 0x177e4
        int32_t i_v589 = i_v546 + i_v588 + i_v563;                // 0x177e6
        uint32_t i_v590 = i_v589 ^ i_v536;                        // 0x177f2
        int32_t i_v591 = i_v590 / 0x10000 | 0x10000 * i_v590;     // 0x177f4
        int32_t i_v592 = i_v591 + i_v523;                         // 0x177fe
        uint32_t i_v593 = i_v592 ^ i_v563;                        // 0x17806
        int32_t i_v594 = i_v593 / 0x1000 | 0x100000 * i_v593;     // 0x17808
        int32_t i_v595 = i_v62 ^ 0x82efa98;                       // 0x17820
        int32_t i_v596 = i_v589 + i_v595 + i_v594;                // 0x17822
        uint32_t i_v597 = i_v596 ^ i_v591;                        // 0x1782e
        int32_t i_v598 = i_v597 / 256 | 0x1000000 * i_v597;       // 0x17830
        int32_t i_v599 = i_v598 + i_v592;                         // 0x1783a
        uint32_t i_v600 = i_v599 ^ i_v594;                        // 0x17842
        int32_t i_v601 = i_v600 / 128 | 0x2000000 * i_v600;       // 0x17844
        int32_t i_v602 = i_v558 + (i_v57 ^ -0x3683af23) + i_v525; // 0x17860
        uint32_t i_v603 = i_v602 ^ i_v548;                        // 0x1786c
        int32_t i_v604 = i_v603 / 0x10000 | 0x10000 * i_v603;     // 0x1786e
        int32_t i_v605 = i_v604 + i_v537;                         // 0x17878
        uint32_t i_v606 = i_v605 ^ i_v525;                        // 0x17882
        int32_t i_v607 = i_v606 / 0x1000 | 0x100000 * i_v606;     // 0x17884
        int32_t i_v608 = i_v602 + (i_v67 ^ 0x3707344) + i_v607;   // 0x178a2
        uint32_t i_v609 = i_v608 ^ i_v604;                        // 0x178ae
        int32_t i_v610 = i_v609 / 256 | 0x1000000 * i_v609;       // 0x178b0
        int32_t i_v611 = i_v610 + i_v605;                         // 0x178ba
        uint32_t i_v612 = i_v611 ^ i_v607;                        // 0x178c4
        int32_t i_v613 = i_v612 / 128 | 0x2000000 * i_v612;       // 0x178c6
        int32_t i_v614 = i_v56 ^ -0x3f53d649;                     // 0x178e2
        int32_t i_v615 = i_v570 + i_v614 + i_v613;                // 0x178e4
        uint32_t i_v616 = i_v615 ^ i_v584;                        // 0x178f0
        int32_t i_v617 = i_v616 / 0x10000 | 0x10000 * i_v616;     // 0x178f2
        int32_t i_v618 = i_v617 + i_v599;                         // 0x178fc
        uint32_t i_v619 = i_v618 ^ i_v613;                        // 0x17906
        int32_t i_v620 = i_v619 / 0x1000 | 0x100000 * i_v619;     // 0x17908
        int32_t i_v621 = i_v66 ^ ((int32_t)&p_g248 | 0x13190000); // 0x17924
        int32_t i_v622 = i_v615 + i_v621 + i_v620;                // 0x17926
        uint32_t i_v623 = i_v622 ^ i_v617;                        // 0x17932
        int32_t i_v624 = i_v623 / 256 | 0x1000000 * i_v623;       // 0x17934
        int32_t i_v625 = i_v624 + i_v618;                         // 0x1793e
        uint32_t i_v626 = i_v625 ^ i_v620;                        // 0x17948
        int32_t i_v627 = i_v626 / 128 | 0x2000000 * i_v626;       // 0x1794a
        int32_t i_v628 = i_v582 + (i_v60 ^ -0x41ab9931) + i_v575; // 0x17966
        uint32_t i_v629 = i_v628 ^ i_v598;                        // 0x17972
        int32_t i_v630 = i_v629 / 0x10000 | 0x10000 * i_v629;     // 0x17974
        int32_t i_v631 = i_v630 + i_v611;                         // 0x1797e
        uint32_t i_v632 = i_v631 ^ i_v575;                        // 0x17986
        int32_t i_v633 = i_v632 / 0x1000 | 0x100000 * i_v632;     // 0x17988
        int32_t i_v634 = i_v628 + (i_v64 ^ 0x82efa98) + i_v633;   // 0x179a2
        uint32_t i_v635 = i_v634 ^ i_v630;                        // 0x179ae
        int32_t i_v636 = i_v635 / 256 | 0x1000000 * i_v635;       // 0x179b0
        int32_t i_v637 = i_v636 + i_v631;                         // 0x179ba
        uint32_t i_v638 = i_v637 ^ i_v633;                        // 0x179c2
        int32_t i_v639 = i_v638 / 128 | 0x2000000 * i_v638;       // 0x179c4
        int32_t i_v640 = i_v596 + (i_v54 ^ 0x34e90c6c) + i_v587;  // 0x179de
        uint32_t i_v641 = i_v640 ^ i_v610;                        // 0x179ea
        int32_t i_v642 = i_v641 / 0x10000 | 0x10000 * i_v641;     // 0x179ec
        int32_t i_v643 = i_v642 + i_v573;                         // 0x179f6
        uint32_t i_v644 = i_v643 ^ i_v587;                        // 0x179fe
        int32_t i_v645 = i_v644 / 0x1000 | 0x100000 * i_v644;     // 0x17a00
        int32_t i_v646 = i_v640 + (i_v65 ^ 0x243f6a88) + i_v645;  // 0x17a1a
        uint32_t i_v647 = i_v646 ^ i_v642;                        // 0x17a26
        int32_t i_v648 = i_v647 / 256 | 0x1000000 * i_v647;       // 0x17a28
        int32_t i_v649 = i_v648 + i_v643;                         // 0x17a32
        uint32_t i_v650 = i_v649 ^ i_v645;                        // 0x17a3a
        int32_t i_v651 = i_v650 / 128 | 0x2000000 * i_v650;       // 0x17a3c
        int32_t i_v652 = i_v608 + (i_v62 ^ 0x3707344) + i_v601;   // 0x17a56
        uint32_t i_v653 = i_v652 ^ i_v572;                        // 0x17a62
        int32_t i_v654 = i_v653 / 0x10000 | 0x10000 * i_v653;     // 0x17a64
        int32_t i_v655 = i_v654 + i_v585;                         // 0x17a6e
        uint32_t i_v656 = i_v655 ^ i_v601;                        // 0x17a76
        int32_t i_v657 = i_v656 / 0x1000 | 0x100000 * i_v656;     // 0x17a78
        int32_t i_v658 = i_v652 + (i_v57 ^ 0x452821e6) + i_v657;  // 0x17a92
        uint32_t i_v659 = i_v658 ^ i_v654;                        // 0x17a9e
        int32_t i_v660 = i_v659 / 256 | 0x1000000 * i_v659;       // 0x17aa0
        int32_t i_v661 = i_v660 + i_v655;                         // 0x17aaa
        uint32_t i_v662 = i_v661 ^ i_v657;                        // 0x17ab2
        int32_t i_v663 = i_v662 / 128 | 0x2000000 * i_v662;       // 0x17ab4
        int32_t i_v664 = i_v622 + (i_v58 ^ -0x3683af23) + i_v639; // 0x17ace
        uint32_t i_v665 = i_v664 ^ i_v660;                        // 0x17ada
        int32_t i_v666 = i_v665 / 0x10000 | 0x10000 * i_v665;     // 0x17adc
        int32_t i_v667 = i_v666 + i_v649;                         // 0x17ae6
        uint32_t i_v668 = i_v667 ^ i_v639;                        // 0x17aee
        int32_t i_v669 = i_v668 / 0x1000 | 0x100000 * i_v668;     // 0x17af0
        int32_t i_v670 = i_v664 + (i_v67 ^ -0x5bf6c7de) + i_v669; // 0x17b0a
        uint32_t i_v671 = i_v670 ^ i_v666;                        // 0x17b16
        int32_t i_v672 = i_v671 / 256 | 0x1000000 * i_v671;       // 0x17b18
        int32_t i_v673 = i_v672 + i_v667;                         // 0x17b22
        uint32_t i_v674 = i_v673 ^ i_v669;                        // 0x17b2a
        int32_t i_v675 = i_v674 / 128 | 0x2000000 * i_v674;       // 0x17b2c
        int32_t i_v676 = i_v634 + i_v533 + i_v651;                // 0x17b46
        uint32_t i_v677 = i_v676 ^ i_v624;                        // 0x17b52
        int32_t i_v678 = i_v677 / 0x10000 | 0x10000 * i_v677;     // 0x17b54
        int32_t i_v679 = i_v678 + i_v661;                         // 0x17b5e
        uint32_t i_v680 = i_v679 ^ i_v651;                        // 0x17b66
        int32_t i_v681 = i_v680 / 0x1000 | 0x100000 * i_v680;     // 0x17b68
        int32_t i_v682 = i_v676 + i_v526 + i_v681;                // 0x17b82
        uint32_t i_v683 = i_v682 ^ i_v678;                        // 0x17b8e
        int32_t i_v684 = i_v683 / 256 | 0x1000000 * i_v683;       // 0x17b90
        int32_t i_v685 = i_v684 + i_v679;                         // 0x17b9a
        uint32_t i_v686 = i_v685 ^ i_v681;                        // 0x17ba2
        int32_t i_v687 = i_v686 / 128 | 0x2000000 * i_v686;       // 0x17ba4
        int32_t i_v688 = i_v646 + i_v175 + i_v663;                // 0x17bbe
        uint32_t i_v689 = i_v688 ^ i_v636;                        // 0x17bca
        int32_t i_v690 = i_v689 / 0x10000 | 0x10000 * i_v689;     // 0x17bcc
        int32_t i_v691 = i_v690 + i_v625;                         // 0x17bd6
        uint32_t i_v692 = i_v691 ^ i_v663;                        // 0x17bde
        int32_t i_v693 = i_v692 / 0x1000 | 0x100000 * i_v692;     // 0x17be0
        int32_t i_v694 = i_v688 + i_v168 + i_v693;                // 0x17bfa
        uint32_t i_v695 = i_v694 ^ i_v690;                        // 0x17c06
        int32_t i_v696 = i_v695 / 256 | 0x1000000 * i_v695;       // 0x17c08
        int32_t i_v697 = i_v696 + i_v691;                         // 0x17c12
        uint32_t i_v698 = i_v697 ^ i_v693;                        // 0x17c1a
        int32_t i_v699 = i_v698 / 128 | 0x2000000 * i_v698;       // 0x17c1c
        int32_t i_v700 = i_v658 + (i_v55 ^ 0x38d01377) + i_v627;  // 0x17c38
        uint32_t i_v701 = i_v700 ^ i_v648;                        // 0x17c44
        int32_t i_v702 = i_v701 / 0x10000 | 0x10000 * i_v701;     // 0x17c46
        int32_t i_v703 = i_v702 + i_v637;                         // 0x17c50
        uint32_t i_v704 = i_v703 ^ i_v627;                        // 0x17c5a
        int32_t i_v705 = i_v704 / 0x1000 | 0x100000 * i_v704;     // 0x17c5c
        int32_t i_v706 = i_v700 + (i_v63 ^ -0x7a5cf72d) + i_v705; // 0x17c7a
        uint32_t i_v707 = i_v706 ^ i_v702;                        // 0x17c86
        int32_t i_v708 = i_v707 / 256 | 0x1000000 * i_v707;       // 0x17c88
        int32_t i_v709 = i_v708 + i_v703;                         // 0x17c92
        uint32_t i_v710 = i_v709 ^ i_v705;                        // 0x17c9c
        int32_t i_v711 = i_v710 / 128 | 0x2000000 * i_v710;       // 0x17c9e
        int32_t i_v712 = i_v670 + (i_v66 ^ 0x299f31d0) + i_v711;  // 0x17cbc
        uint32_t i_v713 = i_v712 ^ i_v684;                        // 0x17cc8
        int32_t i_v714 = i_v713 / 0x10000 | 0x10000 * i_v713;     // 0x17cca
        int32_t i_v715 = i_v714 + i_v697;                         // 0x17cd4
        uint32_t i_v716 = i_v715 ^ i_v711;                        // 0x17cde
        int32_t i_v717 = i_v716 / 0x1000 | 0x100000 * i_v716;     // 0x17ce0
        int32_t i_v718 = i_v712 + (i_v59 ^ -0x3f53d649) + i_v717; // 0x17cfe
        uint32_t i_v719 = i_v718 ^ i_v714;                        // 0x17d0a
        int32_t i_v720 = i_v719 / 256 | 0x1000000 * i_v719;       // 0x17d0c
        int32_t i_v721 = i_v720 + i_v715;                         // 0x17d16
        uint32_t i_v722 = i_v721 ^ i_v717;                        // 0x17d20
        int32_t i_v723 = i_v722 / 128 | 0x2000000 * i_v722;       // 0x17d22
        int32_t i_v724 = i_v682 + (i_v55 ^ -0x4ab8f6e9) + i_v675; // 0x17d3e
        uint32_t i_v725 = i_v724 ^ i_v696;                        // 0x17d4a
        int32_t i_v726 = i_v725 / 0x10000 | 0x10000 * i_v725;     // 0x17d4c
        int32_t i_v727 = i_v726 + i_v709;                         // 0x17d56
        uint32_t i_v728 = i_v727 ^ i_v675;                        // 0x17d5e
        int32_t i_v729 = i_v728 / 0x1000 | 0x100000 * i_v728;     // 0x17d60
        int32_t i_v730 = i_v724 + (i_v69 ^ -0x7a5cf72d) + i_v729; // 0x17d7a
        uint32_t i_v731 = i_v730 ^ i_v726;                        // 0x17d86
        int32_t i_v732 = i_v731 / 256 | 0x1000000 * i_v731;       // 0x17d88
        int32_t i_v733 = i_v732 + i_v727;                         // 0x17d92
        uint32_t i_v734 = i_v733 ^ i_v729;                        // 0x17d9a
        int32_t i_v735 = i_v734 / 128 | 0x2000000 * i_v734;       // 0x17d9c
        int32_t i_v736 = i_v694 + (i_v68 ^ -0x3683af23) + i_v687; // 0x17db6
        uint32_t i_v737 = i_v736 ^ i_v708;                        // 0x17dc2
        int32_t i_v738 = i_v737 / 0x10000 | 0x10000 * i_v737;     // 0x17dc4
        int32_t i_v739 = i_v738 + i_v673;                         // 0x17dce
        uint32_t i_v740 = i_v739 ^ i_v687;                        // 0x17dd6
        int32_t i_v741 = i_v740 / 0x1000 | 0x100000 * i_v740;     // 0x17dd8
        int32_t i_v742 = i_v736 + (i_v67 ^ 0x3f84d5b5) + i_v741;  // 0x17df2
        uint32_t i_v743 = i_v742 ^ i_v738;                        // 0x17dfe
        int32_t i_v744 = i_v743 / 256 | 0x1000000 * i_v743;       // 0x17e00
        int32_t i_v745 = i_v744 + i_v739;                         // 0x17e0a
        uint32_t i_v746 = i_v745 ^ i_v741;                        // 0x17e12
        int32_t i_v747 = i_v746 / 128 | 0x2000000 * i_v746;       // 0x17e14
        int32_t i_v748 = i_v706 + (i_v58 ^ -0x41ab9931) + i_v699; // 0x17e2e
        uint32_t i_v749 = i_v748 ^ i_v672;                        // 0x17e3a
        int32_t i_v750 = i_v749 / 0x10000 | 0x10000 * i_v749;     // 0x17e3c
        int32_t i_v751 = i_v750 + i_v685;                         // 0x17e46
        uint32_t i_v752 = i_v751 ^ i_v699;                        // 0x17e4e
        int32_t i_v753 = i_v752 / 0x1000 | 0x100000 * i_v752;     // 0x17e50
        int32_t i_v754 = i_v748 + (i_v64 ^ -0x5bf6c7de) + i_v753; // 0x17e6a
        uint32_t i_v755 = i_v754 ^ i_v750;                        // 0x17e76
        int32_t i_v756 = i_v755 / 256 | 0x1000000 * i_v755;       // 0x17e78
        int32_t i_v757 = i_v756 + i_v751;                         // 0x17e82
        uint32_t i_v758 = i_v757 ^ i_v753;                        // 0x17e8a
        int32_t i_v759 = i_v758 / 128 | 0x2000000 * i_v758;       // 0x17e8c
        int32_t i_v760 = i_v718 + (i_v54 ^ -0x13b19377) + i_v735; // 0x17ea6
        uint32_t i_v761 = i_v760 ^ i_v756;                        // 0x17eb2
        int32_t i_v762 = i_v761 / 0x10000 | 0x10000 * i_v761;     // 0x17eb4
        int32_t i_v763 = i_v762 + i_v745;                         // 0x17ebe
        uint32_t i_v764 = i_v763 ^ i_v735;                        // 0x17ec6
        int32_t i_v765 = i_v764 / 0x1000 | 0x100000 * i_v764;     // 0x17ec8
        int32_t i_v766 = i_v760 + (i_v61 ^ 0x243f6a88) + i_v765;  // 0x17ee2
        uint32_t i_v767 = i_v766 ^ i_v762;                        // 0x17eee
        int32_t i_v768 = i_v767 / 256 | 0x1000000 * i_v767;       // 0x17ef0
        int32_t i_v769 = i_v768 + i_v763;                         // 0x17efa
        uint32_t i_v770 = i_v769 ^ i_v765;                        // 0x17f02
        int32_t i_v771 = i_v770 / 128 | 0x2000000 * i_v770;       // 0x17f04
        int32_t i_v772 = i_v730 + i_v369 + i_v747;                // 0x17f1e
        uint32_t i_v773 = i_v772 ^ i_v720;                        // 0x17f2a
        int32_t i_v774 = i_v773 / 0x10000 | 0x10000 * i_v773;     // 0x17f2c
        int32_t i_v775 = i_v774 + i_v757;                         // 0x17f36
        uint32_t i_v776 = i_v775 ^ i_v747;                        // 0x17f3e
        int32_t i_v777 = i_v776 / 0x1000 | 0x100000 * i_v776;     // 0x17f40
        int32_t i_v778 = i_v772 + i_v362 + i_v777;                // 0x17f5a
        uint32_t i_v779 = i_v778 ^ i_v774;                        // 0x17f66
        int32_t i_v780 = i_v779 / 256 | 0x1000000 * i_v779;       // 0x17f68
        int32_t i_v781 = i_v780 + i_v775;                         // 0x17f72
        uint32_t i_v782 = i_v781 ^ i_v777;                        // 0x17f7a
        int32_t i_v783 = i_v782 / 128 | 0x2000000 * i_v782;       // 0x17f7c
        int32_t i_v784 = i_v742 + (i_v63 ^ ((int32_t)&p_g248 | 0x13190000)) +
                         i_v759;                                     // 0x17f96
        uint32_t i_v785 = i_v784 ^ i_v732;                           // 0x17fa2
        int32_t i_v786 = i_v785 / 0x10000 | 0x10000 * i_v785;        // 0x17fa4
        int32_t i_v787 = i_v786 + i_v721;                            // 0x17fae
        uint32_t i_v788 = i_v787 ^ i_v759;                           // 0x17fb6
        int32_t i_v789 = i_v788 / 0x1000 | 0x100000 * i_v788;        // 0x17fb8
        int32_t i_v790 = i_v784 + (i_v56 ^ 0x38d01377) + i_v789;     // 0x17fd2
        uint32_t i_v791 = i_v790 ^ i_v786;                           // 0x17fde
        int32_t i_v792 = i_v791 / 256 | 0x1000000 * i_v791;          // 0x17fe0
        int32_t i_v793 = i_v792 + i_v787;                            // 0x17fea
        uint32_t i_v794 = i_v793 ^ i_v789;                           // 0x17ff2
        int32_t i_v795 = i_v794 / 128 | 0x2000000 * i_v794;          // 0x17ff4
        int32_t i_v796 = i_v754 + i_v301 + i_v723;                   // 0x18010
        uint32_t i_v797 = i_v796 ^ i_v744;                           // 0x1801c
        int32_t i_v798 = i_v797 / 0x10000 | 0x10000 * i_v797;        // 0x1801e
        int32_t i_v799 = i_v798 + i_v733;                            // 0x18028
        uint32_t i_v800 = i_v799 ^ i_v723;                           // 0x18032
        int32_t i_v801 = i_v800 / 0x1000 | 0x100000 * i_v800;        // 0x18034
        int32_t i_v802 = i_v796 + i_v294 + i_v801;                   // 0x18052
        uint32_t i_v803 = i_v802 ^ i_v798;                           // 0x1805e
        int32_t i_v804 = i_v803 / 256 | 0x1000000 * i_v803;          // 0x18060
        int32_t i_v805 = i_v804 + i_v799;                            // 0x1806a
        uint32_t i_v806 = i_v805 ^ i_v801;                           // 0x18074
        int32_t i_v807 = i_v806 / 128 | 0x2000000 * i_v806;          // 0x18076
        int32_t i_v808 = i_v766 + (i_v67 ^ 0x34e90c6c) + i_v807;     // 0x18094
        uint32_t i_v809 = i_v808 ^ i_v780;                           // 0x180a0
        int32_t i_v810 = i_v809 / 0x10000 | 0x10000 * i_v809;        // 0x180a2
        int32_t i_v811 = i_v810 + i_v793;                            // 0x180ac
        uint32_t i_v812 = i_v811 ^ i_v807;                           // 0x180b6
        int32_t i_v813 = i_v812 / 0x1000 | 0x100000 * i_v812;        // 0x180b8
        int32_t i_v814 = i_v808 + (i_v65 ^ -0x3683af23) + i_v813;    // 0x180d6
        uint32_t i_v815 = i_v814 ^ i_v810;                           // 0x180e2
        int32_t i_v816 = i_v815 / 256 | 0x1000000 * i_v815;          // 0x180e4
        int32_t i_v817 = i_v816 + i_v811;                            // 0x180ee
        uint32_t i_v818 = i_v817 ^ i_v813;                           // 0x180f8
        int32_t i_v819 = i_v818 / 128 | 0x2000000 * i_v818;          // 0x180fa
        int32_t i_v820 = i_v778 + (i_v61 ^ 0x3f84d5b5) + i_v771;     // 0x18116
        uint32_t i_v821 = i_v820 ^ i_v792;                           // 0x18122
        int32_t i_v822 = i_v821 / 0x10000 | 0x10000 * i_v821;        // 0x18124
        int32_t i_v823 = i_v822 + i_v805;                            // 0x1812e
        uint32_t i_v824 = i_v823 ^ i_v771;                           // 0x18136
        int32_t i_v825 = i_v824 / 0x1000 | 0x100000 * i_v824;        // 0x18138
        int32_t i_v826 = i_v820 + (i_v68 ^ -0x13b19377) + i_v825;    // 0x18152
        uint32_t i_v827 = i_v826 ^ i_v822;                           // 0x1815e
        int32_t i_v828 = i_v827 / 256 | 0x1000000 * i_v827;          // 0x18160
        int32_t i_v829 = i_v828 + i_v823;                            // 0x1816a
        uint32_t i_v830 = i_v829 ^ i_v825;                           // 0x18172
        int32_t i_v831 = i_v830 / 128 | 0x2000000 * i_v830;          // 0x18174
        int32_t i_v832 = i_v790 + i_v245 + i_v783;                   // 0x1818e
        uint32_t i_v833 = i_v832 ^ i_v804;                           // 0x1819a
        int32_t i_v834 = i_v833 / 0x10000 | 0x10000 * i_v833;        // 0x1819c
        int32_t i_v835 = i_v834 + i_v769;                            // 0x181a6
        uint32_t i_v836 = i_v835 ^ i_v783;                           // 0x181ae
        int32_t i_v837 = i_v836 / 0x1000 | 0x100000 * i_v836;        // 0x181b0
        int32_t i_v838 = i_v832 + i_v238 + i_v837;                   // 0x181ca
        uint32_t i_v839 = i_v838 ^ i_v834;                           // 0x181d6
        int32_t i_v840 = i_v839 / 256 | 0x1000000 * i_v839;          // 0x181d8
        int32_t i_v841 = i_v840 + i_v835;                            // 0x181e2
        uint32_t i_v842 = i_v841 ^ i_v837;                           // 0x181ea
        int32_t i_v843 = i_v842 / 128 | 0x2000000 * i_v842;          // 0x181ec
        int32_t i_v844 = i_v802 + (i_v57 ^ 0x38d01377) + i_v795;     // 0x18206
        uint32_t i_v845 = i_v844 ^ i_v768;                           // 0x18212
        int32_t i_v846 = i_v845 / 0x10000 | 0x10000 * i_v845;        // 0x18214
        int32_t i_v847 = i_v846 + i_v781;                            // 0x1821e
        uint32_t i_v848 = i_v847 ^ i_v795;                           // 0x18226
        int32_t i_v849 = i_v848 / 0x1000 | 0x100000 * i_v848;        // 0x18228
        int32_t i_v850 = i_v844 + (i_v63 ^ 0x3707344) + i_v849;      // 0x18242
        uint32_t i_v851 = i_v850 ^ i_v846;                           // 0x1824e
        int32_t i_v852 = i_v851 / 256 | 0x1000000 * i_v851;          // 0x18250
        int32_t i_v853 = i_v852 + i_v847;                            // 0x1825a
        uint32_t i_v854 = i_v853 ^ i_v849;                           // 0x18262
        int32_t i_v855 = i_v854 / 128 | 0x2000000 * i_v854;          // 0x18264
        int32_t i_v856 = i_v814 + (i_v59 ^ 0x243f6a88) + i_v831;     // 0x1827e
        uint32_t i_v857 = i_v856 ^ i_v852;                           // 0x1828a
        int32_t i_v858 = i_v857 / 0x10000 | 0x10000 * i_v857;        // 0x1828c
        int32_t i_v859 = i_v858 + i_v841;                            // 0x18296
        uint32_t i_v860 = i_v859 ^ i_v831;                           // 0x1829e
        int32_t i_v861 = i_v860 / 0x1000 | 0x100000 * i_v860;        // 0x182a0
        int32_t i_v862 = i_v856 + (i_v54 ^ 0x299f31d0) + i_v861;     // 0x182ba
        uint32_t i_v863 = i_v862 ^ i_v858;                           // 0x182c6
        int32_t i_v864 = i_v863 / 256 | 0x1000000 * i_v863;          // 0x182c8
        int32_t i_v865 = i_v864 + i_v859;                            // 0x182d2
        uint32_t i_v866 = i_v865 ^ i_v861;                           // 0x182da
        int32_t i_v867 = i_v866 / 128 | 0x2000000 * i_v866;          // 0x182dc
        int32_t i_v868 = i_v826 + (i_v69 ^ -0x5bf6c7de) + i_v843;    // 0x182f6
        uint32_t i_v869 = i_v868 ^ i_v816;                           // 0x18302
        int32_t i_v870 = i_v869 / 0x10000 | 0x10000 * i_v869;        // 0x18304
        int32_t i_v871 = i_v870 + i_v853;                            // 0x1830e
        uint32_t i_v872 = i_v871 ^ i_v843;                           // 0x18316
        int32_t i_v873 = i_v872 / 0x1000 | 0x100000 * i_v872;        // 0x18318
        int32_t i_v874 = i_v868 + (i_v58 ^ -0x4ab8f6e9) + i_v873;    // 0x18332
        uint32_t i_v875 = i_v874 ^ i_v870;                           // 0x1833e
        int32_t i_v876 = i_v875 / 256 | 0x1000000 * i_v875;          // 0x18340
        int32_t i_v877 = i_v876 + i_v871;                            // 0x1834a
        uint32_t i_v878 = i_v877 ^ i_v873;                           // 0x18352
        int32_t i_v879 = i_v878 / 128 | 0x2000000 * i_v878;          // 0x18354
        int32_t i_v880 = i_v838 + i_v595 + i_v855;                   // 0x1836e
        uint32_t i_v881 = i_v880 ^ i_v828;                           // 0x1837a
        int32_t i_v882 = i_v881 / 0x10000 | 0x10000 * i_v881;        // 0x1837c
        int32_t i_v883 = i_v882 + i_v817;                            // 0x18386
        uint32_t i_v884 = i_v883 ^ i_v855;                           // 0x1838e
        int32_t i_v885 = i_v884 / 0x1000 | 0x100000 * i_v884;        // 0x18390
        int32_t i_v886 = i_v880 + i_v588 + i_v885;                   // 0x183aa
        uint32_t i_v887 = i_v886 ^ i_v882;                           // 0x183b6
        int32_t i_v888 = i_v887 / 256 | 0x1000000 * i_v887;          // 0x183b8
        int32_t i_v889 = i_v888 + i_v883;                            // 0x183c2
        uint32_t i_v890 = i_v889 ^ i_v885;                           // 0x183ca
        int32_t i_v891 = i_v890 / 128 | 0x2000000 * i_v890;          // 0x183cc
        int32_t i_v892 = i_v56 ^ -0x41ab9931;                        // 0x183e6
        int32_t i_v893 = i_v850 + i_v892 + i_v819;                   // 0x183e8
        uint32_t i_v894 = i_v893 ^ i_v840;                           // 0x183f4
        int32_t i_v895 = i_v894 / 0x10000 | 0x10000 * i_v894;        // 0x183f6
        int32_t i_v896 = i_v895 + i_v829;                            // 0x18400
        uint32_t i_v897 = i_v896 ^ i_v819;                           // 0x1840a
        int32_t i_v898 = i_v897 / 0x1000 | 0x100000 * i_v897;        // 0x1840c
        int32_t i_v899 = i_v64 ^ ((int32_t)&p_g248 | 0x13190000);    // 0x18428
        int32_t i_v900 = i_v893 + i_v899 + i_v898;                   // 0x1842a
        uint32_t i_v901 = i_v900 ^ i_v895;                           // 0x18436
        int32_t i_v902 = i_v901 / 256 | 0x1000000 * i_v901;          // 0x18438
        int32_t i_v903 = i_v902 + i_v896;                            // 0x18442
        uint32_t i_v904 = i_v903 ^ i_v898;                           // 0x1844c
        int32_t i_v905 = i_v904 / 128 | 0x2000000 * i_v904;          // 0x1844e
        int32_t i_v906 = i_v862 + (i_v60 ^ -0x4ab8f6e9) + i_v905;    // 0x1846c
        uint32_t i_v907 = i_v906 ^ i_v876;                           // 0x18478
        int32_t i_v908 = i_v907 / 0x10000 | 0x10000 * i_v907;        // 0x1847a
        int32_t i_v909 = i_v908 + i_v889;                            // 0x18484
        uint32_t i_v910 = i_v909 ^ i_v905;                           // 0x1848e
        int32_t i_v911 = i_v910 / 0x1000 | 0x100000 * i_v910;        // 0x18490
        int32_t i_v912 = i_v906 + (i_v69 ^ 0x82efa98) + i_v911;      // 0x184ae
        uint32_t i_v913 = i_v912 ^ i_v908;                           // 0x184ba
        int32_t i_v914 = i_v913 / 256 | 0x1000000 * i_v913;          // 0x184bc
        int32_t i_v915 = i_v914 + i_v909;                            // 0x184c6
        uint32_t i_v916 = i_v915 ^ i_v911;                           // 0x184d0
        int32_t i_v917 = i_v916 / 128 | 0x2000000 * i_v916;          // 0x184d2
        int32_t i_v918 = i_v68 ^ 0x38d01377;                         // 0x184ec
        int32_t i_v919 = i_v874 + i_v918 + i_v867;                   // 0x184ee
        uint32_t i_v920 = i_v919 ^ i_v888;                           // 0x184fa
        int32_t i_v921 = i_v920 / 0x10000 | 0x10000 * i_v920;        // 0x184fc
        int32_t i_v922 = i_v921 + i_v903;                            // 0x18506
        uint32_t i_v923 = i_v922 ^ i_v867;                           // 0x1850e
        int32_t i_v924 = i_v923 / 0x1000 | 0x100000 * i_v923;        // 0x18510
        int32_t i_v925 = i_v63 ^ 0x3f84d5b5;                         // 0x18528
        int32_t i_v926 = i_v919 + i_v925 + i_v924;                   // 0x1852a
        uint32_t i_v927 = i_v926 ^ i_v921;                           // 0x18536
        int32_t i_v928 = i_v927 / 256 | 0x1000000 * i_v927;          // 0x18538
        int32_t i_v929 = i_v928 + i_v922;                            // 0x18542
        uint32_t i_v930 = i_v929 ^ i_v924;                           // 0x1854a
        int32_t i_v931 = i_v930 / 128 | 0x2000000 * i_v930;          // 0x1854c
        int32_t i_v932 = i_v886 + (i_v65 ^ 0x3707344) + i_v879;      // 0x18566
        uint32_t i_v933 = i_v932 ^ i_v902;                           // 0x18572
        int32_t i_v934 = i_v933 / 0x10000 | 0x10000 * i_v933;        // 0x18574
        int32_t i_v935 = i_v934 + i_v865;                            // 0x1857e
        uint32_t i_v936 = i_v935 ^ i_v879;                           // 0x18586
        int32_t i_v937 = i_v936 / 0x1000 | 0x100000 * i_v936;        // 0x18588
        int32_t i_v938 = i_v932 + (i_v57 ^ 0x34e90c6c) + i_v937;     // 0x185a2
        uint32_t i_v939 = i_v938 ^ i_v934;                           // 0x185ae
        int32_t i_v940 = i_v939 / 256 | 0x1000000 * i_v939;          // 0x185b0
        int32_t i_v941 = i_v940 + i_v935;                            // 0x185ba
        uint32_t i_v942 = i_v941 ^ i_v937;                           // 0x185c2
        int32_t i_v943 = i_v942 / 128 | 0x2000000 * i_v942;          // 0x185c4
        int32_t i_v944 = i_v900 + (i_v54 ^ 0x452821e6) + i_v891;     // 0x185de
        uint32_t i_v945 = i_v944 ^ i_v864;                           // 0x185ea
        int32_t i_v946 = i_v945 / 0x10000 | 0x10000 * i_v945;        // 0x185ec
        int32_t i_v947 = i_v946 + i_v877;                            // 0x185f6
        uint32_t i_v948 = i_v947 ^ i_v891;                           // 0x185fe
        int32_t i_v949 = i_v948 / 0x1000 | 0x100000 * i_v948;        // 0x18600
        int32_t i_v950 = i_v944 + (i_v62 ^ 0x243f6a88) + i_v949;     // 0x1861a
        uint32_t i_v951 = i_v950 ^ i_v946;                           // 0x18626
        int32_t i_v952 = i_v951 / 256 | 0x1000000 * i_v951;          // 0x18628
        int32_t i_v953 = i_v952 + i_v947;                            // 0x18632
        uint32_t i_v954 = i_v953 ^ i_v949;                           // 0x1863a
        int32_t i_v955 = i_v954 / 128 | 0x2000000 * i_v954;          // 0x1863c
        int32_t i_v956 = i_v912 + i_v621 + i_v931;                   // 0x18656
        uint32_t i_v957 = i_v956 ^ i_v952;                           // 0x18662
        int32_t i_v958 = i_v957 / 0x10000 | 0x10000 * i_v957;        // 0x18664
        int32_t i_v959 = i_v958 + i_v941;                            // 0x1866e
        uint32_t i_v960 = i_v959 ^ i_v931;                           // 0x18676
        int32_t i_v961 = i_v960 / 0x1000 | 0x100000 * i_v960;        // 0x18678
        int32_t i_v962 = i_v956 + i_v614 + i_v961;                   // 0x18692
        uint32_t i_v963 = i_v962 ^ i_v958;                           // 0x1869e
        int32_t i_v964 = i_v963 / 256 | 0x1000000 * i_v963;          // 0x186a0
        int32_t i_v965 = i_v964 + i_v959;                            // 0x186aa
        uint32_t i_v966 = i_v965 ^ i_v961;                           // 0x186b2
        int32_t i_v967 = i_v966 / 128 | 0x2000000 * i_v966;          // 0x186b4
        int32_t i_v968 = i_v926 + (i_v67 ^ -0x13b19377) + i_v943;    // 0x186ce
        uint32_t i_v969 = i_v968 ^ i_v914;                           // 0x186da
        int32_t i_v970 = i_v969 / 0x10000 | 0x10000 * i_v969;        // 0x186dc
        int32_t i_v971 = i_v970 + i_v953;                            // 0x186e6
        uint32_t i_v972 = i_v971 ^ i_v943;                           // 0x186ee
        int32_t i_v973 = i_v972 / 0x1000 | 0x100000 * i_v972;        // 0x186f0
        int32_t i_v974 = i_v968 + (i_v61 ^ -0x3683af23) + i_v973;    // 0x1870a
        uint32_t i_v975 = i_v974 ^ i_v970;                           // 0x18716
        int32_t i_v976 = i_v975 / 256 | 0x1000000 * i_v975;          // 0x18718
        int32_t i_v977 = i_v976 + i_v971;                            // 0x18722
        uint32_t i_v978 = i_v977 ^ i_v973;                           // 0x1872a
        int32_t i_v979 = i_v978 / 128 | 0x2000000 * i_v978;          // 0x1872c
        int32_t i_v980 = i_v938 + (i_v55 ^ -0x5bf6c7de) + i_v955;    // 0x18746
        uint32_t i_v981 = i_v980 ^ i_v928;                           // 0x18752
        int32_t i_v982 = i_v981 / 0x10000 | 0x10000 * i_v981;        // 0x18754
        int32_t i_v983 = i_v982 + i_v915;                            // 0x1875e
        uint32_t i_v984 = i_v983 ^ i_v955;                           // 0x18766
        int32_t i_v985 = i_v984 / 0x1000 | 0x100000 * i_v984;        // 0x18768
        int32_t i_v986 = i_v980 + (i_v58 ^ -0x7a5cf72d) + i_v985;    // 0x18782
        uint32_t i_v987 = i_v986 ^ i_v982;                           // 0x1878e
        int32_t i_v988 = i_v987 / 256 | 0x1000000 * i_v987;          // 0x18790
        int32_t i_v989 = i_v988 + i_v983;                            // 0x1879a
        uint32_t i_v990 = i_v989 ^ i_v985;                           // 0x187a2
        int32_t i_v991 = i_v990 / 128 | 0x2000000 * i_v990;          // 0x187a4
        int32_t i_v992 = i_v950 + i_v479 + i_v917;                   // 0x187c0
        uint32_t i_v993 = i_v992 ^ i_v940;                           // 0x187cc
        int32_t i_v994 = i_v993 / 0x10000 | 0x10000 * i_v993;        // 0x187ce
        int32_t i_v995 = i_v994 + i_v929;                            // 0x187d8
        uint32_t i_v996 = i_v995 ^ i_v917;                           // 0x187e2
        int32_t i_v997 = i_v996 / 0x1000 | 0x100000 * i_v996;        // 0x187e4
        int32_t i_v998 = i_v992 + i_v472 + i_v997;                   // 0x18802
        uint32_t i_v999 = i_v998 ^ i_v994;                           // 0x1880e
        int32_t i_v1000 = i_v999 / 256 | 0x1000000 * i_v999;         // 0x18810
        int32_t i_v1001 = i_v1000 + i_v995;                          // 0x1881a
        uint32_t i_v1002 = i_v1001 ^ i_v997;                         // 0x18824
        int32_t i_v1003 = i_v1002 / 128 | 0x2000000 * i_v1002;       // 0x18826
        int32_t i_v1004 = i_v962 + i_v899 + i_v1003;                 // 0x18844
        uint32_t i_v1005 = i_v1004 ^ i_v976;                         // 0x18850
        int32_t i_v1006 = i_v1005 / 0x10000 | 0x10000 * i_v1005;     // 0x18852
        int32_t i_v1007 = i_v1006 + i_v989;                          // 0x1885c
        uint32_t i_v1008 = i_v1007 ^ i_v1003;                        // 0x18866
        int32_t i_v1009 = i_v1008 / 0x1000 | 0x100000 * i_v1008;     // 0x18868
        int32_t i_v1010 = i_v1004 + i_v892 + i_v1009;                // 0x18886
        uint32_t i_v1011 = i_v1010 ^ i_v1006;                        // 0x18892
        int32_t i_v1012 = i_v1011 / 256 | 0x1000000 * i_v1011;       // 0x18894
        int32_t i_v1013 = i_v1012 + i_v1007;                         // 0x1889e
        uint32_t i_v1014 = i_v1013 ^ i_v1009;                        // 0x188a8
        int32_t i_v1015 = i_v1014 / 128 | 0x2000000 * i_v1014;       // 0x188aa
        int32_t i_v1016 = i_v974 + i_v203 + i_v967;                  // 0x188c6
        uint32_t i_v1017 = i_v1016 ^ i_v988;                         // 0x188d2
        int32_t i_v1018 = i_v1017 / 0x10000 | 0x10000 * i_v1017;     // 0x188d4
        int32_t i_v1019 = i_v1018 + i_v1001;                         // 0x188de
        uint32_t i_v1020 = i_v1019 ^ i_v967;                         // 0x188e6
        int32_t i_v1021 = i_v1020 / 0x1000 | 0x100000 * i_v1020;     // 0x188e8
        int32_t i_v1022 = i_v1016 + i_v196 + i_v1021;                // 0x18902
        uint32_t i_v1023 = i_v1022 ^ i_v1018;                        // 0x1890e
        int32_t i_v1024 = i_v1023 / 256 | 0x1000000 * i_v1023;       // 0x18910
        int32_t i_v1025 = i_v1024 + i_v1019;                         // 0x1891a
        uint32_t i_v1026 = i_v1025 ^ i_v1021;                        // 0x18922
        int32_t i_v1027 = i_v1026 / 128 | 0x2000000 * i_v1026;       // 0x18924
        int32_t i_v1028 = i_v986 + i_v119 + i_v979;                  // 0x1893e
        uint32_t i_v1029 = i_v1028 ^ i_v1000;                        // 0x1894a
        int32_t i_v1030 = i_v1029 / 0x10000 | 0x10000 * i_v1029;     // 0x1894c
        int32_t i_v1031 = i_v1030 + i_v965;                          // 0x18956
        uint32_t i_v1032 = i_v1031 ^ i_v979;                         // 0x1895e
        int32_t i_v1033 = i_v1032 / 0x1000 | 0x100000 * i_v1032;     // 0x18960
        int32_t i_v1034 = i_v1028 + i_v112 + i_v1033;                // 0x1897a
        uint32_t i_v1035 = i_v1034 ^ i_v1030;                        // 0x18986
        int32_t i_v1036 = i_v1035 / 256 | 0x1000000 * i_v1035;       // 0x18988
        int32_t i_v1037 = i_v1036 + i_v1031;                         // 0x18992
        uint32_t i_v1038 = i_v1037 ^ i_v1033;                        // 0x1899a
        int32_t i_v1039 = i_v1038 / 128 | 0x2000000 * i_v1038;       // 0x1899c
        int32_t i_v1040 = i_v998 + (i_v55 ^ 0x299f31d0) + i_v991;    // 0x189b6
        uint32_t i_v1041 = i_v1040 ^ i_v964;                         // 0x189c2
        int32_t i_v1042 = i_v1041 / 0x10000 | 0x10000 * i_v1041;     // 0x189c4
        int32_t i_v1043 = i_v1042 + i_v977;                          // 0x189ce
        uint32_t i_v1044 = i_v1043 ^ i_v991;                         // 0x189d6
        int32_t i_v1045 = i_v1044 / 0x1000 | 0x100000 * i_v1044;     // 0x189d8
        int32_t i_v1046 = i_v1040 + (i_v59 ^ -0x7a5cf72d) + i_v1045; // 0x189f2
        uint32_t i_v1047 = i_v1046 ^ i_v1042;                        // 0x189fe
        int32_t i_v1048 = i_v1047 / 256 | 0x1000000 * i_v1047;       // 0x18a00
        int32_t i_v1049 = i_v1048 + i_v1043;                         // 0x18a0a
        uint32_t i_v1050 = i_v1049 ^ i_v1045;                        // 0x18a12
        int32_t i_v1051 = i_v1050 / 128 | 0x2000000 * i_v1050;       // 0x18a14
        int32_t i_v1052 = i_v1010 + (i_v69 ^ 0x34e90c6c) + i_v1027;  // 0x18a2e
        uint32_t i_v1053 = i_v1052 ^ i_v1048;                        // 0x18a3a
        int32_t i_v1054 = i_v1053 / 0x10000 | 0x10000 * i_v1053;     // 0x18a3c
        int32_t i_v1055 = i_v1054 + i_v1037;                         // 0x18a46
        uint32_t i_v1056 = i_v1055 ^ i_v1027;                        // 0x18a4e
        int32_t i_v1057 = i_v1056 / 0x1000 | 0x100000 * i_v1056;     // 0x18a50
        int32_t i_v1058 = i_v1052 + (i_v65 ^ -0x4ab8f6e9) + i_v1057; // 0x18a6a
        uint32_t i_v1059 = i_v1058 ^ i_v1054;                        // 0x18a76
        int32_t i_v1060 = i_v1059 / 256 | 0x1000000 * i_v1059;       // 0x18a78
        int32_t i_v1061 = i_v1060 + i_v1055;                         // 0x18a82
        uint32_t i_v1062 = i_v1061 ^ i_v1057;                        // 0x18a8a
        int32_t i_v1063 = i_v1062 / 128 | 0x2000000 * i_v1062;       // 0x18a8c
        int32_t i_v1064 = i_v1022 + i_v925 + i_v1039;                // 0x18aa6
        uint32_t i_v1065 = i_v1064 ^ i_v1012;                        // 0x18ab2
        int32_t i_v1066 = i_v1065 / 0x10000 | 0x10000 * i_v1065;     // 0x18ab4
        int32_t i_v1067 = i_v1066 + i_v1049;                         // 0x18abe
        uint32_t i_v1068 = i_v1067 ^ i_v1039;                        // 0x18ac6
        int32_t i_v1069 = i_v1068 / 0x1000 | 0x100000 * i_v1068;     // 0x18ac8
        int32_t i_v1070 = i_v1064 + i_v918 + i_v1069;                // 0x18ae2
        uint32_t i_v1071 = i_v1070 ^ i_v1066;                        // 0x18aee
        int32_t i_v1072 = i_v1071 / 256 | 0x1000000 * i_v1071;       // 0x18af0
        int32_t i_v1073 = i_v1072 + i_v1067;                         // 0x18afa
        uint32_t i_v1074 = i_v1073 ^ i_v1069;                        // 0x18b02
        int32_t i_v1075 = i_v1074 / 128 | 0x2000000 * i_v1074;       // 0x18b04
        int32_t i_v1076 = i_v1034 + (i_v57 ^ -0x3f53d649) + i_v1051; // 0x18b1e
        uint32_t i_v1077 = i_v1076 ^ i_v1024;                        // 0x18b2a
        int32_t i_v1078 = i_v1077 / 0x10000 | 0x10000 * i_v1077;     // 0x18b2c
        int32_t i_v1079 = i_v1078 + i_v1013;                         // 0x18b36
        uint32_t i_v1080 = i_v1079 ^ i_v1051;                        // 0x18b3e
        int32_t i_v1081 = i_v1080 / 0x1000 | 0x100000 * i_v1080;     // 0x18b40
        int32_t i_v1082 = i_v1076 + (i_v66 ^ 0x3707344) + i_v1081;   // 0x18b5a
        uint32_t i_v1083 = i_v1082 ^ i_v1078;                        // 0x18b66
        int32_t i_v1084 = i_v1083 / 256 | 0x1000000 * i_v1083;       // 0x18b68
        int32_t i_v1085 = i_v1084 + i_v1079;                         // 0x18b72
        uint32_t i_v1086 = i_v1085 ^ i_v1081;                        // 0x18b7a
        int32_t i_v1087 = i_v1086 / 128 | 0x2000000 * i_v1086;       // 0x18b7c
        int32_t i_v1088 = i_v1046 + (i_v67 ^ 0x243f6a88) + i_v1015;  // 0x18b98
        uint32_t i_v1089 = i_v1088 ^ i_v1036;                        // 0x18ba4
        int32_t i_v1090 = i_v1089 / 0x10000 | 0x10000 * i_v1089;     // 0x18ba6
        int32_t i_v1091 = i_v1090 + i_v1025;                         // 0x18bb0
        uint32_t i_v1092 = i_v1091 ^ i_v1015;                        // 0x18bba
        int32_t i_v1093 = i_v1092 / 0x1000 | 0x100000 * i_v1092;     // 0x18bbc
        int32_t i_v1094 = i_v1088 + (i_v54 ^ -0x3683af23) + i_v1093; // 0x18bda
        uint32_t i_v1095 = i_v1094 ^ i_v1090;                        // 0x18be6
        int32_t i_v1096 = i_v1095 / 256 | 0x1000000 * i_v1095;       // 0x18be8
        int32_t i_v1097 = i_v1096 + i_v1091;                         // 0x18bf2
        uint32_t i_v1098 = i_v1097 ^ i_v1093;                        // 0x18bfc
        int32_t i_v1099 = i_v1098 / 128 | 0x2000000 * i_v1098;       // 0x18bfe
        int32_t i_v1100 = i_v1058 + i_v70 + i_v1099;                 // 0x18c1c
        uint32_t i_v1101 = i_v1100 ^ i_v1072;                        // 0x18c28
        int32_t i_v1102 = i_v1101 / 0x10000 | 0x10000 * i_v1101;     // 0x18c2a
        int32_t i_v1103 = i_v1102 + i_v1085;                         // 0x18c34
        uint32_t i_v1104 = i_v1103 ^ i_v1099;                        // 0x18c3e
        int32_t i_v1105 = i_v1104 / 0x1000 | 0x100000 * i_v1104;     // 0x18c40
        int32_t i_v1106 = i_v1100 + i_v77 + i_v1105;                 // 0x18c5e
        uint32_t i_v1107 = i_v1106 ^ i_v1102;                        // 0x18c6a
        int32_t i_v1108 = i_v1107 / 256 | 0x1000000 * i_v1107;       // 0x18c6c
        int32_t i_v1109 = i_v1108 + i_v1103;                         // 0x18c76
        uint32_t i_v1110 = i_v1109 ^ i_v1105;                        // 0x18c80
        int32_t i_v1111 = i_v1110 / 128 | 0x2000000 * i_v1110;       // 0x18c82
        int32_t i_v1112 = i_v1070 + i_v84 + i_v1063;                 // 0x18c9e
        uint32_t i_v1113 = i_v1112 ^ i_v1084;                        // 0x18caa
        int32_t i_v1114 = i_v1113 / 0x10000 | 0x10000 * i_v1113;     // 0x18cac
        int32_t i_v1115 = i_v1114 + i_v1097;                         // 0x18cb6
        uint32_t i_v1116 = i_v1115 ^ i_v1063;                        // 0x18cbe
        int32_t i_v1117 = i_v1116 / 0x1000 | 0x100000 * i_v1116;     // 0x18cc0
        int32_t i_v1118 = i_v1112 + i_v91 + i_v1117;                 // 0x18cda
        uint32_t i_v1119 = i_v1118 ^ i_v1114;                        // 0x18ce6
        int32_t i_v1120 = i_v1119 / 256 | 0x1000000 * i_v1119;       // 0x18ce8
        int32_t i_v1121 = i_v1120 + i_v1115;                         // 0x18cf2
        uint32_t i_v1122 = i_v1121 ^ i_v1117;                        // 0x18cfa
        int32_t i_v1123 = i_v1122 / 128 | 0x2000000 * i_v1122;       // 0x18cfc
        int32_t i_v1124 = i_v1082 + i_v98 + i_v1075;                 // 0x18d16
        uint32_t i_v1125 = i_v1124 ^ i_v1096;                        // 0x18d22
        int32_t i_v1126 = i_v1125 / 0x10000 | 0x10000 * i_v1125;     // 0x18d24
        int32_t i_v1127 = i_v1126 + i_v1061;                         // 0x18d2e
        uint32_t i_v1128 = i_v1127 ^ i_v1075;                        // 0x18d36
        int32_t i_v1129 = i_v1128 / 0x1000 | 0x100000 * i_v1128;     // 0x18d38
        int32_t i_v1130 = i_v1124 + i_v105 + i_v1129;                // 0x18d52
        uint32_t i_v1131 = i_v1130 ^ i_v1126;                        // 0x18d5e
        int32_t i_v1132 = i_v1131 / 256 | 0x1000000 * i_v1131;       // 0x18d60
        int32_t i_v1133 = i_v1132 + i_v1127;                         // 0x18d6a
        uint32_t i_v1134 = i_v1133 ^ i_v1129;                        // 0x18d72
        int32_t i_v1135 = i_v1134 / 128 | 0x2000000 * i_v1134;       // 0x18d74
        int32_t i_v1136 = i_v1094 + i_v112 + i_v1087;                // 0x18d8e
        uint32_t i_v1137 = i_v1136 ^ i_v1060;                        // 0x18d9a
        int32_t i_v1138 = i_v1137 / 0x10000 | 0x10000 * i_v1137;     // 0x18d9c
        int32_t i_v1139 = i_v1138 + i_v1073;                         // 0x18da6
        uint32_t i_v1140 = i_v1139 ^ i_v1087;                        // 0x18dae
        int32_t i_v1141 = i_v1140 / 0x1000 | 0x100000 * i_v1140;     // 0x18db0
        int32_t i_v1142 = i_v1136 + i_v119 + i_v1141;                // 0x18dca
        uint32_t i_v1143 = i_v1142 ^ i_v1138;                        // 0x18dd6
        int32_t i_v1144 = i_v1143 / 256 | 0x1000000 * i_v1143;       // 0x18dd8
        int32_t i_v1145 = i_v1144 + i_v1139;                         // 0x18de2
        uint32_t i_v1146 = i_v1145 ^ i_v1141;                        // 0x18dea
        int32_t i_v1147 = i_v1146 / 128 | 0x2000000 * i_v1146;       // 0x18dec
        int32_t i_v1148 = i_v1106 + i_v126 + i_v1123;                // 0x18e06
        uint32_t i_v1149 = i_v1148 ^ i_v1144;                        // 0x18e12
        int32_t i_v1150 = i_v1149 / 0x10000 | 0x10000 * i_v1149;     // 0x18e14
        int32_t i_v1151 = i_v1150 + i_v1133;                         // 0x18e1e
        uint32_t i_v1152 = i_v1151 ^ i_v1123;                        // 0x18e26
        int32_t i_v1153 = i_v1152 / 0x1000 | 0x100000 * i_v1152;     // 0x18e28
        int32_t i_v1154 = i_v1148 + i_v133 + i_v1153;                // 0x18e42
        uint32_t i_v1155 = i_v1154 ^ i_v1150;                        // 0x18e4e
        int32_t i_v1156 = i_v1155 / 256 | 0x1000000 * i_v1155;       // 0x18e50
        int32_t i_v1157 = i_v1156 + i_v1151;                         // 0x18e5a
        uint32_t i_v1158 = i_v1157 ^ i_v1153;                        // 0x18e62
        int32_t i_v1159 = i_v1158 / 128 | 0x2000000 * i_v1158;       // 0x18e64
        int32_t i_v1160 = i_v1118 + i_v140 + i_v1135;                // 0x18e7e
        uint32_t i_v1161 = i_v1160 ^ i_v1108;                        // 0x18e8a
        int32_t i_v1162 = i_v1161 / 0x10000 | 0x10000 * i_v1161;     // 0x18e8c
        int32_t i_v1163 = i_v1162 + i_v1145;                         // 0x18e96
        uint32_t i_v1164 = i_v1163 ^ i_v1135;                        // 0x18e9e
        int32_t i_v1165 = i_v1164 / 0x1000 | 0x100000 * i_v1164;     // 0x18ea0
        int32_t i_v1166 = i_v1160 + i_v147 + i_v1165;                // 0x18eba
        uint32_t i_v1167 = i_v1166 ^ i_v1162;                        // 0x18ec6
        int32_t i_v1168 = i_v1167 / 256 | 0x1000000 * i_v1167;       // 0x18ec8
        int32_t i_v1169 = i_v1168 + i_v1163;                         // 0x18ed2
        uint32_t i_v1170 = i_v1169 ^ i_v1165;                        // 0x18eda
        int32_t i_v1171 = i_v1170 / 128 | 0x2000000 * i_v1170;       // 0x18edc
        int32_t i_v1172 = i_v1130 + i_v154 + i_v1147;                // 0x18ef6
        uint32_t i_v1173 = i_v1172 ^ i_v1120;                        // 0x18f02
        int32_t i_v1174 = i_v1173 / 0x10000 | 0x10000 * i_v1173;     // 0x18f04
        int32_t i_v1175 = i_v1174 + i_v1109;                         // 0x18f0e
        uint32_t i_v1176 = i_v1175 ^ i_v1147;                        // 0x18f16
        int32_t i_v1177 = i_v1176 / 0x1000 | 0x100000 * i_v1176;     // 0x18f18
        int32_t i_v1178 = i_v1172 + i_v161 + i_v1177;                // 0x18f32
        uint32_t i_v1179 = i_v1178 ^ i_v1174;                        // 0x18f3e
        int32_t i_v1180 = i_v1179 / 256 | 0x1000000 * i_v1179;       // 0x18f40
        int32_t i_v1181 = i_v1180 + i_v1175;                         // 0x18f4a
        uint32_t i_v1182 = i_v1181 ^ i_v1177;                        // 0x18f52
        int32_t i_v1183 = i_v1182 / 128 | 0x2000000 * i_v1182;       // 0x18f54
        int32_t i_v1184 = i_v1142 + i_v168 + i_v1111;                // 0x18f70
        uint32_t i_v1185 = i_v1184 ^ i_v1132;                        // 0x18f7c
        int32_t i_v1186 = i_v1185 / 0x10000 | 0x10000 * i_v1185;     // 0x18f7e
        int32_t i_v1187 = i_v1186 + i_v1121;                         // 0x18f88
        uint32_t i_v1188 = i_v1187 ^ i_v1111;                        // 0x18f92
        int32_t i_v1189 = i_v1188 / 0x1000 | 0x100000 * i_v1188;     // 0x18f94
        int32_t i_v1190 = i_v1184 + i_v175 + i_v1189;                // 0x18fb2
        uint32_t i_v1191 = i_v1190 ^ i_v1186;                        // 0x18fbe
        int32_t i_v1192 = i_v1191 / 256 | 0x1000000 * i_v1191;       // 0x18fc0
        int32_t i_v1193 = i_v1192 + i_v1187;                         // 0x18fca
        uint32_t i_v1194 = i_v1193 ^ i_v1189;                        // 0x18fd4
        int32_t i_v1195 = i_v1194 / 128 | 0x2000000 * i_v1194;       // 0x18fd6
        int32_t i_v1196 = i_v1154 + i_v182 + i_v1195;                // 0x18ff4
        uint32_t i_v1197 = i_v1196 ^ i_v1168;                        // 0x19000
        int32_t i_v1198 = i_v1197 / 0x10000 | 0x10000 * i_v1197;     // 0x19002
        int32_t i_v1199 = i_v1198 + i_v1181;                         // 0x1900c
        uint32_t i_v1200 = i_v1199 ^ i_v1195;                        // 0x19016
        int32_t i_v1201 = i_v1200 / 0x1000 | 0x100000 * i_v1200;     // 0x19018
        int32_t i_v1202 = i_v1196 + i_v189 + i_v1201;                // 0x19036
        uint32_t i_v1203 = i_v1202 ^ i_v1198;                        // 0x19042
        int32_t i_v1204 = i_v1203 / 256 | 0x1000000 * i_v1203;       // 0x19044
        int32_t i_v1205 = i_v1204 + i_v1199;                         // 0x1904e
        uint32_t i_v1206 = i_v1205 ^ i_v1201;                        // 0x19058
        int32_t i_v1207 = i_v1206 / 128 | 0x2000000 * i_v1206;       // 0x1905a
        int32_t i_v1208 = i_v1166 + i_v196 + i_v1159;                // 0x19076
        uint32_t i_v1209 = i_v1208 ^ i_v1180;                        // 0x19082
        int32_t i_v1210 = i_v1209 / 0x10000 | 0x10000 * i_v1209;     // 0x19084
        int32_t i_v1211 = i_v1210 + i_v1193;                         // 0x1908e
        uint32_t i_v1212 = i_v1211 ^ i_v1159;                        // 0x19096
        int32_t i_v1213 = i_v1212 / 0x1000 | 0x100000 * i_v1212;     // 0x19098
        int32_t i_v1214 = i_v1208 + i_v203 + i_v1213;                // 0x190b2
        uint32_t i_v1215 = i_v1214 ^ i_v1210;                        // 0x190be
        int32_t i_v1216 = i_v1215 / 256 | 0x1000000 * i_v1215;       // 0x190c0
        int32_t i_v1217 = i_v1216 + i_v1211;                         // 0x190ca
        uint32_t i_v1218 = i_v1217 ^ i_v1213;                        // 0x190d2
        int32_t i_v1219 = i_v1218 / 128 | 0x2000000 * i_v1218;       // 0x190d4
        int32_t i_v1220 = i_v1178 + i_v210 + i_v1171;                // 0x190ee
        uint32_t i_v1221 = i_v1220 ^ i_v1192;                        // 0x190fa
        int32_t i_v1222 = i_v1221 / 0x10000 | 0x10000 * i_v1221;     // 0x190fc
        int32_t i_v1223 = i_v1222 + i_v1157;                         // 0x19106
        uint32_t i_v1224 = i_v1223 ^ i_v1171;                        // 0x1910e
        int32_t i_v1225 = i_v1224 / 0x1000 | 0x100000 * i_v1224;     // 0x19110
        int32_t i_v1226 = i_v1220 + i_v217 + i_v1225;                // 0x1912a
        uint32_t i_v1227 = i_v1226 ^ i_v1222;                        // 0x19136
        int32_t i_v1228 = i_v1227 / 256 | 0x1000000 * i_v1227;       // 0x19138
        int32_t i_v1229 = i_v1228 + i_v1223;                         // 0x19142
        uint32_t i_v1230 = i_v1229 ^ i_v1225;                        // 0x1914a
        int32_t i_v1231 = i_v1230 / 128 | 0x2000000 * i_v1230;       // 0x1914c
        int32_t i_v1232 = i_v1190 + i_v224 + i_v1183;                // 0x19166
        uint32_t i_v1233 = i_v1232 ^ i_v1156;                        // 0x19172
        int32_t i_v1234 = i_v1233 / 0x10000 | 0x10000 * i_v1233;     // 0x19174
        int32_t i_v1235 = i_v1234 + i_v1169;                         // 0x1917e
        uint32_t i_v1236 = i_v1235 ^ i_v1183;                        // 0x19186
        int32_t i_v1237 = i_v1236 / 0x1000 | 0x100000 * i_v1236;     // 0x19188
        int32_t i_v1238 = i_v1232 + i_v231 + i_v1237;                // 0x191a2
        uint32_t i_v1239 = i_v1238 ^ i_v1234;                        // 0x191ae
        int32_t i_v1240 = i_v1239 / 256 | 0x1000000 * i_v1239;       // 0x191b0
        int32_t i_v1241 = i_v1240 + i_v1235;                         // 0x191ba
        uint32_t i_v1242 = i_v1241 ^ i_v1237;                        // 0x191c2
        int32_t i_v1243 = i_v1242 / 128 | 0x2000000 * i_v1242;       // 0x191c4
        int32_t i_v1244 = i_v1202 + i_v238 + i_v1219;                // 0x191de
        uint32_t i_v1245 = i_v1244 ^ i_v1240;                        // 0x191ea
        int32_t i_v1246 = i_v1245 / 0x10000 | 0x10000 * i_v1245;     // 0x191ec
        int32_t i_v1247 = i_v1246 + i_v1229;                         // 0x191f6
        uint32_t i_v1248 = i_v1247 ^ i_v1219;                        // 0x191fe
        int32_t i_v1249 = i_v1248 / 0x1000 | 0x100000 * i_v1248;     // 0x19200
        int32_t i_v1250 = i_v1244 + i_v245 + i_v1249;                // 0x1921a
        uint32_t i_v1251 = i_v1250 ^ i_v1246;                        // 0x19226
        int32_t i_v1252 = i_v1251 / 256 | 0x1000000 * i_v1251;       // 0x19228
        int32_t i_v1253 = i_v1252 + i_v1247;                         // 0x19232
        uint32_t i_v1254 = i_v1253 ^ i_v1249;                        // 0x1923a
        int32_t i_v1255 = i_v1254 / 128 | 0x2000000 * i_v1254;       // 0x1923c
        int32_t i_v1256 = i_v1214 + i_v252 + i_v1231;                // 0x19256
        uint32_t i_v1257 = i_v1256 ^ i_v1204;                        // 0x19262
        int32_t i_v1258 = i_v1257 / 0x10000 | 0x10000 * i_v1257;     // 0x19264
        int32_t i_v1259 = i_v1258 + i_v1241;                         // 0x1926e
        uint32_t i_v1260 = i_v1259 ^ i_v1231;                        // 0x19276
        int32_t i_v1261 = i_v1260 / 0x1000 | 0x100000 * i_v1260;     // 0x19278
        int32_t i_v1262 = i_v1256 + i_v259 + i_v1261;                // 0x19292
        uint32_t i_v1263 = i_v1262 ^ i_v1258;                        // 0x1929e
        int32_t i_v1264 = i_v1263 / 256 | 0x1000000 * i_v1263;       // 0x192a0
        int32_t i_v1265 = i_v1264 + i_v1259;                         // 0x192aa
        uint32_t i_v1266 = i_v1265 ^ i_v1261;                        // 0x192b2
        int32_t i_v1267 = i_v1266 / 128 | 0x2000000 * i_v1266;       // 0x192b4
        int32_t i_v1268 = i_v1226 + i_v266 + i_v1243;                // 0x192ce
        uint32_t i_v1269 = i_v1268 ^ i_v1216;                        // 0x192da
        int32_t i_v1270 = i_v1269 / 0x10000 | 0x10000 * i_v1269;     // 0x192dc
        int32_t i_v1271 = i_v1270 + i_v1205;                         // 0x192e6
        uint32_t i_v1272 = i_v1271 ^ i_v1243;                        // 0x192ee
        int32_t i_v1273 = i_v1272 / 0x1000 | 0x100000 * i_v1272;     // 0x192f0
        int32_t i_v1274 = i_v1268 + i_v273 + i_v1273;                // 0x1930a
        uint32_t i_v1275 = i_v1274 ^ i_v1270;                        // 0x19316
        int32_t i_v1276 = i_v1275 / 256 | 0x1000000 * i_v1275;       // 0x19318
        int32_t i_v1277 = i_v1276 + i_v1271;                         // 0x19322
        uint32_t i_v1278 = i_v1277 ^ i_v1273;                        // 0x1932a
        int32_t i_v1279 = i_v1278 / 128 | 0x2000000 * i_v1278;       // 0x1932c
        int32_t i_v1280 = i_v1238 + i_v280 + i_v1207;                // 0x19348
        uint32_t i_v1281 = i_v1280 ^ i_v1228;                        // 0x19354
        int32_t i_v1282 = i_v1281 / 0x10000 | 0x10000 * i_v1281;     // 0x19356
        int32_t i_v1283 = i_v1282 + i_v1217;                         // 0x19360
        uint32_t i_v1284 = i_v1283 ^ i_v1207;                        // 0x1936a
        int32_t i_v1285 = i_v1284 / 0x1000 | 0x100000 * i_v1284;     // 0x1936c
        int32_t i_v1286 = i_v1280 + i_v287 + i_v1285;                // 0x1938a
        uint32_t i_v1287 = i_v1286 ^ i_v1282;                        // 0x19396
        int32_t i_v1288 = i_v1287 / 256 | 0x1000000 * i_v1287;       // 0x19398
        int32_t i_v1289 = i_v1288 + i_v1283;                         // 0x193a2
        uint32_t i_v1290 = i_v1289 ^ i_v1285;                        // 0x193ac
        int32_t i_v1291 = i_v1290 / 128 | 0x2000000 * i_v1290;       // 0x193ae
        int32_t i_v1292 = i_v1250 + i_v294 + i_v1291;                // 0x193cc
        uint32_t i_v1293 = i_v1292 ^ i_v1264;                        // 0x193d8
        int32_t i_v1294 = i_v1293 / 0x10000 | 0x10000 * i_v1293;     // 0x193da
        int32_t i_v1295 = i_v1294 + i_v1277;                         // 0x193e4
        uint32_t i_v1296 = i_v1295 ^ i_v1291;                        // 0x193ee
        int32_t i_v1297 = i_v1296 / 0x1000 | 0x100000 * i_v1296;     // 0x193f0
        int32_t i_v1298 = i_v1292 + i_v301 + i_v1297;                // 0x1940e
        uint32_t i_v1299 = i_v1298 ^ i_v1294;                        // 0x1941a
        int32_t i_v1300 = i_v1299 / 256 | 0x1000000 * i_v1299;       // 0x1941c
        int32_t i_v1301 = i_v1300 + i_v1295;                         // 0x19426
        uint32_t i_v1302 = i_v1301 ^ i_v1297;                        // 0x19430
        int32_t i_v1303 = i_v1302 / 128 | 0x2000000 * i_v1302;       // 0x19432
        int32_t i_v1304 = i_v1262 + i_v308 + i_v1255;                // 0x1944e
        uint32_t i_v1305 = i_v1304 ^ i_v1276;                        // 0x1945a
        int32_t i_v1306 = i_v1305 / 0x10000 | 0x10000 * i_v1305;     // 0x1945c
        int32_t i_v1307 = i_v1306 + i_v1289;                         // 0x19466
        uint32_t i_v1308 = i_v1307 ^ i_v1255;                        // 0x1946e
        int32_t i_v1309 = i_v1308 / 0x1000 | 0x100000 * i_v1308;     // 0x19470
        int32_t i_v1310 = i_v1304 + i_v315 + i_v1309;                // 0x1948a
        uint32_t i_v1311 = i_v1310 ^ i_v1306;                        // 0x19496
        int32_t i_v1312 = i_v1311 / 256 | 0x1000000 * i_v1311;       // 0x19498
        int32_t i_v1313 = i_v1312 + i_v1307;                         // 0x194a2
        uint32_t i_v1314 = i_v1313 ^ i_v1309;                        // 0x194aa
        int32_t i_v1315 = i_v1314 / 128 | 0x2000000 * i_v1314;       // 0x194ac
        int32_t i_v1316 = i_v1274 + i_v322 + i_v1267;                // 0x194c6
        uint32_t i_v1317 = i_v1316 ^ i_v1288;                        // 0x194d2
        int32_t i_v1318 = i_v1317 / 0x10000 | 0x10000 * i_v1317;     // 0x194d4
        int32_t i_v1319 = i_v1318 + i_v1253;                         // 0x194de
        uint32_t i_v1320 = i_v1319 ^ i_v1267;                        // 0x194e6
        int32_t i_v1321 = i_v1320 / 0x1000 | 0x100000 * i_v1320;     // 0x194e8
        int32_t i_v1322 = i_v1316 + i_v329 + i_v1321;                // 0x19502
        uint32_t i_v1323 = i_v1322 ^ i_v1318;                        // 0x1950e
        int32_t i_v1324 = i_v1323 / 256 | 0x1000000 * i_v1323;       // 0x19510
        int32_t i_v1325 = i_v1324 + i_v1319;                         // 0x1951a
        uint32_t i_v1326 = i_v1325 ^ i_v1321;                        // 0x19522
        int32_t i_v1327 = i_v1326 / 128 | 0x2000000 * i_v1326;       // 0x19524
        int32_t i_v1328 = i_v1286 + i_v336 + i_v1279;                // 0x1953e
        uint32_t i_v1329 = i_v1328 ^ i_v1252;                        // 0x1954a
        int32_t i_v1330 = i_v1329 / 0x10000 | 0x10000 * i_v1329;     // 0x1954c
        int32_t i_v1331 = i_v1330 + i_v1265;                         // 0x19556
        uint32_t i_v1332 = i_v1331 ^ i_v1279;                        // 0x1955e
        int32_t i_v1333 = i_v1332 / 0x1000 | 0x100000 * i_v1332;     // 0x19560
        int32_t i_v1334 = i_v1328 + i_v343 + i_v1333;                // 0x1957a
        uint32_t i_v1335 = i_v1334 ^ i_v1330;                        // 0x19586
        int32_t i_v1336 = i_v1335 / 256 | 0x1000000 * i_v1335;       // 0x19588
        int32_t i_v1337 = i_v1336 + i_v1331;                         // 0x19592
        uint32_t i_v1338 = i_v1337 ^ i_v1333;                        // 0x1959a
        int32_t i_v1339 = i_v1338 / 128 | 0x2000000 * i_v1338;       // 0x1959c
        int32_t i_v1340 = i_v1298 + i_v189 + i_v1315;                // 0x195b6
        uint32_t i_v1341 = i_v1340 ^ i_v1336;                        // 0x195c2
        int32_t i_v1342 = i_v1341 / 0x10000 | 0x10000 * i_v1341;     // 0x195c4
        int32_t i_v1343 = i_v1342 + i_v1325;                         // 0x195ce
        uint32_t i_v1344 = i_v1343 ^ i_v1315;                        // 0x195d6
        int32_t i_v1345 = i_v1344 / 0x1000 | 0x100000 * i_v1344;     // 0x195d8
        int32_t i_v1346 = i_v1340 + i_v182 + i_v1345;                // 0x195f2
        uint32_t i_v1347 = i_v1346 ^ i_v1342;                        // 0x195fe
        int32_t i_v1348 = i_v1347 / 256 | 0x1000000 * i_v1347;       // 0x19600
        int32_t i_v1349 = i_v1348 + i_v1343;                         // 0x1960a
        uint32_t i_v1350 = i_v1349 ^ i_v1345;                        // 0x19612
        int32_t i_v1351 = i_v1350 / 128 | 0x2000000 * i_v1350;       // 0x19614
        int32_t i_v1352 = i_v1310 + i_v362 + i_v1327;                // 0x1962e
        uint32_t i_v1353 = i_v1352 ^ i_v1300;                        // 0x1963a
        int32_t i_v1354 = i_v1353 / 0x10000 | 0x10000 * i_v1353;     // 0x1963c
        int32_t i_v1355 = i_v1354 + i_v1337;                         // 0x19646
        uint32_t i_v1356 = i_v1355 ^ i_v1327;                        // 0x1964e
        int32_t i_v1357 = i_v1356 / 0x1000 | 0x100000 * i_v1356;     // 0x19650
        int32_t i_v1358 = i_v1352 + i_v369 + i_v1357;                // 0x1966a
        uint32_t i_v1359 = i_v1358 ^ i_v1354;                        // 0x19676
        int32_t i_v1360 = i_v1359 / 256 | 0x1000000 * i_v1359;       // 0x19678
        int32_t i_v1361 = i_v1360 + i_v1355;                         // 0x19682
        uint32_t i_v1362 = i_v1361 ^ i_v1357;                        // 0x1968a
        int32_t i_v1363 = i_v1362 / 128 | 0x2000000 * i_v1362;       // 0x1968c
        int32_t i_v1364 = i_v1322 + i_v376 + i_v1339;                // 0x196a6
        uint32_t i_v1365 = i_v1364 ^ i_v1312;                        // 0x196b2
        int32_t i_v1366 = i_v1365 / 0x10000 | 0x10000 * i_v1365;     // 0x196b4
        int32_t i_v1367 = i_v1366 + i_v1301;                         // 0x196be
        uint32_t i_v1368 = i_v1367 ^ i_v1339;                        // 0x196c6
        int32_t i_v1369 = i_v1368 / 0x1000 | 0x100000 * i_v1368;     // 0x196c8
        int32_t i_v1370 = i_v1364 + i_v383 + i_v1369;                // 0x196e2
        uint32_t i_v1371 = i_v1370 ^ i_v1366;                        // 0x196ee
        int32_t i_v1372 = i_v1371 / 256 | 0x1000000 * i_v1371;       // 0x196f0
        int32_t i_v1373 = i_v1372 + i_v1367;                         // 0x196fa
        uint32_t i_v1374 = i_v1373 ^ i_v1369;                        // 0x19702
        int32_t i_v1375 = i_v1374 / 128 | 0x2000000 * i_v1374;       // 0x19704
        int32_t i_v1376 = i_v1334 + i_v390 + i_v1303;                // 0x19720
        uint32_t i_v1377 = i_v1376 ^ i_v1324;                        // 0x1972c
        int32_t i_v1378 = i_v1377 / 0x10000 | 0x10000 * i_v1377;     // 0x1972e
        int32_t i_v1379 = i_v1378 + i_v1313;                         // 0x19738
        uint32_t i_v1380 = i_v1379 ^ i_v1303;                        // 0x19742
        int32_t i_v1381 = i_v1380 / 0x1000 | 0x100000 * i_v1380;     // 0x19744
        int32_t i_v1382 = i_v1376 + i_v397 + i_v1381;                // 0x19762
        uint32_t i_v1383 = i_v1382 ^ i_v1378;                        // 0x1976e
        int32_t i_v1384 = i_v1383 / 256 | 0x1000000 * i_v1383;       // 0x19770
        int32_t i_v1385 = i_v1384 + i_v1379;                         // 0x1977a
        uint32_t i_v1386 = i_v1385 ^ i_v1381;                        // 0x19784
        int32_t i_v1387 = i_v1386 / 128 | 0x2000000 * i_v1386;       // 0x19786
        int32_t i_v1388 = i_v1346 + i_v404 + i_v1387;                // 0x197a4
        uint32_t i_v1389 = i_v1388 ^ i_v1360;                        // 0x197b0
        int32_t i_v1390 = i_v1389 / 0x10000 | 0x10000 * i_v1389;     // 0x197b2
        int32_t i_v1391 = i_v1390 + i_v1373;                         // 0x197bc
        uint32_t i_v1392 = i_v1391 ^ i_v1387;                        // 0x197c6
        int32_t i_v1393 = i_v1392 / 0x1000 | 0x100000 * i_v1392;     // 0x197c8
        int32_t i_v1394 = i_v1388 + i_v411 + i_v1393;                // 0x197e6
        uint32_t i_v1395 = i_v1394 ^ i_v1390;                        // 0x197f2
        int32_t i_v1396 = i_v1395 / 256 | 0x1000000 * i_v1395;       // 0x197f4
        int32_t i_v1397 = i_v1396 + i_v1391;                         // 0x197fe
        uint32_t i_v1398 = i_v1397 ^ i_v1393;                        // 0x19808
        int32_t i_v1399 = i_v1398 / 128 | 0x2000000 * i_v1398;       // 0x1980a
        int32_t i_v1400 = i_v1358 + i_v418 + i_v1351;                // 0x19826
        uint32_t i_v1401 = i_v1400 ^ i_v1372;                        // 0x19832
        int32_t i_v1402 = i_v1401 / 0x10000 | 0x10000 * i_v1401;     // 0x19834
        int32_t i_v1403 = i_v1402 + i_v1385;                         // 0x1983e
        uint32_t i_v1404 = i_v1403 ^ i_v1351;                        // 0x19846
        int32_t i_v1405 = i_v1404 / 0x1000 | 0x100000 * i_v1404;     // 0x19848
        int32_t i_v1406 = i_v1400 + i_v425 + i_v1405;                // 0x19862
        uint32_t i_v1407 = i_v1406 ^ i_v1402;                        // 0x1986e
        int32_t i_v1408 = i_v1407 / 256 | 0x1000000 * i_v1407;       // 0x19870
        int32_t i_v1409 = i_v1408 + i_v1403;                         // 0x1987a
        uint32_t i_v1410 = i_v1409 ^ i_v1405;                        // 0x19882
        int32_t i_v1411 = i_v1410 / 128 | 0x2000000 * i_v1410;       // 0x19884
        int32_t i_v1412 = i_v1370 + i_v161 + i_v1363;                // 0x1989e
        uint32_t i_v1413 = i_v1412 ^ i_v1384;                        // 0x198aa
        int32_t i_v1414 = i_v1413 / 0x10000 | 0x10000 * i_v1413;     // 0x198ac
        int32_t i_v1415 = i_v1414 + i_v1349;                         // 0x198b6
        uint32_t i_v1416 = i_v1415 ^ i_v1363;                        // 0x198be
        int32_t i_v1417 = i_v1416 / 0x1000 | 0x100000 * i_v1416;     // 0x198c0
        int32_t i_v1418 = i_v1412 + i_v154 + i_v1417;                // 0x198da
        uint32_t i_v1419 = i_v1418 ^ i_v1414;                        // 0x198e6
        int32_t i_v1420 = i_v1419 / 256 | 0x1000000 * i_v1419;       // 0x198e8
        int32_t i_v1421 = i_v1420 + i_v1415;                         // 0x198f2
        uint32_t i_v1422 = i_v1421 ^ i_v1417;                        // 0x198fa
        int32_t i_v1423 = i_v1422 / 128 | 0x2000000 * i_v1422;       // 0x198fc
        int32_t i_v1424 = i_v1382 + i_v444 + i_v1375;                // 0x19916
        uint32_t i_v1425 = i_v1424 ^ i_v1348;                        // 0x19922
        int32_t i_v1426 = i_v1425 / 0x10000 | 0x10000 * i_v1425;     // 0x19924
        int32_t i_v1427 = i_v1426 + i_v1361;                         // 0x1992e
        uint32_t i_v1428 = i_v1427 ^ i_v1375;                        // 0x19936
        int32_t i_v1429 = i_v1428 / 0x1000 | 0x100000 * i_v1428;     // 0x19938
        int32_t i_v1430 = i_v1424 + i_v451 + i_v1429;                // 0x19952
        uint32_t i_v1431 = i_v1430 ^ i_v1426;                        // 0x1995e
        int32_t i_v1432 = i_v1431 / 256 | 0x1000000 * i_v1431;       // 0x19960
        int32_t i_v1433 = i_v1432 + i_v1427;                         // 0x1996a
        uint32_t i_v1434 = i_v1433 ^ i_v1429;                        // 0x19972
        int32_t i_v1435 = i_v1434 / 128 | 0x2000000 * i_v1434;       // 0x19974
        int32_t i_v1436 = i_v1394 + i_v458 + i_v1411;                // 0x1998e
        uint32_t i_v1437 = i_v1436 ^ i_v1432;                        // 0x1999a
        int32_t i_v1438 = i_v1437 / 0x10000 | 0x10000 * i_v1437;     // 0x1999c
        int32_t i_v1439 = i_v1438 + i_v1421;                         // 0x199a6
        uint32_t i_v1440 = i_v1439 ^ i_v1411;                        // 0x199ae
        int32_t i_v1441 = i_v1440 / 0x1000 | 0x100000 * i_v1440;     // 0x199b0
        int32_t i_v1442 = i_v1436 + i_v465 + i_v1441;                // 0x199ca
        uint32_t i_v1443 = i_v1442 ^ i_v1438;                        // 0x199d6
        int32_t i_v1444 = i_v1443 / 256 | 0x1000000 * i_v1443;       // 0x199d8
        int32_t i_v1445 = i_v1444 + i_v1439;                         // 0x199e2
        uint32_t i_v1446 = i_v1445 ^ i_v1441;                        // 0x199ea
        int32_t i_v1447 = i_v1406 + i_v472 + i_v1423;                // 0x19a06
        uint32_t i_v1448 = i_v1447 ^ i_v1396;                        // 0x19a12
        int32_t i_v1449 = i_v1448 / 0x10000 | 0x10000 * i_v1448;     // 0x19a14
        int32_t i_v1450 = i_v1449 + i_v1433;                         // 0x19a1e
        uint32_t i_v1451 = i_v1450 ^ i_v1423;                        // 0x19a26
        int32_t i_v1452 = i_v1451 / 0x1000 | 0x100000 * i_v1451;     // 0x19a28
        int32_t i_v1453 = i_v1447 + i_v479 + i_v1452;                // 0x19a42
        uint32_t i_v1454 = i_v1453 ^ i_v1449;                        // 0x19a4e
        int32_t i_v1455 = i_v1454 / 256 | 0x1000000 * i_v1454;       // 0x19a50
        int32_t i_v1456 = i_v1455 + i_v1450;                         // 0x19a5a
        uint32_t i_v1457 = i_v1456 ^ i_v1452;                        // 0x19a62
        int32_t i_v1458 = i_v1418 + i_v486 + i_v1435;                // 0x19a7e
        uint32_t i_v1459 = i_v1458 ^ i_v1408;                        // 0x19a8a
        int32_t i_v1460 = i_v1459 / 0x10000 | 0x10000 * i_v1459;     // 0x19a8c
        int32_t i_v1461 = i_v1460 + i_v1397;                         // 0x19a96
        uint32_t i_v1462 = i_v1461 ^ i_v1435;                        // 0x19a9e
        int32_t i_v1463 = i_v1462 / 0x1000 | 0x100000 * i_v1462;     // 0x19aa0
        int32_t i_v1464 = i_v1458 + i_v493 + i_v1463;                // 0x19aba
        uint32_t i_v1465 = i_v1464 ^ i_v1460;                        // 0x19ac6
        int32_t i_v1466 = i_v1465 / 256 | 0x1000000 * i_v1465;       // 0x19ac8
        int32_t i_v1467 = i_v1466 + i_v1461;                         // 0x19ad2
        uint32_t i_v1468 = i_v1467 ^ i_v1463;                        // 0x19ada
        int32_t i_v1469 = i_v1430 + i_v500 + i_v1399;                // 0x19af8
        uint32_t i_v1470 = i_v1469 ^ i_v1420;                        // 0x19b04
        int32_t i_v1471 = i_v1470 / 0x10000 | 0x10000 * i_v1470;     // 0x19b06
        int32_t i_v1472 = i_v1471 + i_v1409;                         // 0x19b10
        uint32_t i_v1473 = i_v1472 ^ i_v1399;                        // 0x19b1a
        int32_t i_v1474 = i_v1473 / 0x1000 | 0x100000 * i_v1473;     // 0x19b1c
        int32_t i_v1475 = i_v1469 + i_v507 + i_v1474;                // 0x19b3a
        uint32_t i_v1476 = i_v1475 ^ i_v1471;                        // 0x19b46
        int32_t i_v1477 = i_v1476 / 256 | 0x1000000 * i_v1476;       // 0x19b48
        int32_t i_v1478 = i_v1477 + i_v1472;                         // 0x19b52
        uint32_t i_v1479 = i_v1478 ^ i_v1474;                        // 0x19b5c
        int32_t i_v1480 = i_v6 ^ i_v22 ^ i_v1442 ^ i_v1467;          // 0x19b78
        int32_t i_v1481 = i_v8 ^ i_v24 ^ i_v1453 ^ i_v1478;          // 0x19b90
        int32_t i_v1482 = i_v10 ^ i_v26 ^ i_v1464 ^ i_v1445;         // 0x19ba8
        int32_t i_v1483 = i_v12 ^ i_v28 ^ i_v1475 ^ i_v1456;         // 0x19bc0
        int32_t i_v1484 = i_v14 ^ i_v22 ^
                          (i_v1479 / 128 | 0x2000000 * i_v1479) ^
                          i_v1455; // 0x19bd8
        int32_t i_v1485 = i_v16 ^ i_v24 ^
                          (i_v1446 / 128 | 0x2000000 * i_v1446) ^
                          i_v1466; // 0x19bee
        int32_t i_v1486 = i_v18 ^ i_v26 ^ i_v1477 ^
                          (i_v1457 / 128 | 0x2000000 * i_v1457); // 0x19c04
        int32_t i_v1487 = i_v20 ^ i_v28 ^ i_v1444 ^
                          (i_v1468 / 128 | 0x2000000 * i_v1468); // 0x19c1a
        i_v33 = i_v1480;
        i_v34 = i_v1481;
        i_v35 = i_v1482;
        i_v36 = i_v1483;
        i_v37 = i_v1484;
        i_v38 = i_v1485;
        i_v39 = i_v1486;
        i_v40 = i_v1487;
        i_v41 = i_v52;
        i_v42 = i_v53;
        i_v43 = 0;
        i_v44 = i_v69;
        while (i_v51 != 0) {
            int32_t i_v1488 = i_v1480;
            int32_t i_v1489 = i_v1481;
            int32_t i_v1490 = i_v1482;
            int32_t i_v1491 = i_v1483;
            int32_t i_v1492 = i_v1484;
            int32_t i_v1493 = i_v1485;
            int32_t i_v1494 = i_v1486;
            int32_t i_v1495 = i_v1487;
            int32_t i_v1496 = i_v52;
            int32_t i_v1497 = i_v53;
            int32_t i_v1498 = 0; // 0x162b8
            i_v45 = i_v51;
            i_v46 = 64 - i_v1498;
            i_v47 = i_v46 == i_v45 | i_v46 < i_v45 ? i_v46 : i_v45;
            p_v48 =
                memcpy((int32_t *)(i_v1498 + i_a1), (int32_t *)i_v50, i_v47);
            i_v49 = i_v47 + i_v1498;
            i_v50 += i_v47;
            i_v51 = i_v45 - i_v47;
            while (i_v49 != 64) {
                // 0x19c26
                if (i_v51 == 0) {
                    // 0x19c26
                    i_v33 = i_v1488;
                    i_v34 = i_v1489;
                    i_v35 = i_v1490;
                    i_v36 = i_v1491;
                    i_v37 = i_v1492;
                    i_v38 = i_v1493;
                    i_v39 = i_v1494;
                    i_v40 = i_v1495;
                    i_v41 = i_v1496;
                    i_v42 = i_v1497;
                    i_v43 = i_v49;
                    i_v44 = (int32_t)p_v48;
                    goto lab_0x19c2e;
                }
                i_v45 = i_v51;
                i_v46 = 64 - i_v49;
                i_v47 = i_v46 == i_v45 | i_v46 < i_v45 ? i_v46 : i_v45;
                p_v48 =
                    memcpy((int32_t *)(i_v49 + i_a1), (int32_t *)i_v50, i_v47);
                i_v49 += i_v47;
                i_v50 += i_v47;
                i_v51 = i_v45 - i_v47;
            }
            // 0x163de
            i_v52 = i_v1496 + 512;
            i_v53 = i_v1497 + (int32_t)(i_v52 >= 511 != i_v52 != 511);
            i_v54 = sph_dec32be_aligned(i_a1);
            i_v55 = sph_dec32be_aligned(i_a1 + 4);
            i_v56 = sph_dec32be_aligned(i_a1 + 8);
            i_v57 = sph_dec32be_aligned(i_a1 + 12);
            i_v58 = sph_dec32be_aligned(i_a1 + 16);
            i_v59 = sph_dec32be_aligned(i_a1 + 20);
            i_v60 = sph_dec32be_aligned(i_a1 + 24);
            i_v61 = sph_dec32be_aligned(i_a1 + 28);
            i_v62 = sph_dec32be_aligned(i_a1 + 32);
            i_v63 = sph_dec32be_aligned(i_a1 + 36);
            i_v64 = sph_dec32be_aligned(i_a1 + 40);
            i_v65 = sph_dec32be_aligned(i_a1 + 44);
            i_v66 = sph_dec32be_aligned(i_a1 + 48);
            i_v67 = sph_dec32be_aligned(i_a1 + 52);
            i_v68 = sph_dec32be_aligned(i_a1 + 56);
            i_v69 = sph_dec32be_aligned(i_a1 + 60);
            i_v70 = i_v54 ^ -0x7a5cf72d;
            i_v71 = i_v1488 + i_v1492 + i_v70;
            i_v72 = i_v52 ^ -0x5bf6c7de ^ i_v71;
            i_v73 = i_v72 / 0x10000 | 0x10000 * i_v72;
            i_v74 = i_v73 + (i_v22 ^ 0x243f6a88);
            i_v75 = i_v74 ^ i_v1492;
            i_v76 = i_v75 / 0x1000 | 0x100000 * i_v75;
            i_v77 = i_v55 ^ 0x243f6a88;
            i_v78 = i_v77 + i_v71 + i_v76;
            i_v79 = i_v78 ^ i_v73;
            i_v80 = i_v79 / 256 | 0x1000000 * i_v79;
            i_v81 = i_v80 + i_v74;
            i_v82 = i_v81 ^ i_v76;
            i_v83 = i_v82 / 128 | 0x2000000 * i_v82;
            i_v84 = i_v56 ^ 0x3707344;
            i_v85 = i_v1489 + i_v1493 + i_v84;
            i_v86 = i_v52 ^ 0x299f31d0 ^ i_v85;
            i_v87 = i_v86 / 0x10000 | 0x10000 * i_v86;
            i_v88 = i_v87 + (i_v24 ^ -0x7a5cf72d);
            i_v89 = i_v88 ^ i_v1493;
            i_v90 = i_v89 / 0x1000 | 0x100000 * i_v89;
            i_v91 = i_v57 ^ ((int32_t)&p_g248 | 0x13190000);
            i_v92 = i_v91 + i_v85 + i_v90;
            i_v93 = i_v92 ^ i_v87;
            i_v94 = i_v93 / 256 | 0x1000000 * i_v93;
            i_v95 = i_v94 + i_v88;
            i_v96 = i_v95 ^ i_v90;
            i_v97 = i_v96 / 128 | 0x2000000 * i_v96;
            i_v98 = i_v58 ^ 0x299f31d0;
            i_v99 = i_v1490 + i_v1494 + i_v98;
            i_v100 = i_v53 ^ 0x82efa98 ^ i_v99;
            i_v101 = i_v100 / 0x10000 | 0x10000 * i_v100;
            i_v102 = i_v101 + (i_v26 ^ ((int32_t)&p_g248 | 0x13190000));
            i_v103 = i_v102 ^ i_v1494;
            i_v104 = i_v103 / 0x1000 | 0x100000 * i_v103;
            i_v105 = i_v59 ^ -0x5bf6c7de;
            i_v106 = i_v105 + i_v99 + i_v104;
            i_v107 = i_v106 ^ i_v101;
            i_v108 = i_v107 / 256 | 0x1000000 * i_v107;
            i_v109 = i_v108 + i_v102;
            i_v110 = i_v109 ^ i_v104;
            i_v111 = i_v110 / 128 | 0x2000000 * i_v110;
            i_v112 = i_v60 ^ -0x13b19377;
            i_v113 = i_v1491 + i_v1495 + i_v112;
            i_v114 = i_v53 ^ -0x13b19377 ^ i_v113;
            i_v115 = i_v114 / 0x10000 | 0x10000 * i_v114;
            i_v116 = i_v115 + (i_v28 ^ 0x3707344);
            i_v117 = i_v116 ^ i_v1495;
            i_v118 = i_v117 / 0x1000 | 0x100000 * i_v117;
            i_v119 = i_v61 ^ 0x82efa98;
            i_v120 = i_v119 + i_v113 + i_v118;
            i_v121 = i_v120 ^ i_v115;
            i_v122 = i_v121 / 256 | 0x1000000 * i_v121;
            i_v123 = i_v122 + i_v116;
            i_v124 = i_v123 ^ i_v118;
            i_v125 = i_v124 / 128 | 0x2000000 * i_v124;
            i_v126 = i_v62 ^ 0x38d01377;
            i_v127 = i_v78 + i_v126 + i_v97;
            i_v128 = i_v127 ^ i_v122;
            i_v129 = i_v128 / 0x10000 | 0x10000 * i_v128;
            i_v130 = i_v129 + i_v109;
            i_v131 = i_v130 ^ i_v97;
            i_v132 = i_v131 / 0x1000 | 0x100000 * i_v131;
            i_v133 = i_v63 ^ 0x452821e6;
            i_v134 = i_v127 + i_v133 + i_v132;
            i_v135 = i_v134 ^ i_v129;
            i_v136 = i_v135 / 256 | 0x1000000 * i_v135;
            i_v137 = i_v136 + i_v130;
            i_v138 = i_v137 ^ i_v132;
            i_v139 = i_v138 / 128 | 0x2000000 * i_v138;
            i_v140 = i_v64 ^ 0x34e90c6c;
            i_v141 = i_v92 + i_v140 + i_v111;
            i_v142 = i_v141 ^ i_v80;
            i_v143 = i_v142 / 0x10000 | 0x10000 * i_v142;
            i_v144 = i_v143 + i_v123;
            i_v145 = i_v144 ^ i_v111;
            i_v146 = i_v145 / 0x1000 | 0x100000 * i_v145;
            i_v147 = i_v65 ^ -0x41ab9931;
            i_v148 = i_v141 + i_v147 + i_v146;
            i_v149 = i_v148 ^ i_v143;
            i_v150 = i_v149 / 256 | 0x1000000 * i_v149;
            i_v151 = i_v150 + i_v144;
            i_v152 = i_v151 ^ i_v146;
            i_v153 = i_v152 / 128 | 0x2000000 * i_v152;
            i_v154 = i_v66 ^ -0x3683af23;
            i_v155 = i_v106 + i_v154 + i_v125;
            i_v156 = i_v155 ^ i_v94;
            i_v157 = i_v156 / 0x10000 | 0x10000 * i_v156;
            i_v158 = i_v157 + i_v81;
            i_v159 = i_v158 ^ i_v125;
            i_v160 = i_v159 / 0x1000 | 0x100000 * i_v159;
            i_v161 = i_v67 ^ -0x3f53d649;
            i_v162 = i_v155 + i_v161 + i_v160;
            i_v163 = i_v162 ^ i_v157;
            i_v164 = i_v163 / 256 | 0x1000000 * i_v163;
            i_v165 = i_v164 + i_v158;
            i_v166 = i_v165 ^ i_v160;
            i_v167 = i_v166 / 128 | 0x2000000 * i_v166;
            i_v168 = i_v68 ^ -0x4ab8f6e9;
            i_v169 = i_v120 + i_v168 + i_v83;
            i_v170 = i_v169 ^ i_v108;
            i_v171 = i_v170 / 0x10000 | 0x10000 * i_v170;
            i_v172 = i_v171 + i_v95;
            i_v173 = i_v172 ^ i_v83;
            i_v174 = i_v173 / 0x1000 | 0x100000 * i_v173;
            i_v175 = i_v69 ^ 0x3f84d5b5;
            i_v176 = i_v169 + i_v175 + i_v174;
            i_v177 = i_v176 ^ i_v171;
            i_v178 = i_v177 / 256 | 0x1000000 * i_v177;
            i_v179 = i_v178 + i_v172;
            i_v180 = i_v179 ^ i_v174;
            i_v181 = i_v180 / 128 | 0x2000000 * i_v180;
            i_v182 = i_v68 ^ -0x41ab9931;
            i_v183 = i_v134 + i_v182 + i_v181;
            i_v184 = i_v183 ^ i_v150;
            i_v185 = i_v184 / 0x10000 | 0x10000 * i_v184;
            i_v186 = i_v185 + i_v165;
            i_v187 = i_v186 ^ i_v181;
            i_v188 = i_v187 / 0x1000 | 0x100000 * i_v187;
            i_v189 = i_v64 ^ 0x3f84d5b5;
            i_v190 = i_v183 + i_v189 + i_v188;
            i_v191 = i_v190 ^ i_v185;
            i_v192 = i_v191 / 256 | 0x1000000 * i_v191;
            i_v193 = i_v192 + i_v186;
            i_v194 = i_v193 ^ i_v188;
            i_v195 = i_v194 / 128 | 0x2000000 * i_v194;
            i_v196 = i_v58 ^ 0x452821e6;
            i_v197 = i_v148 + i_v196 + i_v139;
            i_v198 = i_v197 ^ i_v164;
            i_v199 = i_v198 / 0x10000 | 0x10000 * i_v198;
            i_v200 = i_v199 + i_v179;
            i_v201 = i_v200 ^ i_v139;
            i_v202 = i_v201 / 0x1000 | 0x100000 * i_v201;
            i_v203 = i_v62 ^ -0x5bf6c7de;
            i_v204 = i_v197 + i_v203 + i_v202;
            i_v205 = i_v204 ^ i_v199;
            i_v206 = i_v205 / 256 | 0x1000000 * i_v205;
            i_v207 = i_v206 + i_v200;
            i_v208 = i_v207 ^ i_v202;
            i_v209 = i_v208 / 128 | 0x2000000 * i_v208;
            i_v210 = i_v63 ^ -0x4ab8f6e9;
            i_v211 = i_v162 + i_v210 + i_v153;
            i_v212 = i_v211 ^ i_v178;
            i_v213 = i_v212 / 0x10000 | 0x10000 * i_v212;
            i_v214 = i_v213 + i_v137;
            i_v215 = i_v214 ^ i_v153;
            i_v216 = i_v215 / 0x1000 | 0x100000 * i_v215;
            i_v217 = i_v69 ^ 0x38d01377;
            i_v218 = i_v211 + i_v217 + i_v216;
            i_v219 = i_v218 ^ i_v213;
            i_v220 = i_v219 / 256 | 0x1000000 * i_v219;
            i_v221 = i_v220 + i_v214;
            i_v222 = i_v221 ^ i_v216;
            i_v223 = i_v222 / 128 | 0x2000000 * i_v222;
            i_v224 = i_v67 ^ 0x82efa98;
            i_v225 = i_v176 + i_v224 + i_v167;
            i_v226 = i_v225 ^ i_v136;
            i_v227 = i_v226 / 0x10000 | 0x10000 * i_v226;
            i_v228 = i_v227 + i_v151;
            i_v229 = i_v228 ^ i_v167;
            i_v230 = i_v229 / 0x1000 | 0x100000 * i_v229;
            i_v231 = i_v60 ^ -0x3683af23;
            i_v232 = i_v225 + i_v231 + i_v230;
            i_v233 = i_v232 ^ i_v227;
            i_v234 = i_v233 / 256 | 0x1000000 * i_v233;
            i_v235 = i_v234 + i_v228;
            i_v236 = i_v235 ^ i_v230;
            i_v237 = i_v236 / 128 | 0x2000000 * i_v236;
            i_v238 = i_v55 ^ -0x3f53d649;
            i_v239 = i_v190 + i_v238 + i_v209;
            i_v240 = i_v239 ^ i_v234;
            i_v241 = i_v240 / 0x10000 | 0x10000 * i_v240;
            i_v242 = i_v241 + i_v221;
            i_v243 = i_v242 ^ i_v209;
            i_v244 = i_v243 / 0x1000 | 0x100000 * i_v243;
            i_v245 = i_v66 ^ -0x7a5cf72d;
            i_v246 = i_v239 + i_v245 + i_v244;
            i_v247 = i_v246 ^ i_v241;
            i_v248 = i_v247 / 256 | 0x1000000 * i_v247;
            i_v249 = i_v248 + i_v242;
            i_v250 = i_v249 ^ i_v244;
            i_v251 = i_v250 / 128 | 0x2000000 * i_v250;
            i_v252 = i_v54 ^ ((int32_t)&p_g248 | 0x13190000);
            i_v253 = i_v204 + i_v252 + i_v223;
            i_v254 = i_v253 ^ i_v192;
            i_v255 = i_v254 / 0x10000 | 0x10000 * i_v254;
            i_v256 = i_v255 + i_v235;
            i_v257 = i_v256 ^ i_v223;
            i_v258 = i_v257 / 0x1000 | 0x100000 * i_v257;
            i_v259 = i_v56 ^ 0x243f6a88;
            i_v260 = i_v253 + i_v259 + i_v258;
            i_v261 = i_v260 ^ i_v255;
            i_v262 = i_v261 / 256 | 0x1000000 * i_v261;
            i_v263 = i_v262 + i_v256;
            i_v264 = i_v263 ^ i_v258;
            i_v265 = i_v264 / 128 | 0x2000000 * i_v264;
            i_v266 = i_v65 ^ -0x13b19377;
            i_v267 = i_v218 + i_v266 + i_v237;
            i_v268 = i_v267 ^ i_v206;
            i_v269 = i_v268 / 0x10000 | 0x10000 * i_v268;
            i_v270 = i_v269 + i_v193;
            i_v271 = i_v270 ^ i_v237;
            i_v272 = i_v271 / 0x1000 | 0x100000 * i_v271;
            i_v273 = i_v61 ^ 0x34e90c6c;
            i_v274 = i_v267 + i_v273 + i_v272;
            i_v275 = i_v274 ^ i_v269;
            i_v276 = i_v275 / 256 | 0x1000000 * i_v275;
            i_v277 = i_v276 + i_v270;
            i_v278 = i_v277 ^ i_v272;
            i_v279 = i_v278 / 128 | 0x2000000 * i_v278;
            i_v280 = i_v59 ^ 0x3707344;
            i_v281 = i_v232 + i_v280 + i_v195;
            i_v282 = i_v281 ^ i_v220;
            i_v283 = i_v282 / 0x10000 | 0x10000 * i_v282;
            i_v284 = i_v283 + i_v207;
            i_v285 = i_v284 ^ i_v195;
            i_v286 = i_v285 / 0x1000 | 0x100000 * i_v285;
            i_v287 = i_v57 ^ 0x299f31d0;
            i_v288 = i_v281 + i_v287 + i_v286;
            i_v289 = i_v288 ^ i_v283;
            i_v290 = i_v289 / 256 | 0x1000000 * i_v289;
            i_v291 = i_v290 + i_v284;
            i_v292 = i_v291 ^ i_v286;
            i_v293 = i_v292 / 128 | 0x2000000 * i_v292;
            i_v294 = i_v65 ^ 0x452821e6;
            i_v295 = i_v246 + i_v294 + i_v293;
            i_v296 = i_v295 ^ i_v262;
            i_v297 = i_v296 / 0x10000 | 0x10000 * i_v296;
            i_v298 = i_v297 + i_v277;
            i_v299 = i_v298 ^ i_v293;
            i_v300 = i_v299 / 0x1000 | 0x100000 * i_v299;
            i_v301 = i_v62 ^ 0x34e90c6c;
            i_v302 = i_v295 + i_v301 + i_v300;
            i_v303 = i_v302 ^ i_v297;
            i_v304 = i_v303 / 256 | 0x1000000 * i_v303;
            i_v305 = i_v304 + i_v298;
            i_v306 = i_v305 ^ i_v300;
            i_v307 = i_v306 / 128 | 0x2000000 * i_v306;
            i_v308 = i_v66 ^ 0x243f6a88;
            i_v309 = i_v260 + i_v308 + i_v251;
            i_v310 = i_v309 ^ i_v276;
            i_v311 = i_v310 / 0x10000 | 0x10000 * i_v310;
            i_v312 = i_v311 + i_v291;
            i_v313 = i_v312 ^ i_v251;
            i_v314 = i_v313 / 0x1000 | 0x100000 * i_v313;
            i_v315 = i_v54 ^ -0x3f53d649;
            i_v316 = i_v309 + i_v315 + i_v314;
            i_v317 = i_v316 ^ i_v311;
            i_v318 = i_v317 / 256 | 0x1000000 * i_v317;
            i_v319 = i_v318 + i_v312;
            i_v320 = i_v319 ^ i_v314;
            i_v321 = i_v320 / 128 | 0x2000000 * i_v320;
            i_v322 = i_v59 ^ ((int32_t)&p_g248 | 0x13190000);
            i_v323 = i_v274 + i_v322 + i_v265;
            i_v324 = i_v323 ^ i_v290;
            i_v325 = i_v324 / 0x10000 | 0x10000 * i_v324;
            i_v326 = i_v325 + i_v249;
            i_v327 = i_v326 ^ i_v265;
            i_v328 = i_v327 / 0x1000 | 0x100000 * i_v327;
            i_v329 = i_v56 ^ 0x299f31d0;
            i_v330 = i_v323 + i_v329 + i_v328;
            i_v331 = i_v330 ^ i_v325;
            i_v332 = i_v331 / 256 | 0x1000000 * i_v331;
            i_v333 = i_v332 + i_v326;
            i_v334 = i_v333 ^ i_v328;
            i_v335 = i_v334 / 128 | 0x2000000 * i_v334;
            i_v336 = i_v69 ^ -0x3683af23;
            i_v337 = i_v288 + i_v336 + i_v279;
            i_v338 = i_v337 ^ i_v248;
            i_v339 = i_v338 / 0x10000 | 0x10000 * i_v338;
            i_v340 = i_v339 + i_v263;
            i_v341 = i_v340 ^ i_v279;
            i_v342 = i_v341 / 0x1000 | 0x100000 * i_v341;
            i_v343 = i_v67 ^ -0x4ab8f6e9;
            i_v344 = i_v337 + i_v343 + i_v342;
            i_v345 = i_v344 ^ i_v339;
            i_v346 = i_v345 / 256 | 0x1000000 * i_v345;
            i_v347 = i_v346 + i_v340;
            i_v348 = i_v347 ^ i_v342;
            i_v349 = i_v348 / 128 | 0x2000000 * i_v348;
            i_v350 = i_v302 + i_v189 + i_v321;
            i_v351 = i_v350 ^ i_v346;
            i_v352 = i_v351 / 0x10000 | 0x10000 * i_v351;
            i_v353 = i_v352 + i_v333;
            i_v354 = i_v353 ^ i_v321;
            i_v355 = i_v354 / 0x1000 | 0x100000 * i_v354;
            i_v356 = i_v350 + i_v182 + i_v355;
            i_v357 = i_v356 ^ i_v352;
            i_v358 = i_v357 / 256 | 0x1000000 * i_v357;
            i_v359 = i_v358 + i_v353;
            i_v360 = i_v359 ^ i_v355;
            i_v361 = i_v360 / 128 | 0x2000000 * i_v360;
            i_v362 = i_v57 ^ 0x82efa98;
            i_v363 = i_v316 + i_v362 + i_v335;
            i_v364 = i_v363 ^ i_v304;
            i_v365 = i_v364 / 0x10000 | 0x10000 * i_v364;
            i_v366 = i_v365 + i_v347;
            i_v367 = i_v366 ^ i_v335;
            i_v368 = i_v367 / 0x1000 | 0x100000 * i_v367;
            i_v369 = i_v60 ^ 0x3707344;
            i_v370 = i_v363 + i_v369 + i_v368;
            i_v371 = i_v370 ^ i_v365;
            i_v372 = i_v371 / 256 | 0x1000000 * i_v371;
            i_v373 = i_v372 + i_v366;
            i_v374 = i_v373 ^ i_v368;
            i_v375 = i_v374 / 128 | 0x2000000 * i_v374;
            i_v376 = i_v61 ^ -0x7a5cf72d;
            i_v377 = i_v330 + i_v376 + i_v349;
            i_v378 = i_v377 ^ i_v318;
            i_v379 = i_v378 / 0x10000 | 0x10000 * i_v378;
            i_v380 = i_v379 + i_v305;
            i_v381 = i_v380 ^ i_v349;
            i_v382 = i_v381 / 0x1000 | 0x100000 * i_v381;
            i_v383 = i_v55 ^ -0x13b19377;
            i_v384 = i_v377 + i_v383 + i_v382;
            i_v385 = i_v384 ^ i_v379;
            i_v386 = i_v385 / 256 | 0x1000000 * i_v385;
            i_v387 = i_v386 + i_v380;
            i_v388 = i_v387 ^ i_v382;
            i_v389 = i_v388 / 128 | 0x2000000 * i_v388;
            i_v390 = i_v63 ^ -0x5bf6c7de;
            i_v391 = i_v344 + i_v390 + i_v307;
            i_v392 = i_v391 ^ i_v332;
            i_v393 = i_v392 / 0x10000 | 0x10000 * i_v392;
            i_v394 = i_v393 + i_v319;
            i_v395 = i_v394 ^ i_v307;
            i_v396 = i_v395 / 0x1000 | 0x100000 * i_v395;
            i_v397 = i_v58 ^ 0x38d01377;
            i_v398 = i_v391 + i_v397 + i_v396;
            i_v399 = i_v398 ^ i_v393;
            i_v400 = i_v399 / 256 | 0x1000000 * i_v399;
            i_v401 = i_v400 + i_v394;
            i_v402 = i_v401 ^ i_v396;
            i_v403 = i_v402 / 128 | 0x2000000 * i_v402;
            i_v404 = i_v61 ^ 0x38d01377;
            i_v405 = i_v356 + i_v404 + i_v403;
            i_v406 = i_v405 ^ i_v372;
            i_v407 = i_v406 / 0x10000 | 0x10000 * i_v406;
            i_v408 = i_v407 + i_v387;
            i_v409 = i_v408 ^ i_v403;
            i_v410 = i_v409 / 0x1000 | 0x100000 * i_v409;
            i_v411 = i_v63 ^ -0x13b19377;
            i_v412 = i_v405 + i_v411 + i_v410;
            i_v413 = i_v412 ^ i_v407;
            i_v414 = i_v413 / 256 | 0x1000000 * i_v413;
            i_v415 = i_v414 + i_v408;
            i_v416 = i_v415 ^ i_v410;
            i_v417 = i_v416 / 128 | 0x2000000 * i_v416;
            i_v418 = i_v57 ^ -0x7a5cf72d;
            i_v419 = i_v370 + i_v418 + i_v361;
            i_v420 = i_v419 ^ i_v386;
            i_v421 = i_v420 / 0x10000 | 0x10000 * i_v420;
            i_v422 = i_v421 + i_v401;
            i_v423 = i_v422 ^ i_v361;
            i_v424 = i_v423 / 0x1000 | 0x100000 * i_v423;
            i_v425 = i_v55 ^ 0x3707344;
            i_v426 = i_v419 + i_v425 + i_v424;
            i_v427 = i_v426 ^ i_v421;
            i_v428 = i_v427 / 256 | 0x1000000 * i_v427;
            i_v429 = i_v428 + i_v422;
            i_v430 = i_v429 ^ i_v424;
            i_v431 = i_v430 / 128 | 0x2000000 * i_v430;
            i_v432 = i_v384 + i_v161 + i_v375;
            i_v433 = i_v432 ^ i_v400;
            i_v434 = i_v433 / 0x10000 | 0x10000 * i_v433;
            i_v435 = i_v434 + i_v359;
            i_v436 = i_v435 ^ i_v375;
            i_v437 = i_v436 / 0x1000 | 0x100000 * i_v436;
            i_v438 = i_v432 + i_v154 + i_v437;
            i_v439 = i_v438 ^ i_v434;
            i_v440 = i_v439 / 256 | 0x1000000 * i_v439;
            i_v441 = i_v440 + i_v435;
            i_v442 = i_v441 ^ i_v437;
            i_v443 = i_v442 / 128 | 0x2000000 * i_v442;
            i_v444 = i_v65 ^ 0x3f84d5b5;
            i_v445 = i_v398 + i_v444 + i_v389;
            i_v446 = i_v445 ^ i_v358;
            i_v447 = i_v446 / 0x10000 | 0x10000 * i_v446;
            i_v448 = i_v447 + i_v373;
            i_v449 = i_v448 ^ i_v389;
            i_v450 = i_v449 / 0x1000 | 0x100000 * i_v449;
            i_v451 = i_v68 ^ 0x34e90c6c;
            i_v452 = i_v445 + i_v451 + i_v450;
            i_v453 = i_v452 ^ i_v447;
            i_v454 = i_v453 / 256 | 0x1000000 * i_v453;
            i_v455 = i_v454 + i_v448;
            i_v456 = i_v455 ^ i_v450;
            i_v457 = i_v456 / 128 | 0x2000000 * i_v456;
            i_v458 = i_v56 ^ 0x82efa98;
            i_v459 = i_v412 + i_v458 + i_v431;
            i_v460 = i_v459 ^ i_v454;
            i_v461 = i_v460 / 0x10000 | 0x10000 * i_v460;
            i_v462 = i_v461 + i_v441;
            i_v463 = i_v462 ^ i_v431;
            i_v464 = i_v463 / 0x1000 | 0x100000 * i_v463;
            i_v465 = i_v60 ^ ((int32_t)&p_g248 | 0x13190000);
            i_v466 = i_v459 + i_v465 + i_v464;
            i_v467 = i_v466 ^ i_v461;
            i_v468 = i_v467 / 256 | 0x1000000 * i_v467;
            i_v469 = i_v468 + i_v462;
            i_v470 = i_v469 ^ i_v464;
            i_v471 = i_v470 / 128 | 0x2000000 * i_v470;
            i_v472 = i_v59 ^ -0x41ab9931;
            i_v473 = i_v426 + i_v472 + i_v443;
            i_v474 = i_v473 ^ i_v414;
            i_v475 = i_v474 / 0x10000 | 0x10000 * i_v474;
            i_v476 = i_v475 + i_v455;
            i_v477 = i_v476 ^ i_v443;
            i_v478 = i_v477 / 0x1000 | 0x100000 * i_v477;
            i_v479 = i_v64 ^ 0x299f31d0;
            i_v480 = i_v473 + i_v479 + i_v478;
            i_v481 = i_v480 ^ i_v475;
            i_v482 = i_v481 / 256 | 0x1000000 * i_v481;
            i_v483 = i_v482 + i_v476;
            i_v484 = i_v483 ^ i_v478;
            i_v485 = i_v484 / 128 | 0x2000000 * i_v484;
            i_v486 = i_v58 ^ 0x243f6a88;
            i_v487 = i_v438 + i_v486 + i_v457;
            i_v488 = i_v487 ^ i_v428;
            i_v489 = i_v488 / 0x10000 | 0x10000 * i_v488;
            i_v490 = i_v489 + i_v415;
            i_v491 = i_v490 ^ i_v457;
            i_v492 = i_v491 / 0x1000 | 0x100000 * i_v491;
            i_v493 = i_v54 ^ -0x5bf6c7de;
            i_v494 = i_v487 + i_v493 + i_v492;
            i_v495 = i_v494 ^ i_v489;
            i_v496 = i_v495 / 256 | 0x1000000 * i_v495;
            i_v497 = i_v496 + i_v490;
            i_v498 = i_v497 ^ i_v492;
            i_v499 = i_v498 / 128 | 0x2000000 * i_v498;
            i_v500 = i_v69 ^ 0x452821e6;
            i_v501 = i_v452 + i_v500 + i_v417;
            i_v502 = i_v501 ^ i_v440;
            i_v503 = i_v502 / 0x10000 | 0x10000 * i_v502;
            i_v504 = i_v503 + i_v429;
            i_v505 = i_v504 ^ i_v417;
            i_v506 = i_v505 / 0x1000 | 0x100000 * i_v505;
            i_v507 = i_v62 ^ -0x4ab8f6e9;
            i_v508 = i_v501 + i_v507 + i_v506;
            i_v509 = i_v508 ^ i_v503;
            i_v510 = i_v509 / 256 | 0x1000000 * i_v509;
            i_v511 = i_v510 + i_v504;
            i_v512 = i_v511 ^ i_v506;
            i_v513 = i_v512 / 128 | 0x2000000 * i_v512;
            i_v514 = i_v466 + (i_v63 ^ 0x243f6a88) + i_v513;
            i_v515 = i_v514 ^ i_v482;
            i_v516 = i_v515 / 0x10000 | 0x10000 * i_v515;
            i_v517 = i_v516 + i_v497;
            i_v518 = i_v517 ^ i_v513;
            i_v519 = i_v518 / 0x1000 | 0x100000 * i_v518;
            i_v520 = i_v514 + (i_v54 ^ 0x38d01377) + i_v519;
            i_v521 = i_v520 ^ i_v516;
            i_v522 = i_v521 / 256 | 0x1000000 * i_v521;
            i_v523 = i_v522 + i_v517;
            i_v524 = i_v523 ^ i_v519;
            i_v525 = i_v524 / 128 | 0x2000000 * i_v524;
            i_v526 = i_v59 ^ -0x13b19377;
            i_v527 = i_v480 + i_v526 + i_v471;
            i_v528 = i_v527 ^ i_v496;
            i_v529 = i_v528 / 0x10000 | 0x10000 * i_v528;
            i_v530 = i_v529 + i_v511;
            i_v531 = i_v530 ^ i_v471;
            i_v532 = i_v531 / 0x1000 | 0x100000 * i_v531;
            i_v533 = i_v61 ^ 0x299f31d0;
            i_v534 = i_v527 + i_v533 + i_v532;
            i_v535 = i_v534 ^ i_v529;
            i_v536 = i_v535 / 256 | 0x1000000 * i_v535;
            i_v537 = i_v536 + i_v530;
            i_v538 = i_v537 ^ i_v532;
            i_v539 = i_v538 / 128 | 0x2000000 * i_v538;
            i_v540 = i_v494 + (i_v56 ^ -0x5bf6c7de) + i_v485;
            i_v541 = i_v540 ^ i_v510;
            i_v542 = i_v541 / 0x10000 | 0x10000 * i_v541;
            i_v543 = i_v542 + i_v469;
            i_v544 = i_v543 ^ i_v485;
            i_v545 = i_v544 / 0x1000 | 0x100000 * i_v544;
            i_v546 =
                i_v540 + (i_v58 ^ ((int32_t)&p_g248 | 0x13190000)) + i_v545;
            i_v547 = i_v546 ^ i_v542;
            i_v548 = i_v547 / 256 | 0x1000000 * i_v547;
            i_v549 = i_v548 + i_v543;
            i_v550 = i_v549 ^ i_v545;
            i_v551 = i_v550 / 128 | 0x2000000 * i_v550;
            i_v552 = i_v508 + (i_v64 ^ -0x4ab8f6e9) + i_v499;
            i_v553 = i_v552 ^ i_v468;
            i_v554 = i_v553 / 0x10000 | 0x10000 * i_v553;
            i_v555 = i_v554 + i_v483;
            i_v556 = i_v555 ^ i_v499;
            i_v557 = i_v556 / 0x1000 | 0x100000 * i_v556;
            i_v558 = i_v552 + (i_v69 ^ -0x41ab9931) + i_v557;
            i_v559 = i_v558 ^ i_v554;
            i_v560 = i_v559 / 256 | 0x1000000 * i_v559;
            i_v561 = i_v560 + i_v555;
            i_v562 = i_v561 ^ i_v557;
            i_v563 = i_v562 / 128 | 0x2000000 * i_v562;
            i_v564 = i_v520 + (i_v68 ^ -0x7a5cf72d) + i_v539;
            i_v565 = i_v564 ^ i_v560;
            i_v566 = i_v565 / 0x10000 | 0x10000 * i_v565;
            i_v567 = i_v566 + i_v549;
            i_v568 = i_v567 ^ i_v539;
            i_v569 = i_v568 / 0x1000 | 0x100000 * i_v568;
            i_v570 = i_v564 + (i_v55 ^ 0x3f84d5b5) + i_v569;
            i_v571 = i_v570 ^ i_v566;
            i_v572 = i_v571 / 256 | 0x1000000 * i_v571;
            i_v573 = i_v572 + i_v567;
            i_v574 = i_v573 ^ i_v569;
            i_v575 = i_v574 / 128 | 0x2000000 * i_v574;
            i_v576 = i_v534 + (i_v65 ^ -0x3f53d649) + i_v551;
            i_v577 = i_v576 ^ i_v522;
            i_v578 = i_v577 / 0x10000 | 0x10000 * i_v577;
            i_v579 = i_v578 + i_v561;
            i_v580 = i_v579 ^ i_v551;
            i_v581 = i_v580 / 0x1000 | 0x100000 * i_v580;
            i_v582 = i_v576 + (i_v66 ^ 0x34e90c6c) + i_v581;
            i_v583 = i_v582 ^ i_v578;
            i_v584 = i_v583 / 256 | 0x1000000 * i_v583;
            i_v585 = i_v584 + i_v579;
            i_v586 = i_v585 ^ i_v581;
            i_v587 = i_v586 / 128 | 0x2000000 * i_v586;
            i_v588 = i_v60 ^ 0x452821e6;
            i_v589 = i_v546 + i_v588 + i_v563;
            i_v590 = i_v589 ^ i_v536;
            i_v591 = i_v590 / 0x10000 | 0x10000 * i_v590;
            i_v592 = i_v591 + i_v523;
            i_v593 = i_v592 ^ i_v563;
            i_v594 = i_v593 / 0x1000 | 0x100000 * i_v593;
            i_v595 = i_v62 ^ 0x82efa98;
            i_v596 = i_v589 + i_v595 + i_v594;
            i_v597 = i_v596 ^ i_v591;
            i_v598 = i_v597 / 256 | 0x1000000 * i_v597;
            i_v599 = i_v598 + i_v592;
            i_v600 = i_v599 ^ i_v594;
            i_v601 = i_v600 / 128 | 0x2000000 * i_v600;
            i_v602 = i_v558 + (i_v57 ^ -0x3683af23) + i_v525;
            i_v603 = i_v602 ^ i_v548;
            i_v604 = i_v603 / 0x10000 | 0x10000 * i_v603;
            i_v605 = i_v604 + i_v537;
            i_v606 = i_v605 ^ i_v525;
            i_v607 = i_v606 / 0x1000 | 0x100000 * i_v606;
            i_v608 = i_v602 + (i_v67 ^ 0x3707344) + i_v607;
            i_v609 = i_v608 ^ i_v604;
            i_v610 = i_v609 / 256 | 0x1000000 * i_v609;
            i_v611 = i_v610 + i_v605;
            i_v612 = i_v611 ^ i_v607;
            i_v613 = i_v612 / 128 | 0x2000000 * i_v612;
            i_v614 = i_v56 ^ -0x3f53d649;
            i_v615 = i_v570 + i_v614 + i_v613;
            i_v616 = i_v615 ^ i_v584;
            i_v617 = i_v616 / 0x10000 | 0x10000 * i_v616;
            i_v618 = i_v617 + i_v599;
            i_v619 = i_v618 ^ i_v613;
            i_v620 = i_v619 / 0x1000 | 0x100000 * i_v619;
            i_v621 = i_v66 ^ ((int32_t)&p_g248 | 0x13190000);
            i_v622 = i_v615 + i_v621 + i_v620;
            i_v623 = i_v622 ^ i_v617;
            i_v624 = i_v623 / 256 | 0x1000000 * i_v623;
            i_v625 = i_v624 + i_v618;
            i_v626 = i_v625 ^ i_v620;
            i_v627 = i_v626 / 128 | 0x2000000 * i_v626;
            i_v628 = i_v582 + (i_v60 ^ -0x41ab9931) + i_v575;
            i_v629 = i_v628 ^ i_v598;
            i_v630 = i_v629 / 0x10000 | 0x10000 * i_v629;
            i_v631 = i_v630 + i_v611;
            i_v632 = i_v631 ^ i_v575;
            i_v633 = i_v632 / 0x1000 | 0x100000 * i_v632;
            i_v634 = i_v628 + (i_v64 ^ 0x82efa98) + i_v633;
            i_v635 = i_v634 ^ i_v630;
            i_v636 = i_v635 / 256 | 0x1000000 * i_v635;
            i_v637 = i_v636 + i_v631;
            i_v638 = i_v637 ^ i_v633;
            i_v639 = i_v638 / 128 | 0x2000000 * i_v638;
            i_v640 = i_v596 + (i_v54 ^ 0x34e90c6c) + i_v587;
            i_v641 = i_v640 ^ i_v610;
            i_v642 = i_v641 / 0x10000 | 0x10000 * i_v641;
            i_v643 = i_v642 + i_v573;
            i_v644 = i_v643 ^ i_v587;
            i_v645 = i_v644 / 0x1000 | 0x100000 * i_v644;
            i_v646 = i_v640 + (i_v65 ^ 0x243f6a88) + i_v645;
            i_v647 = i_v646 ^ i_v642;
            i_v648 = i_v647 / 256 | 0x1000000 * i_v647;
            i_v649 = i_v648 + i_v643;
            i_v650 = i_v649 ^ i_v645;
            i_v651 = i_v650 / 128 | 0x2000000 * i_v650;
            i_v652 = i_v608 + (i_v62 ^ 0x3707344) + i_v601;
            i_v653 = i_v652 ^ i_v572;
            i_v654 = i_v653 / 0x10000 | 0x10000 * i_v653;
            i_v655 = i_v654 + i_v585;
            i_v656 = i_v655 ^ i_v601;
            i_v657 = i_v656 / 0x1000 | 0x100000 * i_v656;
            i_v658 = i_v652 + (i_v57 ^ 0x452821e6) + i_v657;
            i_v659 = i_v658 ^ i_v654;
            i_v660 = i_v659 / 256 | 0x1000000 * i_v659;
            i_v661 = i_v660 + i_v655;
            i_v662 = i_v661 ^ i_v657;
            i_v663 = i_v662 / 128 | 0x2000000 * i_v662;
            i_v664 = i_v622 + (i_v58 ^ -0x3683af23) + i_v639;
            i_v665 = i_v664 ^ i_v660;
            i_v666 = i_v665 / 0x10000 | 0x10000 * i_v665;
            i_v667 = i_v666 + i_v649;
            i_v668 = i_v667 ^ i_v639;
            i_v669 = i_v668 / 0x1000 | 0x100000 * i_v668;
            i_v670 = i_v664 + (i_v67 ^ -0x5bf6c7de) + i_v669;
            i_v671 = i_v670 ^ i_v666;
            i_v672 = i_v671 / 256 | 0x1000000 * i_v671;
            i_v673 = i_v672 + i_v667;
            i_v674 = i_v673 ^ i_v669;
            i_v675 = i_v674 / 128 | 0x2000000 * i_v674;
            i_v676 = i_v634 + i_v533 + i_v651;
            i_v677 = i_v676 ^ i_v624;
            i_v678 = i_v677 / 0x10000 | 0x10000 * i_v677;
            i_v679 = i_v678 + i_v661;
            i_v680 = i_v679 ^ i_v651;
            i_v681 = i_v680 / 0x1000 | 0x100000 * i_v680;
            i_v682 = i_v676 + i_v526 + i_v681;
            i_v683 = i_v682 ^ i_v678;
            i_v684 = i_v683 / 256 | 0x1000000 * i_v683;
            i_v685 = i_v684 + i_v679;
            i_v686 = i_v685 ^ i_v681;
            i_v687 = i_v686 / 128 | 0x2000000 * i_v686;
            i_v688 = i_v646 + i_v175 + i_v663;
            i_v689 = i_v688 ^ i_v636;
            i_v690 = i_v689 / 0x10000 | 0x10000 * i_v689;
            i_v691 = i_v690 + i_v625;
            i_v692 = i_v691 ^ i_v663;
            i_v693 = i_v692 / 0x1000 | 0x100000 * i_v692;
            i_v694 = i_v688 + i_v168 + i_v693;
            i_v695 = i_v694 ^ i_v690;
            i_v696 = i_v695 / 256 | 0x1000000 * i_v695;
            i_v697 = i_v696 + i_v691;
            i_v698 = i_v697 ^ i_v693;
            i_v699 = i_v698 / 128 | 0x2000000 * i_v698;
            i_v700 = i_v658 + (i_v55 ^ 0x38d01377) + i_v627;
            i_v701 = i_v700 ^ i_v648;
            i_v702 = i_v701 / 0x10000 | 0x10000 * i_v701;
            i_v703 = i_v702 + i_v637;
            i_v704 = i_v703 ^ i_v627;
            i_v705 = i_v704 / 0x1000 | 0x100000 * i_v704;
            i_v706 = i_v700 + (i_v63 ^ -0x7a5cf72d) + i_v705;
            i_v707 = i_v706 ^ i_v702;
            i_v708 = i_v707 / 256 | 0x1000000 * i_v707;
            i_v709 = i_v708 + i_v703;
            i_v710 = i_v709 ^ i_v705;
            i_v711 = i_v710 / 128 | 0x2000000 * i_v710;
            i_v712 = i_v670 + (i_v66 ^ 0x299f31d0) + i_v711;
            i_v713 = i_v712 ^ i_v684;
            i_v714 = i_v713 / 0x10000 | 0x10000 * i_v713;
            i_v715 = i_v714 + i_v697;
            i_v716 = i_v715 ^ i_v711;
            i_v717 = i_v716 / 0x1000 | 0x100000 * i_v716;
            i_v718 = i_v712 + (i_v59 ^ -0x3f53d649) + i_v717;
            i_v719 = i_v718 ^ i_v714;
            i_v720 = i_v719 / 256 | 0x1000000 * i_v719;
            i_v721 = i_v720 + i_v715;
            i_v722 = i_v721 ^ i_v717;
            i_v723 = i_v722 / 128 | 0x2000000 * i_v722;
            i_v724 = i_v682 + (i_v55 ^ -0x4ab8f6e9) + i_v675;
            i_v725 = i_v724 ^ i_v696;
            i_v726 = i_v725 / 0x10000 | 0x10000 * i_v725;
            i_v727 = i_v726 + i_v709;
            i_v728 = i_v727 ^ i_v675;
            i_v729 = i_v728 / 0x1000 | 0x100000 * i_v728;
            i_v730 = i_v724 + (i_v69 ^ -0x7a5cf72d) + i_v729;
            i_v731 = i_v730 ^ i_v726;
            i_v732 = i_v731 / 256 | 0x1000000 * i_v731;
            i_v733 = i_v732 + i_v727;
            i_v734 = i_v733 ^ i_v729;
            i_v735 = i_v734 / 128 | 0x2000000 * i_v734;
            i_v736 = i_v694 + (i_v68 ^ -0x3683af23) + i_v687;
            i_v737 = i_v736 ^ i_v708;
            i_v738 = i_v737 / 0x10000 | 0x10000 * i_v737;
            i_v739 = i_v738 + i_v673;
            i_v740 = i_v739 ^ i_v687;
            i_v741 = i_v740 / 0x1000 | 0x100000 * i_v740;
            i_v742 = i_v736 + (i_v67 ^ 0x3f84d5b5) + i_v741;
            i_v743 = i_v742 ^ i_v738;
            i_v744 = i_v743 / 256 | 0x1000000 * i_v743;
            i_v745 = i_v744 + i_v739;
            i_v746 = i_v745 ^ i_v741;
            i_v747 = i_v746 / 128 | 0x2000000 * i_v746;
            i_v748 = i_v706 + (i_v58 ^ -0x41ab9931) + i_v699;
            i_v749 = i_v748 ^ i_v672;
            i_v750 = i_v749 / 0x10000 | 0x10000 * i_v749;
            i_v751 = i_v750 + i_v685;
            i_v752 = i_v751 ^ i_v699;
            i_v753 = i_v752 / 0x1000 | 0x100000 * i_v752;
            i_v754 = i_v748 + (i_v64 ^ -0x5bf6c7de) + i_v753;
            i_v755 = i_v754 ^ i_v750;
            i_v756 = i_v755 / 256 | 0x1000000 * i_v755;
            i_v757 = i_v756 + i_v751;
            i_v758 = i_v757 ^ i_v753;
            i_v759 = i_v758 / 128 | 0x2000000 * i_v758;
            i_v760 = i_v718 + (i_v54 ^ -0x13b19377) + i_v735;
            i_v761 = i_v760 ^ i_v756;
            i_v762 = i_v761 / 0x10000 | 0x10000 * i_v761;
            i_v763 = i_v762 + i_v745;
            i_v764 = i_v763 ^ i_v735;
            i_v765 = i_v764 / 0x1000 | 0x100000 * i_v764;
            i_v766 = i_v760 + (i_v61 ^ 0x243f6a88) + i_v765;
            i_v767 = i_v766 ^ i_v762;
            i_v768 = i_v767 / 256 | 0x1000000 * i_v767;
            i_v769 = i_v768 + i_v763;
            i_v770 = i_v769 ^ i_v765;
            i_v771 = i_v770 / 128 | 0x2000000 * i_v770;
            i_v772 = i_v730 + i_v369 + i_v747;
            i_v773 = i_v772 ^ i_v720;
            i_v774 = i_v773 / 0x10000 | 0x10000 * i_v773;
            i_v775 = i_v774 + i_v757;
            i_v776 = i_v775 ^ i_v747;
            i_v777 = i_v776 / 0x1000 | 0x100000 * i_v776;
            i_v778 = i_v772 + i_v362 + i_v777;
            i_v779 = i_v778 ^ i_v774;
            i_v780 = i_v779 / 256 | 0x1000000 * i_v779;
            i_v781 = i_v780 + i_v775;
            i_v782 = i_v781 ^ i_v777;
            i_v783 = i_v782 / 128 | 0x2000000 * i_v782;
            i_v784 =
                i_v742 + (i_v63 ^ ((int32_t)&p_g248 | 0x13190000)) + i_v759;
            i_v785 = i_v784 ^ i_v732;
            i_v786 = i_v785 / 0x10000 | 0x10000 * i_v785;
            i_v787 = i_v786 + i_v721;
            i_v788 = i_v787 ^ i_v759;
            i_v789 = i_v788 / 0x1000 | 0x100000 * i_v788;
            i_v790 = i_v784 + (i_v56 ^ 0x38d01377) + i_v789;
            i_v791 = i_v790 ^ i_v786;
            i_v792 = i_v791 / 256 | 0x1000000 * i_v791;
            i_v793 = i_v792 + i_v787;
            i_v794 = i_v793 ^ i_v789;
            i_v795 = i_v794 / 128 | 0x2000000 * i_v794;
            i_v796 = i_v754 + i_v301 + i_v723;
            i_v797 = i_v796 ^ i_v744;
            i_v798 = i_v797 / 0x10000 | 0x10000 * i_v797;
            i_v799 = i_v798 + i_v733;
            i_v800 = i_v799 ^ i_v723;
            i_v801 = i_v800 / 0x1000 | 0x100000 * i_v800;
            i_v802 = i_v796 + i_v294 + i_v801;
            i_v803 = i_v802 ^ i_v798;
            i_v804 = i_v803 / 256 | 0x1000000 * i_v803;
            i_v805 = i_v804 + i_v799;
            i_v806 = i_v805 ^ i_v801;
            i_v807 = i_v806 / 128 | 0x2000000 * i_v806;
            i_v808 = i_v766 + (i_v67 ^ 0x34e90c6c) + i_v807;
            i_v809 = i_v808 ^ i_v780;
            i_v810 = i_v809 / 0x10000 | 0x10000 * i_v809;
            i_v811 = i_v810 + i_v793;
            i_v812 = i_v811 ^ i_v807;
            i_v813 = i_v812 / 0x1000 | 0x100000 * i_v812;
            i_v814 = i_v808 + (i_v65 ^ -0x3683af23) + i_v813;
            i_v815 = i_v814 ^ i_v810;
            i_v816 = i_v815 / 256 | 0x1000000 * i_v815;
            i_v817 = i_v816 + i_v811;
            i_v818 = i_v817 ^ i_v813;
            i_v819 = i_v818 / 128 | 0x2000000 * i_v818;
            i_v820 = i_v778 + (i_v61 ^ 0x3f84d5b5) + i_v771;
            i_v821 = i_v820 ^ i_v792;
            i_v822 = i_v821 / 0x10000 | 0x10000 * i_v821;
            i_v823 = i_v822 + i_v805;
            i_v824 = i_v823 ^ i_v771;
            i_v825 = i_v824 / 0x1000 | 0x100000 * i_v824;
            i_v826 = i_v820 + (i_v68 ^ -0x13b19377) + i_v825;
            i_v827 = i_v826 ^ i_v822;
            i_v828 = i_v827 / 256 | 0x1000000 * i_v827;
            i_v829 = i_v828 + i_v823;
            i_v830 = i_v829 ^ i_v825;
            i_v831 = i_v830 / 128 | 0x2000000 * i_v830;
            i_v832 = i_v790 + i_v245 + i_v783;
            i_v833 = i_v832 ^ i_v804;
            i_v834 = i_v833 / 0x10000 | 0x10000 * i_v833;
            i_v835 = i_v834 + i_v769;
            i_v836 = i_v835 ^ i_v783;
            i_v837 = i_v836 / 0x1000 | 0x100000 * i_v836;
            i_v838 = i_v832 + i_v238 + i_v837;
            i_v839 = i_v838 ^ i_v834;
            i_v840 = i_v839 / 256 | 0x1000000 * i_v839;
            i_v841 = i_v840 + i_v835;
            i_v842 = i_v841 ^ i_v837;
            i_v843 = i_v842 / 128 | 0x2000000 * i_v842;
            i_v844 = i_v802 + (i_v57 ^ 0x38d01377) + i_v795;
            i_v845 = i_v844 ^ i_v768;
            i_v846 = i_v845 / 0x10000 | 0x10000 * i_v845;
            i_v847 = i_v846 + i_v781;
            i_v848 = i_v847 ^ i_v795;
            i_v849 = i_v848 / 0x1000 | 0x100000 * i_v848;
            i_v850 = i_v844 + (i_v63 ^ 0x3707344) + i_v849;
            i_v851 = i_v850 ^ i_v846;
            i_v852 = i_v851 / 256 | 0x1000000 * i_v851;
            i_v853 = i_v852 + i_v847;
            i_v854 = i_v853 ^ i_v849;
            i_v855 = i_v854 / 128 | 0x2000000 * i_v854;
            i_v856 = i_v814 + (i_v59 ^ 0x243f6a88) + i_v831;
            i_v857 = i_v856 ^ i_v852;
            i_v858 = i_v857 / 0x10000 | 0x10000 * i_v857;
            i_v859 = i_v858 + i_v841;
            i_v860 = i_v859 ^ i_v831;
            i_v861 = i_v860 / 0x1000 | 0x100000 * i_v860;
            i_v862 = i_v856 + (i_v54 ^ 0x299f31d0) + i_v861;
            i_v863 = i_v862 ^ i_v858;
            i_v864 = i_v863 / 256 | 0x1000000 * i_v863;
            i_v865 = i_v864 + i_v859;
            i_v866 = i_v865 ^ i_v861;
            i_v867 = i_v866 / 128 | 0x2000000 * i_v866;
            i_v868 = i_v826 + (i_v69 ^ -0x5bf6c7de) + i_v843;
            i_v869 = i_v868 ^ i_v816;
            i_v870 = i_v869 / 0x10000 | 0x10000 * i_v869;
            i_v871 = i_v870 + i_v853;
            i_v872 = i_v871 ^ i_v843;
            i_v873 = i_v872 / 0x1000 | 0x100000 * i_v872;
            i_v874 = i_v868 + (i_v58 ^ -0x4ab8f6e9) + i_v873;
            i_v875 = i_v874 ^ i_v870;
            i_v876 = i_v875 / 256 | 0x1000000 * i_v875;
            i_v877 = i_v876 + i_v871;
            i_v878 = i_v877 ^ i_v873;
            i_v879 = i_v878 / 128 | 0x2000000 * i_v878;
            i_v880 = i_v838 + i_v595 + i_v855;
            i_v881 = i_v880 ^ i_v828;
            i_v882 = i_v881 / 0x10000 | 0x10000 * i_v881;
            i_v883 = i_v882 + i_v817;
            i_v884 = i_v883 ^ i_v855;
            i_v885 = i_v884 / 0x1000 | 0x100000 * i_v884;
            i_v886 = i_v880 + i_v588 + i_v885;
            i_v887 = i_v886 ^ i_v882;
            i_v888 = i_v887 / 256 | 0x1000000 * i_v887;
            i_v889 = i_v888 + i_v883;
            i_v890 = i_v889 ^ i_v885;
            i_v891 = i_v890 / 128 | 0x2000000 * i_v890;
            i_v892 = i_v56 ^ -0x41ab9931;
            i_v893 = i_v850 + i_v892 + i_v819;
            i_v894 = i_v893 ^ i_v840;
            i_v895 = i_v894 / 0x10000 | 0x10000 * i_v894;
            i_v896 = i_v895 + i_v829;
            i_v897 = i_v896 ^ i_v819;
            i_v898 = i_v897 / 0x1000 | 0x100000 * i_v897;
            i_v899 = i_v64 ^ ((int32_t)&p_g248 | 0x13190000);
            i_v900 = i_v893 + i_v899 + i_v898;
            i_v901 = i_v900 ^ i_v895;
            i_v902 = i_v901 / 256 | 0x1000000 * i_v901;
            i_v903 = i_v902 + i_v896;
            i_v904 = i_v903 ^ i_v898;
            i_v905 = i_v904 / 128 | 0x2000000 * i_v904;
            i_v906 = i_v862 + (i_v60 ^ -0x4ab8f6e9) + i_v905;
            i_v907 = i_v906 ^ i_v876;
            i_v908 = i_v907 / 0x10000 | 0x10000 * i_v907;
            i_v909 = i_v908 + i_v889;
            i_v910 = i_v909 ^ i_v905;
            i_v911 = i_v910 / 0x1000 | 0x100000 * i_v910;
            i_v912 = i_v906 + (i_v69 ^ 0x82efa98) + i_v911;
            i_v913 = i_v912 ^ i_v908;
            i_v914 = i_v913 / 256 | 0x1000000 * i_v913;
            i_v915 = i_v914 + i_v909;
            i_v916 = i_v915 ^ i_v911;
            i_v917 = i_v916 / 128 | 0x2000000 * i_v916;
            i_v918 = i_v68 ^ 0x38d01377;
            i_v919 = i_v874 + i_v918 + i_v867;
            i_v920 = i_v919 ^ i_v888;
            i_v921 = i_v920 / 0x10000 | 0x10000 * i_v920;
            i_v922 = i_v921 + i_v903;
            i_v923 = i_v922 ^ i_v867;
            i_v924 = i_v923 / 0x1000 | 0x100000 * i_v923;
            i_v925 = i_v63 ^ 0x3f84d5b5;
            i_v926 = i_v919 + i_v925 + i_v924;
            i_v927 = i_v926 ^ i_v921;
            i_v928 = i_v927 / 256 | 0x1000000 * i_v927;
            i_v929 = i_v928 + i_v922;
            i_v930 = i_v929 ^ i_v924;
            i_v931 = i_v930 / 128 | 0x2000000 * i_v930;
            i_v932 = i_v886 + (i_v65 ^ 0x3707344) + i_v879;
            i_v933 = i_v932 ^ i_v902;
            i_v934 = i_v933 / 0x10000 | 0x10000 * i_v933;
            i_v935 = i_v934 + i_v865;
            i_v936 = i_v935 ^ i_v879;
            i_v937 = i_v936 / 0x1000 | 0x100000 * i_v936;
            i_v938 = i_v932 + (i_v57 ^ 0x34e90c6c) + i_v937;
            i_v939 = i_v938 ^ i_v934;
            i_v940 = i_v939 / 256 | 0x1000000 * i_v939;
            i_v941 = i_v940 + i_v935;
            i_v942 = i_v941 ^ i_v937;
            i_v943 = i_v942 / 128 | 0x2000000 * i_v942;
            i_v944 = i_v900 + (i_v54 ^ 0x452821e6) + i_v891;
            i_v945 = i_v944 ^ i_v864;
            i_v946 = i_v945 / 0x10000 | 0x10000 * i_v945;
            i_v947 = i_v946 + i_v877;
            i_v948 = i_v947 ^ i_v891;
            i_v949 = i_v948 / 0x1000 | 0x100000 * i_v948;
            i_v950 = i_v944 + (i_v62 ^ 0x243f6a88) + i_v949;
            i_v951 = i_v950 ^ i_v946;
            i_v952 = i_v951 / 256 | 0x1000000 * i_v951;
            i_v953 = i_v952 + i_v947;
            i_v954 = i_v953 ^ i_v949;
            i_v955 = i_v954 / 128 | 0x2000000 * i_v954;
            i_v956 = i_v912 + i_v621 + i_v931;
            i_v957 = i_v956 ^ i_v952;
            i_v958 = i_v957 / 0x10000 | 0x10000 * i_v957;
            i_v959 = i_v958 + i_v941;
            i_v960 = i_v959 ^ i_v931;
            i_v961 = i_v960 / 0x1000 | 0x100000 * i_v960;
            i_v962 = i_v956 + i_v614 + i_v961;
            i_v963 = i_v962 ^ i_v958;
            i_v964 = i_v963 / 256 | 0x1000000 * i_v963;
            i_v965 = i_v964 + i_v959;
            i_v966 = i_v965 ^ i_v961;
            i_v967 = i_v966 / 128 | 0x2000000 * i_v966;
            i_v968 = i_v926 + (i_v67 ^ -0x13b19377) + i_v943;
            i_v969 = i_v968 ^ i_v914;
            i_v970 = i_v969 / 0x10000 | 0x10000 * i_v969;
            i_v971 = i_v970 + i_v953;
            i_v972 = i_v971 ^ i_v943;
            i_v973 = i_v972 / 0x1000 | 0x100000 * i_v972;
            i_v974 = i_v968 + (i_v61 ^ -0x3683af23) + i_v973;
            i_v975 = i_v974 ^ i_v970;
            i_v976 = i_v975 / 256 | 0x1000000 * i_v975;
            i_v977 = i_v976 + i_v971;
            i_v978 = i_v977 ^ i_v973;
            i_v979 = i_v978 / 128 | 0x2000000 * i_v978;
            i_v980 = i_v938 + (i_v55 ^ -0x5bf6c7de) + i_v955;
            i_v981 = i_v980 ^ i_v928;
            i_v982 = i_v981 / 0x10000 | 0x10000 * i_v981;
            i_v983 = i_v982 + i_v915;
            i_v984 = i_v983 ^ i_v955;
            i_v985 = i_v984 / 0x1000 | 0x100000 * i_v984;
            i_v986 = i_v980 + (i_v58 ^ -0x7a5cf72d) + i_v985;
            i_v987 = i_v986 ^ i_v982;
            i_v988 = i_v987 / 256 | 0x1000000 * i_v987;
            i_v989 = i_v988 + i_v983;
            i_v990 = i_v989 ^ i_v985;
            i_v991 = i_v990 / 128 | 0x2000000 * i_v990;
            i_v992 = i_v950 + i_v479 + i_v917;
            i_v993 = i_v992 ^ i_v940;
            i_v994 = i_v993 / 0x10000 | 0x10000 * i_v993;
            i_v995 = i_v994 + i_v929;
            i_v996 = i_v995 ^ i_v917;
            i_v997 = i_v996 / 0x1000 | 0x100000 * i_v996;
            i_v998 = i_v992 + i_v472 + i_v997;
            i_v999 = i_v998 ^ i_v994;
            i_v1000 = i_v999 / 256 | 0x1000000 * i_v999;
            i_v1001 = i_v1000 + i_v995;
            i_v1002 = i_v1001 ^ i_v997;
            i_v1003 = i_v1002 / 128 | 0x2000000 * i_v1002;
            i_v1004 = i_v962 + i_v899 + i_v1003;
            i_v1005 = i_v1004 ^ i_v976;
            i_v1006 = i_v1005 / 0x10000 | 0x10000 * i_v1005;
            i_v1007 = i_v1006 + i_v989;
            i_v1008 = i_v1007 ^ i_v1003;
            i_v1009 = i_v1008 / 0x1000 | 0x100000 * i_v1008;
            i_v1010 = i_v1004 + i_v892 + i_v1009;
            i_v1011 = i_v1010 ^ i_v1006;
            i_v1012 = i_v1011 / 256 | 0x1000000 * i_v1011;
            i_v1013 = i_v1012 + i_v1007;
            i_v1014 = i_v1013 ^ i_v1009;
            i_v1015 = i_v1014 / 128 | 0x2000000 * i_v1014;
            i_v1016 = i_v974 + i_v203 + i_v967;
            i_v1017 = i_v1016 ^ i_v988;
            i_v1018 = i_v1017 / 0x10000 | 0x10000 * i_v1017;
            i_v1019 = i_v1018 + i_v1001;
            i_v1020 = i_v1019 ^ i_v967;
            i_v1021 = i_v1020 / 0x1000 | 0x100000 * i_v1020;
            i_v1022 = i_v1016 + i_v196 + i_v1021;
            i_v1023 = i_v1022 ^ i_v1018;
            i_v1024 = i_v1023 / 256 | 0x1000000 * i_v1023;
            i_v1025 = i_v1024 + i_v1019;
            i_v1026 = i_v1025 ^ i_v1021;
            i_v1027 = i_v1026 / 128 | 0x2000000 * i_v1026;
            i_v1028 = i_v986 + i_v119 + i_v979;
            i_v1029 = i_v1028 ^ i_v1000;
            i_v1030 = i_v1029 / 0x10000 | 0x10000 * i_v1029;
            i_v1031 = i_v1030 + i_v965;
            i_v1032 = i_v1031 ^ i_v979;
            i_v1033 = i_v1032 / 0x1000 | 0x100000 * i_v1032;
            i_v1034 = i_v1028 + i_v112 + i_v1033;
            i_v1035 = i_v1034 ^ i_v1030;
            i_v1036 = i_v1035 / 256 | 0x1000000 * i_v1035;
            i_v1037 = i_v1036 + i_v1031;
            i_v1038 = i_v1037 ^ i_v1033;
            i_v1039 = i_v1038 / 128 | 0x2000000 * i_v1038;
            i_v1040 = i_v998 + (i_v55 ^ 0x299f31d0) + i_v991;
            i_v1041 = i_v1040 ^ i_v964;
            i_v1042 = i_v1041 / 0x10000 | 0x10000 * i_v1041;
            i_v1043 = i_v1042 + i_v977;
            i_v1044 = i_v1043 ^ i_v991;
            i_v1045 = i_v1044 / 0x1000 | 0x100000 * i_v1044;
            i_v1046 = i_v1040 + (i_v59 ^ -0x7a5cf72d) + i_v1045;
            i_v1047 = i_v1046 ^ i_v1042;
            i_v1048 = i_v1047 / 256 | 0x1000000 * i_v1047;
            i_v1049 = i_v1048 + i_v1043;
            i_v1050 = i_v1049 ^ i_v1045;
            i_v1051 = i_v1050 / 128 | 0x2000000 * i_v1050;
            i_v1052 = i_v1010 + (i_v69 ^ 0x34e90c6c) + i_v1027;
            i_v1053 = i_v1052 ^ i_v1048;
            i_v1054 = i_v1053 / 0x10000 | 0x10000 * i_v1053;
            i_v1055 = i_v1054 + i_v1037;
            i_v1056 = i_v1055 ^ i_v1027;
            i_v1057 = i_v1056 / 0x1000 | 0x100000 * i_v1056;
            i_v1058 = i_v1052 + (i_v65 ^ -0x4ab8f6e9) + i_v1057;
            i_v1059 = i_v1058 ^ i_v1054;
            i_v1060 = i_v1059 / 256 | 0x1000000 * i_v1059;
            i_v1061 = i_v1060 + i_v1055;
            i_v1062 = i_v1061 ^ i_v1057;
            i_v1063 = i_v1062 / 128 | 0x2000000 * i_v1062;
            i_v1064 = i_v1022 + i_v925 + i_v1039;
            i_v1065 = i_v1064 ^ i_v1012;
            i_v1066 = i_v1065 / 0x10000 | 0x10000 * i_v1065;
            i_v1067 = i_v1066 + i_v1049;
            i_v1068 = i_v1067 ^ i_v1039;
            i_v1069 = i_v1068 / 0x1000 | 0x100000 * i_v1068;
            i_v1070 = i_v1064 + i_v918 + i_v1069;
            i_v1071 = i_v1070 ^ i_v1066;
            i_v1072 = i_v1071 / 256 | 0x1000000 * i_v1071;
            i_v1073 = i_v1072 + i_v1067;
            i_v1074 = i_v1073 ^ i_v1069;
            i_v1075 = i_v1074 / 128 | 0x2000000 * i_v1074;
            i_v1076 = i_v1034 + (i_v57 ^ -0x3f53d649) + i_v1051;
            i_v1077 = i_v1076 ^ i_v1024;
            i_v1078 = i_v1077 / 0x10000 | 0x10000 * i_v1077;
            i_v1079 = i_v1078 + i_v1013;
            i_v1080 = i_v1079 ^ i_v1051;
            i_v1081 = i_v1080 / 0x1000 | 0x100000 * i_v1080;
            i_v1082 = i_v1076 + (i_v66 ^ 0x3707344) + i_v1081;
            i_v1083 = i_v1082 ^ i_v1078;
            i_v1084 = i_v1083 / 256 | 0x1000000 * i_v1083;
            i_v1085 = i_v1084 + i_v1079;
            i_v1086 = i_v1085 ^ i_v1081;
            i_v1087 = i_v1086 / 128 | 0x2000000 * i_v1086;
            i_v1088 = i_v1046 + (i_v67 ^ 0x243f6a88) + i_v1015;
            i_v1089 = i_v1088 ^ i_v1036;
            i_v1090 = i_v1089 / 0x10000 | 0x10000 * i_v1089;
            i_v1091 = i_v1090 + i_v1025;
            i_v1092 = i_v1091 ^ i_v1015;
            i_v1093 = i_v1092 / 0x1000 | 0x100000 * i_v1092;
            i_v1094 = i_v1088 + (i_v54 ^ -0x3683af23) + i_v1093;
            i_v1095 = i_v1094 ^ i_v1090;
            i_v1096 = i_v1095 / 256 | 0x1000000 * i_v1095;
            i_v1097 = i_v1096 + i_v1091;
            i_v1098 = i_v1097 ^ i_v1093;
            i_v1099 = i_v1098 / 128 | 0x2000000 * i_v1098;
            i_v1100 = i_v1058 + i_v70 + i_v1099;
            i_v1101 = i_v1100 ^ i_v1072;
            i_v1102 = i_v1101 / 0x10000 | 0x10000 * i_v1101;
            i_v1103 = i_v1102 + i_v1085;
            i_v1104 = i_v1103 ^ i_v1099;
            i_v1105 = i_v1104 / 0x1000 | 0x100000 * i_v1104;
            i_v1106 = i_v1100 + i_v77 + i_v1105;
            i_v1107 = i_v1106 ^ i_v1102;
            i_v1108 = i_v1107 / 256 | 0x1000000 * i_v1107;
            i_v1109 = i_v1108 + i_v1103;
            i_v1110 = i_v1109 ^ i_v1105;
            i_v1111 = i_v1110 / 128 | 0x2000000 * i_v1110;
            i_v1112 = i_v1070 + i_v84 + i_v1063;
            i_v1113 = i_v1112 ^ i_v1084;
            i_v1114 = i_v1113 / 0x10000 | 0x10000 * i_v1113;
            i_v1115 = i_v1114 + i_v1097;
            i_v1116 = i_v1115 ^ i_v1063;
            i_v1117 = i_v1116 / 0x1000 | 0x100000 * i_v1116;
            i_v1118 = i_v1112 + i_v91 + i_v1117;
            i_v1119 = i_v1118 ^ i_v1114;
            i_v1120 = i_v1119 / 256 | 0x1000000 * i_v1119;
            i_v1121 = i_v1120 + i_v1115;
            i_v1122 = i_v1121 ^ i_v1117;
            i_v1123 = i_v1122 / 128 | 0x2000000 * i_v1122;
            i_v1124 = i_v1082 + i_v98 + i_v1075;
            i_v1125 = i_v1124 ^ i_v1096;
            i_v1126 = i_v1125 / 0x10000 | 0x10000 * i_v1125;
            i_v1127 = i_v1126 + i_v1061;
            i_v1128 = i_v1127 ^ i_v1075;
            i_v1129 = i_v1128 / 0x1000 | 0x100000 * i_v1128;
            i_v1130 = i_v1124 + i_v105 + i_v1129;
            i_v1131 = i_v1130 ^ i_v1126;
            i_v1132 = i_v1131 / 256 | 0x1000000 * i_v1131;
            i_v1133 = i_v1132 + i_v1127;
            i_v1134 = i_v1133 ^ i_v1129;
            i_v1135 = i_v1134 / 128 | 0x2000000 * i_v1134;
            i_v1136 = i_v1094 + i_v112 + i_v1087;
            i_v1137 = i_v1136 ^ i_v1060;
            i_v1138 = i_v1137 / 0x10000 | 0x10000 * i_v1137;
            i_v1139 = i_v1138 + i_v1073;
            i_v1140 = i_v1139 ^ i_v1087;
            i_v1141 = i_v1140 / 0x1000 | 0x100000 * i_v1140;
            i_v1142 = i_v1136 + i_v119 + i_v1141;
            i_v1143 = i_v1142 ^ i_v1138;
            i_v1144 = i_v1143 / 256 | 0x1000000 * i_v1143;
            i_v1145 = i_v1144 + i_v1139;
            i_v1146 = i_v1145 ^ i_v1141;
            i_v1147 = i_v1146 / 128 | 0x2000000 * i_v1146;
            i_v1148 = i_v1106 + i_v126 + i_v1123;
            i_v1149 = i_v1148 ^ i_v1144;
            i_v1150 = i_v1149 / 0x10000 | 0x10000 * i_v1149;
            i_v1151 = i_v1150 + i_v1133;
            i_v1152 = i_v1151 ^ i_v1123;
            i_v1153 = i_v1152 / 0x1000 | 0x100000 * i_v1152;
            i_v1154 = i_v1148 + i_v133 + i_v1153;
            i_v1155 = i_v1154 ^ i_v1150;
            i_v1156 = i_v1155 / 256 | 0x1000000 * i_v1155;
            i_v1157 = i_v1156 + i_v1151;
            i_v1158 = i_v1157 ^ i_v1153;
            i_v1159 = i_v1158 / 128 | 0x2000000 * i_v1158;
            i_v1160 = i_v1118 + i_v140 + i_v1135;
            i_v1161 = i_v1160 ^ i_v1108;
            i_v1162 = i_v1161 / 0x10000 | 0x10000 * i_v1161;
            i_v1163 = i_v1162 + i_v1145;
            i_v1164 = i_v1163 ^ i_v1135;
            i_v1165 = i_v1164 / 0x1000 | 0x100000 * i_v1164;
            i_v1166 = i_v1160 + i_v147 + i_v1165;
            i_v1167 = i_v1166 ^ i_v1162;
            i_v1168 = i_v1167 / 256 | 0x1000000 * i_v1167;
            i_v1169 = i_v1168 + i_v1163;
            i_v1170 = i_v1169 ^ i_v1165;
            i_v1171 = i_v1170 / 128 | 0x2000000 * i_v1170;
            i_v1172 = i_v1130 + i_v154 + i_v1147;
            i_v1173 = i_v1172 ^ i_v1120;
            i_v1174 = i_v1173 / 0x10000 | 0x10000 * i_v1173;
            i_v1175 = i_v1174 + i_v1109;
            i_v1176 = i_v1175 ^ i_v1147;
            i_v1177 = i_v1176 / 0x1000 | 0x100000 * i_v1176;
            i_v1178 = i_v1172 + i_v161 + i_v1177;
            i_v1179 = i_v1178 ^ i_v1174;
            i_v1180 = i_v1179 / 256 | 0x1000000 * i_v1179;
            i_v1181 = i_v1180 + i_v1175;
            i_v1182 = i_v1181 ^ i_v1177;
            i_v1183 = i_v1182 / 128 | 0x2000000 * i_v1182;
            i_v1184 = i_v1142 + i_v168 + i_v1111;
            i_v1185 = i_v1184 ^ i_v1132;
            i_v1186 = i_v1185 / 0x10000 | 0x10000 * i_v1185;
            i_v1187 = i_v1186 + i_v1121;
            i_v1188 = i_v1187 ^ i_v1111;
            i_v1189 = i_v1188 / 0x1000 | 0x100000 * i_v1188;
            i_v1190 = i_v1184 + i_v175 + i_v1189;
            i_v1191 = i_v1190 ^ i_v1186;
            i_v1192 = i_v1191 / 256 | 0x1000000 * i_v1191;
            i_v1193 = i_v1192 + i_v1187;
            i_v1194 = i_v1193 ^ i_v1189;
            i_v1195 = i_v1194 / 128 | 0x2000000 * i_v1194;
            i_v1196 = i_v1154 + i_v182 + i_v1195;
            i_v1197 = i_v1196 ^ i_v1168;
            i_v1198 = i_v1197 / 0x10000 | 0x10000 * i_v1197;
            i_v1199 = i_v1198 + i_v1181;
            i_v1200 = i_v1199 ^ i_v1195;
            i_v1201 = i_v1200 / 0x1000 | 0x100000 * i_v1200;
            i_v1202 = i_v1196 + i_v189 + i_v1201;
            i_v1203 = i_v1202 ^ i_v1198;
            i_v1204 = i_v1203 / 256 | 0x1000000 * i_v1203;
            i_v1205 = i_v1204 + i_v1199;
            i_v1206 = i_v1205 ^ i_v1201;
            i_v1207 = i_v1206 / 128 | 0x2000000 * i_v1206;
            i_v1208 = i_v1166 + i_v196 + i_v1159;
            i_v1209 = i_v1208 ^ i_v1180;
            i_v1210 = i_v1209 / 0x10000 | 0x10000 * i_v1209;
            i_v1211 = i_v1210 + i_v1193;
            i_v1212 = i_v1211 ^ i_v1159;
            i_v1213 = i_v1212 / 0x1000 | 0x100000 * i_v1212;
            i_v1214 = i_v1208 + i_v203 + i_v1213;
            i_v1215 = i_v1214 ^ i_v1210;
            i_v1216 = i_v1215 / 256 | 0x1000000 * i_v1215;
            i_v1217 = i_v1216 + i_v1211;
            i_v1218 = i_v1217 ^ i_v1213;
            i_v1219 = i_v1218 / 128 | 0x2000000 * i_v1218;
            i_v1220 = i_v1178 + i_v210 + i_v1171;
            i_v1221 = i_v1220 ^ i_v1192;
            i_v1222 = i_v1221 / 0x10000 | 0x10000 * i_v1221;
            i_v1223 = i_v1222 + i_v1157;
            i_v1224 = i_v1223 ^ i_v1171;
            i_v1225 = i_v1224 / 0x1000 | 0x100000 * i_v1224;
            i_v1226 = i_v1220 + i_v217 + i_v1225;
            i_v1227 = i_v1226 ^ i_v1222;
            i_v1228 = i_v1227 / 256 | 0x1000000 * i_v1227;
            i_v1229 = i_v1228 + i_v1223;
            i_v1230 = i_v1229 ^ i_v1225;
            i_v1231 = i_v1230 / 128 | 0x2000000 * i_v1230;
            i_v1232 = i_v1190 + i_v224 + i_v1183;
            i_v1233 = i_v1232 ^ i_v1156;
            i_v1234 = i_v1233 / 0x10000 | 0x10000 * i_v1233;
            i_v1235 = i_v1234 + i_v1169;
            i_v1236 = i_v1235 ^ i_v1183;
            i_v1237 = i_v1236 / 0x1000 | 0x100000 * i_v1236;
            i_v1238 = i_v1232 + i_v231 + i_v1237;
            i_v1239 = i_v1238 ^ i_v1234;
            i_v1240 = i_v1239 / 256 | 0x1000000 * i_v1239;
            i_v1241 = i_v1240 + i_v1235;
            i_v1242 = i_v1241 ^ i_v1237;
            i_v1243 = i_v1242 / 128 | 0x2000000 * i_v1242;
            i_v1244 = i_v1202 + i_v238 + i_v1219;
            i_v1245 = i_v1244 ^ i_v1240;
            i_v1246 = i_v1245 / 0x10000 | 0x10000 * i_v1245;
            i_v1247 = i_v1246 + i_v1229;
            i_v1248 = i_v1247 ^ i_v1219;
            i_v1249 = i_v1248 / 0x1000 | 0x100000 * i_v1248;
            i_v1250 = i_v1244 + i_v245 + i_v1249;
            i_v1251 = i_v1250 ^ i_v1246;
            i_v1252 = i_v1251 / 256 | 0x1000000 * i_v1251;
            i_v1253 = i_v1252 + i_v1247;
            i_v1254 = i_v1253 ^ i_v1249;
            i_v1255 = i_v1254 / 128 | 0x2000000 * i_v1254;
            i_v1256 = i_v1214 + i_v252 + i_v1231;
            i_v1257 = i_v1256 ^ i_v1204;
            i_v1258 = i_v1257 / 0x10000 | 0x10000 * i_v1257;
            i_v1259 = i_v1258 + i_v1241;
            i_v1260 = i_v1259 ^ i_v1231;
            i_v1261 = i_v1260 / 0x1000 | 0x100000 * i_v1260;
            i_v1262 = i_v1256 + i_v259 + i_v1261;
            i_v1263 = i_v1262 ^ i_v1258;
            i_v1264 = i_v1263 / 256 | 0x1000000 * i_v1263;
            i_v1265 = i_v1264 + i_v1259;
            i_v1266 = i_v1265 ^ i_v1261;
            i_v1267 = i_v1266 / 128 | 0x2000000 * i_v1266;
            i_v1268 = i_v1226 + i_v266 + i_v1243;
            i_v1269 = i_v1268 ^ i_v1216;
            i_v1270 = i_v1269 / 0x10000 | 0x10000 * i_v1269;
            i_v1271 = i_v1270 + i_v1205;
            i_v1272 = i_v1271 ^ i_v1243;
            i_v1273 = i_v1272 / 0x1000 | 0x100000 * i_v1272;
            i_v1274 = i_v1268 + i_v273 + i_v1273;
            i_v1275 = i_v1274 ^ i_v1270;
            i_v1276 = i_v1275 / 256 | 0x1000000 * i_v1275;
            i_v1277 = i_v1276 + i_v1271;
            i_v1278 = i_v1277 ^ i_v1273;
            i_v1279 = i_v1278 / 128 | 0x2000000 * i_v1278;
            i_v1280 = i_v1238 + i_v280 + i_v1207;
            i_v1281 = i_v1280 ^ i_v1228;
            i_v1282 = i_v1281 / 0x10000 | 0x10000 * i_v1281;
            i_v1283 = i_v1282 + i_v1217;
            i_v1284 = i_v1283 ^ i_v1207;
            i_v1285 = i_v1284 / 0x1000 | 0x100000 * i_v1284;
            i_v1286 = i_v1280 + i_v287 + i_v1285;
            i_v1287 = i_v1286 ^ i_v1282;
            i_v1288 = i_v1287 / 256 | 0x1000000 * i_v1287;
            i_v1289 = i_v1288 + i_v1283;
            i_v1290 = i_v1289 ^ i_v1285;
            i_v1291 = i_v1290 / 128 | 0x2000000 * i_v1290;
            i_v1292 = i_v1250 + i_v294 + i_v1291;
            i_v1293 = i_v1292 ^ i_v1264;
            i_v1294 = i_v1293 / 0x10000 | 0x10000 * i_v1293;
            i_v1295 = i_v1294 + i_v1277;
            i_v1296 = i_v1295 ^ i_v1291;
            i_v1297 = i_v1296 / 0x1000 | 0x100000 * i_v1296;
            i_v1298 = i_v1292 + i_v301 + i_v1297;
            i_v1299 = i_v1298 ^ i_v1294;
            i_v1300 = i_v1299 / 256 | 0x1000000 * i_v1299;
            i_v1301 = i_v1300 + i_v1295;
            i_v1302 = i_v1301 ^ i_v1297;
            i_v1303 = i_v1302 / 128 | 0x2000000 * i_v1302;
            i_v1304 = i_v1262 + i_v308 + i_v1255;
            i_v1305 = i_v1304 ^ i_v1276;
            i_v1306 = i_v1305 / 0x10000 | 0x10000 * i_v1305;
            i_v1307 = i_v1306 + i_v1289;
            i_v1308 = i_v1307 ^ i_v1255;
            i_v1309 = i_v1308 / 0x1000 | 0x100000 * i_v1308;
            i_v1310 = i_v1304 + i_v315 + i_v1309;
            i_v1311 = i_v1310 ^ i_v1306;
            i_v1312 = i_v1311 / 256 | 0x1000000 * i_v1311;
            i_v1313 = i_v1312 + i_v1307;
            i_v1314 = i_v1313 ^ i_v1309;
            i_v1315 = i_v1314 / 128 | 0x2000000 * i_v1314;
            i_v1316 = i_v1274 + i_v322 + i_v1267;
            i_v1317 = i_v1316 ^ i_v1288;
            i_v1318 = i_v1317 / 0x10000 | 0x10000 * i_v1317;
            i_v1319 = i_v1318 + i_v1253;
            i_v1320 = i_v1319 ^ i_v1267;
            i_v1321 = i_v1320 / 0x1000 | 0x100000 * i_v1320;
            i_v1322 = i_v1316 + i_v329 + i_v1321;
            i_v1323 = i_v1322 ^ i_v1318;
            i_v1324 = i_v1323 / 256 | 0x1000000 * i_v1323;
            i_v1325 = i_v1324 + i_v1319;
            i_v1326 = i_v1325 ^ i_v1321;
            i_v1327 = i_v1326 / 128 | 0x2000000 * i_v1326;
            i_v1328 = i_v1286 + i_v336 + i_v1279;
            i_v1329 = i_v1328 ^ i_v1252;
            i_v1330 = i_v1329 / 0x10000 | 0x10000 * i_v1329;
            i_v1331 = i_v1330 + i_v1265;
            i_v1332 = i_v1331 ^ i_v1279;
            i_v1333 = i_v1332 / 0x1000 | 0x100000 * i_v1332;
            i_v1334 = i_v1328 + i_v343 + i_v1333;
            i_v1335 = i_v1334 ^ i_v1330;
            i_v1336 = i_v1335 / 256 | 0x1000000 * i_v1335;
            i_v1337 = i_v1336 + i_v1331;
            i_v1338 = i_v1337 ^ i_v1333;
            i_v1339 = i_v1338 / 128 | 0x2000000 * i_v1338;
            i_v1340 = i_v1298 + i_v189 + i_v1315;
            i_v1341 = i_v1340 ^ i_v1336;
            i_v1342 = i_v1341 / 0x10000 | 0x10000 * i_v1341;
            i_v1343 = i_v1342 + i_v1325;
            i_v1344 = i_v1343 ^ i_v1315;
            i_v1345 = i_v1344 / 0x1000 | 0x100000 * i_v1344;
            i_v1346 = i_v1340 + i_v182 + i_v1345;
            i_v1347 = i_v1346 ^ i_v1342;
            i_v1348 = i_v1347 / 256 | 0x1000000 * i_v1347;
            i_v1349 = i_v1348 + i_v1343;
            i_v1350 = i_v1349 ^ i_v1345;
            i_v1351 = i_v1350 / 128 | 0x2000000 * i_v1350;
            i_v1352 = i_v1310 + i_v362 + i_v1327;
            i_v1353 = i_v1352 ^ i_v1300;
            i_v1354 = i_v1353 / 0x10000 | 0x10000 * i_v1353;
            i_v1355 = i_v1354 + i_v1337;
            i_v1356 = i_v1355 ^ i_v1327;
            i_v1357 = i_v1356 / 0x1000 | 0x100000 * i_v1356;
            i_v1358 = i_v1352 + i_v369 + i_v1357;
            i_v1359 = i_v1358 ^ i_v1354;
            i_v1360 = i_v1359 / 256 | 0x1000000 * i_v1359;
            i_v1361 = i_v1360 + i_v1355;
            i_v1362 = i_v1361 ^ i_v1357;
            i_v1363 = i_v1362 / 128 | 0x2000000 * i_v1362;
            i_v1364 = i_v1322 + i_v376 + i_v1339;
            i_v1365 = i_v1364 ^ i_v1312;
            i_v1366 = i_v1365 / 0x10000 | 0x10000 * i_v1365;
            i_v1367 = i_v1366 + i_v1301;
            i_v1368 = i_v1367 ^ i_v1339;
            i_v1369 = i_v1368 / 0x1000 | 0x100000 * i_v1368;
            i_v1370 = i_v1364 + i_v383 + i_v1369;
            i_v1371 = i_v1370 ^ i_v1366;
            i_v1372 = i_v1371 / 256 | 0x1000000 * i_v1371;
            i_v1373 = i_v1372 + i_v1367;
            i_v1374 = i_v1373 ^ i_v1369;
            i_v1375 = i_v1374 / 128 | 0x2000000 * i_v1374;
            i_v1376 = i_v1334 + i_v390 + i_v1303;
            i_v1377 = i_v1376 ^ i_v1324;
            i_v1378 = i_v1377 / 0x10000 | 0x10000 * i_v1377;
            i_v1379 = i_v1378 + i_v1313;
            i_v1380 = i_v1379 ^ i_v1303;
            i_v1381 = i_v1380 / 0x1000 | 0x100000 * i_v1380;
            i_v1382 = i_v1376 + i_v397 + i_v1381;
            i_v1383 = i_v1382 ^ i_v1378;
            i_v1384 = i_v1383 / 256 | 0x1000000 * i_v1383;
            i_v1385 = i_v1384 + i_v1379;
            i_v1386 = i_v1385 ^ i_v1381;
            i_v1387 = i_v1386 / 128 | 0x2000000 * i_v1386;
            i_v1388 = i_v1346 + i_v404 + i_v1387;
            i_v1389 = i_v1388 ^ i_v1360;
            i_v1390 = i_v1389 / 0x10000 | 0x10000 * i_v1389;
            i_v1391 = i_v1390 + i_v1373;
            i_v1392 = i_v1391 ^ i_v1387;
            i_v1393 = i_v1392 / 0x1000 | 0x100000 * i_v1392;
            i_v1394 = i_v1388 + i_v411 + i_v1393;
            i_v1395 = i_v1394 ^ i_v1390;
            i_v1396 = i_v1395 / 256 | 0x1000000 * i_v1395;
            i_v1397 = i_v1396 + i_v1391;
            i_v1398 = i_v1397 ^ i_v1393;
            i_v1399 = i_v1398 / 128 | 0x2000000 * i_v1398;
            i_v1400 = i_v1358 + i_v418 + i_v1351;
            i_v1401 = i_v1400 ^ i_v1372;
            i_v1402 = i_v1401 / 0x10000 | 0x10000 * i_v1401;
            i_v1403 = i_v1402 + i_v1385;
            i_v1404 = i_v1403 ^ i_v1351;
            i_v1405 = i_v1404 / 0x1000 | 0x100000 * i_v1404;
            i_v1406 = i_v1400 + i_v425 + i_v1405;
            i_v1407 = i_v1406 ^ i_v1402;
            i_v1408 = i_v1407 / 256 | 0x1000000 * i_v1407;
            i_v1409 = i_v1408 + i_v1403;
            i_v1410 = i_v1409 ^ i_v1405;
            i_v1411 = i_v1410 / 128 | 0x2000000 * i_v1410;
            i_v1412 = i_v1370 + i_v161 + i_v1363;
            i_v1413 = i_v1412 ^ i_v1384;
            i_v1414 = i_v1413 / 0x10000 | 0x10000 * i_v1413;
            i_v1415 = i_v1414 + i_v1349;
            i_v1416 = i_v1415 ^ i_v1363;
            i_v1417 = i_v1416 / 0x1000 | 0x100000 * i_v1416;
            i_v1418 = i_v1412 + i_v154 + i_v1417;
            i_v1419 = i_v1418 ^ i_v1414;
            i_v1420 = i_v1419 / 256 | 0x1000000 * i_v1419;
            i_v1421 = i_v1420 + i_v1415;
            i_v1422 = i_v1421 ^ i_v1417;
            i_v1423 = i_v1422 / 128 | 0x2000000 * i_v1422;
            i_v1424 = i_v1382 + i_v444 + i_v1375;
            i_v1425 = i_v1424 ^ i_v1348;
            i_v1426 = i_v1425 / 0x10000 | 0x10000 * i_v1425;
            i_v1427 = i_v1426 + i_v1361;
            i_v1428 = i_v1427 ^ i_v1375;
            i_v1429 = i_v1428 / 0x1000 | 0x100000 * i_v1428;
            i_v1430 = i_v1424 + i_v451 + i_v1429;
            i_v1431 = i_v1430 ^ i_v1426;
            i_v1432 = i_v1431 / 256 | 0x1000000 * i_v1431;
            i_v1433 = i_v1432 + i_v1427;
            i_v1434 = i_v1433 ^ i_v1429;
            i_v1435 = i_v1434 / 128 | 0x2000000 * i_v1434;
            i_v1436 = i_v1394 + i_v458 + i_v1411;
            i_v1437 = i_v1436 ^ i_v1432;
            i_v1438 = i_v1437 / 0x10000 | 0x10000 * i_v1437;
            i_v1439 = i_v1438 + i_v1421;
            i_v1440 = i_v1439 ^ i_v1411;
            i_v1441 = i_v1440 / 0x1000 | 0x100000 * i_v1440;
            i_v1442 = i_v1436 + i_v465 + i_v1441;
            i_v1443 = i_v1442 ^ i_v1438;
            i_v1444 = i_v1443 / 256 | 0x1000000 * i_v1443;
            i_v1445 = i_v1444 + i_v1439;
            i_v1446 = i_v1445 ^ i_v1441;
            i_v1447 = i_v1406 + i_v472 + i_v1423;
            i_v1448 = i_v1447 ^ i_v1396;
            i_v1449 = i_v1448 / 0x10000 | 0x10000 * i_v1448;
            i_v1450 = i_v1449 + i_v1433;
            i_v1451 = i_v1450 ^ i_v1423;
            i_v1452 = i_v1451 / 0x1000 | 0x100000 * i_v1451;
            i_v1453 = i_v1447 + i_v479 + i_v1452;
            i_v1454 = i_v1453 ^ i_v1449;
            i_v1455 = i_v1454 / 256 | 0x1000000 * i_v1454;
            i_v1456 = i_v1455 + i_v1450;
            i_v1457 = i_v1456 ^ i_v1452;
            i_v1458 = i_v1418 + i_v486 + i_v1435;
            i_v1459 = i_v1458 ^ i_v1408;
            i_v1460 = i_v1459 / 0x10000 | 0x10000 * i_v1459;
            i_v1461 = i_v1460 + i_v1397;
            i_v1462 = i_v1461 ^ i_v1435;
            i_v1463 = i_v1462 / 0x1000 | 0x100000 * i_v1462;
            i_v1464 = i_v1458 + i_v493 + i_v1463;
            i_v1465 = i_v1464 ^ i_v1460;
            i_v1466 = i_v1465 / 256 | 0x1000000 * i_v1465;
            i_v1467 = i_v1466 + i_v1461;
            i_v1468 = i_v1467 ^ i_v1463;
            i_v1469 = i_v1430 + i_v500 + i_v1399;
            i_v1470 = i_v1469 ^ i_v1420;
            i_v1471 = i_v1470 / 0x10000 | 0x10000 * i_v1470;
            i_v1472 = i_v1471 + i_v1409;
            i_v1473 = i_v1472 ^ i_v1399;
            i_v1474 = i_v1473 / 0x1000 | 0x100000 * i_v1473;
            i_v1475 = i_v1469 + i_v507 + i_v1474;
            i_v1476 = i_v1475 ^ i_v1471;
            i_v1477 = i_v1476 / 256 | 0x1000000 * i_v1476;
            i_v1478 = i_v1477 + i_v1472;
            i_v1479 = i_v1478 ^ i_v1474;
            i_v1480 = i_v1488 ^ i_v22 ^ i_v1442 ^ i_v1467;
            i_v1481 = i_v1489 ^ i_v24 ^ i_v1453 ^ i_v1478;
            i_v1482 = i_v1490 ^ i_v26 ^ i_v1464 ^ i_v1445;
            i_v1483 = i_v1491 ^ i_v28 ^ i_v1475 ^ i_v1456;
            i_v1484 = i_v1492 ^ i_v22 ^ (i_v1479 / 128 | 0x2000000 * i_v1479) ^
                      i_v1455;
            i_v1485 = i_v1493 ^ i_v24 ^ (i_v1446 / 128 | 0x2000000 * i_v1446) ^
                      i_v1466;
            i_v1486 = i_v1494 ^ i_v26 ^ i_v1477 ^
                      (i_v1457 / 128 | 0x2000000 * i_v1457);
            i_v1487 = i_v1495 ^ i_v28 ^ i_v1444 ^
                      (i_v1468 / 128 | 0x2000000 * i_v1468);
            i_v33 = i_v1480;
            i_v34 = i_v1481;
            i_v35 = i_v1482;
            i_v36 = i_v1483;
            i_v37 = i_v1484;
            i_v38 = i_v1485;
            i_v39 = i_v1486;
            i_v40 = i_v1487;
            i_v41 = i_v52;
            i_v42 = i_v53;
            i_v43 = 0;
            i_v44 = i_v69;
        }
    }
    goto lab_0x19c2e;
lab_0x19c2e:
    // 0x19c2e
    *p_v5 = i_v33;
    *p_v7 = i_v34;
    *p_v9 = i_v35;
    *p_v11 = i_v36;
    *p_v13 = i_v37;
    *p_v15 = i_v38;
    *p_v17 = i_v39;
    *p_v19 = i_v40;
    *p_v21 = i_v22;
    *p_v23 = i_v24;
    *p_v25 = i_v26;
    *p_v27 = i_v28;
    *p_v29 = i_v41;
    *p_v31 = i_v42;
    // 0x19ca6
    *p_v1 = i_v43;
    return i_v44;
}

// Address range: 0x19cb0 - 0x19e8c
int32_t blake32_close(int32_t i_a1, int32_t i_a2, uint32_t i_a3, int32_t i_a4,
                      uint32_t i_a5) {
    int32_t i_v1 = *(int32_t *)(i_a1 + 64); // 0x19cc0
    uint32_t i_v2 = 8 * i_v1 + i_a3;        // 0x19cca
    int32_t i_v3 = 128 >> i_a3;             // 0x19cd2
    int32_t i_v4;                           // bp-100, 0x19cb0
    int32_t i_v5 = &i_v4;                   // 0x19cf0
    int32_t i_v6 = i_v1 + i_v5;
    *(char *)i_v6 = (char)(-i_v3 & i_a2 | i_v3);
    int32_t *p_v7 = (int32_t *)(i_a1 + 116);  // 0x19cfc
    int32_t i_v8 = *p_v7;                     // 0x19cfc
    int32_t i_v9 = i_v8 + i_v2;               // 0x19d00
    int32_t *p_v10 = (int32_t *)(i_a1 + 120); // 0x19d06
    int32_t i_v11 = *p_v10;                   // 0x19d06
    if ((i_v1 || i_a3) == 0) {
        // 0x19d16
        *p_v7 = -512;
        *p_v10 = -1;
    } else {
        if (i_v8 == 0) {
            // 0x19d34
            *p_v7 = i_v2 - 512;
            *p_v10 = *p_v10 - 1;
        } else {
            // 0x19d4a
            *p_v7 = i_v9 - 512;
        }
    }
    int32_t i_v12 = i_v6 + 1;
    int32_t i_v13; // bp-40, 0x19cb0
    int32_t i_v14; // bp-44, 0x19cb0
    int32_t i_v15; // 0x19cb0
    if (i_v2 >= 446 == (i_v2 != 446)) {
        // 0x19dc6
        memset((int32_t *)i_v12, 0, 63 - i_v1);
        blake32(i_a1, i_v6, 64 - i_v1);
        *p_v7 = -512;
        *p_v10 = -1;
        memset(&i_v4, 0, 56);
        sph_enc32be_aligned(&i_v14, i_v11);
        sph_enc32be_aligned(&i_v13, i_v9);
        i_v15 = blake32(i_a1, i_v5, 64);
    } else {
        // 0x19d62
        memset((int32_t *)i_v12, 0, 55 - i_v1);
        sph_enc32be_aligned(&i_v14, i_v11);
        sph_enc32be_aligned(&i_v13, i_v9);
        i_v15 = blake32(i_a1, i_v6, 64 - i_v1);
    }
    // 0x19e50
    if (i_a5 == 0) {
        // 0x19e84
        return i_v15;
    }
    int32_t i_v16 = 0;         // 0x19e78
    int32_t i_v17 = 4 * i_v16; // 0x19e5c
    i_v16++;
    int32_t i_v18 =
        sph_enc32be(i_v17 + i_a4, *(int32_t *)(i_a1 + 68 + i_v17)); // 0x19e82
    while (i_v16 < i_a5) {
        // 0x19e5a
        i_v17 = 4 * i_v16;
        i_v16++;
        i_v18 = sph_enc32be(i_v17 + i_a4, *(int32_t *)(i_a1 + 68 + i_v17));
    }
    // 0x19e84
    return i_v18;
}

// Address range: 0x19e8c - 0x19ede
int32_t blake64_init(int32_t i_a1, int32_t *p_a2, int32_t *p_a3) {
    // 0x19e8c
    memcpy((int32_t *)(i_a1 + 136), p_a2, 64);
    int32_t *p_v1 = memcpy((int32_t *)(i_a1 + 200), p_a3, 32); // 0x19eb0
    int32_t i_v2 = i_a1 + 240;                                 // 0x19ebe
    *(int32_t *)i_v2 = 0;
    *(int32_t *)(i_a1 + 244) = 0;
    uint64_t i_v3 = *(int64_t *)i_v2; // 0x19ec4
    *(int32_t *)(i_a1 + 232) = (int32_t)(i_v3 / 0x100000000);
    *(int32_t *)(i_a1 + 236) = (int32_t)i_v3;
    *(int32_t *)(i_a1 + 128) = 0;
    return (int32_t)p_v1;
}

// Address range: 0x19ee0 - 0x1b686
int32_t blake64(int32_t i_a1, int32_t i_a2, uint32_t i_a3, int32_t i_a4) {
    int32_t *p_v1 = (int32_t *)(i_a1 + 128); // 0x19f0c
    int32_t i_v2 = *p_v1;                    // 0x19f0c
    uint32_t i_v3 = 128 - i_v2;              // 0x19f18
    if (i_v3 != i_a3 && i_v3 >= i_a3) {
        int32_t *p_v4 =
            memcpy((int32_t *)(i_v2 + i_a1), (int32_t *)i_a2, i_a3); // 0x19f3e
        // 0x1b67c
        *p_v1 = i_v2 + i_a3;
        return (int32_t)p_v4;
    }
    int32_t i_v5 = i_a1 + 136;                // 0x19f6a
    int32_t i_v6 = i_a1 + 144;                // 0x19f7c
    int32_t i_v7 = i_a1 + 152;                // 0x19f8e
    int32_t i_v8 = i_a1 + 160;                // 0x19fa0
    int32_t i_v9 = i_a1 + 168;                // 0x19fb2
    int32_t i_v10 = i_a1 + 176;               // 0x19fc4
    int32_t i_v11 = i_a1 + 184;               // 0x19fd6
    int32_t i_v12 = i_a1 + 192;               // 0x19fe8
    int32_t i_v13 = i_a1 + 200;               // 0x19ffa
    uint64_t i_v14 = *(int64_t *)i_v13 >> 32; // 0x1a002
    int32_t i_v15 = i_a1 + 208;               // 0x1a00c
    uint64_t i_v16 = *(int64_t *)i_v15 >> 32; // 0x1a014
    int32_t i_v17 = i_a1 + 216;               // 0x1a022
    uint64_t i_v18 = *(int64_t *)i_v17 >> 32; // 0x1a026
    int32_t i_v19 = i_a1 + 224;               // 0x1a034
    uint64_t i_v20 = *(int64_t *)i_v19 >> 32; // 0x1a038
    int32_t i_v21 = i_a1 + 232;               // 0x1a042
    uint64_t i_v22 = *(int64_t *)i_v21 >> 32; // 0x1a04a
    int32_t i_v23 = i_a1 + 240;               // 0x1a054
    int64_t i_v24 = *(int64_t *)i_v23 >> 32;  // bp-120, 0x1a05c
    int32_t i_v25;                            // bp-424, 0x19ee0
    int32_t i_v26 = &i_v25;
    int32_t i_v27 = i_a2;                    // 0x1a060
    int32_t i_v28 = i_a3;                    // 0x1a060
    int32_t i_v29 = i_v2;                    // 0x1a060
    int64_t i_v30 = *(int64_t *)i_v5 >> 32;  // 0x1a060
    int64_t i_v31 = *(int64_t *)i_v6 >> 32;  // 0x1a060
    int64_t i_v32 = *(int64_t *)i_v7 >> 32;  // 0x1a060
    int64_t i_v33 = *(int64_t *)i_v8 >> 32;  // 0x1a060
    int64_t i_v34 = *(int64_t *)i_v9 >> 32;  // 0x1a060
    int64_t i_v35 = *(int64_t *)i_v10 >> 32; // 0x1a060
    int64_t i_v36 = *(int64_t *)i_v11 >> 32; // 0x1a060
    int64_t i_v37 = *(int64_t *)i_v12 >> 32; // 0x1a060
    int32_t i_v38 = i_v22;                   // 0x1a060
    int32_t i_v39 = i_v22 / 0x100000000;     // 0x1a060
    int64_t i_v40;                           // 0x19ee0
    int32_t i_v41;                           // 0x19ee0
    int32_t i_v42;                           // 0x19ee0
    int32_t i_v43;                           // 0x19ee0
    int64_t i_v44;                           // 0x19ee0
    int64_t i_v45;                           // 0x19ee0
    int64_t i_v46;                           // 0x19ee0
    int64_t i_v47;                           // 0x19ee0
    int64_t i_v48;                           // 0x19ee0
    int64_t i_v49;                           // 0x19ee0
    int64_t i_v50;                           // 0x19ee0
    while (true) {
        // 0x1b566
        i_v42 = i_v39;
        i_v41 = i_v38;
        i_v40 = i_v37;
        i_v50 = i_v36;
        i_v49 = i_v35;
        i_v48 = i_v34;
        i_v47 = i_v33;
        i_v46 = i_v32;
        i_v45 = i_v31;
        i_v44 = i_v30;
        i_v43 = i_v29;
        uint32_t i_v51 = i_v28;
        if (i_v51 == 0) {
            // break (via goto) -> 0x1b572
            goto lab_0x1b572;
        }
        uint32_t i_v52 = 128 - i_v43; // 0x1a068
        int32_t i_v53 = i_v52 == i_v51 | i_v52 < i_v51 ? i_v52 : i_v51;
        memcpy((int32_t *)(i_v43 + i_a1), (int32_t *)i_v27, i_v53);
        int32_t i_v54 = i_v53 + i_v43; // 0x1a0aa
        i_v27 += i_v53;
        i_v28 = i_v51 - i_v53;
        int32_t i_v55 = i_v27; // 0x1a0da
        while (i_v54 != 128) {
            // 0x1b566
            i_v43 = i_v54;
            i_v51 = i_v28;
            if (i_v51 == 0) {
                // break (via goto) -> 0x1b572
                goto lab_0x1b572;
            }
            // 0x1a064
            i_v52 = 128 - i_v43;
            i_v53 = i_v52 == i_v51 | i_v52 < i_v51 ? i_v52 : i_v51;
            memcpy((int32_t *)(i_v43 + i_a1), (int32_t *)i_v55, i_v53);
            i_v54 = i_v53 + i_v43;
            i_v27 = i_v53 + i_v55;
            i_v28 = i_v51 - i_v53;
            i_v55 = i_v27;
        }
        // 0x1a0de
        i_v38 = i_v42 + 1024;
        i_v39 = i_v38 >> 31;
        int32_t i_v56 = i_v39; // 0x1a108
        if (i_v38 == 0) {
            i_v56 = __asm_it();
        }
        if (!((i_v38 == 0 ? i_v56 > 1023 : i_v38 != 0))) {
            // 0x1a10e
            i_v24 = (int32_t)((0x100000000 * i_v24 >> 32) / 0x100000000) + 1;
        }
        int64_t i_v57 = i_v38;                      // 0x1a0f2
        uint64_t i_v58 = i_v48 >> 31;               // 0x1a170
        uint64_t i_v59 = i_v49 >> 31;               // 0x1a180
        uint64_t i_v60 = i_v50 >> 31;               // 0x1a190
        uint64_t i_v61 = i_v40 >> 31;               // 0x1a1a0
        int64_t i_v62 = *(int64_t *)__asm_adr(560); // 0x1a1ae
        int64_t i_v63 = *(int64_t *)__asm_adr(540); // 0x1a1cc
        int64_t i_v64 = *(int64_t *)__asm_adr(516); // 0x1a1ea
        int64_t i_v65 = *(int64_t *)__asm_adr(496); // 0x1a208
        int64_t i_v66 = *(int64_t *)__asm_adr(472); // 0x1a226
        int64_t i_v67 = *(int64_t *)__asm_adr(452); // 0x1a244
        int64_t i_v68 = *(int64_t *)__asm_adr(428); // 0x1a262
        int64_t i_v69 = *(int64_t *)__asm_adr(408); // 0x1a280
        i_v25 = sph_dec64be_aligned(i_a1);
        sph_dec64be_aligned(i_a1 + 8);
        sph_dec64be_aligned(i_a1 + 16);
        sph_dec64be_aligned(i_a1 + 24);
        sph_dec64be_aligned(i_a1 + 32);
        sph_dec64be_aligned(i_a1 + 40);
        sph_dec64be_aligned(i_a1 + 48);
        sph_dec64be_aligned(i_a1 + 56);
        sph_dec64be_aligned(i_a1 + 64);
        sph_dec64be_aligned(i_a1 + 72);
        sph_dec64be_aligned(i_a1 + 80);
        sph_dec64be_aligned(i_a1 + 88);
        sph_dec64be_aligned(i_a1 + 96);
        sph_dec64be_aligned(i_a1 + 104);
        sph_dec64be_aligned(i_a1 + 112);
        sph_dec64be_aligned(i_a1 + 120);
        int32_t i_v70 = 0;                                         // 0x1b350
        int32_t i_v71 = i_v61 / 0x100000000;                       // 0x19ee0
        int32_t i_v72 = i_v60 / 0x100000000;                       // 0x19ee0
        int32_t i_v73 = i_v59 / 0x100000000;                       // 0x19ee0
        int32_t i_v74 = i_v58 / 0x100000000;                       // 0x19ee0
        int32_t i_v75 = (i_v47 >> 31) / 0x100000000;               // 0x19ee0
        int32_t i_v76 = (i_v46 >> 31) / 0x100000000;               // 0x19ee0
        int32_t i_v77 = (i_v45 >> 31) / 0x100000000;               // 0x19ee0
        int32_t i_v78 = (i_v44 >> 31) / 0x100000000;               // 0x19ee0
        int32_t i_v79 = 64 * i_v70;                                // 0x1a442
        int32_t i_v80 = 8 * *(int32_t *)(i_v79 + (int32_t)&i_g79); // 0x1a44c
        int64_t i_v81 = *(int64_t *)(i_v80 + i_v26);               // 0x1a450
        int32_t i_v82 =
            8 * *(int32_t *)(i_v79 + (int32_t)&i_g79 + 4);     // 0x1a470
        int64_t i_v83 = *(int64_t *)(i_v82 + (int32_t)&p_g89); // 0x1a474
        int32_t i_v84 =
            i_v78 + i_v74 + (int32_t)((i_v83 ^ i_v81) / 0x100000000); // 0x1a480
        int32_t i_v85 =
            (i_v84 ^ (int32_t)((i_v66 ^ i_v57) / 0x100000000)) >> 31;
        int32_t i_v86 = i_v85 + (int32_t)((i_v62 ^ i_v14) / 0x100000000 /
                                          0x100000000); // 0x1a4ca
        int32_t i_v87 = 128 * (i_v86 ^ (int32_t)i_v58) >> 31;
        int64_t i_v88 = *(int64_t *)(i_v82 + i_v26);           // 0x1a542
        int64_t i_v89 = *(int64_t *)(i_v80 + (int32_t)&p_g89); // 0x1a564
        int32_t i_v90 = (i_v84 >> 31) +
                        (int32_t)((i_v89 ^ i_v88) / 0x100000000) +
                        i_v87; // 0x1a570
        int32_t i_v91 = 0x10000 * (i_v90 ^ i_v85) >> 31;
        int32_t i_v92 = i_v91 + (i_v86 >> 31); // 0x1a5c6
        int32_t i_v93 = (i_v92 ^ i_v87) >> 10;
        int32_t i_v94 =
            8 * *(int32_t *)(i_v79 + (int32_t)&i_g79 + 8); // 0x1a63a
        int64_t i_v95 = *(int64_t *)(i_v94 + i_v26);       // 0x1a63e
        int32_t i_v96 =
            8 * *(int32_t *)(i_v79 + (int32_t)&i_g79 + 12);    // 0x1a65e
        int64_t i_v97 = *(int64_t *)(i_v96 + (int32_t)&p_g89); // 0x1a662
        int32_t i_v98 =
            i_v77 + i_v73 + (int32_t)((i_v97 ^ i_v95) / 0x100000000); // 0x1a66e
        int32_t i_v99 =
            (i_v98 ^ (int32_t)((i_v67 ^ i_v57) / 0x100000000)) >> 31;
        int32_t i_v100 = i_v99 + (int32_t)((i_v63 ^ i_v16) / 0x100000000 /
                                           0x100000000); // 0x1a6b8
        int32_t i_v101 = 128 * (i_v100 ^ (int32_t)i_v59) >> 31;
        int64_t i_v102 = *(int64_t *)(i_v96 + i_v26);           // 0x1a730
        int64_t i_v103 = *(int64_t *)(i_v94 + (int32_t)&p_g89); // 0x1a754
        int32_t i_v104 = (i_v98 >> 31) +
                         (int32_t)((i_v103 ^ i_v102) / 0x100000000) +
                         i_v101; // 0x1a760
        int32_t i_v105 = 0x10000 * (i_v104 ^ i_v99) >> 31;
        int32_t i_v106 = i_v105 + (i_v100 >> 31); // 0x1a7b6
        int32_t i_v107 = (i_v106 ^ i_v101) >> 10;
        int32_t i_v108 =
            8 * *(int32_t *)(i_v79 + (int32_t)&i_g79 + 16); // 0x1a82a
        int64_t i_v109 = *(int64_t *)(i_v108 + i_v26);      // 0x1a82e
        int32_t i_v110 =
            8 * *(int32_t *)(i_v79 + (int32_t)&i_g79 + 20);      // 0x1a84e
        int64_t i_v111 = *(int64_t *)(i_v110 + (int32_t)&p_g89); // 0x1a852
        int32_t i_v112 = i_v76 + i_v72 +
                         (int32_t)((i_v111 ^ i_v109) / 0x100000000); // 0x1a85e
        int32_t i_v113 =
            (i_v112 ^
             (int32_t)((i_v68 ^ 0x100000000 * i_v24 >> 32) / 0x100000000)) >>
            31;
        int32_t i_v114 = i_v113 + (int32_t)((i_v64 ^ i_v18) / 0x100000000 /
                                            0x100000000); // 0x1a8a8
        int32_t i_v115 = 128 * (i_v114 ^ (int32_t)i_v60) >> 31;
        int64_t i_v116 = *(int64_t *)(i_v110 + i_v26);           // 0x1a920
        int64_t i_v117 = *(int64_t *)(i_v108 + (int32_t)&p_g89); // 0x1a944
        int32_t i_v118 = (i_v112 >> 31) +
                         (int32_t)((i_v117 ^ i_v116) / 0x100000000) +
                         i_v115; // 0x1a950
        int32_t i_v119 = 0x10000 * (i_v118 ^ i_v113) >> 31;
        int32_t i_v120 = i_v119 + (i_v114 >> 31); // 0x1a9a6
        int32_t i_v121 = (i_v120 ^ i_v115) >> 10;
        int32_t i_v122 =
            8 * *(int32_t *)(i_v79 + (int32_t)&i_g79 + 24); // 0x1aa1a
        int64_t i_v123 = *(int64_t *)(i_v122 + i_v26);      // 0x1aa1e
        int32_t i_v124 =
            8 * *(int32_t *)(i_v79 + (int32_t)&i_g79 + 28);      // 0x1aa3e
        int64_t i_v125 = *(int64_t *)(i_v124 + (int32_t)&p_g89); // 0x1aa42
        int32_t i_v126 = i_v75 + i_v71 +
                         (int32_t)((i_v125 ^ i_v123) / 0x100000000); // 0x1aa4e
        int32_t i_v127 =
            (i_v126 ^
             (int32_t)((i_v69 ^ 0x100000000 * i_v24 >> 32) / 0x100000000)) >>
            31;
        int32_t i_v128 = i_v127 + (int32_t)((i_v65 ^ i_v20) / 0x100000000 /
                                            0x100000000); // 0x1aa98
        int32_t i_v129 = 128 * (i_v128 ^ (int32_t)i_v61) >> 31;
        int64_t i_v130 = *(int64_t *)(i_v124 + i_v26);           // 0x1ab10
        int64_t i_v131 = *(int64_t *)(i_v122 + (int32_t)&p_g89); // 0x1ab34
        int32_t i_v132 = (i_v126 >> 31) +
                         (int32_t)((i_v131 ^ i_v130) / 0x100000000) +
                         i_v129; // 0x1ab40
        int32_t i_v133 = 0x10000 * (i_v132 ^ i_v127) >> 31;
        int32_t i_v134 = i_v133 + (i_v128 >> 31); // 0x1ab92
        int32_t i_v135 = (i_v134 ^ i_v129) >> 10;
        int32_t i_v136 =
            8 * *(int32_t *)(i_v79 + (int32_t)&i_g79 + 32); // 0x1ac02
        int64_t i_v137 = *(int64_t *)(i_v136 + i_v26);      // 0x1ac06
        int32_t i_v138 =
            8 * *(int32_t *)(i_v79 + (int32_t)&i_g79 + 36);      // 0x1ac26
        int64_t i_v139 = *(int64_t *)(i_v138 + (int32_t)&p_g89); // 0x1ac2a
        int32_t i_v140 = i_v107 + (i_v90 >> 31) +
                         (int32_t)((i_v139 ^ i_v137) / 0x100000000); // 0x1ac36
        int32_t i_v141 = (i_v133 ^ i_v140) >> 31;
        int32_t i_v142 = i_v141 + (i_v120 >> 31); // 0x1ac7c
        int32_t i_v143 = (i_v142 ^ i_v107) >> 24;
        int64_t i_v144 = *(int64_t *)(i_v138 + i_v26);           // 0x1acf0
        int64_t i_v145 = *(int64_t *)(i_v136 + (int32_t)&p_g89); // 0x1ad14
        int32_t i_v146 = (i_v140 >> 31) +
                         (int32_t)((i_v145 ^ i_v144) / 0x100000000) +
                         i_v143; // 0x1ad20
        int32_t i_v147 = 0x10000 * (i_v146 ^ i_v141) >> 31;
        int32_t i_v148 = i_v147 + (i_v142 >> 31); // 0x1ad72
        int32_t i_v149 = (i_v148 ^ i_v143) >> 10;
        int32_t i_v150 =
            8 * *(int32_t *)(i_v79 + (int32_t)&i_g79 + 40); // 0x1ade2
        int64_t i_v151 = *(int64_t *)(i_v150 + i_v26);      // 0x1ade6
        int32_t i_v152 =
            8 * *(int32_t *)(i_v79 + (int32_t)&i_g79 + 44);      // 0x1ae06
        int64_t i_v153 = *(int64_t *)(i_v152 + (int32_t)&p_g89); // 0x1ae0a
        int32_t i_v154 = i_v121 + (i_v104 >> 31) +
                         (int32_t)((i_v153 ^ i_v151) / 0x100000000); // 0x1ae16
        int32_t i_v155 = (i_v154 ^ i_v91) >> 31;
        int32_t i_v156 = i_v155 + (i_v134 >> 31); // 0x1ae5c
        int32_t i_v157 = (i_v156 ^ i_v121) >> 24;
        int64_t i_v158 = *(int64_t *)(i_v152 + i_v26);           // 0x1aed0
        int64_t i_v159 = *(int64_t *)(i_v150 + (int32_t)&p_g89); // 0x1aef4
        int32_t i_v160 = (i_v154 >> 31) +
                         (int32_t)((i_v159 ^ i_v158) / 0x100000000) +
                         i_v157; // 0x1af00
        int32_t i_v161 = 0x10000 * (i_v160 ^ i_v155) >> 31;
        int32_t i_v162 = i_v161 + (i_v156 >> 31); // 0x1af52
        int32_t i_v163 = (i_v162 ^ i_v157) >> 10;
        int32_t i_v164 =
            8 * *(int32_t *)(i_v79 + (int32_t)&i_g79 + 48); // 0x1afc2
        int64_t i_v165 = *(int64_t *)(i_v164 + i_v26);      // 0x1afc6
        int32_t i_v166 =
            8 * *(int32_t *)(i_v79 + (int32_t)&i_g79 + 52);      // 0x1afe6
        int64_t i_v167 = *(int64_t *)(i_v166 + (int32_t)&p_g89); // 0x1afea
        int32_t i_v168 = i_v135 + (i_v118 >> 31) +
                         (int32_t)((i_v167 ^ i_v165) / 0x100000000); // 0x1aff6
        int32_t i_v169 = (i_v168 ^ i_v105) >> 31;
        int32_t i_v170 = i_v169 + (i_v92 >> 31); // 0x1b03c
        int32_t i_v171 = (i_v170 ^ i_v135) >> 24;
        int64_t i_v172 = *(int64_t *)(i_v166 + i_v26);           // 0x1b0b0
        int64_t i_v173 = *(int64_t *)(i_v164 + (int32_t)&p_g89); // 0x1b0d4
        int32_t i_v174 = (i_v168 >> 31) +
                         (int32_t)((i_v173 ^ i_v172) / 0x100000000) +
                         i_v171; // 0x1b0e0
        int32_t i_v175 = 0x10000 * (i_v174 ^ i_v169) >> 31;
        int32_t i_v176 = i_v175 + (i_v170 >> 31); // 0x1b132
        int32_t i_v177 = (i_v176 ^ i_v171) >> 10;
        int32_t i_v178 =
            8 * *(int32_t *)(i_v79 + (int32_t)&i_g79 + 56); // 0x1b1a2
        int64_t i_v179 = *(int64_t *)(i_v178 + i_v26);      // 0x1b1a6
        int32_t i_v180 =
            8 * *(int32_t *)(i_v79 + (int32_t)&i_g79 + 60);      // 0x1b1c6
        int64_t i_v181 = *(int64_t *)(i_v180 + (int32_t)&p_g89); // 0x1b1ca
        int32_t i_v182 = (i_v132 >> 31) + i_v93 +
                         (int32_t)((i_v181 ^ i_v179) / 0x100000000); // 0x1b1d6
        int32_t i_v183 = (i_v182 ^ i_v119) >> 31;
        int32_t i_v184 = i_v183 + (i_v106 >> 31); // 0x1b21c
        int32_t i_v185 = (i_v184 ^ i_v93) >> 24;
        int64_t i_v186 = *(int64_t *)(i_v180 + i_v26);           // 0x1b290
        int64_t i_v187 = *(int64_t *)(i_v178 + (int32_t)&p_g89); // 0x1b2b4
        int32_t i_v188 = (i_v182 >> 31) +
                         (int32_t)((i_v187 ^ i_v186) / 0x100000000) +
                         i_v185;                          // 0x1b2c0
        int32_t i_v189 = 0x10000 * (i_v188 ^ i_v183);     // 0x1b2ee
        int32_t i_v190 = (i_v189 >> 31) + (i_v184 >> 31); // 0x1b30e
        int32_t i_v191 = i_v190 ^ i_v185;
        int32_t i_v192 = 0x200000 * i_v191; // 0x1b33c
        i_v70++;
        while (i_v70 == 15 || i_v70 < 15) {
            // 0x1a420
            i_v79 = 64 * i_v70;
            i_v80 = 8 * *(int32_t *)(i_v79 + (int32_t)&i_g79);
            i_v81 = *(int64_t *)(i_v80 + i_v26);
            i_v82 = 8 * *(int32_t *)(i_v79 + (int32_t)&i_g79 + 4);
            i_v83 = *(int64_t *)(i_v82 + (int32_t)&p_g89);
            i_v84 = (i_v146 >> 31) + (i_v191 >> 10) +
                    (int32_t)((i_v83 ^ i_v81) / 0x100000000);
            i_v85 = (i_v84 ^ i_v161) >> 31;
            i_v86 = i_v85 + (i_v176 >> 31);
            i_v87 = 128 * (i_v86 ^ i_v192) >> 31;
            i_v88 = *(int64_t *)(i_v82 + i_v26);
            i_v89 = *(int64_t *)(i_v80 + (int32_t)&p_g89);
            i_v90 = (i_v84 >> 31) + (int32_t)((i_v89 ^ i_v88) / 0x100000000) +
                    i_v87;
            i_v91 = 0x10000 * (i_v90 ^ i_v85) >> 31;
            i_v92 = i_v91 + (i_v86 >> 31);
            i_v93 = (i_v92 ^ i_v87) >> 10;
            i_v94 = 8 * *(int32_t *)(i_v79 + (int32_t)&i_g79 + 8);
            i_v95 = *(int64_t *)(i_v94 + i_v26);
            i_v96 = 8 * *(int32_t *)(i_v79 + (int32_t)&i_g79 + 12);
            i_v97 = *(int64_t *)(i_v96 + (int32_t)&p_g89);
            i_v98 = (i_v160 >> 31) + i_v149 +
                    (int32_t)((i_v97 ^ i_v95) / 0x100000000);
            i_v99 = (i_v98 ^ i_v175) >> 31;
            i_v100 = i_v99 + (i_v190 >> 31);
            i_v101 = 128 * (i_v100 ^ i_v149) >> 31;
            i_v102 = *(int64_t *)(i_v96 + i_v26);
            i_v103 = *(int64_t *)(i_v94 + (int32_t)&p_g89);
            i_v104 = (i_v98 >> 31) +
                     (int32_t)((i_v103 ^ i_v102) / 0x100000000) + i_v101;
            i_v105 = 0x10000 * (i_v104 ^ i_v99) >> 31;
            i_v106 = i_v105 + (i_v100 >> 31);
            i_v107 = (i_v106 ^ i_v101) >> 10;
            i_v108 = 8 * *(int32_t *)(i_v79 + (int32_t)&i_g79 + 16);
            i_v109 = *(int64_t *)(i_v108 + i_v26);
            i_v110 = 8 * *(int32_t *)(i_v79 + (int32_t)&i_g79 + 20);
            i_v111 = *(int64_t *)(i_v110 + (int32_t)&p_g89);
            i_v112 = (i_v174 >> 31) + i_v163 +
                     (int32_t)((i_v111 ^ i_v109) / 0x100000000);
            i_v113 = (i_v112 ^ i_v189) >> 31;
            i_v114 = i_v113 + (i_v148 >> 31);
            i_v115 = 128 * (i_v114 ^ i_v163) >> 31;
            i_v116 = *(int64_t *)(i_v110 + i_v26);
            i_v117 = *(int64_t *)(i_v108 + (int32_t)&p_g89);
            i_v118 = (i_v112 >> 31) +
                     (int32_t)((i_v117 ^ i_v116) / 0x100000000) + i_v115;
            i_v119 = 0x10000 * (i_v118 ^ i_v113) >> 31;
            i_v120 = i_v119 + (i_v114 >> 31);
            i_v121 = (i_v120 ^ i_v115) >> 10;
            i_v122 = 8 * *(int32_t *)(i_v79 + (int32_t)&i_g79 + 24);
            i_v123 = *(int64_t *)(i_v122 + i_v26);
            i_v124 = 8 * *(int32_t *)(i_v79 + (int32_t)&i_g79 + 28);
            i_v125 = *(int64_t *)(i_v124 + (int32_t)&p_g89);
            i_v126 = (i_v188 >> 31) + i_v177 +
                     (int32_t)((i_v125 ^ i_v123) / 0x100000000);
            i_v127 = (i_v126 ^ i_v147) >> 31;
            i_v128 = i_v127 + (i_v162 >> 31);
            i_v129 = 128 * (i_v128 ^ i_v177) >> 31;
            i_v130 = *(int64_t *)(i_v124 + i_v26);
            i_v131 = *(int64_t *)(i_v122 + (int32_t)&p_g89);
            i_v132 = (i_v126 >> 31) +
                     (int32_t)((i_v131 ^ i_v130) / 0x100000000) + i_v129;
            i_v133 = 0x10000 * (i_v132 ^ i_v127) >> 31;
            i_v134 = i_v133 + (i_v128 >> 31);
            i_v135 = (i_v134 ^ i_v129) >> 10;
            i_v136 = 8 * *(int32_t *)(i_v79 + (int32_t)&i_g79 + 32);
            i_v137 = *(int64_t *)(i_v136 + i_v26);
            i_v138 = 8 * *(int32_t *)(i_v79 + (int32_t)&i_g79 + 36);
            i_v139 = *(int64_t *)(i_v138 + (int32_t)&p_g89);
            i_v140 = i_v107 + (i_v90 >> 31) +
                     (int32_t)((i_v139 ^ i_v137) / 0x100000000);
            i_v141 = (i_v133 ^ i_v140) >> 31;
            i_v142 = i_v141 + (i_v120 >> 31);
            i_v143 = (i_v142 ^ i_v107) >> 24;
            i_v144 = *(int64_t *)(i_v138 + i_v26);
            i_v145 = *(int64_t *)(i_v136 + (int32_t)&p_g89);
            i_v146 = (i_v140 >> 31) +
                     (int32_t)((i_v145 ^ i_v144) / 0x100000000) + i_v143;
            i_v147 = 0x10000 * (i_v146 ^ i_v141) >> 31;
            i_v148 = i_v147 + (i_v142 >> 31);
            i_v149 = (i_v148 ^ i_v143) >> 10;
            i_v150 = 8 * *(int32_t *)(i_v79 + (int32_t)&i_g79 + 40);
            i_v151 = *(int64_t *)(i_v150 + i_v26);
            i_v152 = 8 * *(int32_t *)(i_v79 + (int32_t)&i_g79 + 44);
            i_v153 = *(int64_t *)(i_v152 + (int32_t)&p_g89);
            i_v154 = i_v121 + (i_v104 >> 31) +
                     (int32_t)((i_v153 ^ i_v151) / 0x100000000);
            i_v155 = (i_v154 ^ i_v91) >> 31;
            i_v156 = i_v155 + (i_v134 >> 31);
            i_v157 = (i_v156 ^ i_v121) >> 24;
            i_v158 = *(int64_t *)(i_v152 + i_v26);
            i_v159 = *(int64_t *)(i_v150 + (int32_t)&p_g89);
            i_v160 = (i_v154 >> 31) +
                     (int32_t)((i_v159 ^ i_v158) / 0x100000000) + i_v157;
            i_v161 = 0x10000 * (i_v160 ^ i_v155) >> 31;
            i_v162 = i_v161 + (i_v156 >> 31);
            i_v163 = (i_v162 ^ i_v157) >> 10;
            i_v164 = 8 * *(int32_t *)(i_v79 + (int32_t)&i_g79 + 48);
            i_v165 = *(int64_t *)(i_v164 + i_v26);
            i_v166 = 8 * *(int32_t *)(i_v79 + (int32_t)&i_g79 + 52);
            i_v167 = *(int64_t *)(i_v166 + (int32_t)&p_g89);
            i_v168 = i_v135 + (i_v118 >> 31) +
                     (int32_t)((i_v167 ^ i_v165) / 0x100000000);
            i_v169 = (i_v168 ^ i_v105) >> 31;
            i_v170 = i_v169 + (i_v92 >> 31);
            i_v171 = (i_v170 ^ i_v135) >> 24;
            i_v172 = *(int64_t *)(i_v166 + i_v26);
            i_v173 = *(int64_t *)(i_v164 + (int32_t)&p_g89);
            i_v174 = (i_v168 >> 31) +
                     (int32_t)((i_v173 ^ i_v172) / 0x100000000) + i_v171;
            i_v175 = 0x10000 * (i_v174 ^ i_v169) >> 31;
            i_v176 = i_v175 + (i_v170 >> 31);
            i_v177 = (i_v176 ^ i_v171) >> 10;
            i_v178 = 8 * *(int32_t *)(i_v79 + (int32_t)&i_g79 + 56);
            i_v179 = *(int64_t *)(i_v178 + i_v26);
            i_v180 = 8 * *(int32_t *)(i_v79 + (int32_t)&i_g79 + 60);
            i_v181 = *(int64_t *)(i_v180 + (int32_t)&p_g89);
            i_v182 = (i_v132 >> 31) + i_v93 +
                     (int32_t)((i_v181 ^ i_v179) / 0x100000000);
            i_v183 = (i_v182 ^ i_v119) >> 31;
            i_v184 = i_v183 + (i_v106 >> 31);
            i_v185 = (i_v184 ^ i_v93) >> 24;
            i_v186 = *(int64_t *)(i_v180 + i_v26);
            i_v187 = *(int64_t *)(i_v178 + (int32_t)&p_g89);
            i_v188 = (i_v182 >> 31) +
                     (int32_t)((i_v187 ^ i_v186) / 0x100000000) + i_v185;
            i_v189 = 0x10000 * (i_v188 ^ i_v183);
            i_v190 = (i_v189 >> 31) + (i_v184 >> 31);
            i_v191 = i_v190 ^ i_v185;
            i_v192 = 0x200000 * i_v191;
            i_v70++;
        }
        // 0x1b360
        i_v29 = 0;
        i_v30 = 0x100000000 *
                (i_v44 ^ i_v14 ^ (int64_t)i_v146 ^ (int64_t)i_v176) /
                0x8000000000000000;
        i_v31 = 0x100000000 *
                (i_v45 ^ i_v16 ^ (int64_t)i_v160 ^ (int64_t)i_v190) /
                0x8000000000000000;
        i_v32 = 0x100000000 *
                (i_v46 ^ i_v18 ^ (int64_t)i_v148 ^ (int64_t)i_v174) /
                0x8000000000000000;
        i_v33 = 0x100000000 *
                (i_v47 ^ i_v20 ^ (int64_t)i_v162 ^ (int64_t)i_v188) /
                0x8000000000000000;
        i_v34 = 0x100000000 *
                (i_v48 ^ i_v14 ^ (int64_t)i_v161 ^ (int64_t)i_v192) /
                0x8000000000000000;
        i_v35 = 0x100000000 *
                (i_v49 ^ i_v16 ^ (int64_t)i_v149 ^ (int64_t)i_v175) /
                0x8000000000000000;
        i_v36 = 0x100000000 *
                (i_v50 ^ i_v18 ^ (int64_t)i_v163 ^ (int64_t)i_v189) /
                0x8000000000000000;
        i_v37 = 0x100000000 *
                (i_v40 ^ i_v20 ^ (int64_t)i_v147 ^ (int64_t)i_v177) /
                0x8000000000000000;
    }
lab_0x1b572:
    // 0x1b572
    *(int32_t *)i_v5 = (int32_t)(i_v44 / 0x100000000);
    *(int32_t *)(i_a1 + 140) = (int32_t)i_v44;
    *(int32_t *)i_v6 = (int32_t)(i_v45 / 0x100000000);
    *(int32_t *)(i_a1 + 148) = (int32_t)i_v45;
    *(int32_t *)i_v7 = (int32_t)(i_v46 / 0x100000000);
    *(int32_t *)(i_a1 + 156) = (int32_t)i_v46;
    *(int32_t *)i_v8 = (int32_t)(i_v47 / 0x100000000);
    *(int32_t *)(i_a1 + 164) = (int32_t)i_v47;
    *(int32_t *)i_v9 = (int32_t)(i_v48 / 0x100000000);
    *(int32_t *)(i_a1 + 172) = (int32_t)i_v48;
    *(int32_t *)i_v10 = (int32_t)(i_v49 / 0x100000000);
    *(int32_t *)(i_a1 + 180) = (int32_t)i_v49;
    *(int32_t *)i_v11 = (int32_t)(i_v50 / 0x100000000);
    *(int32_t *)(i_a1 + 188) = (int32_t)i_v50;
    *(int32_t *)i_v12 = (int32_t)(i_v40 / 0x100000000);
    *(int32_t *)(i_a1 + 196) = (int32_t)i_v40;
    *(int32_t *)i_v13 = (int32_t)(i_v14 / 0x100000000);
    *(int32_t *)(i_a1 + 204) = (int32_t)i_v14;
    *(int32_t *)i_v15 = (int32_t)(i_v16 / 0x100000000);
    *(int32_t *)(i_a1 + 212) = (int32_t)i_v16;
    *(int32_t *)i_v17 = (int32_t)(i_v18 / 0x100000000);
    *(int32_t *)(i_a1 + 220) = (int32_t)i_v18;
    *(int32_t *)i_v19 = (int32_t)(i_v20 / 0x100000000);
    *(int32_t *)(i_a1 + 228) = (int32_t)i_v20;
    *(int32_t *)i_v21 = i_v42;
    *(int32_t *)(i_a1 + 236) = i_v41;
    uint64_t i_v193 = 0x100000000 * i_v24 >> 32; // 0x1b666
    *(int32_t *)i_v23 = (int32_t)(i_v193 / 0x100000000);
    *(int32_t *)(i_a1 + 244) = (int32_t)i_v193;
    // 0x1b67c
    *p_v1 = i_v43;
    return &i_v24;
}

// Address range: 0x1b688 - 0x1b8fa
int32_t blake64_close(int32_t i_a1, int32_t i_a2, uint32_t i_a3, int32_t i_a4,
                      uint32_t i_a5) {
    int32_t i_v1 = *(int32_t *)(i_a1 + 128); // 0x1b698
    uint32_t i_v2 = 8 * i_v1 + i_a3;         // 0x1b6a8
    int32_t i_v3 = 128 >> i_a3;              // 0x1b6b2
    int32_t i_v4;                            // bp-184, 0x1b688
    int32_t i_v5 = &i_v4;                    // 0x1b6d6
    int32_t i_v6 = i_v1 + i_v5;
    *(char *)i_v6 = (char)(-i_v3 & i_a2 | i_v3);
    int32_t i_v7 = i_a1 + 232;          // 0x1b6e4
    uint64_t i_v8 = *(int64_t *)i_v7;   // 0x1b6e4
    uint64_t i_v9 = i_v8 / 0x100000000; // 0x1b6e4
    uint32_t i_v10 = (int32_t)i_v9;     // 0x1b6e4
    int32_t i_v11 = i_a1 + 240;         // 0x1b6fc
    int64_t *p_v12 = (int64_t *)i_v11;  // 0x1b6fc
    int64_t i_v13 = *p_v12;             // 0x1b6fc
    if ((i_v1 || i_a3) == 0) {
        // 0x1b712
        *(int32_t *)i_v7 = -1024;
        *(int32_t *)(i_a1 + 236) = -1;
        *(int32_t *)i_v11 = -1;
        *(int32_t *)(i_a1 + 244) = -1;
    } else {
        if ((int32_t)(i_v9 || i_v8) == 0) {
            // 0x1b740
            *(int32_t *)i_v7 = i_v2 - 1024;
            *(int32_t *)(i_a1 + 236) = (int32_t)(i_v2 < 1024);
            uint64_t i_v14 = *p_v12;             // 0x1b758
            int32_t i_v15 = i_v14 / 0x100000000; // 0x1b758
            *(int32_t *)i_v11 = i_v15 - 1;
            *(int32_t *)(i_a1 + 244) =
                (int32_t)i_v14 - 1 + (int32_t)(i_v15 != 0);
        } else {
            uint32_t i_v16 = 1024 - i_v2; // 0x1b776
            *(int32_t *)i_v7 = i_v10 - i_v16;
            *(int32_t *)(i_a1 + 236) = (int32_t)i_v8 - (int32_t)(i_v16 > i_v10);
        }
    }
    int32_t i_v17 = i_v2 + i_v10; // 0x1b6f0
    int64_t i_v18 = i_v17;        // 0x1b6f6
    int64_t i_v19 = i_v13 >> 32;  // 0x1b700
    int32_t i_v20 = i_v6 + 1;
    int32_t i_v21; // bp-64, 0x1b688
    int32_t i_v22; // bp-72, 0x1b688
    int32_t i_v23; // 0x1b688
    if (i_v2 >= 894 == (i_v2 != 894)) {
        // 0x1b808
        memset((int32_t *)i_v20, 0, 127 - i_v1);
        int32_t i_v24 = 128 - i_v1; // 0x1b834
        blake64(i_a1, i_v6, i_v24, i_v24);
        *(int32_t *)i_v7 = -1024;
        *(int32_t *)(i_a1 + 236) = -1;
        *(int32_t *)i_v11 = -1;
        *(int32_t *)(i_a1 + 244) = -1;
        memset(&i_v4, 0, 112);
        sph_enc64be_aligned(&i_v22, 0, i_v13 >> 63, (int32_t)i_v19);
        sph_enc64be_aligned(&i_v21, 0, i_v18 >> 31, i_v17);
        i_v23 = blake64(i_a1, i_v5, 128, i_v5);
    } else {
        // 0x1b796
        memset((int32_t *)i_v20, 0, 111 - i_v1);
        sph_enc64be_aligned(&i_v22, 0, i_v13 >> 63, (int32_t)i_v19);
        sph_enc64be_aligned(&i_v21, 0, i_v18 >> 31, i_v17);
        int32_t i_v25 = 128 - i_v1; // 0x1b7f8
        i_v23 = blake64(i_a1, i_v6, i_v25, i_v25);
    }
    // 0x1b8ac
    if (i_a5 == 0) {
        // 0x1b8f2
        return i_v23;
    }
    int32_t i_v26 = 0;                                // 0x1b8e0
    int32_t i_v27 = 8 * i_v26;                        // 0x1b8be
    int32_t i_v28 = i_v27 + i_a4;                     // 0x1b8c4
    int64_t i_v29 = *(int64_t *)(i_a1 + 136 + i_v27); // 0x1b8d2
    i_v26++;
    int32_t i_v30 = sph_enc64be(i_v28, i_v28, i_v29 >> 32,
                                0x100000000 * i_v29 >> 32); // 0x1b8f0
    while (i_v26 < i_a5) {
        // 0x1b8ba
        i_v27 = 8 * i_v26;
        i_v28 = i_v27 + i_a4;
        i_v29 = *(int64_t *)(i_a1 + 136 + i_v27);
        i_v26++;
        i_v30 =
            sph_enc64be(i_v28, i_v28, i_v29 >> 32, 0x100000000 * i_v29 >> 32);
    }
    // 0x1b8f2
    return i_v30;
}

// Address range: 0x1b8fc - 0x1b922
int32_t sph_blake224_init(int32_t i_a1) {
    int32_t i_v1 = blake32_init(i_a1, (int32_t)&i_g301 | 0x20000,
                                (int32_t) "(H" | 0x20000); // 0x1b916
    return i_v1;
}

// Address range: 0x1b924 - 0x1b942
int32_t sph_blake224(int32_t i_a1, int32_t i_a2, int32_t i_a3) {
    // 0x1b924
    return blake32(i_a1, i_a2, i_a3);
}

// Address range: 0x1b944 - 0x1b962
int32_t sph_blake224_close(int32_t i_a1, int32_t i_a2) {
    // 0x1b944
    return sph_blake224_addbits_and_close(i_a1, 0, 0, i_a2);
}

// Address range: 0x1b964 - 0x1b990
int32_t sph_blake224_addbits_and_close(int32_t i_a1, int32_t i_a2, int32_t i_a3,
                                       int32_t i_a4) {
    // 0x1b964
    blake32_close(i_a1, i_a2, i_a3, i_a4, 7);
    return sph_blake224_init(i_a1);
}

// Address range: 0x1b990 - 0x1b9b6
int32_t sph_blake256_init(int32_t *p_a1) {
    int32_t i_v1 = blake32_init((int32_t)p_a1, (int32_t)&i_g77,
                                (int32_t) "(H" | 0x20000); // 0x1b9aa
    return i_v1;
}

// Address range: 0x1b9b8 - 0x1b9d6
int32_t sph_blake256(int32_t *p_a1, int32_t i_a2, int32_t i_a3) {
    // 0x1b9b8
    return blake32((int32_t)p_a1, i_a2, i_a3);
}

// Address range: 0x1b9d8 - 0x1b9f6
int32_t sph_blake256_close(int32_t *p_a1, int32_t i_a2) {
    // 0x1b9d8
    return sph_blake256_addbits_and_close((int32_t)p_a1, 0, 0, i_a2);
}

// Address range: 0x1b9f8 - 0x1ba24
int32_t sph_blake256_addbits_and_close(int32_t i_a1, int32_t i_a2, int32_t i_a3,
                                       int32_t i_a4) {
    // 0x1b9f8
    blake32_close(i_a1, i_a2, i_a3, i_a4, 8);
    return sph_blake256_init((int32_t *)i_a1);
}

// Address range: 0x1ba24 - 0x1ba4a
int32_t sph_blake384_init(int32_t i_a1) {
    // 0x1ba24
    return blake64_init(i_a1, &i_g78, &i_g90);
}

// Address range: 0x1ba4c - 0x1ba6a
int32_t sph_blake384(int32_t i_a1, int32_t i_a2, int32_t i_a3) {
    // 0x1ba4c
    int32_t i_v1; // 0x1ba4c
    return blake64(i_a1, i_a2, i_a3, i_v1);
}

// Address range: 0x1ba6c - 0x1ba8a
int32_t sph_blake384_close(int32_t i_a1, int32_t i_a2) {
    // 0x1ba6c
    return sph_blake384_addbits_and_close(i_a1, 0, 0, i_a2);
}

// Address range: 0x1ba8c - 0x1bab8
int32_t sph_blake384_addbits_and_close(int32_t i_a1, int32_t i_a2, int32_t i_a3,
                                       int32_t i_a4) {
    // 0x1ba8c
    blake64_close(i_a1, i_a2, i_a3, i_a4, 6);
    return sph_blake384_init(i_a1);
}

// Address range: 0x1bab8 - 0x1bade
// Used cryptographic patterns:
//  - SHA512 (64-bit, little endian)
int32_t sph_blake512_init(int32_t i_a1) {
    // 0x1bab8
    return blake64_init(i_a1, (int32_t *)&SHA512_at_2b350, &i_g90);
}

// Address range: 0x1bae0 - 0x1bafe
int32_t sph_blake512(int32_t i_a1, int32_t i_a2, int32_t i_a3) {
    // 0x1bae0
    int32_t i_v1; // 0x1bae0
    return blake64(i_a1, i_a2, i_a3, i_v1);
}

// Address range: 0x1bb00 - 0x1bb1e
int32_t sph_blake512_close(int32_t i_a1, int32_t i_a2) {
    // 0x1bb00
    return sph_blake512_addbits_and_close(i_a1, 0, 0, i_a2);
}

// Address range: 0x1bb20 - 0x1bb4c
int32_t sph_blake512_addbits_and_close(int32_t i_a1, int32_t i_a2, int32_t i_a3,
                                       int32_t i_a4) {
    // 0x1bb20
    blake64_close(i_a1, i_a2, i_a3, i_a4, 8);
    return sph_blake512_init(i_a1);
}

// Address range: 0x1bb4c - 0x1bb50
int32_t function_1bb4c(void) {
    // 0x1bb4c
    int32_t i_v1; // 0x1bb4c
    return i_v1;
}

// Address range: 0x1bb50 - 0x1bc92
int32_t platform_dump_capability(int32_t *p_a1) {
    int32_t i_v1 = (int32_t)p_a1;
    if (p_a1 == NULL) {
        // 0x1bc8a
        return i_v1;
    }
    // 0x1bb60
    printf("%s:%d", "platform_dump_capability", 32);
    puts(
        "==========================capability start==========================");
    if (printf("board num = %d\n",
               printf("%s:%d", "platform_dump_capability", 33)) != 0) {
        int32_t i_v2 = 0;
        printf("%s:%d", "platform_dump_capability", 35);
        int32_t i_v3 = 72 * i_v2 + i_v1;       // 0x1bbd2
        int32_t *p_v4 = (int32_t *)(i_v3 + 8); // 0x1bbe8
        printf("board id = %d, chain num = %d\n", *(int32_t *)(i_v3 + 4),
               *p_v4);
        if (*p_v4 != 0) {
            for (int32_t i_v5 = 0; i_v5 < *p_v4; i_v5++) {
                // 0x1bbfe
                printf("%s:%d", "platform_dump_capability", 37);
                printf("\tchain id = %d\n",
                       *(int32_t *)(i_v1 + 12 + 4 * (i_v5 + 18 * i_v2)));
            }
        }
        int32_t i_v6 = i_v2 + 1; // 0x1bc5a
        while (i_v6 < i_v1) {
            // 0x1bbb0
            i_v2 = i_v6;
            printf("%s:%d", "platform_dump_capability", 35);
            i_v3 = 72 * i_v2 + i_v1;
            p_v4 = (int32_t *)(i_v3 + 8);
            printf("board id = %d, chain num = %d\n", *(int32_t *)(i_v3 + 4),
                   *p_v4);
            if (*p_v4 != 0) {
                for (int32_t i_v5 = 0; i_v5 < *p_v4; i_v5++) {
                    // 0x1bbfe
                    printf("%s:%d", "platform_dump_capability", 37);
                    printf("\tchain id = %d\n",
                           *(int32_t *)(i_v1 + 12 + 4 * (i_v5 + 18 * i_v2)));
                }
            }
            // 0x1bc58
            i_v6 = i_v2 + 1;
        }
    }
    // 0x1bc68
    printf("%s:%d", "platform_dump_capability", 41);
    // 0x1bc8a
    return puts(
        "==========================capability end============================");
}

// Address range: 0x1bc94 - 0x1c098
int32_t platform_init(void) {
    // 0x1bc94
    if (i_g40 != 0) {
        // 0x1c08e
        return 0;
    }
    // 0x1bcae
    if (fpga_init() != 0) {
        // 0x1bcb8
        printf("%s:%d", "platform_init", 47);
        puts("fpga init failed");
        // 0x1c08e
        return -1;
    }
    // 0x1bce0
    if (gpio_init() != 0) {
        // 0x1bcea
        printf("%s:%d", "platform_init", 51);
        puts("gpio init failed");
        // 0x1c08e
        return -2;
    }
    // 0x1bd12
    memset(&i_g42, 0, 292);
    char *p_v1 = getenv("HAL_CONFIG_PATH"); // 0x1bd2c
    int32_t i_v2;                           // bp-528, 0x1bc94
    if (p_v1 == NULL) {
        // 0x1bd3c
        snprintf((char *)&i_v2, 512, "/media/card/%s", "hal_conf.json");
    } else {
        // 0x1bd5c
        snprintf((char *)&i_v2, 512, "%s/%s", p_v1, "hal_conf.json");
    }
    // 0x1bd80
    printf("%s:%d", "platform_init", 65);
    printf("hal config path = %s\n", &i_v2);
    if (hal_load_conf(&i_v2) != 0) {
        // 0x1bdb8
        fpga_uninit();
        gpio_uninit();
        printf("%s:%d", "platform_init", 69);
        puts("failed to load hal config");
        // 0x1c08e
        return -3;
    }
    int32_t i_v3 = 0; // bp-532, 0x1bdec
    fpga_read(2, &i_v3);
    uint32_t i_v4 = i_v3; // 0x1be00
    if (i_v4 == 0) {
        // 0x1be06
        printf("%s:%d", "platform_init", 76);
        puts("Cannot Find Any Plug In!\r");
    } else {
        if (i_v4 < 0x1000000) {
            // 0x1be76
            i_g41 = 0;
            i_v3 = i_v4 % 0x10000;
            printf("%s:%d", "platform_init", 87);
            printf("HASH_ON_PLUG V9 = 0x%x\n", i_v3);
            int32_t i_v5 = i_v3; // 0x1bfbc
            if (i_v3 != 0) {
                int32_t i_v6 = 0;
                int32_t i_v7 = i_v5; // 0x1bec0
                int32_t i_v8;        // 0x1bf34
                int32_t *p_v9;       // 0x1bf72
                if (i_v5 % 2 != 0) {
                    // 0x1bec2
                    printf("%s:%d", "platform_init", 90);
                    printf("slot %d pluged\n", i_v6);
                    *(int32_t *)(72 * i_g42 + (int32_t)&i_g42 + 4) = i_v6;
                    i_v8 = *(int32_t *)(72 * i_g42 + (int32_t)&i_g42 + 8);
                    *(int32_t *)(4 * (18 * i_g42 + i_v8) + (int32_t)&i_g42 +
                                 12) = i_v6;
                    p_v9 = (int32_t *)(72 * i_g42 + (int32_t)&i_g42 + 8);
                    *p_v9 = *p_v9 + 1;
                    i_g42++;
                    i_v7 = i_v3;
                }
                int32_t i_v10 = i_v7 / 2; // 0x1bfa6
                i_v3 = i_v10;
                int32_t i_v11 = i_v6 + 1; // 0x1bfbc
                i_v5 = i_v10;
                while (i_v7 >= 2) {
                    // 0x1beb6
                    i_v6 = i_v11;
                    i_v7 = i_v5;
                    if (i_v5 % 2 != 0) {
                        // 0x1bec2
                        printf("%s:%d", "platform_init", 90);
                        printf("slot %d pluged\n", i_v6);
                        *(int32_t *)(72 * i_g42 + (int32_t)&i_g42 + 4) = i_v6;
                        i_v8 = *(int32_t *)(72 * i_g42 + (int32_t)&i_g42 + 8);
                        *(int32_t *)(4 * (18 * i_g42 + i_v8) + (int32_t)&i_g42 +
                                     12) = i_v6;
                        p_v9 = (int32_t *)(72 * i_g42 + (int32_t)&i_g42 + 8);
                        *p_v9 = *p_v9 + 1;
                        i_g42++;
                        i_v7 = i_v3;
                    }
                    // 0x1bfa2
                    i_v10 = i_v7 / 2;
                    i_v3 = i_v10;
                    i_v11 = i_v6 + 1;
                    i_v5 = i_v10;
                }
            }
        } else {
            // 0x1be36
            i_g41 = 1;
            i_v3 = i_v4 / 0x1000000;
            printf("%s:%d", "platform_init", 81);
            printf("HASH_ON_PLUG T9 = 0x%x\n", i_v3);
        }
    }
    // 0x1bfc0
    if (i_g41 == 0) {
        // 0x1bfe4
        fpga_read(i_g170, &i_v3);
    } else {
        // 0x1bfce
        fpga_read(i_g165, &i_v3);
    }
    // 0x1bff8
    i_v3 |= 0x20000000;
    printf("%s:%d", "platform_init", 104);
    printf("HARDWARE_VERSION = 0x%x\n", i_v3);
    if (i_g41 == 0) {
        // 0x1c052
        fpga_write(i_g170, i_v3);
    } else {
        // 0x1c03a
        fpga_write(i_g165, i_v3);
    }
    // 0x1c068
    platform_dump_capability(&i_g42);
    i_g40 = 1;
    fan_init();
    ui_init();
    uart_init();
    // 0x1c08e
    return 0;
}

// Address range: 0x1c098 - 0x1c0cc
int32_t platform_uninit(void) {
    // 0x1c098
    int32_t i_v1; // 0x1c098
    if (i_g40 != 0) {
        // 0x1c0aa
        uart_uninit();
        fan_uninit(fpga_uninit());
        ui_uninit();
        int32_t i_v2 = gpio_uninit(); // 0x1c0ba
        i_g40 = 0;
        i_v1 = i_v2;
    }
    // 0x1c0ca
    return i_v1;
}

// Address range: 0x1c0cc - 0x1c0f4
int32_t get_system_capability(int32_t *p_a1) {
    int32_t i_v1 = 0; // 0x1c0d8
    if (p_a1 != NULL) {
        // 0x1c0da
        i_v1 = (int32_t)memcpy(p_a1, &i_g42, 292);
    }
    // 0x1c0ec
    return i_v1;
}

// Address range: 0x1c0f4 - 0x1c1c2
int32_t get_eth_mac(char *p_a1, int32_t i_a2) {
    int32_t i_v1 = socket(AF_INET, SOCK_STREAM, IPPROTO_IP); // 0x1c108
    if (i_v1 < 0) {
        // 0x1c114
        printf("%s:%d", "get_eth_mac", 143);
        printf("error sock");
        // 0x1c1b8
        return -1;
    }
    // 0x1c13c
    int32_t i_v2; // bp-48, 0x1c0f4
    strcpy((char *)&i_v2, p_a1);
    if (ioctl(i_v1, (int32_t) "gettimeofday") < 0) {
        // 0x1c15e
        printf("%s:%d", "get_eth_mac", 149);
        printf("error ioctl");
        close(i_v1);
        // 0x1c1b8
        return -2;
    }
    for (int32_t i_v3 = 0; i_v3 < 6; i_v3++) {
        // 0x1c192
        int32_t i_v4;                                       // bp-32, 0x1c0f4
        char i_v5 = *(char *)(i_v3 + ((int32_t)&i_v4 | 2)); // 0x1c1a0
        *(char *)(i_v3 + i_a2) = i_v5;
    }
    // 0x1c1b0
    close(i_v1);
    // 0x1c1b8
    return 0;
}

// Address range: 0x1c1c4 - 0x1c200
int32_t get_uuid(int32_t i_a1) {
    int32_t i_v1 = -1; // 0x1c1d0
    if (i_a1 != 0) {
        // 0x1c1d2
        memset((int32_t *)i_a1, 0, 16);
        i_v1 = get_eth_mac("eth0", i_a1);
    }
    // 0x1c1f6
    return i_v1;
}

// Address range: 0x1c200 - 0x1c230
int32_t get_mac(int32_t i_a1) {
    int32_t i_v1 = -1; // 0x1c20c
    if (i_a1 != 0) {
        // 0x1c20e
        i_v1 = get_eth_mac("eth0", i_a1);
    }
    // 0x1c226
    return i_v1;
}

// Address range: 0x1c230 - 0x1c25a
int32_t chain_reset(int32_t i_a1) {
    // 0x1c230
    chain_reset_low(i_a1);
    usleep((int32_t)&i_g239 | 0x10000);
    int32_t i_v1; // 0x1c230
    return __asm_nop(chain_reset_high(i_a1), i_v1, i_v1, i_v1);
}

// Address range: 0x1c25c - 0x1c2f4
int32_t chain_reset_low(uint32_t i_a1) {
    int32_t i_v1 = 0; // bp-12, 0x1c266
    if (i_g41 == 0) {
        // 0x1c28e
        fpga_read(i_g173, &i_v1);
    } else {
        // 0x1c276
        fpga_read(i_g168, &i_v1);
    }
    int32_t i_v2 = i_v1 | 1 << i_a1; // 0x1c2b0
    i_v1 = i_v2;
    int32_t i_v3; // 0x1c25c
    if (i_g41 == 0) {
        // 0x1c2d8
        i_v3 = fpga_write(i_g173, i_v2);
    } else {
        // 0x1c2c2
        i_v3 = fpga_write(i_g168, i_v2);
    }
    // 0x1c2ec
    return i_v3;
}

// Address range: 0x1c2f4 - 0x1c38e
int32_t chain_reset_high(uint32_t i_a1) {
    int32_t i_v1 = 0; // bp-12, 0x1c2fe
    if (i_g41 == 0) {
        // 0x1c326
        fpga_read(i_g173, &i_v1);
    } else {
        // 0x1c30e
        fpga_read(i_g168, &i_v1);
    }
    int32_t i_v2 = i_v1 & (-1 << i_a1) - 1; // 0x1c34a
    i_v1 = i_v2;
    int32_t i_v3; // 0x1c2f4
    if (i_g41 == 0) {
        // 0x1c372
        i_v3 = fpga_write(i_g173, i_v2);
    } else {
        // 0x1c35c
        i_v3 = fpga_write(i_g168, i_v2);
    }
    // 0x1c386
    return i_v3;
}

// Address range: 0x1c390 - 0x1c3b8
int32_t board_reset(int32_t i_a1) {
    // 0x1c390
    board_reset_low(i_a1);
    usleep((int32_t)&i_g239 | 0x10000);
    return board_reset_high(i_a1);
}

// Address range: 0x1c3b8 - 0x1c3ca
int32_t board_reset_low(int32_t i_a1) {
    // 0x1c3b8
    return i_a1;
}

// Address range: 0x1c3cc - 0x1c3de
int32_t board_reset_high(int32_t i_a1) {
    // 0x1c3cc
    return i_a1;
}

// Address range: 0x1c3e0 - 0x1c46c
int32_t get_hardware_type(void) {
    int32_t i_v1 = 0; // bp-12, 0x1c3e8
    if (i_g40 == 0) {
        // 0x1c3f8
        printf("%s:%d", "get_hardware_type", 222);
        puts("platform not inited");
        // 0x1c462
        return 2;
    }
    // 0x1c41e
    if (i_g41 == 0) {
        // 0x1c442
        fpga_read(i_g170, &i_v1);
    } else {
        // 0x1c42c
        fpga_read(i_g165, &i_v1);
    }
    // 0x1c462
    return i_v1 < 0;
}

// Address range: 0x1c46c - 0x1c54e
int32_t set_hardware_type(int32_t i_a1) {
    int32_t i_v1 = 0; // bp-12, 0x1c476
    if (i_g40 == 0) {
        // 0x1c486
        printf("%s:%d", "set_hardware_type", 237);
        puts("platform not inited");
        // 0x1c544
        return -2;
    }
    // 0x1c4ae
    int32_t i_v2; // 0x1c46c
    int32_t i_v3; // 0x1c46c
    if (i_g41 == 0) {
        int32_t i_v4 = fpga_read(i_g170, &i_v1); // 0x1c4e6
        i_v2 = i_g170;
        i_v3 = i_v4;
    } else {
        int32_t i_v5 = fpga_read(i_g165, &i_v1); // 0x1c4ce
        i_v2 = i_g165;
        i_v3 = i_v5;
    }
    switch (i_a1) {
    case 0: {
        // 0x1c4fe
        i_v1 = fabsf((float32_t)i_v1);
        // break -> 0x1c50a
        break;
    }
    case 1: {
        // 0x1c4f4
        i_v1 |= -0x80000000;
        // break -> 0x1c50a
        break;
    }
    default: {
        // 0x1c508
        __asm_nop(i_v3, (int32_t)&i_v1, i_v2, i_a1);
        // break -> 0x1c50a
        break;
    }
    }
    // 0x1c50a
    if (i_g41 == 0) {
        // 0x1c52e
        fpga_write(i_g170, i_v1);
    } else {
        // 0x1c518
        fpga_write(i_g165, i_v1);
    }
    // 0x1c544
    return 0;
}

// Address range: 0x1c550 - 0x1c616
int32_t enable_bypass_mode(void) {
    int32_t i_v1 = 0; // bp-12, 0x1c558
    if (i_g40 == 0) {
        // 0x1c568
        printf("%s:%d", "enable_bypass_mode", 260);
        puts("platform not inited");
        // 0x1c60c
        return -2;
    }
    // 0x1c592
    if (i_g41 == 0) {
        // 0x1c5b6
        fpga_read(i_g170, &i_v1);
    } else {
        // 0x1c5a0
        fpga_read(i_g165, &i_v1);
    }
    int32_t i_v2 = i_v1 | 0x20000000; // 0x1c5cc
    i_v1 = i_v2;
    if (i_g41 == 0) {
        // 0x1c5f6
        fpga_write(i_g170, i_v2);
    } else {
        // 0x1c5e0
        fpga_write(i_g165, i_v2);
    }
    // 0x1c60c
    return 0;
}

// Address range: 0x1c618 - 0x1c6de
int32_t disable_bypass_mode(void) {
    int32_t i_v1 = 0; // bp-12, 0x1c620
    if (i_g40 == 0) {
        // 0x1c630
        printf("%s:%d", "disable_bypass_mode", 274);
        puts("platform not inited");
        // 0x1c6d4
        return -2;
    }
    // 0x1c65a
    if (i_g41 == 0) {
        // 0x1c67e
        fpga_read(i_g170, &i_v1);
    } else {
        // 0x1c668
        fpga_read(i_g165, &i_v1);
    }
    int32_t i_v2 = i_v1 & -0x20000001; // 0x1c694
    i_v1 = i_v2;
    if (i_g41 == 0) {
        // 0x1c6be
        fpga_write(i_g170, i_v2);
    } else {
        // 0x1c6a8
        fpga_write(i_g165, i_v2);
    }
    // 0x1c6d4
    return 0;
}

// Address range: 0x1c6e0 - 0x1c776
int32_t is_bypass_mode_enable(void) {
    int32_t i_v1 = 0; // bp-12, 0x1c6e8
    if (i_g40 == 0) {
        // 0x1c6f8
        printf("%s:%d", "is_bypass_mode_enable", 288);
        puts("platform not inited");
        // 0x1c76c
        return 0;
    }
    // 0x1c720
    if (i_g41 == 0) {
        // 0x1c744
        fpga_read(i_g170, &i_v1);
    } else {
        // 0x1c72e
        fpga_read(i_g165, &i_v1);
    }
    int32_t i_v2 = i_v1 & 0x20000000; // 0x1c75a
    i_v1 = i_v2;
    if (i_v2 == 0) {
        __asm_ite();
    }
    // 0x1c76c
    return i_v2 != 0;
}

// Address range: 0x1c778 - 0x1c7fe
int32_t get_hardware_version(void) {
    int32_t i_v1 = 0; // bp-12, 0x1c780
    if (i_g40 == 0) {
        // 0x1c790
        printf("%s:%d", "get_hardware_version", 301);
        puts("platform not inited");
        // 0x1c7f4
        return 0;
    }
    // 0x1c7b8
    if (i_g41 == 0) {
        // 0x1c7dc
        fpga_read(i_g170, &i_v1);
    } else {
        // 0x1c7c6
        fpga_read(i_g165, &i_v1);
    }
    // 0x1c7f4
    return i_v1 % 0x10000;
}

// Address range: 0x1c800 - 0x1c840
int32_t fan_init(void) {
    int32_t i_v1 = 0; // 0x1c810
    if (i_g40 == 0) {
        // 0x1c812
        printf("%s:%d", "fan_init", 11);
        puts("please init platform first!!");
        i_v1 = -1;
    }
    // 0x1c83c
    return i_v1;
}

// Address range: 0x1c840 - 0x1c84c
int32_t fan_uninit(int32_t i_a1) {
    // 0x1c840
    int32_t i_v1; // 0x1c840
    return __asm_nop(i_a1, i_v1, i_v1, i_v1);
}

// Address range: 0x1c84c - 0x1c8fe
int32_t fan_get_realtime_speed(int32_t i_a1) {
    int32_t i_v1 = 0; // bp-16, 0x1c856
    int32_t i_v2 = 0; // 0x1c8e6
    if (i_g41 == 0) {
        // 0x1c884
        fpga_read(i_g171, &i_v1);
    } else {
        // 0x1c86c
        fpga_read(i_g166, &i_v1);
    }
    // 0x1c89a
    printf("%s:%d", (char *)((int32_t)&p_g302 | 0x20000), 32);
    printf("FAN_SPEED fpga value = 0x%x\n", i_v1);
    while (i_v1 / 256 % 8 != i_a1) {
        // 0x1c8dc
        usleep(0x2710);
        i_v2++;
        if (i_v2 >= 6) {
            // 0x1c8f4
            return -1;
        }
        if (i_g41 == 0) {
            // 0x1c884
            fpga_read(i_g171, &i_v1);
        } else {
            // 0x1c86c
            fpga_read(i_g166, &i_v1);
        }
        // 0x1c89a
        printf("%s:%d", (char *)((int32_t)&p_g302 | 0x20000), 32);
        printf("FAN_SPEED fpga value = 0x%x\n", i_v1);
    }
    // 0x1c8f4
    return 120 * (i_v1 % 256);
}

// Address range: 0x1c900 - 0x1c90e
int32_t fan_get_max_num(void) {
    // 0x1c900
    return hal_fan_number();
}

// Address range: 0x1c910 - 0x1c92a
int32_t fan_get_max_speed(int32_t i_a1) {
    // 0x1c910
    return hal_fan_max_speed(i_a1);
}

// Address range: 0x1c92c - 0x1c98a
int32_t reset(void) {
    int32_t i_v1 = -0x7fff8000; // bp-12, 0x1c936
    fpga_write(16, -0x7fff8000);
    usleep((int32_t)&i_g239 | 0x10000);
    fpga_read(16, &i_v1);
    while (i_v1 < 0) {
        // 0x1c942
        usleep((int32_t)&i_g239 | 0x10000);
        fpga_read(16, &i_v1);
    }
    // 0x1c95e
    printf("%s:%d", "reset", 291);
    return puts("fpga reset success");
}

// Address range: 0x1c98c - 0x1cac8
int32_t fpga_init(void) {
    // 0x1c98c
    if (i_g43 != 0) {
        // 0x1cac2
        return 0;
    }
    int32_t i_v1 = open("/dev/axi_fpga_dev", O_RDWR); // 0x1c9ae
    i_g44 = i_v1;
    if (i_v1 < 0) {
        // 0x1c9cc
        printf("%s:%d", "fpga_init", 303);
        printf("/dev/axi_fpga_dev open failed. fd = %d\n", i_g44);
        // 0x1cac2
        return -1;
    }
    int32_t *p_v2 = mmap(NULL, 0x1200, 3, 1, i_v1, 0); // 0x1ca1c
    i_g45 = (int32_t)p_v2;
    int32_t i_v3; // 0x1c98c
    if (p_v2 == NULL) {
        // 0x1ca3a
        printf("%s:%d", "fpga_init", 310);
        printf("mmap axi_fpga_addr failed. axi_fpga_addr = 0x%x\n", i_g45);
        close(i_g44);
        i_v3 = -2;
    } else {
        // 0x1ca80
        printf("%s:%d", "fpga_init", 314);
        printf("fpga_init success. axi_fpga_addr = 0x%x\n", i_g45);
        reset();
        i_g43 = 1;
        i_v3 = 0;
    }
    // 0x1cac2
    return i_v3;
}

// Address range: 0x1cac8 - 0x1cb44
int32_t fpga_uninit(void) {
    // 0x1cac8
    if (i_g43 == 0) {
        // 0x1cb3c
        int32_t i_v1; // 0x1cac8
        return __asm_nop(i_v1, i_v1, i_v1, 0);
    }
    // 0x1cadc
    if (munmap((int32_t *)i_g45, 0x1200) < 0) {
        // 0x1caf8
        printf("%s:%d", "fpga_uninit", 330);
        puts((char *)((int32_t)&p_g303 | 0x20000));
    }
    // 0x1cb1c
    i_g43 = 0;
    // 0x1cb3c
    return close(i_g44);
}

// Address range: 0x1cb44 - 0x1cb72
int32_t fpga_read(int32_t i_a1, int32_t *p_a2) {
    // 0x1cb44
    *p_a2 = *(int32_t *)(i_g45 + 4 * i_a1);
    return 0;
}

// Address range: 0x1cb74 - 0x1cba0
int32_t fpga_write(int32_t i_a1, int32_t i_a2) {
    // 0x1cb74
    *(int32_t *)(i_g45 + 4 * i_a1) = i_a2;
    return 0;
}

// Address range: 0x1cba0 - 0x1cbc0
int32_t gpio_compare_e(int32_t i_a1, int32_t i_a2) {
    // 0x1cba0
    return i_a1 - i_a2;
}

// Address range: 0x1cbc0 - 0x1cd1e
int32_t gpio_thread_function(int32_t i_a1) {
    // 0x1cbc0
    if (i_g47 == 0) {
        // 0x1cd12
        return 0;
    }
    int32_t i_v1 = pthread_mutex_lock(&i_g50); // 0x1cbd6
    int32_t i_v2;                              // 0x1cbc0
    int32_t i_v3;                              // 0x1cbc0
    int32_t *p_v4;                             // 0x1cbc0
    int32_t i_v5;                              // 0x1cbc0
    int32_t i_v6;                              // 0x1cbc0
    int32_t i_v7;                              // 0x1cbc0
    char i_v8;                                 // bp-33, 0x1cbc0
    int32_t i_v9;                              // 0x1cc16
    int32_t i_v10;                             // 0x1cc26
    int32_t *p_v11;                            // 0x1cc12
    int32_t i_v12;                             // 0x1cc16
    int32_t i_v13;                             // 0x1cc26
    int32_t i_v14;                             // 0x1cc84
    int32_t i_v15;                             // 0x1cbee
    int32_t *p_v16;                            // 0x1cc02
    int32_t *p_v17;                            // 0x1cbc0
    int32_t *p_v18;                            // 0x1cbc0
    int32_t *p_v19;                            // 0x1cc12
    if (i_v1 == 0) {
        // 0x1cbe2
        i_v15 = new_iterator_c_map(i_g51);
        i_v3 = i_v6;
        if (i_v15 != 0) {
            // 0x1cc00
            p_v16 = (int32_t *)(i_v15 + 20);
            p_v17 = (int32_t *)(i_v15 + 4);
            p_v18 = (int32_t *)i_v15;
            p_v19 = (int32_t *)(*p_v16 + 16);
            i_v9 = *(int32_t *)*(int32_t *)*p_v19;
            i_v8 = 0;
            i_v10 = gpio_read(i_v9, &i_v8);
            i_v2 = i_v9;
            p_v4 = p_v19;
            if (i_v10 == 0) {
                if (*p_v17 != (int32_t)i_v8) {
                    // 0x1cc68
                    printf("%s:%d", "gpio_thread_function", 55);
                    i_v14 = *(int32_t *)*(int32_t *)*p_v4;
                    printf("gpio port %d, last val = %d, new val = %d\n", i_v14,
                           *p_v17, (int32_t)i_v8);
                }
                // 0x1ccbe
                free(p_v18);
                p_v11 = (int32_t *)(*p_v16 + 16);
                i_v12 = *(int32_t *)*(int32_t *)*p_v11;
                i_v8 = 0;
                i_v13 = gpio_read(i_v12, &i_v8);
                i_v2 = i_v12;
                p_v4 = p_v11;
                while (i_v13 == 0) {
                    // 0x1cc5e
                    if (*p_v17 != (int32_t)i_v8) {
                        // 0x1cc68
                        printf("%s:%d", "gpio_thread_function", 55);
                        i_v14 = *(int32_t *)*(int32_t *)*p_v4;
                        printf("gpio port %d, last val = %d, new val = %d\n",
                               i_v14, *p_v17, (int32_t)i_v8);
                    }
                    // 0x1ccbe
                    free(p_v18);
                    p_v11 = (int32_t *)(*p_v16 + 16);
                    i_v12 = *(int32_t *)*(int32_t *)*p_v11;
                    i_v8 = 0;
                    i_v13 = gpio_read(i_v12, &i_v8);
                    i_v2 = i_v12;
                    p_v4 = p_v11;
                }
            }
            // 0x1cc32
            i_v3 = i_v2;
            printf("%s:%d", "gpio_thread_function", 50);
            printf("failed to read gpio port %d\n", i_v3);
            free(p_v18);
        }
        // 0x1ccd4
        delete_iterator_c_map(i_v15);
        pthread_mutex_unlock(&i_g50);
        i_v5 = i_v3;
    } else {
        // 0x1cce8
        __asm_nop(i_v1, i_v6, i_v7, i_v1);
        i_v5 = i_v6;
    }
    // 0x1ccea
    usleep(0x30d40);
    i_v7 = 1000;
    while (i_g47 != 0) {
        int32_t i_v20 = i_v5;
        i_v1 = pthread_mutex_lock(&i_g50);
        if (i_v1 == 0) {
            // 0x1cbe2
            i_v15 = new_iterator_c_map(i_g51);
            i_v3 = i_v20;
            if (i_v15 != 0) {
                // 0x1cc00
                p_v16 = (int32_t *)(i_v15 + 20);
                p_v17 = (int32_t *)(i_v15 + 4);
                p_v18 = (int32_t *)i_v15;
                p_v19 = (int32_t *)(*p_v16 + 16);
                i_v9 = *(int32_t *)*(int32_t *)*p_v19;
                i_v8 = 0;
                i_v10 = gpio_read(i_v9, &i_v8);
                i_v2 = i_v9;
                p_v4 = p_v19;
                if (i_v10 == 0) {
                    if (*p_v17 != (int32_t)i_v8) {
                        // 0x1cc68
                        printf("%s:%d", "gpio_thread_function", 55);
                        i_v14 = *(int32_t *)*(int32_t *)*p_v4;
                        printf("gpio port %d, last val = %d, new val = %d\n",
                               i_v14, *p_v17, (int32_t)i_v8);
                    }
                    // 0x1ccbe
                    free(p_v18);
                    p_v11 = (int32_t *)(*p_v16 + 16);
                    i_v12 = *(int32_t *)*(int32_t *)*p_v11;
                    i_v8 = 0;
                    i_v13 = gpio_read(i_v12, &i_v8);
                    i_v2 = i_v12;
                    p_v4 = p_v11;
                    while (i_v13 == 0) {
                        // 0x1cc5e
                        if (*p_v17 != (int32_t)i_v8) {
                            // 0x1cc68
                            printf("%s:%d", "gpio_thread_function", 55);
                            i_v14 = *(int32_t *)*(int32_t *)*p_v4;
                            printf(
                                "gpio port %d, last val = %d, new val = %d\n",
                                i_v14, *p_v17, (int32_t)i_v8);
                        }
                        // 0x1ccbe
                        free(p_v18);
                        p_v11 = (int32_t *)(*p_v16 + 16);
                        i_v12 = *(int32_t *)*(int32_t *)*p_v11;
                        i_v8 = 0;
                        i_v13 = gpio_read(i_v12, &i_v8);
                        i_v2 = i_v12;
                        p_v4 = p_v11;
                    }
                }
                // 0x1cc32
                i_v3 = i_v2;
                printf("%s:%d", "gpio_thread_function", 50);
                printf("failed to read gpio port %d\n", i_v3);
                free(p_v18);
            }
            // 0x1ccd4
            delete_iterator_c_map(i_v15);
            pthread_mutex_unlock(&i_g50);
            i_v5 = i_v3;
        } else {
            // 0x1cce8
            __asm_nop(i_v1, i_v20, i_v7, i_v1);
            i_v5 = i_v20;
        }
        // 0x1ccea
        usleep(0x30d40);
        i_v7 = 1000;
    }
    // 0x1cd12
    return 0;
}

// Address range: 0x1cd20 - 0x1cdc6
int32_t gpio_init(void) {
    // 0x1cd20
    if (i_g46 == 0) {
        // 0x1cd58
        pthread_mutex_init(&i_g50, NULL);
        i_g51 = new_c_map((int32_t)&i_g306 | 0x10000, 0, 0);
        pthread_mutex_init(&i_g49, NULL);
        i_g47 = 1;
        pthread_create(&i_g48, NULL, (int32_t * (*)(int32_t *))0x1cbc1, NULL);
        i_g46 = 1;
    } else {
        // 0x1cd32
        printf("%s:%d", "gpio_init", 78);
        puts("gpio re init");
    }
    // 0x1cdc2
    return 0;
}

// Address range: 0x1cdc8 - 0x1ce30
int32_t gpio_uninit(void) {
    int32_t i_v1 = 0; // 0x1cdd8
    int32_t i_v2;     // 0x1cdc8
    int32_t i_v3;     // 0x1cdc8
    int32_t i_v4;     // 0x1cdc8
    if (i_g46 != 0) {
        // 0x1cdda
        i_g47 = 0;
        pthread_join(i_g48, NULL);
        pthread_mutex_destroy(&i_g50);
        delete_c_map(i_g51);
        i_g46 = 0;
        i_v2 = pthread_mutex_destroy(&i_g49);
        i_v3 = 0;
        i_v4 = 0;
        i_v1 = &i_g46;
    }
    // 0x1ce2c
    return __asm_nop(i_v2, i_v3, i_v4, i_v1);
}

// Address range: 0x1ce30 - 0x1cf4a
int32_t gpio_reg_callback(int32_t i_a1, int32_t i_a2) {
    int32_t i_v1 = i_a1; // bp-20, 0x1ce36
    if (i_a2 == 0) {
        // 0x1ce40
        printf("%s:%d", "gpio_reg_callback", 120);
        puts("bad param");
        // 0x1cf40
        return -1;
    }
    // 0x1ce68
    if (pthread_mutex_lock(&i_g50) != 0) {
        // 0x1ce7a
        printf("%s:%d", "gpio_reg_callback", 124);
        puts("fail to lock gpio ctrl mutex");
        // 0x1cf40
        return -1;
    }
    // 0x1cea2
    if (exists_c_map(i_g51, &i_v1) == 0) {
        // 0x1cebc
        printf("%s:%d", "gpio_reg_callback", 129);
        printf("add %d to callback map\n", i_v1);
        int32_t i_v2 = i_a2; // bp-16, 0x1cee4
        insert_c_map(i_g51, &i_v1, 4, &i_v2, 8);
    } else {
        // 0x1cf0c
        printf("%s:%d", "gpio_reg_callback", 133);
        printf("port %d already exist in callback map \n", i_v1);
    }
    // 0x1cf32
    pthread_mutex_unlock(&i_g50);
    // 0x1cf40
    return 0;
}

// Address range: 0x1cf4c - 0x1d04e
int32_t gpio_unreg_callback(int32_t i_a1, int32_t i_a2) {
    int32_t i_v1 = i_a1; // bp-12, 0x1cf52
    if (i_a2 == 0) {
        // 0x1cf5c
        printf("%s:%d", "gpio_unreg_callback", 148);
        puts("bad param");
        // 0x1d044
        return -1;
    }
    // 0x1cf84
    if (pthread_mutex_lock(&i_g50) != 0) {
        // 0x1cf96
        printf("%s:%d", "gpio_unreg_callback", 152);
        puts("fail to lock gpio ctrl mutex");
        // 0x1d044
        return -1;
    }
    // 0x1cfbe
    if (exists_c_map(i_g51, &i_v1) == 1) {
        // 0x1cfd8
        printf("%s:%d", "gpio_unreg_callback", 157);
        printf("remove %d from callback list\n", i_v1);
        remove_c_map(i_g51, &i_v1);
    } else {
        // 0x1d014
        printf("%s:%d", "gpio_unreg_callback", 160);
        puts("callback function not registered before");
    }
    // 0x1d036
    pthread_mutex_unlock(&i_g50);
    // 0x1d044
    return 0;
}

// Address range: 0x1d050 - 0x1d1f0
int32_t gpio_export(int32_t i_a1) {
    // 0x1d050
    if (pthread_mutex_lock(&i_g49) != 0) {
        // 0x1d06a
        printf("%s:%d", (char *)((int32_t) "eH" | 0x20000), 177);
        puts("failed to api lock");
        // 0x1d1e6
        return -1;
    }
    // 0x1d092
    int32_t i_v1; // bp-80, 0x1d050
    snprintf((char *)&i_v1, 64, "/sys/class/gpio/gpio%d", i_a1);
    if (access((char *)&i_v1, F_OK) == 0) {
        // 0x1d0ba
        printf("%s:%d", (char *)((int32_t) "eH" | 0x20000), 183);
        printf("port %d already exported\n", i_a1);
        perror("access error");
        pthread_mutex_unlock(&i_g49);
        // 0x1d1e6
        return 0;
    }
    int32_t i_v2 = open("/sys/class/gpio/export", O_WRONLY); // 0x1d104
    if (i_v2 < 0) {
        // 0x1d110
        printf("%s:%d", (char *)((int32_t) "eH" | 0x20000), 191);
        puts("Failed to open export for writing!");
        pthread_mutex_unlock(&i_g49);
        // 0x1d1e6
        return -2;
    }
    // 0x1d144
    int32_t i_v3; // 0x1d050
    if (write(i_v2, &i_v1, snprintf((char *)&i_v1, 64, "%d", i_a1)) < 0) {
        // 0x1d172
        printf("%s:%d", (char *)((int32_t) "eH" | 0x20000), 198);
        printf("Failed to export gpio %d!", i_a1);
        close(i_v2);
        pthread_mutex_unlock(&i_g49);
        i_v3 = -3;
    } else {
        // 0x1d1ae
        printf("%s:%d", (char *)((int32_t) "eH" | 0x20000), 203);
        printf("export gpio %d success\n", i_a1);
        close(i_v2);
        pthread_mutex_unlock(&i_g49);
        i_v3 = 0;
    }
    // 0x1d1e6
    return i_v3;
}

// Address range: 0x1d1f0 - 0x1d394
int32_t gpio_unexport(int32_t i_a1) {
    // 0x1d1f0
    if (pthread_mutex_lock(&i_g49) != 0) {
        // 0x1d20a
        printf("%s:%d", "gpio_unexport", 220);
        puts("failed to api lock");
        // 0x1d38a
        return -1;
    }
    // 0x1d232
    int32_t i_v1; // bp-80, 0x1d1f0
    snprintf((char *)&i_v1, 64, "/sys/class/gpio/gpio%d", i_a1);
    int32_t i_v2 = access((char *)&i_v1, F_OK); // 0x1d250
    if (i_v2 != 0) {
        // 0x1d25c
        printf("%s:%d", "gpio_unexport", 226);
        printf("port %d already unexported, ret = %d\n", i_a1, i_v2);
        perror("access error");
        pthread_mutex_unlock(&i_g49);
        // 0x1d38a
        return 0;
    }
    int32_t i_v3 = open("/sys/class/gpio/unexport", O_WRONLY); // 0x1d2a8
    if (i_v3 < 0) {
        // 0x1d2b4
        printf("%s:%d", "gpio_unexport", 234);
        puts("Failed to open unexport for writing!");
        pthread_mutex_unlock(&i_g49);
        // 0x1d38a
        return -2;
    }
    // 0x1d2e8
    int32_t i_v4; // 0x1d1f0
    if (write(i_v3, &i_v1, snprintf((char *)&i_v1, 64, "%d", i_a1)) < 0) {
        // 0x1d316
        printf("%s:%d", "gpio_unexport", 241);
        printf("Failed to unexport gpio %d!", i_a1);
        close(i_v3);
        pthread_mutex_unlock(&i_g49);
        i_v4 = -2;
    } else {
        // 0x1d352
        printf("%s:%d", "gpio_unexport", 246);
        printf("unexport gpio %d success\n", i_a1);
        close(i_v3);
        pthread_mutex_unlock(&i_g49);
        i_v4 = 0;
    }
    // 0x1d38a
    return i_v4;
}

// Address range: 0x1d394 - 0x1d520
int32_t gpio_direction(int32_t i_a1, int32_t i_a2) {
    // 0x1d394
    if (pthread_mutex_lock(&i_g49) != 0) {
        // 0x1d3b0
        printf("%s:%d", "gpio_direction", 266);
        puts("failed to api lock");
        // 0x1d516
        return -1;
    }
    // 0x1d3da
    int32_t i_v1; // bp-76, 0x1d394
    snprintf((char *)&i_v1, 64, "/sys/class/gpio/gpio%d/direction", i_a1);
    int32_t i_v2 = open((char *)&i_v1, O_WRONLY); // 0x1d3f8
    if (i_v2 < 0) {
        // 0x1d404
        printf("%s:%d", "gpio_direction", 273);
        printf("Failed to open gpio %d direction for writing!\n", i_a1);
        pthread_mutex_unlock(&i_g49);
        // 0x1d516
        return -2;
    }
    int32_t i_v3 = i_a2 == 0 ? (int32_t) "in" : (int32_t) "in" + 3;
    int32_t i_v4; // 0x1d394
    if (write(i_v2, (int32_t *)i_v3, i_a2 == 0 ? 2 : 3) < 0) {
        // 0x1d46e
        printf("%s:%d", "gpio_direction", 279);
        printf("Failed to set gpio %d direction %s !\n", i_a1, (char *)i_v3);
        close(i_v2);
        pthread_mutex_unlock(&i_g49);
        i_v4 = -3;
    } else {
        // 0x1d4c4
        printf("%s:%d", "gpio_direction", 284);
        printf("set gpio %d direction %s success!\n", i_a1, (char *)i_v3);
        close(i_v2);
        pthread_mutex_unlock(&i_g49);
        i_v4 = 0;
    }
    // 0x1d516
    return i_v4;
}

// Address range: 0x1d520 - 0x1d64c
int32_t gpio_read(int32_t i_a1, char *p_a2) {
    int32_t i_v1 = 0; // bp-80, 0x1d52c
    if (pthread_mutex_lock(&i_g49) != 0) {
        // 0x1d540
        printf("%s:%d", "gpio_read", 303);
        puts("failed to api lock");
        // 0x1d642
        return -1;
    }
    // 0x1d56a
    int32_t i_v2; // bp-76, 0x1d520
    snprintf((char *)&i_v2, 64, "/sys/class/gpio/gpio%d/value", i_a1);
    int32_t i_v3 = open((char *)&i_v2, O_RDONLY); // 0x1d588
    if (i_v3 < 0) {
        // 0x1d594
        printf("%s:%d", "gpio_read", 310);
        printf("Failed to open gpio %d value for reading!\n", i_a1);
        pthread_mutex_unlock(&i_g49);
        // 0x1d642
        return -2;
    }
    // 0x1d5cc
    int32_t i_v4; // 0x1d520
    if (read(i_v3, &i_v1, 4) < 0) {
        // 0x1d5e0
        printf("%s:%d", "gpio_read", 316);
        puts("Failed to read value!");
        close(i_v3);
        pthread_mutex_unlock(&i_g49);
        i_v4 = -3;
    } else {
        // 0x1d61c
        close(i_v3);
        pthread_mutex_unlock(&i_g49);
        *p_a2 = (char)atoi((char *)&i_v1);
        i_v4 = 0;
    }
    // 0x1d642
    return i_v4;
}

// Address range: 0x1d64c - 0x1d776
int32_t gpio_write(int32_t i_a1, uint32_t i_a2) {
    // 0x1d64c
    if (pthread_mutex_lock(&i_g49) != 0) {
        // 0x1d66a
        printf("%s:%d", "gpio_write", 341);
        puts("failed to api lock");
        // 0x1d76c
        return -1;
    }
    // 0x1d694
    int32_t i_v1; // bp-76, 0x1d64c
    snprintf((char *)&i_v1, 64, "/sys/class/gpio/gpio%d/value", i_a1);
    int32_t i_v2 = open((char *)&i_v1, O_WRONLY); // 0x1d6b2
    if (i_v2 < 0) {
        // 0x1d6be
        printf("%s:%d", "gpio_write", 348);
        puts("Failed to open gpio value for writing!");
        pthread_mutex_unlock(&i_g49);
        // 0x1d76c
        return -2;
    }
    if (i_a2 % 256 == 0) {
        __asm_ite();
    }
    int32_t i_v3 =
        i_a2 % 256 == 0 ? (int32_t) "01" : (int32_t) "01" + 1; // 0x1d70a
    int32_t i_v4;                                              // 0x1d64c
    if (write(i_v2, (int32_t *)i_v3, 1) < 0) {
        // 0x1d71c
        printf("%s:%d", "gpio_write", 354);
        puts("Failed to write value!");
        close(i_v2);
        pthread_mutex_unlock(&i_g49);
        i_v4 = -3;
    } else {
        // 0x1d758
        close(i_v2);
        pthread_mutex_unlock(&i_g49);
        i_v4 = 0;
    }
    // 0x1d76c
    return i_v4;
}

// Address range: 0x1d778 - 0x1d91c
int32_t iic_init(int32_t *p_a1) {
    // 0x1d778
    if (pthread_mutex_lock(&i_g52) != 0) {
        // 0x1d79c
        printf("%s:%d", "iic_init", 19);
        puts("failed to iic lock");
        // 0x1d912
        return -4;
    }
    if (p_a1 == NULL) {
        // 0x1d7ca
        printf("%s:%d", "iic_init", 25);
        puts("bad param");
        // 0x1d904
        pthread_mutex_unlock(&i_g52);
        // 0x1d912
        return -3;
    }
    int32_t i_v1 = i2c_init(0); // 0x1d7f6
    if (i_v1 < 0) {
        // 0x1d802
        printf("%s:%d", "iic_init", 31);
        puts("failed to i2c_init");
        // 0x1d904
        pthread_mutex_unlock(&i_g52);
        // 0x1d912
        return -1;
    }
    int32_t i_v2 = (int32_t)p_a1;
    int32_t i_v3 = printf("%s:%d", "iic_init", 35); // 0x1d83e
    int16_t *p_v4 = (int16_t *)(i_v2 + 4);          // 0x1d848
    uint16_t i_v5 = *p_v4;                          // 0x1d848
    char *p_v6 = (char *)(i_v2 + 6);                // 0x1d84e
    unsigned char i_v7 = *p_v6;                     // 0x1d84e
    char *p_v8 = (char *)(i_v2 + 7);                // 0x1d852
    unsigned char i_v9 = *p_v8;                     // 0x1d852
    printf(
        "i2c chain = %d, master = 0x%x, slave high= 0x%x, slave low = 0x%x\n",
        i_v3, (int32_t)i_v5, (int32_t)i_v7, (int32_t)i_v9);
    if (i2c_select(i_v1, (int32_t)*p_v4) == 0) {
        // 0x1d89e
        if (i2c_ioctl(i_v1, 1795, 2 * (int32_t)*p_v8 | 16 * (int32_t)*p_v6) ==
            0) {
            // 0x1d8e8
            pthread_mutex_unlock(&i_g52);
            // 0x1d912
            return i_v1;
        }
        // 0x1d8be
        printf("%s:%d", "iic_init", 42);
        puts("failed to i2c_ioctl");
    } else {
        // 0x1d874
        printf("%s:%d", "iic_init", 37);
        puts("failed to i2c_select");
    }
    // 0x1d8f8
    if (i_v1 >= 1) {
        // 0x1d8fe
        i2c_uninit(i_v1);
    }
    // 0x1d904
    pthread_mutex_unlock(&i_g52);
    // 0x1d912
    return -1;
}

// Address range: 0x1d91c - 0x1d97a
int32_t iic_uninit(int32_t i_a1) {
    // 0x1d91c
    int32_t i_v1; // 0x1d91c
    if (pthread_mutex_lock(&i_g52) == 0) {
        // 0x1d95e
        i2c_uninit(i_a1);
        int32_t i_v2; // 0x1d91c
        i_v1 = __asm_nop(pthread_mutex_unlock(&i_g52), i_v2, i_v2, 0);
    } else {
        // 0x1d93a
        printf("%s:%d", "iic_uninit", 63);
        i_v1 = puts("failed to i2c lock");
    }
    // 0x1d972
    return i_v1;
}

// Address range: 0x1d97c - 0x1d9e8
int32_t iic_read(int32_t i_a1, int32_t i_a2, int32_t i_a3) {
    // 0x1d97c
    int32_t i_v1; // 0x1d97c
    if (pthread_mutex_lock(&i_g52) == 0) {
        int32_t i_v2 = i2c_read(i_a1, i_a2, i_a3); // 0x1d9c8
        pthread_mutex_unlock(&i_g52);
        i_v1 = i_v2;
    } else {
        // 0x1d99a
        printf("%s:%d", "iic_read", 82);
        puts("failed to i2c lock");
        i_v1 = -4;
    }
    // 0x1d9de
    return i_v1;
}

// Address range: 0x1d9e8 - 0x1da54
int32_t iic_write(int32_t i_a1, int32_t i_a2, int32_t i_a3) {
    // 0x1d9e8
    int32_t i_v1; // 0x1d9e8
    if (pthread_mutex_lock(&i_g52) == 0) {
        int32_t i_v2 = i2c_write(i_a1, i_a2, i_a3); // 0x1da34
        pthread_mutex_unlock(&i_g52);
        i_v1 = i_v2;
    } else {
        // 0x1da06
        printf("%s:%d", "iic_write", 102);
        puts("failed to i2c lock");
        i_v1 = -4;
    }
    // 0x1da4a
    return i_v1;
}

// Address range: 0x1da54 - 0x1dac8
int32_t iic_read_reg(int32_t i_a1, char *p_a2, int32_t i_a3, char *p_a4,
                     int32_t i_a5) {
    // 0x1da54
    int32_t i_v1; // 0x1da54
    if (pthread_mutex_lock(&i_g52) == 0) {
        int32_t i_v2 = i2c_read_reg(i_a1, (int32_t)p_a2, i_a3, (int32_t)p_a4,
                                    i_a5); // 0x1daa8
        pthread_mutex_unlock(&i_g52);
        i_v1 = i_v2;
    } else {
        // 0x1da74
        printf("%s:%d", "iic_read_reg", 123);
        puts("failed to i2c lock");
        i_v1 = -4;
    }
    // 0x1dabe
    return i_v1;
}

// Address range: 0x1dac8 - 0x1db3c
int32_t iic_write_reg(int32_t i_a1, char *p_a2, int32_t i_a3, char *p_a4,
                      int32_t i_a5) {
    // 0x1dac8
    int32_t i_v1; // 0x1dac8
    if (pthread_mutex_lock(&i_g52) == 0) {
        int32_t i_v2 = i2c_write_reg(i_a1, (int32_t)p_a2, i_a3, (int32_t)p_a4,
                                     i_a5); // 0x1db1c
        pthread_mutex_unlock(&i_g52);
        i_v1 = i_v2;
    } else {
        // 0x1dae8
        printf("%s:%d", "iic_write_reg", 145);
        puts("failed to i2c lock");
        i_v1 = -4;
    }
    // 0x1db32
    return i_v1;
}

// Address range: 0x1db3c - 0x1dbda
int32_t pwm_init(int32_t i_a1, int32_t i_a2) {
    // 0x1db3c
    if (i_g40 == 0) {
        // 0x1db54
        printf("%s:%d", "pwm_init", 16);
        puts("please init platform first!!");
        // 0x1dbd0
        return -2;
    }
    int32_t i_v1; // 0x1db3c
    if (i_a1 == 1 || i_a1 == 0) {
        int32_t i_v2 = 8 * i_a1; // 0x1dbb6
        *(int32_t *)(i_v2 + (int32_t)&i_g53) = i_a2;
        *(char *)(i_v2 + (int32_t)&i_g53 + 4) = 1;
        i_v1 = i_a1 + 1;
    } else {
        // 0x1db82
        printf("%s:%d", "pwm_init", 20);
        puts((char *)((int32_t)&p_g304 | 0x20000));
        i_v1 = -3;
    }
    // 0x1dbd0
    return i_v1;
}

// Address range: 0x1dbdc - 0x1dc40
int32_t pwm_uninit(int32_t i_a1) {
    int32_t i_v1; // 0x1dbdc
    if (i_a1 < 3) {
        int32_t i_v2 = 8 * i_a1;                   // 0x1dc12
        int32_t i_v3 = i_v2 + (int32_t)&i_g53 - 8; // 0x1dc1e
        *(int32_t *)i_v3 = 0;
        *(char *)(i_v2 + (int32_t)&i_g53 - 4) = 0;
        i_v1 = __asm_nop(i_a1, 0, 0, i_v3);
    } else {
        // 0x1dbec
        printf("%s:%d", "pwm_uninit", 29);
        i_v1 = puts((char *)((int32_t)&p_g304 | 0x20000));
    }
    // 0x1dc38
    return i_v1;
}

// Address range: 0x1dc40 - 0x1dd10
int32_t pwm_set(int32_t i_a1, uint32_t i_a2) {
    uint32_t i_v1 = i_a1 - 1; // 0x1dc4c
    if (i_v1 >= 2) {
        // 0x1dc52
        printf("%s:%d", "pwm_set", 45);
        puts((char *)((int32_t)&p_g304 | 0x20000));
        // 0x1dd06
        return -3;
    }
    if (i_a1 != 1) {
        // 0x1dcda
        printf("%s:%d", "pwm_set", 55);
        __asm_nop(printf((char *)((int32_t)&p_g305 | 0x20000)), i_v1, 55, i_v1);
        // 0x1dd06
        return 0;
    }
    if (i_a2 >= 100) {
        __asm_it();
    }
    int32_t i_v2 = i_a2 >= 100 ? 100 : i_a2;
    if (i_g41 == 0) {
        // 0x1dcba
        fpga_write(*L"!\"#$%&", 100 - i_v2 | 0x10000 * i_v2);
    } else {
        // 0x1dc9a
        fpga_write(*L"!\"#$%&", 100 - i_v2 | 0x10000 * i_v2);
    }
    // 0x1dd06
    return 0;
}

// Address range: 0x1dd10 - 0x1ddd2
int32_t pwm_get(int32_t i_a1, uint32_t i_a2) {
    uint32_t i_v1 = i_a1 - 1; // 0x1dd22
    if (i_v1 >= 2) {
        // 0x1dd28
        printf("%s:%d", "pwm_get", 71);
        puts((char *)((int32_t)&p_g304 | 0x20000));
        // 0x1ddc8
        return -3;
    }
    if (i_v1 != 0) {
        // 0x1ddc4
        int32_t i_v2; // 0x1dd10
        __asm_nop(i_a1, i_a2, i_v2, i_v1);
        // 0x1ddc8
        return -5;
    }
    // 0x1dd58
    int32_t *p_v3; // 0x1dd10
    if (i_g41 == 0) {
        int32_t *p_v4 = (int32_t *)i_a2;
        fpga_read(*L"!\"#$%&", p_v4);
        p_v3 = p_v4;
    } else {
        int32_t *p_v5 = (int32_t *)i_a2;
        fpga_read(*L"!\"#$%&", p_v5);
        p_v3 = p_v5;
    }
    // 0x1dd8c
    *p_v3 = i_a2 / 0x10000;
    printf("%s:%d", "pwm_get", 79);
    printf("duty of fpga = 0x%x\n", (int32_t) "pwm_get");
    // 0x1ddc8
    return 0;
}

// Address range: 0x1ddd4 - 0x1e428
int32_t get_send_address_info(uint32_t i_a1, int32_t *p_a2, int32_t *p_a3,
                              int32_t *p_a4) {
    // 0x1ddd4
    if (i_g41 == 0) {
        if (i_a1 >= 9 != i_a1 != 9) {
            // 0x1e18a
            __asm_adr(4);
            return i_a1;
        }
        // 0x1e3e8
        printf("%s:%d", "get_send_address_info", 201);
        __asm_nop(printf("%s: The uart %d is not supported!!!\n",
                         "get_send_address_info", i_a1),
                  (int32_t) "get_send_address_info", i_a1, -1);
        // 0x1e41c
        return -1;
    }
    if (i_a1 >= 13 != i_a1 != 13) {
        // 0x1ddfe
        __asm_adr(4);
        return i_a1;
    }
    // 0x1e14e
    printf("%s:%d", "get_send_address_info", 124);
    printf("%s: The uart %d is not supported!!!\n", "get_send_address_info",
           i_a1);
    // 0x1e41c
    return -1;
}

// Address range: 0x1e428 - 0x1e7ea
int32_t get_read_address_info(uint32_t i_a1, int32_t *p_a2, int32_t *p_a3,
                              int32_t *p_a4) {
    // 0x1e428
    if (i_g41 == 0) {
        if (i_a1 >= 9 != i_a1 != 9) {
            // 0x1e624
            __asm_adr(4);
            return i_a1;
        }
        // 0x1e7a8
        printf("%s:%d", "get_read_address_info", 326);
        __asm_nop(printf("%s: The uart%d is not supported!!!\n",
                         "get_read_address_info", i_a1),
                  (int32_t) "get_read_address_info", i_a1, -1);
        // 0x1e7de
        return -1;
    }
    if (i_a1 >= 13 != i_a1 != 13) {
        // 0x1e450
        __asm_adr(4);
        return i_a1;
    }
    // 0x1e5e6
    printf("%s:%d", "get_read_address_info", 268);
    printf("%s: The uart%d is not supported!!!\n", "get_read_address_info",
           i_a1);
    // 0x1e7de
    return -1;
}

// Address range: 0x1e7ec - 0x1ec0e
int32_t check_how_many_uart_data_in_fpga(uint32_t i_a1, int32_t i_a2,
                                         int32_t i_a3, int32_t i_a4) {
    uint32_t i_v1 = i_a1 % 256;
    if (i_g41 == 0) {
        if (i_v1 >= 9 != i_v1 != 9) {
            // 0x1ea5a
            __asm_adr(4);
            return i_a1;
        }
        // 0x1ebd2
        printf("%s:%d", "check_how_many_uart_data_in_fpga", 449);
        printf("%s: The uart%d is not supported!!!\n",
               "check_how_many_uart_data_in_fpga", i_v1);
        // 0x1ec04
        return 0;
    }
    if (i_v1 >= 13 != i_v1 != 13) {
        // 0x1e812
        __asm_adr(4);
        return i_a1;
    }
    // 0x1ea1e
    printf("%s:%d", "check_how_many_uart_data_in_fpga", 394);
    printf("%s: The uart%d is not supported!!!\n",
           "check_how_many_uart_data_in_fpga", i_v1);
    // 0x1ec04
    return 0;
}

// Address range: 0x1ec10 - 0x1ede6
int32_t read_uart_data_in_fpga(int32_t i_a1, int32_t i_a2, uint32_t i_a3) {
    int32_t i_v1 = 0; // bp-28, 0x1ec1e
    int32_t i_v2 = 0; // bp-32, 0x1ec22
    int32_t i_v3 = 0; // bp-36, 0x1ec32
    if (get_read_address_info(i_a1, &i_v1, &i_v2, &i_v2) != 0) {
        // 0x1ec50
        printf("%s:%d", "read_uart_data_in_fpga", 461);
        printf("get_read_address_info error, chain_id = %d\n", i_a1);
        // 0x1eddc
        return 0;
    }
    // 0x1ec7a
    fpga_write(i_v1, __asm_ubfx(i_a3, 0, 10) | -0x80000000);
    int32_t i_v4 = 0; // 0x1ecfa
    int32_t i_v5 = 0; // 0x1ecfa
    if (i_a3 >= 4) {
        fpga_read(i_v2, &i_v3);
        int32_t i_v6 = 4 * i_v4; // 0x1ecac
        *(char *)(i_v6 + i_a2) = (char)(i_v3 / 0x1000000);
        *(char *)((i_v6 | 1) + i_a2) = (char)(i_v3 / 0x10000);
        *(char *)((i_v6 | 2) + i_a2) = (char)(i_v3 / 256);
        *(char *)((i_v6 | 3) + i_a2) = (char)i_v3;
        i_v4++;
        while (i_v4 < i_a3 / 4) {
            // 0x1ec9c
            fpga_read(i_v2, &i_v3);
            i_v6 = 4 * i_v4;
            *(char *)(i_v6 + i_a2) = (char)(i_v3 / 0x1000000);
            *(char *)((i_v6 | 1) + i_a2) = (char)(i_v3 / 0x10000);
            *(char *)((i_v6 | 2) + i_a2) = (char)(i_v3 / 256);
            *(char *)((i_v6 | 3) + i_a2) = (char)i_v3;
            i_v4++;
        }
        // 0x1ecf4
        i_v5 = 4 * i_v4;
    }
    int32_t i_v7 = i_a3 & -4; // 0x1ecfe
    uint32_t i_v8 = i_a3 % 4; // 0x1ed04
    if (i_v8 == 0) {
        // 0x1eddc
        return i_v7;
    }
    // 0x1ed10
    fpga_read(i_v2, &i_v3);
    switch ((int2_t)i_a3) {
    case -2: {
        // 0x1ed44
        *(char *)(i_v5 + i_a2) = (char)(i_v3 / 0x1000000);
        *(char *)((i_v5 | 1) + i_a2) = (char)(i_v3 / 0x10000);
        // 0x1eddc
        return i_v7 | 2;
    }
    case -1: {
        // 0x1ed6e
        *(char *)(i_v5 + i_a2) = (char)(i_v3 / 0x1000000);
        *(char *)((i_v5 | 1) + i_a2) = (char)(i_v3 / 0x10000);
        *(char *)((i_v5 | 2) + i_a2) = (char)(i_v3 / 256);
        // 0x1eddc
        return i_a3 | 3;
    }
    case 1: {
        // 0x1ed2c
        *(char *)(i_v5 + i_a2) = (char)(i_v3 / 0x1000000);
        // 0x1eddc
        return i_v7 | 1;
    }
    }
    // 0x1edaa
    printf("%s:%d", "read_uart_data_in_fpga", 507);
    __asm_nop(printf("%s: the uart%d left data is 4*N length, error!!!\n",
                     "read_uart_data_in_fpga", i_a1),
              (int32_t) "read_uart_data_in_fpga", i_a1, i_v8);
    // 0x1eddc
    return i_v7;
}

// Address range: 0x1ede8 - 0x1ee2a
int32_t uart_init(void) {
    int32_t i_v1 = 0; // 0x1edf8
    if (i_g40 == 0) {
        // 0x1edfa
        printf("%s:%d", "uart_init", 518);
        puts("please init platform first!!");
        i_v1 = -1;
    }
    // 0x1ee26
    return i_v1;
}

// Address range: 0x1ee2c - 0x1ee36
int32_t uart_uninit(void) {
    // 0x1ee2c
    int32_t i_v1; // 0x1ee2c
    return i_v1;
}

// Address range: 0x1ee38 - 0x1ef10
int32_t hexdump(int32_t i_a1, int32_t i_a2, int32_t i_a3) {
    int32_t i_v1 = printf("Dumping %u %s bytes from %p:\n", i_a3, (char *)i_a1,
                          (int32_t *)i_a2); // 0x1ee56
    int32_t i_v2 = i_a3;                    // 0x1ef02
    int32_t i_v3 = i_a2;                    // 0x1ef02
    if (i_a3 <= 0) {
        // 0x1ef08
        return i_v1;
    }
    int32_t i_v4 = i_a3; // 0x1ef02
    int32_t i_v5;        // 0x1ee38
    int32_t i_v6;        // 0x1ee38
    int32_t i_v7;        // 0x1ee38
    while (true) {
    lab_0x1ee94:
        // 0x1ee94
        i_v6 = i_v4;
        i_v5 = i_v3;
        int32_t i_v8 = 0;    // 0x1ee90
        int32_t i_v9 = i_v2; // 0x1ee38
        while (true) {
            uint32_t i_v10 = i_v8;
            int32_t i_v11; // 0x1ee38
            if (i_v6 == i_v10 || i_v6 < i_v10) {
                // 0x1ee82
                printf("   ");
                i_v11 = i_v9;
            } else {
                int32_t i_v12 = (int32_t) * (char *)(i_v10 + i_v5); // 0x1ee70
                printf("%02x ", i_v12);
                i_v11 = i_v12;
            }
            // 0x1ee8e
            i_v2 = i_v11;
            i_v8 = i_v10 + 1;
            i_v9 = i_v2;
            i_v7 = 0;
            if (i_v8 != 15 && i_v8 >= 15) {
                goto lab_0x1eea0;
            }
        }
        goto lab_0x1eee6;
    }
lab_0x1ef06:;
    // 0x1ef08
    int32_t i_v13; // 0x1ee38
    int32_t i_v14; // 0x1eee8
    return __asm_nop(i_v14, i_v2, i_v13, i_v6);
lab_0x1eea0:;
    uint32_t i_v15 = i_v7;
    int32_t i_v16; // 0x1ee38
    if (i_v6 == i_v15 || i_v6 < i_v15) {
        // 0x1eed4
        putchar(32);
        i_v13 = i_v6;
        goto lab_0x1eeda;
    } else {
        unsigned char i_v17 = *(char *)(i_v15 + i_v5); // 0x1eeae
        i_v16 = 46;
        if (i_v17 == 31 || i_v17 < 31) {
            goto lab_0x1eecc;
        } else {
            // 0x1eeb4
            i_v16 = i_v17 >= 126 == (i_v17 != 126) ? 46 : (int32_t)i_v17;
            goto lab_0x1eecc;
        }
    }
lab_0x1eee6:
    // 0x1eee6
    i_v14 = putchar(10);
    if (i_v6 < 17) {
        // break -> 0x1ef06
        goto lab_0x1ef06;
    }
    // 0x1eef8
    i_v3 = i_v5 + 16;
    i_v4 = i_v6 - 16;
    goto lab_0x1ee94;
lab_0x1eeda:;
    int32_t i_v18 = i_v15 + 1; // 0x1eedc
    i_v7 = i_v18;
    if (i_v18 == 15 || i_v18 < 15) {
        goto lab_0x1eea0;
    } else {
        goto lab_0x1eee6;
    }
lab_0x1eecc:
    // 0x1eecc
    putchar(i_v16);
    i_v13 = i_v5;
    goto lab_0x1eeda;
}

// Address range: 0x1ef10 - 0x1f212
int32_t uart_send(int32_t i_a1, int32_t *p_a2, uint32_t i_a3) {
    // 0x1ef10
    int32_t i_v1; // bp-292, 0x1ef10
    memset(&i_v1, 0, 256);
    int32_t i_v2 = 0; // bp-296, 0x1ef60
    int32_t i_v3 = 0; // bp-300, 0x1ef68
    int32_t i_v4 = 0; // bp-308, 0x1ef78
    int32_t i_v5 = 0; // bp-312, 0x1ef80
    int32_t *p_v6 = (int32_t *)(24 * i_a1 + (int32_t)&i_g54);
    pthread_mutex_lock(p_v6);
    if (get_send_address_info(i_a1, &i_v5, &i_v2, &i_v3) != 0) {
        // 0x1efc2
        printf("%s:%d", "uart_send", 584);
        printf("get_send_address_info error, chain_id = %d\n", i_a1);
        pthread_mutex_unlock(p_v6);
        // 0x1f208
        return 0;
    }
    int32_t i_v7 = &i_v4;                  // 0x1f024
    int32_t i_v8 = fpga_read(i_v2, &i_v4); // 0x1f026
    uint32_t i_v9 = (i_v4 >> i_v5) % 256;  // 0x1f03a
    i_v4 = i_v9;
    __asm_nop(i_v8, i_v7, i_v9, i_a3);
    while (i_v9 < i_a3) {
        // 0x1f018
        i_v8 = fpga_read(i_v2, &i_v4);
        i_v9 = (i_v4 >> i_v5) % 256;
        i_v4 = i_v9;
        __asm_nop(i_v8, i_v7, i_v9, i_a3);
    }
    int32_t i_v10 = i_v3; // 0x1f060
    __asm_nop(fpga_read(i_v10, &i_v4), i_v7, i_v10, (int32_t)(i_v4 < 0));
    while (i_v4 < 0) {
        // 0x1f05c
        i_v10 = i_v3;
        __asm_nop(fpga_read(i_v10, &i_v4), i_v7, i_v10, (int32_t)(i_v4 < 0));
    }
    // 0x1f07a
    memcpy(&i_v1, p_a2, i_a3);
    int32_t i_v11 = 0; // 0x1f10c
    if (i_a3 >= 4) {
        int32_t i_v12 = &i_v1;                                // 0x1f0a8
        int32_t i_v13 = 0;                                    // 0x1ef10
        int32_t i_v14 = 4 * i_v13;                            // 0x1f0a6
        unsigned char i_v15 = *(char *)(i_v14 + i_v12);       // 0x1f0ac
        unsigned char i_v16 = *(char *)((i_v14 | 1) + i_v12); // 0x1f0bc
        unsigned char i_v17 = *(char *)((i_v14 | 2) + i_v12); // 0x1f0ce
        unsigned char i_v18 = *(char *)((i_v14 | 3) + i_v12); // 0x1f0e0
        fpga_write(0, 0x10000 * (int32_t)i_v16 | 0x1000000 * (int32_t)i_v15 |
                          256 * (int32_t)i_v17 | (int32_t)i_v18);
        int32_t i_v19 = i_v13 + 1; // 0x1f0fc
        i_v13 = i_v19;
        while (i_v19 < i_a3 / 4) {
            // 0x1f0a2
            i_v14 = 4 * i_v13;
            i_v15 = *(char *)(i_v14 + i_v12);
            i_v16 = *(char *)((i_v14 | 1) + i_v12);
            i_v17 = *(char *)((i_v14 | 2) + i_v12);
            i_v18 = *(char *)((i_v14 | 3) + i_v12);
            fpga_write(0, 0x10000 * (int32_t)i_v16 |
                              0x1000000 * (int32_t)i_v15 |
                              256 * (int32_t)i_v17 | (int32_t)i_v18);
            i_v19 = i_v13 + 1;
            i_v13 = i_v19;
        }
        // 0x1f102
        i_v11 = 4 * i_v19;
    }
    // 0x1f10e
    switch ((int2_t)i_a3) {
    case 0: {
        goto lab_0x1f1d0;
    }
    case -2: {
        int32_t i_v20 = &i_v1;                                // 0x1f14c
        unsigned char i_v21 = *(char *)(i_v11 + i_v20);       // 0x1f150
        unsigned char i_v22 = *(char *)((i_v11 | 1) + i_v20); // 0x1f160
        // 0x1f1c0
        fpga_write(0, 0x10000 * (int32_t)i_v22 | 0x1000000 * (int32_t)i_v21);
        goto lab_0x1f1d0;
    }
    case -1: {
        int32_t i_v23 = &i_v1;                                // 0x1f172
        unsigned char i_v24 = *(char *)(i_v11 + i_v23);       // 0x1f176
        unsigned char i_v25 = *(char *)((i_v11 | 1) + i_v23); // 0x1f186
        unsigned char i_v26 = *(char *)((i_v11 | 2) + i_v23); // 0x1f198
        int32_t i_v27 = 0x10000 * (int32_t)i_v25 | 0x1000000 * (int32_t)i_v24 |
                        256 * (int32_t)i_v26; // 0x1f1a2
        // 0x1f1c0
        fpga_write(0, i_v27);
        goto lab_0x1f1d0;
    }
    case 1: {
        unsigned char i_v28 = *(char *)(i_v11 + (int32_t)&i_v1); // 0x1f13c
        // 0x1f1c0
        fpga_write(0, 0x1000000 * (int32_t)i_v28);
        goto lab_0x1f1d0;
    }
    default: {
        // 0x1f1a42
        // UNREACHABLE
    }
    }
lab_0x1f1d0:
    // 0x1f1d0
    fpga_write(i_v3, i_a3 | -0x80000000);
    pthread_mutex_unlock(p_v6);
    // 0x1f208
    return i_a3;
}

// Address range: 0x1f214 - 0x1f2d0
int32_t uart_receive(uint32_t i_a1, int32_t i_a2, uint32_t i_a3, int32_t i_a4) {
    int32_t *p_v1 = (int32_t *)(24 * i_a1 + (int32_t)&i_g55); // 0x1f244
    pthread_mutex_lock(p_v1);
    uint32_t i_v2 = i_a1 % 256; // 0x1f24a
    uint32_t i_v3 = check_how_many_uart_data_in_fpga(
        i_v2, i_a2, (int32_t)&i_g55, i_v2); // 0x1f24e
    int32_t i_v4 = i_v3 == i_a3 | i_v3 < i_a3 ? i_v3 : i_a3;
    int32_t i_v5; // 0x1f214
    if (i_v4 == 0) {
        // 0x1f2aa
        pthread_mutex_unlock(p_v1);
        i_v5 = 0;
    } else {
        int32_t i_v6 = read_uart_data_in_fpga(i_a1, i_a2, i_v4); // 0x1f27e
        pthread_mutex_unlock(p_v1);
        i_v5 = i_v6;
    }
    // 0x1f2c6
    return i_v5;
}

// Address range: 0x1f2d0 - 0x1f3a0
int32_t uart_set_config(int32_t i_a1, int32_t i_a2, int32_t *p_a3,
                        int32_t i_a4) {
    // 0x1f2d0
    if (p_a3 == NULL) {
        // 0x1f396
        return -3;
    }
    int32_t *p_v1 = (int32_t *)(24 * i_a1 + (int32_t)&i_g54); // 0x1f306
    pthread_mutex_lock(p_v1);
    if (i_a2 != 0) {
        // 0x1f352
        printf("%s:%d", "uart_set_config", 736);
        __asm_nop(printf("unknown set config type = %d\n", i_a2), i_a2, 736,
                  i_a2);
        // 0x1f37a
        pthread_mutex_unlock(p_v1);
        // 0x1f396
        return -5;
    }
    // 0x1f310
    int32_t i_v2; // 0x1f2d0
    if (i_g41 == 0) {
        int32_t i_v3 = i_g174; // 0x1f340
        i_v2 = fpga_write(i_v3, i_v3);
    } else {
        int32_t i_v4 = i_g169; // 0x1f326
        i_v2 = fpga_write(i_v4, i_v4);
    }
    // 0x1f37a
    pthread_mutex_unlock(p_v1);
    // 0x1f396
    return i_v2;
}

// Address range: 0x1f3a0 - 0x1f4c0
int32_t uart_get_config(int32_t i_a1, int32_t i_a2, int32_t i_a3,
                        int32_t i_a4) {
    // 0x1f3a0
    if (i_a3 != 0 != (i_a4 == 0)) {
        // 0x1f4b6
        return -3;
    }
    int32_t *p_v1 = (int32_t *)(24 * i_a1 + (int32_t)&i_g54); // 0x1f3dc
    pthread_mutex_lock(p_v1);
    if (i_a2 != 0) {
        // 0x1f472
        printf("%s:%d", "uart_get_config", 767);
        __asm_nop(printf("unknown set config type = %d\n", i_a2), i_a2, 767,
                  i_a2);
        pthread_mutex_unlock(p_v1);
        // 0x1f4b6
        return -5;
    }
    // 0x1f3e6
    if (i_g41 == 0) {
        int32_t i_v2 = 0; // bp-20, 0x1f420
        fpga_read(i_g174, &i_v2);
        *(int32_t *)i_a3 = i_v2;
        abort();
        // UNREACHABLE
    }
    int32_t i_v3 = 0; // bp-16, 0x1f3f6
    fpga_read(i_g169, &i_v3);
    *(int32_t *)i_a3 = i_v3;
    abort();
    // UNREACHABLE
}

// Address range: 0x1f4c0 - 0x1f618
int32_t clear_uart_tx_fifo(int32_t i_a1) {
    int32_t i_v1 = 0;                                         // bp-16, 0x1f4ca
    int32_t i_v2 = 0;                                         // bp-20, 0x1f4ce
    int32_t i_v3 = 0;                                         // bp-28, 0x1f4d6
    int32_t i_v4 = 0;                                         // bp-32, 0x1f4da
    int32_t *p_v5 = (int32_t *)(24 * i_a1 + (int32_t)&i_g54); // 0x1f4f6
    pthread_mutex_lock(p_v5);
    if (get_send_address_info(i_a1, &i_v4, &i_v1, &i_v2) != 0) {
        // 0x1f518
        printf("%s:%d", "clear_uart_tx_fifo", 783);
        printf("get_send_address_info error, chain_id = %d\n", i_a1);
        // 0x1f610
        return pthread_mutex_unlock(p_v5);
    }
    // 0x1f562
    fpga_read(i_v1, &i_v3);
    int32_t i_v6 = (i_v3 >> i_v4) % 256; // 0x1f578
    i_v3 = i_v6;
    if (i_v6 == 255) {
        // 0x1f610
        return pthread_mutex_unlock(p_v5);
    }
    int32_t i_v7 = 0; // 0x1f580
    printf("%s: waiting fpga uart%d clear send fifo space ...\n",
           "clear_uart_tx_fifo", i_a1);
    int32_t i_v8 = usleep(3000); // 0x1f5b8
    i_v7++;
    while (i_v7 == 20 || i_v7 < 20) {
        // 0x1f560
        __asm_nop(i_v8, (int32_t) "clear_uart_tx_fifo", i_a1, i_v7);
        fpga_read(i_v1, &i_v3);
        int32_t i_v9 = (i_v3 >> i_v4) % 256; // 0x1f578
        i_v3 = i_v9;
        if (i_v9 == 255) {
            // 0x1f610
            return pthread_mutex_unlock(p_v5);
        }
        printf("%s: waiting fpga uart%d clear send fifo space ...\n",
               "clear_uart_tx_fifo", i_a1);
        i_v8 = usleep(3000);
        i_v7++;
    }
    // 0x1f5c8
    printf("%s:%d", "clear_uart_tx_fifo", 803);
    printf("%s: uart%d always dose not has enough send fifo space, break\n",
           "clear_uart_tx_fifo", i_a1);
    // 0x1f610
    return pthread_mutex_unlock(p_v5);
}

// Address range: 0x1f618 - 0x1f78a
int32_t clear_uart_rx_fifo(uint32_t i_a1) {
    int32_t i_v1 = 24 * i_a1 + (int32_t)&i_g55; // 0x1f63e
    int32_t *p_v2 = (int32_t *)i_v1;            // 0x1f642
    pthread_mutex_lock(p_v2);
    uint32_t i_v3 = i_a1 % 256; // 0x1f648
    int32_t i_v4;               // 0x1f618
    int32_t i_v5 = check_how_many_uart_data_in_fpga(i_v3, i_v4, (int32_t)&i_g55,
                                                    i_v3); // 0x1f64c
    if (i_v5 == 0) {
        // 0x1f782
        return pthread_mutex_unlock(p_v2);
    }
    int32_t *p_v6 = malloc(i_v5); // 0x1f676
    if (p_v6 == NULL) {
        // 0x1f684
        printf("%s:%d", "clear_uart_rx_fifo", 831);
        printf("%s: uart%d malloc buffer error\n", "clear_uart_rx_fifo", i_a1);
        usleep((int32_t)&i_g207);
        // 0x1f782
        return pthread_mutex_unlock(p_v2);
    }
    int32_t i_v7 = (int32_t)p_v6;                            // 0x1f676
    int32_t i_v8 = read_uart_data_in_fpga(i_a1, i_v7, i_v5); // 0x1f6e4
    int32_t i_v9;                                            // 0x1f618
    if (i_v8 == i_v5) {
        // 0x1f754
        free(p_v6);
        usleep(0x2710);
        i_v9 =
            __asm_nop(pthread_mutex_unlock(p_v2), i_v7, (int32_t)&i_g55, i_v1);
    } else {
        // 0x1f6f2
        printf("%s:%d", "clear_uart_rx_fifo", 840);
        printf("%s: uart%d clear rx fifo error. nbytes = %d, len = %d\n",
               "clear_uart_rx_fifo", i_a1, i_v5, i_v8);
        free(p_v6);
        usleep(0x2710);
        i_v9 = pthread_mutex_unlock(p_v2);
    }
    // 0x1f782
    return i_v9;
}

// Address range: 0x1f78c - 0x1f7da
int32_t uart_flush(int32_t i_a1) {
    // 0x1f78c
    printf("%s:%d", "uart_flush", 859);
    printf("flush uart %d\n", i_a1);
    clear_uart_rx_fifo(i_a1);
    usleep(0x2710);
    clear_uart_tx_fifo(i_a1);
    return 0;
}

// Address range: 0x1f7dc - 0x1f7f6
int32_t uart_flush_tx(int32_t i_a1) {
    // 0x1f7dc
    clear_uart_tx_fifo(i_a1);
    return 0;
}

// Address range: 0x1f7f8 - 0x1f812
int32_t uart_flush_rx(int32_t i_a1) {
    // 0x1f7f8
    clear_uart_rx_fifo(i_a1);
    return 0;
}

// Address range: 0x1f814 - 0x1f86a
int32_t uart_get_readable_byte_num(uint32_t i_a1) {
    int32_t *p_v1 = (int32_t *)(24 * i_a1 + (int32_t)&i_g55); // 0x1f832
    pthread_mutex_lock(p_v1);
    uint32_t i_v2 = i_a1 % 256; // 0x1f838
    int32_t i_v3;               // 0x1f814
    int32_t i_v4 = check_how_many_uart_data_in_fpga(i_v2, i_v3, (int32_t)&i_g55,
                                                    i_v2); // 0x1f83c
    pthread_mutex_unlock(p_v1);
    return i_v4;
}

// Address range: 0x1f86c - 0x1f98e
int32_t ui_pull_function(int32_t i_a1) {
    // 0x1f86c
    if (i_g59 == 0) {
        // 0x1f982
        return 0;
    }
    int32_t i_v1 = pthread_mutex_lock(&i_g56); // 0x1f87e
    int32_t i_v2;                              // 0x1f86c
    int32_t i_v3;                              // 0x1f86c
    if (i_v1 == 0) {
        // 0x1f888
        if (new_iterator_c_map(i_g57) != 0) {
            // break -> 0x1f8a6
            break;
        }
        // 0x1f944
        delete_iterator_c_map(0);
        pthread_mutex_unlock(&i_g56);
    } else {
        // 0x1f958
        __asm_nop(i_v1, i_v3, i_v2, i_v1);
    }
    // 0x1f95a
    usleep(0x30d40);
    i_v2 = 1000;
    while (i_g59 != 0) {
        // 0x1f876
        i_v1 = pthread_mutex_lock(&i_g56);
        if (i_v1 == 0) {
            // 0x1f888
            if (new_iterator_c_map(i_g57) != 0) {
                // break -> 0x1f8a6
                break;
            }
            // 0x1f944
            delete_iterator_c_map(0);
            pthread_mutex_unlock(&i_g56);
        } else {
            // 0x1f958
            __asm_nop(i_v1, i_v3, i_v2, i_v1);
        }
        // 0x1f95a
        usleep(0x30d40);
        i_v2 = 1000;
    }
    // 0x1f982
    return 0;
}

// Address range: 0x1f990 - 0x1f9b0
int32_t gpio_compare_e2(int32_t i_a1, int32_t i_a2) {
    // 0x1f990
    return i_a1 - i_a2;
}

// Address range: 0x1f9b0 - 0x1fa0c
int32_t convert_ui_type_to_port(uint32_t i_a1) {
    // 0x1f9b0
    if (i_a1 == 2) {
        // 0x1f9fe
        return 942;
    }
    int32_t i_v1; // 0x1f9b0
    if (i_a1 < 2) {
        // 0x1f9c6
        if (i_a1 == 1) {
            // 0x1f9fe
            return 941;
        }
        // 0x1f9fc
        int32_t i_v2; // 0x1f9b0
        __asm_nop(i_a1, i_v1, i_v2, i_a1);
        // 0x1f9fe
        return 0;
    }
    // 0x1f9cc
    switch (i_a1) {
    case 256: {
        // 0x1f9fe
        return 921;
    }
    case 257: {
        // 0x1f9fe
        return 943;
    }
    }
    // 0x1f9fc
    __asm_nop(i_a1, i_v1, 257, i_a1);
    // 0x1f9fe
    return 0;
}

// Address range: 0x1fa0c - 0x1fa4e
int32_t convert_port_to_ui_type(int32_t i_a1) {
    int32_t i_v1 = 256; // 0x1fa0c
    switch (i_a1) {
    case 943: {
        // 0x1fa36
        i_v1 = 257;
    }
    case 921: {
        // 0x1fa40
        return i_v1;
    }
    default: {
        // 0x1fa3e
        int32_t i_v2; // 0x1fa0c
        __asm_nop(i_a1, i_v2, 943, i_a1);
        i_v1 = 258;
        return i_v1;
    }
    }
}

// Address range: 0x1fa50 - 0x1fade
int32_t gpio_key_callback(int32_t i_a1, uint32_t i_a2) {
    int32_t i_v1 = convert_port_to_ui_type(i_a1); // 0x1fa5e
    if (i_v1 == 258) {
        // 0x1fa6c
        printf("%s:%d", "gpio_key_callback", 110);
        // 0x1fad6
        return printf("gpio port %d is not a supported key\n", i_a1);
    }
    for (int32_t i_v2 = 0; i_v2 < 5; i_v2++) {
        int32_t i_v3 = *(int32_t *)(4 * i_v2 + (int32_t)&i_g61); // 0x1faa2
        if (i_a2 % 256 == 0 == (i_v3 != 0)) {
            __asm_ite();
        }
    }
    // 0x1fad6
    return i_v1;
}

// Address range: 0x1fae0 - 0x1fc22
int32_t ui_init(void) {
    // 0x1fae0
    if (i_g58 != 0) {
        // 0x1fc18
        return 0;
    }
    // 0x1fafc
    if (gpio_init() != 0) {
        // 0x1fb06
        printf("%s:%d", "ui_init", 124);
        puts("gpio init failed");
        // 0x1fc18
        return -1;
    }
    // 0x1fb2e
    gpio_export(convert_ui_type_to_port(1));
    gpio_export(convert_ui_type_to_port(2));
    gpio_export(convert_ui_type_to_port(256));
    gpio_export(convert_ui_type_to_port(257));
    gpio_reg_callback(convert_ui_type_to_port(256), 0x1fa51);
    gpio_reg_callback(convert_ui_type_to_port(257), 0x1fa51);
    pthread_mutex_init(&i_g56, NULL);
    for (int32_t i_v1 = 0; i_v1 < 5; i_v1++) {
        // 0x1fbae
        *(int32_t *)(4 * i_v1 + (int32_t)&i_g61) = 0;
    }
    // 0x1fbca
    i_g57 = new_c_map(0x1f991, 0, 0);
    i_g59 = 1;
    pthread_create(&i_g60, NULL, (int32_t * (*)(int32_t *))0x1f86d, NULL);
    i_g58 = 1;
    // 0x1fc18
    return 0;
}

// Address range: 0x1fc24 - 0x1fcee
int32_t ui_uninit(void) {
    // 0x1fc24
    int32_t i_v1; // 0x1fc24
    if (i_g58 != 0) {
        // 0x1fc36
        i_g59 = 0;
        pthread_join(i_g60, NULL);
        delete_c_map(i_g57);
        pthread_mutex_destroy(&i_g56);
        gpio_unreg_callback(convert_ui_type_to_port(256), 0x1fa51);
        gpio_unreg_callback(convert_ui_type_to_port(257), 0x1fa51);
        gpio_unexport(convert_ui_type_to_port(1));
        gpio_unexport(convert_ui_type_to_port(2));
        gpio_unexport(convert_ui_type_to_port(256));
        gpio_unexport(convert_ui_type_to_port(257));
        int32_t i_v2 = gpio_uninit(); // 0x1fcdc
        i_g58 = 0;
        i_v1 = i_v2;
    }
    // 0x1fcec
    return i_v1;
}

// Address range: 0x1fcf0 - 0x1fd50
int32_t remove_port_form_gpio_map(int32_t i_a1, int32_t i_a2) {
    int32_t i_v1 = i_a1; // bp-12, 0x1fcf6
    if (i_a2 == 0) {
        // 0x1fd48
        int32_t i_v2; // 0x1fcf0
        return __asm_nop(i_a1, 0, i_v2, 0);
    }
    int32_t i_v3 = exists_c_map(i_a2, &i_v1); // 0x1fd06
    int32_t i_v4 = i_v3;                      // 0x1fd0e
    int32_t i_v5 = i_v3;                      // 0x1fd0e
    int32_t i_v6;                             // 0x1fcf0
    if (i_v3 == 1) {
        // 0x1fd10
        printf("%s:%d", "remove_port_form_gpio_map", 168);
        printf("remove %d from flicker list\n", i_v1);
        i_v4 = remove_c_map(i_a2, &i_v1);
        i_v6 = 168;
    }
    // 0x1fd48
    return __asm_nop(i_v4, i_v5, i_v6, i_v5);
}

// Address range: 0x1fd50 - 0x1fdf2
int32_t add_port_to_gpio_map(int32_t i_a1, int32_t i_a2, int32_t i_a3) {
    int32_t i_v1 = i_a1; // bp-28, 0x1fd56
    if (i_a3 == 0) {
        // 0x1fdea
        return __asm_nop(i_a1, i_a2, 0, 0);
    }
    // 0x1fd62
    int32_t i_v2; // 0x1fd50
    if (exists_c_map(i_a3, &i_v1) == 0) {
        // 0x1fd74
        printf("%s:%d", "add_port_to_gpio_map", 180);
        printf("add %d to flicker map with interval %d\n", i_v1, i_a2);
        int32_t i_v3 = i_a2; // bp-20, 0x1fd9e
        i_v2 = insert_c_map(i_a3, &i_v1, 4, &i_v3, 12);
    } else {
        // 0x1fdc0
        printf("%s:%d", "add_port_to_gpio_map", 184);
        i_v2 = printf("port %d already exist in map\n", i_v1);
    }
    // 0x1fdea
    return i_v2;
}

// Address range: 0x1fdf4 - 0x1feaa
int32_t update_filcker_freq(int32_t i_a1, int32_t i_a2, int32_t i_a3) {
    if (i_a3 == 0) {
        // 0x1fea2
        return __asm_nop(i_a1, i_a2, 0, 0);
    }
    int32_t i_v1 = new_iterator_c_map(i_a3); // 0x1fe08
    while (i_v1 != 0) {
        int32_t i_v2 =
            *(int32_t *)*(int32_t *)(*(int32_t *)(i_v1 + 20) + 16); // 0x1fe24
        if (*(int32_t *)i_v2 == i_a1) {
            // 0x1fe2e
            printf("%s:%d", "update_filcker_freq", 201);
            int32_t *p_v3 = (int32_t *)i_v1; // 0x1fe6c
            printf("update the freq interval of port[%d] from %d to %d\n", i_a1,
                   *p_v3, i_a2);
            free(p_v3);
            return delete_iterator_c_map(i_v1);
        }
    }
lab_0x1fe98:
    // 0x1fea2
    return delete_iterator_c_map(i_v1);
}

// Address range: 0x1feac - 0x20002
int32_t gpio_ctrl_ui(int32_t i_a1, int32_t i_a2) {
    int32_t i_v1 = convert_ui_type_to_port(i_a1); // 0x1febe
    if (i_v1 == 0) {
        // 0x1feca
        printf("%s:%d", "gpio_ctrl_ui", 222);
        puts("unsuported gpio port");
        // 0x1fff8
        return -1;
    }
    // 0x1fef2
    printf("%s:%d", "gpio_ctrl_ui", 225);
    printf("ui type = %d, port = %d, status = %d\n", i_a1, i_v1, i_a2);
    if (pthread_mutex_lock(&i_g56) != 0) {
        // 0x1ff2c
        printf("%s:%d", "gpio_ctrl_ui", 227);
        puts("failed to api lock");
        // 0x1fff8
        return -1;
    }
    int32_t i_v2; // 0x1feac
    switch (i_a2) {
    case 1: {
        // 0x1ff82
        remove_port_form_gpio_map(i_v1, i_g57);
        i_v2 = gpio_write(i_v1, 0);
        // break -> 0x1ffea
        break;
    }
    case 0: {
        // 0x1ff64
        remove_port_form_gpio_map(i_v1, i_g57);
        i_v2 = gpio_write(i_v1, 1);
        // break -> 0x1ffea
        break;
    }
    case 2: {
        // 0x1ffa0
        add_port_to_gpio_map(i_v1, 200, i_g57);
        i_v2 = -1;
        // break -> 0x1ffea
        break;
    }
    default: {
        // 0x1ffc0
        printf("%s:%d", "gpio_ctrl_ui", 243);
        __asm_nop(puts("unsuported led status"), (int32_t) "gpio_ctrl_ui", 243,
                  -2);
        i_v2 = -2;
        // break -> 0x1ffea
        break;
    }
    }
    // 0x1ffea
    pthread_mutex_unlock(&i_g56);
    // 0x1fff8
    return i_v2;
}

// Address range: 0x20004 - 0x2009e
int32_t gpio_set_led_filker_freq(int32_t i_a1, int32_t i_a2) {
    int32_t i_v1 = convert_ui_type_to_port(i_a1); // 0x20010
    if (i_v1 == 0) {
        // 0x2001c
        printf("%s:%d", "gpio_set_led_filker_freq", 262);
        puts("unsuported led port");
        // 0x20094
        return -1;
    }
    if (i_a2 == 200) {
        // 0x20056
        printf("%s:%d", "gpio_set_led_filker_freq", 266);
        puts("interval is same with default");
    } else {
        // 0x2007e
        update_filcker_freq(i_v1, i_a2, i_g57);
    }
    // 0x20094
    return 0;
}

// Address range: 0x200a0 - 0x200b2
int32_t red_led_on(void) {
    // 0x200a0
    return gpio_ctrl_ui(1, 0);
}

// Address range: 0x200b4 - 0x200c6
int32_t red_led_off(void) {
    // 0x200b4
    return gpio_ctrl_ui(1, 1);
}

// Address range: 0x200c8 - 0x200da
int32_t red_led_flicker(void) {
    // 0x200c8
    return gpio_ctrl_ui(1, 2);
}

// Address range: 0x200dc - 0x200ee
int32_t green_led_on(void) {
    // 0x200dc
    return gpio_ctrl_ui(2, 0);
}

// Address range: 0x200f0 - 0x20102
int32_t green_led_off(int32_t i_a1) {
    // 0x200f0
    return gpio_ctrl_ui(2, 1);
}

// Address range: 0x20104 - 0x20116
int32_t green_led_flicker(void) {
    // 0x20104
    return gpio_ctrl_ui(2, 2);
}

// Address range: 0x20118 - 0x2012a
int32_t beeper_on(void) {
    // 0x20118
    return gpio_ctrl_ui(16, 0);
}

// Address range: 0x2012c - 0x2013e
int32_t beeper_off(void) {
    // 0x2012c
    return gpio_ctrl_ui(16, 1);
}

// Address range: 0x20140 - 0x20152
int32_t beeper_flicker(void) {
    // 0x20140
    return gpio_ctrl_ui(16, 2);
}

// Address range: 0x20154 - 0x2021e
int32_t reg_key_callback(int32_t i_a1) {
    int32_t i_v1 = pthread_mutex_lock(&i_g56); // 0x2016c
    int32_t i_v2 = 0;                          // 0x20174
    if (i_v1 != 0) {
        // 0x20176
        printf("%s:%d", "reg_key_callback", 320);
        puts("failed to api lock");
        // 0x20214
        return -1;
    }
    int32_t *p_v3 = (int32_t *)(4 * i_v2 + (int32_t)&i_g61); // 0x201b0
    int32_t i_v4;                                            // 0x20154
    while (*p_v3 != 0) {
        // 0x201d0
        i_v2++;
        if (i_v2 >= 5) {
            // 0x201dc
            printf("%s:%d", "reg_key_callback", 331);
            puts("no more listener available");
            i_v4 = -2;
            goto lab_0x20206;
        }
        p_v3 = (int32_t *)(4 * i_v2 + (int32_t)&i_g61);
    }
    // 0x201d6
    *p_v3 = i_a1;
    i_v4 = 0;
lab_0x20206:
    // 0x20206
    pthread_mutex_unlock(&i_g56);
    // 0x20214
    return i_v4;
}

// Address range: 0x20220 - 0x202e2
int32_t unreg_key_callback(int32_t i_a1) {
    int32_t i_v1 = pthread_mutex_lock(&i_g56); // 0x20234
    int32_t i_v2 = 0;                          // 0x2023c
    if (i_v1 != 0) {
        // 0x2023e
        printf("%s:%d", "unreg_key_callback", 347);
        puts("failed to api lock");
        // 0x202d8
        return -1;
    }
    int32_t *p_v3 = (int32_t *)(4 * i_v2 + (int32_t)&i_g61); // 0x20278
    while (*p_v3 != i_a1) {
        // 0x2029a
        i_v2++;
        if (i_v2 >= 5) {
            // 0x202a6
            printf("%s:%d", "unreg_key_callback", 357);
            puts("listener not registered before");
            goto lab_0x202ca;
        }
        p_v3 = (int32_t *)(4 * i_v2 + (int32_t)&i_g61);
    }
    // 0x202a0
    *p_v3 = 0;
lab_0x202ca:
    // 0x202ca
    pthread_mutex_unlock(&i_g56);
    // 0x202d8
    return 0;
}

// Address range: 0x202e4 - 0x203e2
int32_t lcd_show_result(int32_t i_a1, int32_t i_a2, int32_t i_a3) {
    // 0x202e4
    if (pthread_mutex_lock(&i_g56) != 0) {
        // 0x20308
        printf("%s:%d", "lcd_show_result", 375);
        puts("failed to api lock");
        // 0x203d8
        return -4;
    }
    int32_t i_v1 = i_g175; // 0x2033e
    if (i_g175 < 0) {
        int32_t i_v2 = lcd_init((int32_t)p_g176); // 0x2034c
        i_g175 = i_v2;
        lcd_clear(i_v2);
        i_v1 = i_g175;
    }
    // 0x2036c
    int32_t i_v3; // 0x202e4
    if (i_v1 < 1) {
        // 0x20394
        printf("%s:%d", "lcd_show_result", 385);
        printf("failed to init %s\n", p_g176);
        i_v3 = -1;
    } else {
        // 0x2037a
        i_v3 = lcd_write(i_v1, i_a1, i_a2, i_a3);
    }
    // 0x203ca
    pthread_mutex_unlock(&i_g56);
    // 0x203d8
    return i_v3;
}

// Address range: 0x203e4 - 0x2044e
int32_t lcd_clear_result(void) {
    // 0x203e4
    if (pthread_mutex_lock(&i_g56) != 0) {
        // 0x203fa
        printf("%s:%d", "lcd_clear_result", 396);
        // 0x2044c
        return puts("failed to api lock");
    }
    // 0x20420
    if (i_g175 >= 1) {
        // 0x2042e
        lcd_clear(i_g175);
    }
    // 0x2044c
    int32_t i_v1; // 0x203e4
    return __asm_nop(pthread_mutex_unlock(&i_g56), i_v1, i_v1, i_g175);
}

// Address range: 0x20450 - 0x20504
int32_t lcd_init(int32_t i_a1) {
    // 0x20450
    if (i_g63 != 0) {
        // 0x204fa
        return 0;
    }
    if (i_a1 == 0) {
        // 0x20470
        printf("%s:%d", "lcd_init", 24);
        puts("bad param");
        // 0x204fa
        return -3;
    }
    int32_t i_v1 = open((char *)i_a1, 2050); // 0x2049e
    i_g62 = i_v1;
    int32_t i_v2; // 0x20450
    if (i_v1 < 0) {
        // 0x204bc
        printf("%s:%d", "lcd_init", 30);
        puts("open lcd failed!!!");
        i_v2 = -1;
    } else {
        // 0x204e4
        i_g63 = 1;
        i_v2 = i_v1;
    }
    // 0x204fa
    return i_v2;
}

// Address range: 0x20504 - 0x20628
int32_t lcd_write(int32_t i_a1, int32_t i_a2, int32_t i_a3, uint32_t i_a4) {
    // 0x20504
    if (i_g63 == 0) {
        // 0x2061e
        return -2;
    }
    // 0x2052c
    if (i_g62 != i_a1) {
        // 0x20548
        printf("%s:%d", "lcd_write", 54);
        puts("bad param");
        // 0x2061e
        return -3;
    }
    int32_t i_v1 = 0x1000000 * i_a2 >> 24; // 0x20512
    uint32_t i_v2 = i_v1 % 256;            // 0x2053c
    if (i_v2 >= 3 == (i_v2 != 3)) {
        // 0x20548
        printf("%s:%d", "lcd_write", 54);
        puts("bad param");
        // 0x2061e
        return -3;
    }
    if (i_a4 != 64 && i_a4 >= 64) {
        // 0x20548
        printf("%s:%d", "lcd_write", 54);
        puts("bad param");
        // 0x2061e
        return -3;
    }
    int32_t i_v3 = pthread_mutex_lock(&i_g64); // 0x20578
    int32_t i_v4 = i_v1;                       // 0x20580
    int32_t i_v5 = 0;                          // 0x20580
    if (i_v3 != 0) {
        // 0x20582
        printf("%s:%d", "lcd_write", 59);
        puts("failed to lcd lock");
        // 0x2061e
        return -4;
    }
    uint32_t i_v6 = i_a4;
    if (i_v6 >= 16) {
        __asm_it();
    }
    int32_t i_v7 = i_v6 >= 16 ? 16 : i_v6;
    memcpy((int32_t *)((16 * i_v4 & 4080) + (int32_t)&i_g65),
           (int32_t *)(i_v5 + i_a3), i_v7);
    int32_t i_v8 = i_v6 - i_v7; // 0x205e6
    while (i_v8 != 0) {
        // 0x205f0
        i_v4 = (char)i_v4 + 1;
        uint32_t i_v9 = i_v4 % 256; // 0x205f0
        i_v5 += i_v7;
        if (i_v9 != 3 && i_v9 >= 3) {
            // break -> 0x205f6
            break;
        }
        i_v6 = i_v8;
        if (i_v6 >= 16) {
            __asm_it();
        }
        i_v7 = i_v6 >= 16 ? 16 : i_v6;
        memcpy((int32_t *)((16 * i_v4 & 4080) + (int32_t)&i_g65),
               (int32_t *)(i_v5 + i_a3), i_v7);
        i_v8 = i_v6 - i_v7;
    }
    // 0x205f6
    write(i_g62, &i_g65, 64);
    pthread_mutex_unlock(&i_g64);
    // 0x2061e
    return 0;
}

// Address range: 0x20628 - 0x2063e
int32_t lcd_flush(int32_t i_a1) {
    // 0x20628
    return 0;
}

// Address range: 0x20640 - 0x20724
int32_t lcd_clear(int32_t i_a1) {
    // 0x20640
    if (i_g63 == 0) {
        // 0x2071a
        return -2;
    }
    // 0x2065c
    if (i_g62 != i_a1) {
        // 0x2066c
        printf("%s:%d", "lcd_clear", 93);
        puts("bad param");
        // 0x2071a
        return -3;
    }
    // 0x20694
    int32_t i_v1; // 0x20640
    if (pthread_mutex_lock(&i_g64) == 0) {
        // 0x206ce
        memset(&i_g65, 32, 64);
        lseek(i_g62, 0, SEEK_SET);
        write(i_g62, &i_g65, 64);
        pthread_mutex_unlock(&i_g64);
        i_v1 = 0;
    } else {
        // 0x206a6
        printf("%s:%d", "lcd_clear", 97);
        puts("failed to lcd lock");
        i_v1 = -4;
    }
    // 0x2071a
    return i_v1;
}

// Address range: 0x20724 - 0x2078a
int32_t lcd_uninit(int32_t i_a1) {
    // 0x20724
    if (i_g63 == 0) {
        // 0x2077e
        return 0;
    }
    int32_t i_v1 = 0; // 0x20748
    if (close(i_a1) != 0) {
        // 0x2074a
        printf("%s:%d", "lcd_uninit", 117);
        puts("lcd close failed!!!");
        i_v1 = -1;
    }
    // 0x20772
    i_g63 = 0;
    // 0x2077e
    return i_v1;
}

// Address range: 0x2078c - 0x207ac
int32_t i2c_compare_e(int32_t i_a1, int32_t i_a2) {
    // 0x2078c
    return i_a1 - i_a2;
}

// Address range: 0x207ac - 0x2087e
int32_t i2c_init(int32_t i_a1) {
    int32_t i_v1 = -1; // bp-12, 0x207b8
    if (i_g40 == 0) {
        // 0x207c8
        printf("%s:%d", "i2c_init", 41);
        puts("please init platform first!!");
        // 0x20874
        return -2;
    }
    // 0x207f0
    if (i_g68 == 0) {
        // 0x207fe
        i_g67 = new_c_map(0x2078d, 0, 0);
        pthread_mutex_init(&i_g66, NULL);
    }
    int32_t i_v2 = i_g68 + 1; // 0x20832
    i_g68 = i_v2;
    i_v1 = i_v2;
    int32_t i_v3 = 0; // bp-20, 0x2084c
    insert_c_map(i_g67, &i_v1, 4, &i_v3, 8);
    // 0x20874
    return i_v1;
}

// Address range: 0x20880 - 0x20a04
int32_t i2c_uninit(int32_t i_a1) {
    int32_t i_v1 = i_a1; // bp-28, 0x20886
    if (pthread_mutex_lock(&i_g66) != 0) {
        // 0x2089e
        printf("%s:%d", "i2c_uninit", 62);
        // 0x209fc
        return puts("failed to i2c lock");
    }
    // 0x208c2
    if (exists_c_map(i_g67, &i_v1) == 1) {
        // 0x208dc
        printf("%s:%d", "i2c_uninit", 66);
        printf("remove %d from callback list\n", i_v1);
        remove_c_map(i_g67, &i_v1);
    } else {
        // 0x20918
        printf("%s:%d", "i2c_uninit", 69);
        printf("ctx(%d) is not inited\n", i_v1);
    }
    int32_t i_v2 = new_iterator_c_map(i_g67); // 0x2094a
    while (i_v2 != 0) {
        // continue -> 0x2096c
    }
    // 0x209fa
    delete_iterator_c_map(0);
    pthread_mutex_unlock(&i_g66);
    printf("%s:%d", "i2c_uninit", 80);
    puts("all i2c uninited");
    i_g68 = 0;
    int32_t i_v3 = delete_c_map(i_g67); // 0x209c4
    i_g67 = 0;
    // 0x209fc
    return __asm_nop(i_v3, (int32_t) "i2c_uninit", 0, (int32_t)&i_g67);
}

// Address range: 0x20a04 - 0x20a80
int32_t wait4i2c_ready(void) {
    int32_t i_v1 = 0; // bp-16, 0x20a0c
    uint32_t i_v2 = 0;
    if (i_g41 == 0) {
        // 0x20a36
        fpga_read(i_g172, &i_v1);
    } else {
        // 0x20a20
        fpga_read(i_g167, &i_v1);
    }
    int32_t i_v3 = 1; // 0x20a50
    while (i_v1 >= 0) {
        // 0x20a56
        usleep(0x1388);
        if (i_v2 >= 19 == (i_v2 != 19)) {
            __asm_ite();
        }
        i_v3 = 0;
        if ((i_v2 % 256 == 0 || i_v2 >= 19 == (i_v2 != 19)) ==
            (i_v2 != 19 && i_v2 >= 19)) {
            // break -> 0x20a76
            break;
        }
        i_v2++;
        if (i_g41 == 0) {
            // 0x20a36
            fpga_read(i_g172, &i_v1);
        } else {
            // 0x20a20
            fpga_read(i_g167, &i_v1);
        }
        // 0x20a4a
        i_v3 = 1;
    }
    // 0x20a76
    return i_v3;
}

// Address range: 0x20a80 - 0x20b0a
int32_t wait4i2c_data(int32_t i_a1) {
    int32_t i_v1 = 0; // bp-16, 0x20a8a
    uint32_t i_v2 = 0;
    if (i_g41 == 0) {
        // 0x20ab6
        fpga_read(i_g172, &i_v1);
    } else {
        // 0x20a9e
        fpga_read(i_g167, &i_v1);
    }
    while (i_v1 >= 0) {
        // 0x20ae0
        usleep(0x1388);
        if (i_v2 >= 19 == (i_v2 != 19)) {
            __asm_ite();
        }
        if ((i_v2 % 256 == 0 || i_v2 >= 19 == (i_v2 != 19)) ==
            (i_v2 != 19 && i_v2 >= 19)) {
            // 0x20b00
            return 0;
        }
        i_v2++;
        if (i_g41 == 0) {
            // 0x20ab6
            fpga_read(i_g172, &i_v1);
        } else {
            // 0x20a9e
            fpga_read(i_g167, &i_v1);
        }
    }
    // 0x20ad4
    *(char *)i_a1 = (char)i_v1;
    // 0x20b00
    return 1;
}

// Address range: 0x20b0c - 0x20ce0
int32_t i2c_read(int32_t i_a1, int32_t i_a2, uint32_t i_a3) {
    int32_t i_v1 = i_a1; // bp-28, 0x20b12
    if (pthread_mutex_lock(&i_g66) != 0) {
        // 0x20b2e
        printf("%s:%d", "i2c_read", 132);
        puts("failed to i2c lock");
        // 0x20cd6
        return -1;
    }
    int32_t i_v2 = 0; // bp-24, 0x20b5c
    if (find_c_map(i_g67, &i_v1, &i_v2) != 1) {
        // 0x20ca0
        printf("%s:%d", "i2c_read", 165);
        printf("ctx %d not inited\n", i_v1);
        pthread_mutex_unlock(&i_g66);
        // 0x20cd6
        return -2;
    }
    int32_t *p_v3 = (int32_t *)i_v2;
    uint32_t i_v4 = *(int32_t *)(i_v2 + 4); // 0x20b8e
    int32_t i_v5 = 0x4000000 * *p_v3 | 0x100000 * i_v4 / 16 |
                   0x8000 * i_v4 & 0x70000 | 0x2000000; // 0x20ba4
    int32_t i_v6 = 0;                                   // 0x20c86
    int32_t *p_v7 = p_v3;                               // 0x20c86
    if (i_a3 == 0) {
        goto lab_0x20c88;
    lab_0x20c88:
        // 0x20c88
        free(p_v7);
        pthread_mutex_unlock(&i_g66);
        // 0x20cd6
        return i_a3;
    }
    int32_t i_v8; // 0x20b0c
    while (wait4i2c_ready() != 0) {
        // 0x20bf6
        if (i_g41 == 0) {
            // 0x20c18
            fpga_write(i_g172, i_v5);
        } else {
            // 0x20c04
            fpga_write(i_g167, i_v5);
        }
        // 0x20c2a
        if (wait4i2c_data(i_v6 + i_a2) == 0) {
            // 0x20c44
            free((int32_t *)i_v2);
            printf("%s:%d", "i2c_read", 158);
            puts("iic not ready 4 read2");
            pthread_mutex_unlock(&i_g66);
            i_v8 = -3;
            return i_v8;
        }
        // 0x20c80
        i_v6++;
        if (i_v6 >= i_a3) {
            // 0x20c80
            p_v7 = (int32_t *)i_v2;
            goto lab_0x20c88;
        }
    }
    // 0x20bba
    free((int32_t *)i_v2);
    printf("%s:%d", "i2c_read", 146);
    puts("iic not ready 4 read1");
    pthread_mutex_unlock(&i_g66);
    i_v8 = -2;
lab_0x20cd6:
    // 0x20cd6
    return i_v8;
}

// Address range: 0x20ce0 - 0x20e68
int32_t i2c_write(int32_t i_a1, int32_t i_a2, uint32_t i_a3) {
    int32_t i_v1 = i_a1; // bp-28, 0x20ce6
    if (pthread_mutex_lock(&i_g66) != 0) {
        // 0x20d02
        printf("%s:%d", "i2c_write", 186);
        puts("failed to i2c lock");
        // 0x20e5e
        return -1;
    }
    int32_t i_v2 = 0; // bp-24, 0x20d30
    if (find_c_map(i_g67, &i_v1, &i_v2) != 1) {
        // 0x20e28
        printf("%s:%d", "i2c_write", 210);
        printf("ctx %d not inited\n", i_v1);
        pthread_mutex_unlock(&i_g66);
        // 0x20e5e
        return -2;
    }
    int32_t i_v3 = i_v2; // 0x20d54
    i_v2 = i_v3;
    if (i_a3 == 0) {
        goto lab_0x20e10;
    lab_0x20e10:
        // 0x20e10
        free((int32_t *)i_v2);
        pthread_mutex_unlock(&i_g66);
        // 0x20e5e
        return i_a3;
    }
    int32_t i_v4 = 0;                            // 0x20e04
    int32_t i_v5 = *(int32_t *)i_v3;             // 0x20d60
    uint32_t i_v6 = *(int32_t *)(i_v3 + 4);      // 0x20d66
    unsigned char i_v7 = *(char *)(i_v4 + i_a2); // 0x20d82
    while (wait4i2c_ready() != 0) {
        int32_t i_v8 = 0x100000 * i_v6 / 16 | 0x4000000 * i_v5 |
                       0x8000 * i_v6 & 0x70000 | (int32_t)i_v7; // 0x20d84
        if (i_g41 == 0) {
            // 0x20df0
            fpga_write(i_g172, i_v8);
        } else {
            // 0x20ddc
            fpga_write(i_g167, i_v8);
        }
        // 0x20e02
        i_v4++;
        if (i_v4 >= i_a3) {
            // 0x20e08
            goto lab_0x20e10;
        }
        i_v5 = *(int32_t *)i_v3;
        i_v6 = *(int32_t *)(i_v3 + 4);
        i_v7 = *(char *)(i_v4 + i_a2);
    }
    // 0x20d92
    free((int32_t *)i_v2);
    printf("%s:%d", "i2c_write", 200);
    puts("iic not ready 4 write");
    pthread_mutex_unlock(&i_g66);
    // 0x20e5e
    return -2;
}

// Address range: 0x20e68 - 0x210ae
int32_t i2c_read_reg(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4,
                     uint32_t i_a5) {
    int32_t i_v1 = i_a1; // bp-28, 0x20e6e
    if (i_a3 != 1) {
        // 0x20e80
        printf("%s:%d", "i2c_read_reg", 232);
        puts("more than one byte reg address is not supported");
        // 0x210a4
        return -3;
    }
    // 0x20ea8
    if (pthread_mutex_lock(&i_g66) != 0) {
        // 0x20eba
        printf("%s:%d", "i2c_read_reg", 236);
        puts("failed to i2c lock");
        // 0x210a4
        return -1;
    }
    int32_t i_v2 = 0; // bp-24, 0x20ee8
    if (find_c_map(i_g67, &i_v1, &i_v2) != 1) {
        // 0x2106c
        printf("%s:%d", "i2c_read_reg", 274);
        printf("ctx %d not inited\n", i_v1);
        pthread_mutex_unlock(&i_g66);
        // 0x210a4
        return -2;
    }
    int32_t i_v3 = i_v2; // 0x20f0e
    i_v2 = i_v3;
    if (i_a5 == 0) {
        goto lab_0x21054;
    lab_0x21054:
        // 0x21054
        free((int32_t *)i_v2);
        pthread_mutex_unlock(&i_g66);
        // 0x210a4
        return i_a5;
    }
    int32_t i_v4 = 0;
    int32_t i_v5 = *(int32_t *)i_v3; // 0x20f1a
    uint32_t i_v6 = *(int32_t *)(i_v3 + 4);
    int32_t i_v7 =
        0x100000 * i_v6 / 16 | 0x4000000 * i_v5 | 0x8000 * i_v6 & 0x70000;
    int32_t i_v8; // 0x20e68
    int32_t i_v9; // 0x20e68
    if (i_v5 == 1) {
        // 0x20f20
        i_v8 = i_v7 | 0x2000000;
    } else {
        // 0x20f46
        i_v8 = 256 * (i_v4 + (uint32_t)i_v9 % 256) | i_v7 | 0x3000000;
    }
    int32_t i_v10; // 0x20e68
    while (wait4i2c_ready() != 0) {
        int32_t i_v11 = i_v8;
        if (i_g41 == 0) {
            // 0x20fe0
            fpga_write(i_g172, i_v11);
        } else {
            // 0x20fcc
            fpga_write(i_g167, i_v11);
        }
        // 0x20ff2
        if (wait4i2c_data(i_v4 + i_a4) == 0) {
            // 0x2100c
            printf("%s:%d", "i2c_read_reg", 266);
            puts("iic failed to read data");
            free((int32_t *)i_v2);
            pthread_mutex_unlock(&i_g66);
            i_v10 = -3;
            return i_v10;
        }
        int32_t i_v12 = i_v4 + 1; // 0x21006
        if (i_v12 >= i_a5) {
            // 0x2104a
            goto lab_0x21054;
        }
        i_v4 = i_v12;
        i_v5 = *(int32_t *)i_v3;
        i_v6 = *(int32_t *)(i_v3 + 4);
        i_v7 =
            0x100000 * i_v6 / 16 | 0x4000000 * i_v5 | 0x8000 * i_v6 & 0x70000;
        if (i_v5 == 1) {
            // 0x20f20
            i_v8 = i_v7 | 0x2000000;
        } else {
            // 0x20f46
            i_v8 = 256 * (i_v4 + (uint32_t)i_v9 % 256) | i_v7 | 0x3000000;
        }
    }
    // 0x20f82
    printf("%s:%d", "i2c_read_reg", 254);
    puts("iic not ready 4 read1");
    free((int32_t *)i_v2);
    pthread_mutex_unlock(&i_g66);
    i_v10 = -2;
lab_0x210a4:
    // 0x210a4
    return i_v10;
}

// Address range: 0x210b0 - 0x21282
int32_t i2c_write_reg(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4,
                      uint32_t i_a5) {
    int32_t i_v1 = i_a1; // bp-28, 0x210b6
    if (i_a3 != 1) {
        // 0x210c8
        printf("%s:%d", "i2c_write_reg", 296);
        puts("more than one byte reg address is not supported");
        // 0x21278
        return -3;
    }
    // 0x210f2
    if (pthread_mutex_lock(&i_g66) != 0) {
        // 0x21104
        printf("%s:%d", "i2c_write_reg", 300);
        puts("failed to i2c lock");
        // 0x21278
        return -1;
    }
    int32_t i_v2 = 0; // bp-24, 0x21134
    if (find_c_map(i_g67, &i_v1, &i_v2) != 1) {
        // 0x21240
        printf("%s:%d", "i2c_write_reg", 326);
        printf("ctx %d not inited\n", i_v1);
        pthread_mutex_unlock(&i_g66);
        // 0x21278
        return -2;
    }
    int32_t i_v3 = i_v2; // 0x21158
    i_v2 = i_v3;
    if (i_a5 == 0) {
        goto lab_0x21228;
    lab_0x21228:
        // 0x21228
        free((int32_t *)i_v2);
        pthread_mutex_unlock(&i_g66);
        // 0x21278
        return i_a5;
    }
    // 0x21162
    int32_t i_v4;                                // 0x210b0
    uint32_t i_v5 = (uint32_t)i_v4 % 256;        // 0x21182
    int32_t i_v6 = 0;                            // 0x2121c
    int32_t i_v7 = *(int32_t *)i_v3;             // 0x21164
    uint32_t i_v8 = *(int32_t *)(i_v3 + 4);      // 0x2116a
    unsigned char i_v9 = *(char *)(i_v6 + i_a4); // 0x21194
    while (wait4i2c_ready() != 0) {
        int32_t i_v10 = 0x4000000 * i_v7 | 256 * (i_v6 + i_v5) |
                        0x100000 * i_v8 / 16 | 0x8000 * i_v8 & 0x70000 |
                        (int32_t)i_v9 | 0x1000000; // 0x21198
        if (i_g41 == 0) {
            // 0x21208
            fpga_write(i_g172, i_v10);
        } else {
            // 0x211f4
            fpga_write(i_g167, i_v10);
        }
        // 0x2121a
        i_v6++;
        if (i_v6 >= i_a5) {
            // 0x21220
            goto lab_0x21228;
        }
        i_v7 = *(int32_t *)i_v3;
        i_v8 = *(int32_t *)(i_v3 + 4);
        i_v9 = *(char *)(i_v6 + i_a4);
    }
    // 0x211a8
    printf("%s:%d", "i2c_write_reg", 315);
    puts("iic not ready 4 write");
    free((int32_t *)i_v2);
    pthread_mutex_unlock(&i_g66);
    // 0x21278
    return -2;
}

// Address range: 0x21284 - 0x2138e
int32_t i2c_ioctl(int32_t i_a1, uint32_t i_a2, int32_t i_a3) {
    // 0x21284
    if (pthread_mutex_lock(&i_g66) != 0) {
        // 0x212a4
        printf("%s:%d", "i2c_ioctl", 346);
        puts("failed to i2c lock");
        // 0x21384
        return -4;
    }
    uint32_t i_v1 = i_a2 % 0x10000;
    int32_t i_v2 = new_iterator_c_map(i_g67); // 0x212da
    while (i_v2 != 0) {
        int32_t i_v3 =
            *(int32_t *)*(int32_t *)(*(int32_t *)(i_v2 + 20) + 16); // 0x212f8
        if (*(int32_t *)i_v3 == i_a1) {
            if (i_v1 == 1795) {
                // 0x21314
                printf("%s:%d", "i2c_ioctl", 360);
                printf("update the slave address to %d\n", i_a3);
                free((int32_t *)i_v2);
                goto lab_0x21370;
            } else {
                // 0x2135c
                __asm_nop(i_v2, i_a2, i_v1, 1795);
                goto lab_0x21370;
            }
        }
    }
lab_0x21370:
    // 0x21370
    delete_iterator_c_map(i_v2);
    pthread_mutex_unlock(&i_g66);
    // 0x21384
    return 0;
}

// Address range: 0x21390 - 0x21488
int32_t i2c_select(int32_t i_a1, int32_t i_a2) {
    // 0x21390
    if (pthread_mutex_lock(&i_g66) != 0) {
        // 0x213ac
        printf("%s:%d", "i2c_select", 379);
        puts("failed to i2c lock");
        // 0x2147e
        return -4;
    }
    int32_t i_v1 = new_iterator_c_map(i_g67); // 0x213e2
    while (i_v1 != 0) {
        int32_t i_v2 =
            *(int32_t *)*(int32_t *)(*(int32_t *)(i_v1 + 20) + 16); // 0x21400
        if (*(int32_t *)i_v2 == i_a1) {
            // 0x21408
            printf("%s:%d", "i2c_select", 390);
            printf("update the master address to %d\n", i_a2);
            free((int32_t *)i_v1);
            goto lab_0x2146a;
        }
    }
lab_0x2146a:
    // 0x2146a
    delete_iterator_c_map(i_v1);
    pthread_mutex_unlock(&i_g66);
    // 0x2147e
    return 0;
}

// Address range: 0x21488 - 0x214c0
int32_t json_decref(int32_t i_a1) {
    // 0x21488
    if (i_a1 == 0) {
        // 0x214b8
        return 0;
    }
    int32_t *p_v1 = (int32_t *)(i_a1 + 4); // 0x21498
    int32_t i_v2 = *p_v1;                  // 0x21498
    if (i_v2 == -1) {
        // 0x214b8
        return i_a1;
    }
    int32_t i_v3 = i_v2 - 1; // 0x214a4
    *p_v1 = i_v3;
    int32_t i_v4 = i_a1; // 0x214b0
    if (i_v3 == 0) {
        // 0x214b2
        i_v4 = json_delete(i_a1);
    }
    // 0x214b8
    return i_v4;
}

// Address range: 0x214c0 - 0x21ae8
int32_t hal_load_conf(int32_t *p_a1) {
    // 0x214c0
    memset(&i_g70, 255, 256);
    memset(&i_g71, 255, 72);
    int32_t i_v1;                                           // bp-320, 0x214c0
    int32_t i_v2 = json_load_file((int32_t)p_a1, 0, &i_v1); // 0x21510
    if (i_v2 == 0 || *(int32_t *)i_v2 != 0) {
        // 0x2152a
        printf("%s:%d", "hal_load_conf", 42);
        printf("%s,%d bad json format\n", "platform/7007/src/hal_conf.c", 42);
        // 0x21ade
        return -1;
    }
    int32_t i_v3 = json_dumps(i_v2, 0); // 0x21562
    printf("%s:%d", "hal_load_conf", 46);
    printf("json = %s \n", (char *)i_v3);
    free((int32_t *)i_v3);
    int32_t i_v4 = json_object_get(i_v2, "chain"); // 0x215a4
    if (i_v4 != 0) {
        // 0x215b4
        if (*(int32_t *)i_v4 == 1) {
            int32_t i_v5 = 0; // 0x21746
            if (json_array_size(i_v4) != 0) {
                int32_t i_v6 = json_array_get(i_v4, i_v5); // 0x2160a
                while (i_v6 != 0) {
                    // 0x2161a
                    if (*(int32_t *)i_v6 != 0) {
                        // break -> 0x21624
                        break;
                    }
                    int32_t i_v7 = json_integer_value(
                        json_object_get(i_v6, "id")); // 0x21676
                    int32_t i_v8 = 16 * i_v5;         // 0x2168a
                    *(int32_t *)(i_v8 + (int32_t)&i_g70) = i_v7;
                    int32_t i_v9 = json_integer_value(
                        json_object_get(i_v6, "uart")); // 0x216a8
                    *(int32_t *)(i_v8 + (int32_t)&i_g70 + 4) = i_v9;
                    int32_t i_v10 = json_integer_value(
                        json_object_get(i_v6, "plug")); // 0x216dc
                    *(int32_t *)(i_v8 + (int32_t)&i_g70 + 8) = i_v10;
                    int32_t i_v11 = json_integer_value(
                        json_object_get(i_v6, "reset")); // 0x21710
                    *(int32_t *)(i_v8 + (int32_t)&i_g70 + 12) = i_v11;
                    uint32_t i_v12 = i_v5 + 1; // 0x21730
                    i_v5 = i_v12;
                    if (i_v12 < 16 != i_v12 < json_array_size(i_v4)) {
                        goto lab_0x21752;
                    }
                    i_v6 = json_array_get(i_v4, i_v5);
                }
                // 0x21624
                printf("%s:%d", "hal_load_conf", 62);
                printf("%s,%d bad object in chain\n",
                       "platform/7007/src/hal_conf.c", 62);
                json_decref(i_v2);
                // 0x21ade
                return -3;
            }
        lab_0x21752:;
            int32_t i_v13 = json_object_get(i_v2, "fan"); // 0x2175e
            if (i_v13 != 0) {
                // 0x2176e
                if (*(int32_t *)i_v13 == 1) {
                    int32_t i_v14 = 0; // 0x218e4
                    if (json_array_size(i_v13) != 0) {
                        int32_t i_v15 = json_array_get(i_v13, i_v14); // 0x217c4
                        while (i_v15 != 0) {
                            // 0x217d4
                            if (*(int32_t *)i_v15 != 0) {
                                // break -> 0x217de
                                break;
                            }
                            int32_t i_v16 = json_integer_value(
                                json_object_get(i_v15, "id")); // 0x21830
                            int32_t i_v17 = 12 * i_v14;        // 0x2184c
                            *(int32_t *)(i_v17 + (int32_t)&i_g71) = i_v16;
                            int32_t i_v18 = json_integer_value(
                                json_object_get(i_v15, "name")); // 0x2186a
                            *(int32_t *)(i_v17 + (int32_t)&i_g71 + 4) = i_v18;
                            int32_t i_v19 = json_integer_value(
                                json_object_get(i_v15, "max")); // 0x218a6
                            *(int32_t *)(i_v17 + (int32_t)&i_g71 + 8) = i_v19;
                            uint32_t i_v20 = i_v14 + 1; // 0x218ce
                            i_v14 = i_v20;
                            if (i_v20 < 6 != i_v20 < json_array_size(i_v13)) {
                                goto lab_0x218f0;
                            }
                            i_v15 = json_array_get(i_v13, i_v14);
                        }
                        // 0x217de
                        printf("%s:%d", "hal_load_conf", 88);
                        printf("%s,%d bad object in fan\n",
                               "platform/7007/src/hal_conf.c", 88);
                        json_decref(i_v2);
                        // 0x21ade
                        return -5;
                    }
                lab_0x218f0:;
                    int32_t i_v21 = json_object_get(i_v2, "red"); // 0x218fc
                    if (i_v21 != 0) {
                        // 0x2190c
                        if (*(int32_t *)i_v21 == 3) {
                            // 0x21950
                            i_g72 = json_integer_value(i_v21);
                            int32_t i_v22 =
                                json_object_get(i_v2, "green"); // 0x21972
                            if (i_v22 != 0) {
                                // 0x21982
                                if (*(int32_t *)i_v22 == 3) {
                                    // 0x219c6
                                    i_g73 = json_integer_value(i_v22);
                                    int32_t i_v23 = json_object_get(
                                        i_v2, "reset"); // 0x219e8
                                    if (i_v23 != 0) {
                                        // 0x219f8
                                        if (*(int32_t *)i_v23 == 3) {
                                            // 0x21a3c
                                            i_g74 = json_integer_value(i_v23);
                                            int32_t i_v24 = json_object_get(
                                                i_v2, "ipreport"); // 0x21a5e
                                            if (i_v24 != 0) {
                                                // 0x21a6e
                                                if (*(int32_t *)i_v24 == 3) {
                                                    // 0x21ab2
                                                    i_g75 = json_integer_value(
                                                        i_v24);
                                                    json_decref(i_v2);
                                                    i_g69 = 1;
                                                    // 0x21ade
                                                    return 0;
                                                }
                                            }
                                            // 0x21a78
                                            printf("%s:%d", "hal_load_conf",
                                                   127);
                                            printf(
                                                "%s,%d bad ipreport\n",
                                                "platform/7007/src/hal_conf.c",
                                                127);
                                            json_decref(i_v2);
                                            // 0x21ade
                                            return -9;
                                        }
                                    }
                                    // 0x21a02
                                    printf("%s:%d", "hal_load_conf", 119);
                                    printf("%s,%d bad reset\n",
                                           "platform/7007/src/hal_conf.c", 119);
                                    json_decref(i_v2);
                                    // 0x21ade
                                    return -8;
                                }
                            }
                            // 0x2198c
                            printf("%s:%d", "hal_load_conf", 111);
                            printf("%s,%d bad green\n",
                                   "platform/7007/src/hal_conf.c", 111);
                            json_decref(i_v2);
                            // 0x21ade
                            return -7;
                        }
                    }
                    // 0x21916
                    printf("%s:%d", "hal_load_conf", 103);
                    printf("%s,%d bad red\n", "platform/7007/src/hal_conf.c",
                           103);
                    json_decref(i_v2);
                    // 0x21ade
                    return -6;
                }
            }
            // 0x21778
            printf("%s:%d", "hal_load_conf", 79);
            printf("%s,%d bad fan format\n", "platform/7007/src/hal_conf.c",
                   79);
            json_decref(i_v2);
            // 0x21ade
            return -4;
        }
    }
    // 0x215be
    printf("%s:%d", "hal_load_conf", 52);
    printf("%s,%d bad chain format\n", "platform/7007/src/hal_conf.c", 52);
    json_decref(i_v2);
    // 0x21ade
    return -2;
}

// Address range: 0x21ae8 - 0x21b12
int32_t hal_led_red_addr(void) {
    // 0x21ae8
    return i_g69 == 0 ? -1 : i_g72;
}

// Address range: 0x21b14 - 0x21b3e
int32_t hal_led_green_addr(void) {
    // 0x21b14
    return i_g69 == 0 ? -1 : i_g73;
}

// Address range: 0x21b40 - 0x21b6a
int32_t hal_key_reset_addr(void) {
    // 0x21b40
    return i_g69 == 0 ? -1 : i_g74;
}

// Address range: 0x21b6c - 0x21b96
int32_t hal_key_ipreport_addr(void) {
    // 0x21b6c
    return i_g69 == 0 ? -1 : i_g75;
}

// Address range: 0x21b98 - 0x21c00
int32_t hal_chain_uart_addr(int32_t i_a1) {
    // 0x21b98
    if (i_g69 == 0) {
        // 0x21bf4
        return -1;
    }
    int32_t i_v1 = 0;         // 0x21bac
    int32_t i_v2 = 16 * i_v1; // 0x21bc4
    while (*(int32_t *)(i_v2 + (int32_t)&i_g70) != i_a1) {
        // 0x21bea
        i_v1++;
        if (i_v1 >= 16) {
            // 0x21bf4
            return -2;
        }
        i_v2 = 16 * i_v1;
    }
    // 0x21bf4
    return *(int32_t *)(i_v2 + (int32_t)&i_g70 + 4);
}

// Address range: 0x21c00 - 0x21c68
int32_t hal_chain_plug_addr(int32_t i_a1) {
    // 0x21c00
    if (i_g69 == 0) {
        // 0x21c5c
        return -1;
    }
    int32_t i_v1 = 0;         // 0x21c14
    int32_t i_v2 = 16 * i_v1; // 0x21c2c
    while (*(int32_t *)(i_v2 + (int32_t)&i_g70) != i_a1) {
        // 0x21c52
        i_v1++;
        if (i_v1 >= 16) {
            // 0x21c5c
            return -2;
        }
        i_v2 = 16 * i_v1;
    }
    // 0x21c5c
    return *(int32_t *)(i_v2 + (int32_t)&i_g70 + 8);
}

// Address range: 0x21c68 - 0x21cd0
int32_t hal_chain_reset_addr(int32_t i_a1) {
    // 0x21c68
    if (i_g69 == 0) {
        // 0x21cc4
        return -1;
    }
    int32_t i_v1 = 0;         // 0x21c7c
    int32_t i_v2 = 16 * i_v1; // 0x21c94
    while (*(int32_t *)(i_v2 + (int32_t)&i_g70) != i_a1) {
        // 0x21cba
        i_v1++;
        if (i_v1 >= 16) {
            // 0x21cc4
            return -2;
        }
        i_v2 = 16 * i_v1;
    }
    // 0x21cc4
    return *(int32_t *)(i_v2 + (int32_t)&i_g70 + 12);
}

// Address range: 0x21cd0 - 0x21d6a
int32_t hal_chain_max_num(void) {
    // 0x21cd0
    if (i_g69 == 0) {
        // 0x21d5e
        return -1;
    }
    int32_t i_v1 = 0;
    int32_t i_v2 = 16 * i_v1; // 0x21d00
    int32_t i_v3;             // 0x21cd0
    int32_t i_v4;             // 0x21cd0
    if (*(int32_t *)(i_v2 + (int32_t)&i_g70) == 255) {
        // 0x21d0a
        if (*(int32_t *)(i_v2 + (int32_t)&i_g70 + 4) == 255) {
            // 0x21d20
            if (*(int32_t *)(i_v2 + (int32_t)&i_g70 + 8) == 255) {
                // 0x21d36
                if (*(int32_t *)(i_v2 + (int32_t)&i_g70 + 12) == 255) {
                    // 0x21d5a
                    __asm_nop(i_v4, i_v4, i_v2, 255);
                    i_v3 = i_v1;
                    return i_v3;
                }
            }
        }
    }
    int32_t i_v5 = i_v1 + 1; // 0x21d4e
    i_v3 = 16;
    while (i_v5 < 16) {
        // 0x21cf6
        i_v1 = i_v5;
        i_v2 = 16 * i_v1;
        if (*(int32_t *)(i_v2 + (int32_t)&i_g70) == 255) {
            // 0x21d0a
            if (*(int32_t *)(i_v2 + (int32_t)&i_g70 + 4) == 255) {
                // 0x21d20
                if (*(int32_t *)(i_v2 + (int32_t)&i_g70 + 8) == 255) {
                    // 0x21d36
                    if (*(int32_t *)(i_v2 + (int32_t)&i_g70 + 12) == 255) {
                        // 0x21d5a
                        __asm_nop(i_v4, i_v4, i_v2, 255);
                        i_v3 = i_v1;
                        return i_v3;
                    }
                }
            }
        }
        // 0x21d4c
        i_v5 = i_v1 + 1;
        i_v3 = 16;
    }
lab_0x21d5e:
    // 0x21d5e
    return i_v3;
}

// Address range: 0x21d6c - 0x21de0
int32_t hal_fan_addr(int32_t i_a1) {
    // 0x21d6c
    if (i_g69 == 0) {
        // 0x21dd4
        return -1;
    }
    int32_t i_v1 = 0;         // 0x21d80
    int32_t i_v2 = 12 * i_v1; // 0x21d9e
    while (*(int32_t *)(i_v2 + (int32_t)&i_g71) != i_a1) {
        // 0x21dca
        i_v1++;
        if (i_v1 >= 6) {
            // 0x21dd4
            return -2;
        }
        i_v2 = 12 * i_v1;
    }
    // 0x21dd4
    return *(int32_t *)(i_v2 + (int32_t)&i_g71 + 4);
}

// Address range: 0x21de0 - 0x21e54
int32_t hal_fan_max_speed(int32_t i_a1) {
    // 0x21de0
    if (i_g69 == 0) {
        // 0x21e48
        return -1;
    }
    int32_t i_v1 = 0;         // 0x21df4
    int32_t i_v2 = 12 * i_v1; // 0x21e12
    while (*(int32_t *)(i_v2 + (int32_t)&i_g71) != i_a1) {
        // 0x21e3e
        i_v1++;
        if (i_v1 >= 6) {
            // 0x21e48
            return -1;
        }
        i_v2 = 12 * i_v1;
    }
    // 0x21e48
    return *(int32_t *)(i_v2 + (int32_t)&i_g71 + 8);
}

// Address range: 0x21e54 - 0x21eb4
int32_t hal_fan_number(void) {
    int32_t i_v1 = 0; // 0x21e6a
    if (i_g69 == 0) {
        // 0x21ea8
        return -1;
    }
    int32_t i_v2 = 0;                                         // 0x21e6a
    int32_t i_v3 = *(int32_t *)(12 * i_v1 + (int32_t)&i_g71); // 0x21e8c
    i_v2 += (int32_t)(i_v3 != -1);
    i_v1++;
    while (i_v1 < 6) {
        // 0x21e78
        i_v3 = *(int32_t *)(12 * i_v1 + (int32_t)&i_g71);
        i_v2 += (int32_t)(i_v3 != -1);
        i_v1++;
    }
    // 0x21ea8
    return i_v2;
}

// Address range: 0x21eb4 - 0x21efc
int32_t new_c_map(int32_t i_a1, int32_t i_a2, int32_t i_a3) {
    int32_t *p_v1 = malloc(4); // 0x21ec2
    int32_t i_v2 = 0;          // 0x21ece
    if (p_v1 != NULL) {
        int32_t i_v3 = new_c_rb(i_a1, i_a2, i_a3); // 0x21eda
        *p_v1 = i_v3;
        i_v2 = i_v3 == 0 ? 0 : (int32_t)p_v1;
    }
    // 0x21ef2
    return i_v2;
}

// Address range: 0x21efc - 0x21f36
int32_t insert_c_map(int32_t i_a1, int32_t *p_a2, int32_t i_a3, int32_t *p_a4,
                     int32_t i_a5) {
    int32_t i_v1 = 501; // 0x21f0e
    if (i_a1 != 0) {
        // 0x21f16
        i_v1 = insert_c_rb(i_a1, (int32_t)p_a2, i_a3, (int32_t)p_a4, i_a5);
    }
    // 0x21f2c
    return i_v1;
}

// Address range: 0x21f38 - 0x21f74
int32_t exists_c_map(int32_t i_a1, int32_t *p_a2) {
    int32_t i_v1 = 0; // 0x21f4a
    if (i_a1 != 0) {
        // 0x21f50
        i_v1 = find_c_rb(i_a1, (int32_t)p_a2) != 0;
    }
    // 0x21f6a
    return i_v1;
}

// Address range: 0x21f74 - 0x21ff8
int32_t remove_c_map(int32_t i_a1, int32_t *p_a2) {
    // 0x21f74
    if (i_a1 == 0) {
        // 0x21fee
        return 501;
    }
    int32_t i_v1 = remove_c_rb(i_a1, (int32_t)p_a2); // 0x21f96
    if (i_v1 != 0) {
        int32_t *p_v2 = (int32_t *)(i_v1 + 16); // 0x21fa4
        int32_t i_v3;                           // bp-20, 0x21f74
        get_raw_clib_object(*p_v2, &i_v3);
        free((int32_t *)i_v3);
        delete_clib_object(*p_v2);
        int32_t *p_v4 = (int32_t *)(i_v1 + 20); // 0x21fc6
        get_raw_clib_object(*p_v4, &i_v3);
        free((int32_t *)i_v3);
        delete_clib_object(*p_v4);
        free((int32_t *)i_v1);
    }
    // 0x21fee
    return 0;
}

// Address range: 0x21ff8 - 0x2203e
int32_t find_c_map(int32_t i_a1, int32_t *p_a2, int32_t *p_a3) {
    // 0x21ff8
    if (i_a1 == 0) {
        // 0x22034
        return 0;
    }
    int32_t i_v1 = find_c_rb(i_a1, (int32_t)p_a2); // 0x22016
    int32_t i_v2 = 0;                              // 0x22020
    if (i_v1 != 0) {
        // 0x22026
        get_raw_clib_object(*(int32_t *)(i_v1 + 20), p_a3);
        i_v2 = 1;
    }
    // 0x22034
    return i_v2;
}

// Address range: 0x22040 - 0x22070
int32_t delete_c_map(int32_t i_a1) {
    int32_t i_v1 = 0; // 0x22050
    if (i_a1 != 0) {
        // 0x22052
        i_v1 = delete_c_rb(i_a1);
        free((int32_t *)i_a1);
    }
    // 0x22064
    return i_v1;
}

// Address range: 0x22070 - 0x22096
int32_t minimum_c_map(int32_t i_a1) {
    // 0x22070
    return minimum_c_rb(i_a1, i_a1);
}

// Address range: 0x22098 - 0x220f2
int32_t get_next_c_map(int32_t i_a1) {
    int32_t *p_v1 = (int32_t *)(i_a1 + 20); // 0x220a2
    int32_t i_v2 = *p_v1;                   // 0x220a2
    int32_t i_v3 = *(int32_t *)(i_a1 + 12);
    int32_t i_v4; // 0x22098
    if (i_v2 == 0) {
        // 0x220a8
        i_v4 = minimum_c_map(i_v3);
    } else {
        // 0x220ba
        i_v4 = tree_successor(*(int32_t *)i_v3, i_v2);
    }
    // 0x220d6
    *p_v1 = i_v4;
    int32_t i_v5 = 0; // 0x220dc
    if (i_v4 != 0) {
        // 0x220e2
        i_v5 = *(int32_t *)(i_v4 + 20);
    }
    // 0x220e8
    return i_v5;
}

// Address range: 0x220f4 - 0x22114
int32_t get_value_c_map(int32_t i_a1) {
    // 0x220f4
    int32_t i_v1; // bp-12, 0x220f4
    get_raw_clib_object(i_a1, &i_v1);
    return i_v1;
}

// Address range: 0x22114 - 0x22164
int32_t replace_value_c_map(int32_t i_a1, int32_t i_a2, int32_t i_a3) {
    int32_t *p_v1 = (int32_t *)(i_a1 + 20);
    if (*(int32_t *)(*(int32_t *)*(int32_t *)(i_a1 + 12) + 32) != 0) {
        // 0x22130
        int32_t i_v2; // bp-16, 0x22114
        get_raw_clib_object(*p_v1, &i_v2);
    }
    // 0x2214c
    return replace_raw_clib_object(*(int32_t *)(*p_v1 + 20), i_a2, i_a3);
}

// Address range: 0x22164 - 0x221b8
int32_t new_iterator_c_map(int32_t i_a1) {
    int32_t *p_v1 = malloc(24);   // 0x2216e
    int32_t i_v2 = (int32_t)p_v1; // 0x2216e
    *p_v1 = 0x22099;
    *(int32_t *)(i_v2 + 8) = 0x220f5;
    *(int32_t *)(i_v2 + 4) = 0x22115;
    *(int32_t *)(i_v2 + 12) = i_a1;
    *(int32_t *)(i_v2 + 16) = 0;
    *(int32_t *)(i_v2 + 20) = 0;
    return i_v2;
}

// Address range: 0x221b8 - 0x221ce
int32_t delete_iterator_c_map(int32_t i_a1) {
    // 0x221b8
    free((int32_t *)i_a1);
    return &i_g309;
}

// Address range: 0x221d0 - 0x2225c
int32_t __left_rotate(int32_t i_a1, int32_t i_a2) {
    int32_t *p_v1 = (int32_t *)(i_a2 + 4); // 0x221dc
    int32_t i_v2 = *p_v1;                  // 0x221dc
    int32_t *p_v3 = (int32_t *)i_v2;       // 0x221e2
    *p_v1 = *p_v3;
    int32_t i_v4 = *p_v3;    // 0x221ea
    int32_t i_v5 = i_a1 + 4; // 0x221ee
    if (i_v4 != i_v5) {
        // 0x221f4
        *(int32_t *)(i_v4 + 8) = i_a2;
    }
    int32_t *p_v6 = (int32_t *)(i_a2 + 8);
    if (i_v5 != i_v2) {
        // 0x22206
        *(int32_t *)(i_v2 + 8) = *p_v6;
    }
    int32_t i_v7 = *p_v6; // 0x22210
    if (i_v7 == 0) {
        // 0x22236
        *(int32_t *)i_a1 = i_v2;
    } else {
        int32_t *p_v8 = (int32_t *)i_v7; // 0x2221a
        if (*p_v8 == i_a2) {
            // 0x22222
            *p_v8 = i_v2;
        } else {
            // 0x2222c
            *(int32_t *)(i_v7 + 4) = i_v2;
        }
    }
    // 0x2223c
    *p_v3 = i_a2;
    if (i_v5 != i_a2) {
        // 0x2224c
        *p_v6 = i_v2;
    }
    // 0x22252
    return i_a1;
}

// Address range: 0x2225c - 0x222e8
int32_t __right_rotate(int32_t i_a1, int32_t i_a2) {
    int32_t *p_v1 = (int32_t *)(i_a2 + 4); // 0x2226e
    *(int32_t *)i_a2 = *p_v1;
    int32_t i_v2 = *p_v1;    // 0x22276
    int32_t i_v3 = i_a1 + 4; // 0x2227a
    if (i_v2 != i_v3) {
        // 0x22280
        *(int32_t *)(i_v2 + 8) = i_a2;
    }
    int32_t *p_v4 = (int32_t *)(i_a2 + 8); // 0x2229c
    int32_t i_v5 = *p_v4;                  // 0x2229c
    if (i_v5 == 0) {
        // 0x222c2
        *(int32_t *)i_a1 = i_a2;
    } else {
        int32_t *p_v6 = (int32_t *)(i_v5 + 4); // 0x222a6
        if (*p_v6 == i_a2) {
            // 0x222ae
            *p_v6 = i_a2;
        } else {
            // 0x222b8
            *(int32_t *)i_v5 = i_a2;
        }
    }
    // 0x222c8
    *p_v1 = i_a2;
    if (i_v3 != i_a2) {
        // 0x222d8
        *p_v4 = i_a2;
    }
    // 0x222de
    return i_a1;
}

// Address range: 0x222e8 - 0x22354
int32_t new_c_rb(int32_t i_a1, int32_t i_a2, int32_t i_a3) {
    int32_t *p_v1 = malloc(40); // 0x222f6
    int32_t i_v2 = 0;           // 0x22302
    if (p_v1 != NULL) {
        // 0x22308
        i_v2 = (int32_t)p_v1;
        memset(p_v1, 0, 40);
        *(int32_t *)(i_v2 + 36) = i_a1;
        *(int32_t *)(i_v2 + 28) = i_a2;
        *(int32_t *)(i_v2 + 32) = i_a3;
        int32_t i_v3 = i_v2 + 4; // 0x22326
        *p_v1 = i_v3;
        *(int32_t *)i_v3 = i_v3;
        *(int32_t *)(i_v2 + 8) = i_v3;
        *(int32_t *)(i_v2 + 12) = 0;
        *(int32_t *)(i_v2 + 16) = 0;
    }
    // 0x2234a
    return i_v2;
}

// Address range: 0x22354 - 0x22474
int32_t __rb_insert_fixup(int32_t i_a1, int32_t i_a2) {
    int32_t i_v1 = i_a1; // 0x22456
    int32_t i_v2 = i_a2; // 0x22456
    int32_t i_v3 = i_a1; // 0x22456
    if (i_a1 == i_a2) {
    lab_0x22464_3:
        // 0x22464
        *(int32_t *)(i_v3 + 12) = 0;
        return i_v3;
    }
    int32_t *p_v4; // 0x22354
    int32_t *p_v5; // 0x22354
    int32_t i_v6;  // 0x22354
    int32_t i_v7;  // 0x22354
    int32_t i_v8;  // 0x22354
    while (true) {
    lab_0x22458:;
        int32_t i_v9 = i_v1;
        int32_t i_v10 = i_v2;
        int32_t i_v11;  // 0x22354
        int32_t *p_v12; // 0x22354
        int32_t i_v13;  // 0x2245a
        int32_t *p_v14; // 0x22354
        int32_t *p_v15; // 0x22354
        while (true) {
            // 0x22458
            i_v11 = i_v10;
            p_v12 = (int32_t *)(i_v11 + 8);
            i_v13 = *p_v12;
            p_v14 = (int32_t *)(i_v13 + 12);
            i_v3 = i_v9;
            if (*p_v14 != 1) {
                // break (via goto) -> 0x22464
                goto lab_0x22464_3;
            }
            // 0x22360
            p_v15 = (int32_t *)(i_v13 + 8);
            int32_t i_v16 = *p_v15;            // 0x22368
            int32_t i_v17 = *(int32_t *)i_v16; // 0x2236a
            if (i_v13 == i_v17) {
                int32_t *p_v18 =
                    (int32_t *)(*(int32_t *)(i_v16 + 4) + 12); // 0x2237c
                if (*p_v18 != 1) {
                    // break -> 0x223a4
                    break;
                }
                // 0x22382
                *p_v14 = 0;
                *p_v18 = 0;
                *(int32_t *)(*(int32_t *)(*p_v12 + 8) + 12) = 1;
            } else {
                int32_t *p_v19 = (int32_t *)(i_v17 + 12); // 0x223ec
                if (*p_v19 != 1) {
                    // 0x22414
                    p_v5 = p_v14;
                    p_v4 = p_v12;
                    i_v7 = i_v11;
                    if (*(int32_t *)i_v13 == i_v11) {
                        // 0x22420
                        __right_rotate(i_a1, i_v13);
                        p_v5 = (int32_t *)(*p_v15 + 12);
                        p_v4 = p_v15;
                        i_v7 = i_v13;
                        goto lab_0x2242e;
                    } else {
                        goto lab_0x2242e;
                    }
                }
                // 0x223f2
                *p_v14 = 0;
                *p_v19 = 0;
                *(int32_t *)(*(int32_t *)(*p_v12 + 8) + 12) = 1;
            }
            // 0x2244e
            i_v10 = *(int32_t *)(*p_v12 + 8);
            i_v3 = i_v9;
            if (i_v9 == i_v10) {
                // break (via goto) -> 0x22464
                goto lab_0x22464_3;
            }
        }
        int32_t *p_v20 = p_v14; // 0x223ae
        int32_t *p_v21 = p_v12; // 0x223ae
        int32_t i_v22 = i_v11;  // 0x223ae
        if (*(int32_t *)(i_v13 + 4) == i_v11) {
            // 0x223b0
            __left_rotate(i_a1, i_v13);
            p_v20 = (int32_t *)(*p_v15 + 12);
            p_v21 = p_v15;
            i_v22 = i_v13;
        }
        // 0x223be
        *p_v20 = 0;
        *(int32_t *)(*(int32_t *)(*p_v21 + 8) + 12) = 1;
        i_v8 = i_v22;
        i_v6 = __right_rotate(i_a1, *(int32_t *)(*p_v21 + 8));
        goto lab_0x2244e;
    }
lab_0x22464_3:
    // 0x22464
    *(int32_t *)(i_v3 + 12) = 0;
    return i_v3;
lab_0x2244e:
    // 0x2244e
    i_v1 = i_v6;
    i_v2 = i_v8;
    i_v3 = i_v2;
    if (i_v1 == i_v2) {
        // break -> 0x22464
        goto lab_0x22464_3;
    }
    goto lab_0x22458;
lab_0x2242e:
    // 0x2242e
    *p_v5 = 0;
    *(int32_t *)(*(int32_t *)(*p_v4 + 8) + 12) = 1;
    i_v8 = i_v7;
    i_v6 = __left_rotate(i_a1, *(int32_t *)(*p_v4 + 8));
    goto lab_0x2244e;
}

// Address range: 0x22474 - 0x224ec
int32_t find_c_rb(int32_t i_a1, int32_t i_a2) {
    int32_t i_v1 = i_a1;
    int32_t i_v2; // bp-20, 0x22474
    get_raw_clib_object(*(int32_t *)(i_v1 + 16), &i_v2);
    free((int32_t *)i_v2);
    int32_t i_v3 = i_a1; // 0x224b4
    while (i_a2 != 0) {
        int32_t i_v4 = *(int32_t *)(i_a2 < 0 ? i_v1 : i_v1 + 4);
        i_v3 = 0;
        if (i_a1 + 4 == i_v4) {
            // break -> 0x224d2
            break;
        }
        i_v1 = i_v4;
        get_raw_clib_object(*(int32_t *)(i_v1 + 16), &i_v2);
        free((int32_t *)i_v2);
        i_v3 = i_a1;
    }
    // 0x224d2
    return i_v3;
}

// Address range: 0x224ec - 0x22656
int32_t insert_c_rb(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4,
                    int32_t i_a5) {
    int32_t *p_v1 = malloc(24); // 0x22500
    if (p_v1 == NULL) {
        // 0x2264c
        return 2;
    }
    int32_t i_v2 = (int32_t)p_v1; // 0x22500
    int32_t i_v3 = i_a1 + 4;      // 0x22514
    *p_v1 = i_v3;
    *(int32_t *)(i_v2 + 4) = i_v3;
    *(int32_t *)(i_v2 + 12) = 1;
    int32_t i_v4 = new_clib_object(i_a2, i_a3); // 0x2252c
    int32_t *p_v5 = (int32_t *)(i_v2 + 16);     // 0x22534
    *p_v5 = i_v4;
    int32_t i_v6; // 0x224ec
    if (i_a4 == 0) {
        // 0x2254c
        *(int32_t *)(i_v2 + 20) = 0;
        i_v6 = i_v4;
    } else {
        int32_t i_v7 = new_clib_object(i_a4, i_a5); // 0x22540
        *(int32_t *)(i_v2 + 20) = i_v7;
        i_v6 = i_v7;
    }
    // 0x22552
    if (i_v3 == i_v6) {
        // 0x225d0
        *(int32_t *)(i_v2 + 8) = 0;
        goto lab_0x22636;
    lab_0x22636:
        // 0x22636
        *(int32_t *)i_a1 = i_v2;
    lab_0x2263c:
        // 0x2263c
        __rb_insert_fixup(i_a1, i_v2);
        debug_verify_properties(i_a1);
        // 0x2264c
        return 0;
    }
    int32_t i_v8 = i_v6;
    int32_t *p_v9 = (int32_t *)(i_v8 + 16); // 0x22564
    int32_t i_v10;                          // bp-36, 0x224ec
    get_raw_clib_object(*p_v9, &i_v10);
    int32_t i_v11; // bp-40, 0x224ec
    get_raw_clib_object(*p_v5, &i_v11);
    free((int32_t *)i_v10);
    free((int32_t *)i_v11);
    while (i_v11 != 0) {
        int32_t i_v12 = i_v8 + 4;
        int32_t i_v13 = *(int32_t *)(i_v11 < 0 ? i_v8 : i_v12);
        if (i_v3 == i_v13) {
            // 0x225d0
            *(int32_t *)(i_v2 + 8) = i_v8;
            if (i_v8 == 0) {
                goto lab_0x22636;
            } else {
                // 0x225dc
                int32_t i_v14; // bp-44, 0x224ec
                get_raw_clib_object(*p_v9, &i_v14);
                int32_t i_v15; // bp-48, 0x224ec
                get_raw_clib_object(*p_v5, &i_v15);
                free((int32_t *)i_v14);
                free((int32_t *)i_v15);
                if (i_v15 < 0) {
                    // 0x22626
                    *(int32_t *)i_v8 = i_v2;
                    goto lab_0x2263c;
                } else {
                    // 0x2262e
                    *(int32_t *)i_v12 = i_v2;
                    goto lab_0x2263c;
                }
            }
        }
        i_v8 = i_v13;
        p_v9 = (int32_t *)(i_v8 + 16);
        get_raw_clib_object(*p_v9, &i_v10);
        get_raw_clib_object(*p_v5, &i_v11);
        free((int32_t *)i_v10);
        free((int32_t *)i_v11);
    }
    // 0x2264c
    return 401;
}

// Address range: 0x22658 - 0x227e4
int32_t __rb_remove_fixup(int32_t i_a1, int32_t i_a2) {
    int32_t i_v1 = i_a2; // 0x227ca
    if (i_a1 == i_a2) {
        // 0x227d6
        *(int32_t *)(i_a1 + 12) = 0;
        return i_a1;
    }
    int32_t i_v2 = i_a1;
    int32_t i_v3 = i_v1; // 0x227d2
    int32_t i_v4 = i_v2; // 0x227d2
    int32_t *p_v5;       // 0x22658
    int32_t *p_v6;       // 0x22658
    int32_t i_v7;        // 0x22658
    int32_t i_v8;        // 0x22658
    int32_t i_v9;        // 0x22658
    int32_t i_v10;       // 0x22658
    int32_t *p_v11;      // 0x22666
    while (*(int32_t *)(i_v1 + 12) == 0) {
        // 0x22664
        p_v11 = (int32_t *)(i_v1 + 8);
        int32_t i_v12 = *p_v11;            // 0x22666
        int32_t i_v13 = *(int32_t *)i_v12; // 0x22668
        int32_t i_v14;                     // 0x22658
        if (i_v13 == i_v1) {
            int32_t i_v15 = *(int32_t *)(i_v12 + 4);  // 0x22674
            int32_t *p_v16 = (int32_t *)(i_v15 + 12); // 0x2267a
            int32_t i_v17 = i_v12;                    // 0x2267e
            int32_t i_v18 = i_v15;                    // 0x2267e
            int32_t i_v19 = i_v2;                     // 0x2267e
            if (*p_v16 == 1) {
                // 0x22680
                *p_v16 = 0;
                *(int32_t *)(*p_v11 + 12) = 1;
                i_v19 = __left_rotate(i_a1, *p_v11);
                i_v17 = *p_v11;
                i_v18 = *(int32_t *)(i_v17 + 4);
            }
            int32_t i_v20 = i_v18;
            int32_t i_v21 = i_v17;
            int32_t *p_v22 = (int32_t *)(*(int32_t *)i_v20 + 12);
            int32_t *p_v23 = (int32_t *)(i_v20 + 4);
            int32_t i_v24 = *(int32_t *)(*p_v23 + 12);
            if (*p_v22 != 0) {
                // 0x226c4
                p_v6 = p_v23;
                i_v7 = i_v21;
                i_v9 = i_v20;
                if (i_v24 == 0) {
                    // 0x226ce
                    *p_v22 = 0;
                    *(int32_t *)(i_v20 + 12) = 1;
                    __right_rotate(i_a1, i_v20);
                    int32_t i_v25 = *p_v11;                  // 0x226e6
                    int32_t i_v26 = *(int32_t *)(i_v25 + 4); // 0x226e8
                    p_v6 = (int32_t *)(i_v26 + 4);
                    i_v7 = i_v25;
                    i_v9 = i_v26;
                    goto lab_0x226ec;
                } else {
                    goto lab_0x226ec;
                }
            }
            // 0x226ac
            p_v6 = p_v23;
            i_v7 = i_v21;
            i_v9 = i_v20;
            if (i_v24 != 0) {
                goto lab_0x226ec;
            }
            // 0x226b6
            *(int32_t *)(i_v20 + 12) = 1;
            i_v14 = i_v19;
        } else {
            int32_t *p_v27 = (int32_t *)(i_v13 + 12); // 0x22724
            int32_t i_v28 = i_v12;                    // 0x22728
            int32_t i_v29 = i_v13;                    // 0x22728
            int32_t i_v30 = i_v2;                     // 0x22728
            if (*p_v27 == 1) {
                // 0x2272a
                *p_v27 = 0;
                *(int32_t *)(*p_v11 + 12) = 1;
                i_v30 = __right_rotate(i_a1, *p_v11);
                i_v28 = *p_v11;
                i_v29 = *(int32_t *)i_v28;
            }
            int32_t i_v31 = i_v29;
            int32_t i_v32 = i_v28;
            int32_t *p_v33 = (int32_t *)(*(int32_t *)(i_v31 + 4) + 12);
            int32_t *p_v34 = (int32_t *)i_v31;
            int32_t i_v35 = *(int32_t *)(*p_v34 + 12);
            if (*p_v33 != 0) {
                // 0x2276e
                p_v5 = p_v34;
                i_v8 = i_v32;
                i_v10 = i_v31;
                if (i_v35 == 0) {
                    // 0x22778
                    *p_v33 = 0;
                    *(int32_t *)(i_v31 + 12) = 1;
                    __left_rotate(i_a1, i_v31);
                    int32_t i_v36 = *p_v11;            // 0x22790
                    int32_t i_v37 = *(int32_t *)i_v36; // 0x22792
                    p_v5 = (int32_t *)i_v37;
                    i_v8 = i_v36;
                    i_v10 = i_v37;
                    goto lab_0x22796;
                } else {
                    goto lab_0x22796;
                }
            }
            // 0x22756
            p_v5 = p_v34;
            i_v8 = i_v32;
            i_v10 = i_v31;
            if (i_v35 != 0) {
                goto lab_0x22796;
            }
            // 0x22760
            *(int32_t *)(i_v31 + 12) = 1;
            i_v14 = i_v30;
        }
        // 0x227c2
        i_v1 = *p_v11;
        i_v3 = i_v14;
        i_v4 = i_v14;
        if (i_v14 == i_v1) {
            // break -> 0x227d6
            break;
        }
        i_v2 = i_v14;
        i_v3 = i_v1;
        i_v4 = i_v2;
    }
lab_0x227d6:
    // 0x227d6
    *(int32_t *)(i_v3 + 12) = 0;
    return i_v4;
lab_0x226ec:
    // 0x226ec
    *(int32_t *)(i_v9 + 12) = *(int32_t *)(i_v7 + 12);
    *(int32_t *)(*p_v11 + 12) = 0;
    *(int32_t *)(*p_v6 + 12) = 0;
    int32_t i_v38 = __left_rotate(i_a1, *p_v11); // 0x2270e
    i_v3 = i_v38;
    i_v4 = i_v38;
    goto lab_0x227d6;
lab_0x22796:
    // 0x22796
    *(int32_t *)(i_v10 + 12) = *(int32_t *)(i_v8 + 12);
    *(int32_t *)(*p_v11 + 12) = 0;
    *(int32_t *)(*p_v5 + 12) = 0;
    int32_t i_v39 = __right_rotate(i_a1, *p_v11); // 0x227b8
    i_v3 = i_v39;
    i_v4 = i_v39;
    goto lab_0x227d6;
}

// Address range: 0x227e4 - 0x228d0
int32_t __remove_c_rb(int32_t i_a1, int32_t i_a2) {
    int32_t i_v1 = i_a1 + 4; // 0x227fc
    int32_t i_v2 = i_a2;     // 0x22800
    if (i_v1 != i_a2) {
        int32_t i_v3 = *(int32_t *)(i_a2 + 4); // 0x22804
        i_v2 = i_a2;
        if (i_v3 != i_v1) {
            int32_t i_v4 = *(int32_t *)i_v3; // 0x22824
            i_v2 = i_v3;
            while (i_v4 != i_v1) {
                int32_t i_v5 = i_v4;
                i_v4 = *(int32_t *)i_v5;
                i_v2 = i_v5;
            }
        }
    }
    int32_t i_v6 = i_v2;
    int32_t i_v7 = *(int32_t *)i_v6; // 0x22830
    int32_t i_v8 = i_v7 == i_v1 ? i_v6 + 4 : i_v6;
    int32_t i_v9 = *(int32_t *)i_v8;
    int32_t *p_v10 = (int32_t *)(i_v6 + 8); // 0x2284a
    *(int32_t *)(i_v9 + 8) = *p_v10;
    int32_t i_v11 = *p_v10; // 0x22852
    if (i_v11 == 0) {
        // 0x22878
        *(int32_t *)i_a1 = i_v9;
    } else {
        int32_t *p_v12 = (int32_t *)i_v11; // 0x2285c
        if (*p_v12 == i_v6) {
            // 0x22864
            *p_v12 = i_v9;
        } else {
            // 0x2286e
            *(int32_t *)(i_v11 + 4) = i_v9;
        }
    }
    if (i_v6 != i_a2) {
        int32_t *p_v13 = (int32_t *)(i_a2 + 16); // 0x22888
        int32_t *p_v14 = (int32_t *)(i_v6 + 16); // 0x2288e
        *p_v13 = *p_v14;
        *p_v14 = *p_v13;
        int32_t *p_v15 = (int32_t *)(i_a2 + 20); // 0x2289c
        int32_t *p_v16 = (int32_t *)(i_v6 + 20); // 0x228a2
        *p_v15 = *p_v16;
        *p_v16 = *p_v15;
    }
    // 0x228ae
    if (*(int32_t *)(i_v6 + 12) == 0) {
        // 0x228b6
        __rb_remove_fixup(i_a1, i_v9);
    }
    // 0x228be
    debug_verify_properties(i_a1);
    return i_v6;
}

// Address range: 0x228d0 - 0x22954
int32_t remove_c_rb(int32_t i_a1, int32_t i_a2) {
    int32_t i_v1 = i_a1;
    int32_t i_v2; // bp-20, 0x228d0
    get_raw_clib_object(*(int32_t *)(i_v1 + 16), &i_v2);
    free((int32_t *)i_v2);
    while (i_a2 != 0) {
        int32_t i_v3 = *(int32_t *)(i_a2 < 0 ? i_v1 : i_v1 + 4);
        if (i_a1 + 4 == i_v3) {
            // 0x2294a
            return 0;
        }
        i_v1 = i_v3;
        get_raw_clib_object(*(int32_t *)(i_v1 + 16), &i_v2);
        free((int32_t *)i_v2);
    }
    // 0x2294a
    return __remove_c_rb(i_a1, i_a1);
}

// Address range: 0x22954 - 0x229c6
int32_t __delete_c_rb_node(int32_t i_a1, int32_t i_a2) {
    int32_t *p_v1 = (int32_t *)(i_a2 + 16);
    if (*(int32_t *)(i_a1 + 28) != 0) {
        // 0x22966
        int32_t i_v2; // bp-12, 0x22954
        get_raw_clib_object(*p_v1, &i_v2);
    }
    int32_t i_v3 = delete_clib_object(*p_v1); // 0x22986
    int32_t *p_v4 = (int32_t *)(i_a2 + 20);   // 0x2298c
    int32_t i_v5 = *p_v4;                     // 0x2298c
    if (i_v5 == 0) {
        // 0x229be
        return i_v3;
    }
    int32_t i_v6 = i_v5; // 0x22998
    if (*(int32_t *)(i_a1 + 32) != 0) {
        // 0x2299a
        int32_t i_v7; // bp-16, 0x22954
        get_raw_clib_object(i_v5, &i_v7);
        i_v6 = *p_v4;
    }
    // 0x229be
    return delete_clib_object(i_v6);
}

// Address range: 0x229c8 - 0x22a82
int32_t delete_c_rb(int32_t i_a1) {
    int32_t i_v1 = i_a1 + 4;         // 0x22a68
    int32_t *p_v2 = (int32_t *)i_a1; // 0x229de
    int32_t i_v3 = *p_v2;            // 0x229de
    int32_t i_v4 = i_v3;             // 0x229e6
    int32_t i_v5;                    // 0x229f2
    int32_t i_v6;                    // 0x22a0e
    int32_t *p_v7;                   // 0x22a1c
    int32_t i_v8;                    // 0x22a1c
    int32_t *p_v9;                   // 0x22a3c
    int32_t i_v10;                   // 0x22a3c
    if (i_v3 == i_v1) {
        // 0x229f0
        i_v5 = *(int32_t *)(i_a1 + 4);
        i_v4 = i_v5;
        if (i_v5 == i_v1) {
            // 0x22a04
            __delete_c_rb_node(i_a1, i_a1);
            i_v6 = *(int32_t *)(i_a1 + 8);
            if (i_v6 == 0) {
                // 0x22a66
                free(p_v2);
                goto lab_0x22a70;
            }
            // 0x22a14
            p_v7 = (int32_t *)i_v6;
            i_v8 = *p_v7;
            if (i_v8 == i_v1) {
                // 0x22a3a
                p_v9 = (int32_t *)(i_v6 + 4);
                i_v10 = *p_v9;
                i_v4 = i_v6;
                if (i_v10 != i_v1) {
                    // 0x22a46
                    free((int32_t *)i_v10);
                    *p_v9 = i_v1;
                    i_v4 = i_v6;
                }
            } else {
                // 0x22a26
                free((int32_t *)i_v8);
                *p_v7 = i_v1;
                i_v4 = i_v6;
            }
        }
    }
    // 0x22a66
    while (i_v1 != i_v4) {
        int32_t i_v11 = i_v4;
        p_v2 = (int32_t *)i_v11;
        i_v3 = *p_v2;
        i_v4 = i_v3;
        if (i_v3 == i_v1) {
            // 0x229f0
            i_v5 = *(int32_t *)(i_v11 + 4);
            i_v4 = i_v5;
            if (i_v5 == i_v1) {
                // 0x22a04
                __delete_c_rb_node(i_a1, i_v11);
                i_v6 = *(int32_t *)(i_v11 + 8);
                if (i_v6 == 0) {
                    // 0x22a66
                    free(p_v2);
                    goto lab_0x22a70;
                }
                // 0x22a14
                p_v7 = (int32_t *)i_v6;
                i_v8 = *p_v7;
                if (i_v8 == i_v1) {
                    // 0x22a3a
                    p_v9 = (int32_t *)(i_v6 + 4);
                    i_v10 = *p_v9;
                    i_v4 = i_v6;
                    if (i_v10 != i_v1) {
                        // 0x22a46
                        free((int32_t *)i_v10);
                        *p_v9 = i_v1;
                        i_v4 = i_v6;
                    }
                } else {
                    // 0x22a26
                    free((int32_t *)i_v8);
                    *p_v7 = i_v1;
                    i_v4 = i_v6;
                }
            }
        }
    }
lab_0x22a70:
    // 0x22a70
    free((int32_t *)i_a1);
    return 0;
}

// Address range: 0x22a84 - 0x22ab0
int32_t minimum_c_rb(int32_t i_a1, int32_t i_a2) {
    int32_t i_v1 = i_a2;
    int32_t i_v2 = *(int32_t *)i_v1; // 0x22a98
    while (i_v2 != i_a1 + 4) {
        // 0x22a96
        i_v1 = i_v2;
        i_v2 = *(int32_t *)i_v1;
    }
    // 0x22aa2
    return i_v1;
}

// Address range: 0x22ab0 - 0x22adc
int32_t maximum_c_rb(int32_t i_a1, int32_t i_a2) {
    int32_t i_v1 = i_a2;
    int32_t i_v2 = *(int32_t *)(i_v1 + 4); // 0x22ac4
    while (i_v2 != i_a1 + 4) {
        // 0x22ac2
        i_v1 = i_v2;
        i_v2 = *(int32_t *)(i_v1 + 4);
    }
    // 0x22ace
    return i_v1;
}

// Address range: 0x22adc - 0x22b02
int32_t empty_c_rb(int32_t i_a1) {
    // 0x22adc
    return 1;
}

// Address range: 0x22b04 - 0x22b78
int32_t tree_successor(int32_t i_a1, int32_t i_a2) {
    int32_t i_v1 = *(int32_t *)(i_a2 + 4); // 0x22b14
    if (i_v1 != i_a1 + 4) {
        // 0x22b6e
        return minimum_c_rb(i_a1, i_v1);
    }
    // 0x22b2e
    if (maximum_c_rb(i_a1, i_a1) == i_a2) {
        // 0x22b6e
        return 0;
    }
    int32_t i_v2 = i_a2;
    int32_t i_v3 = *(int32_t *)(i_v2 + 8);
    int32_t i_v4 = i_v1; // 0x22b60
    while (i_v1 != i_v3) {
        // 0x22b62
        i_v4 = i_v3;
        if (*(int32_t *)(i_v3 + 4) != i_v2) {
            // break -> 0x22b6e
            break;
        }
        i_v2 = i_v3;
        i_v3 = *(int32_t *)(i_v2 + 8);
        i_v4 = i_v1;
    }
    // 0x22b6e
    return i_v4;
}

// Address range: 0x22b78 - 0x22bb8
int32_t debug_verify_properties(int32_t i_a1) {
    int32_t i_v1 = debug_verify_property_1(i_a1, i_a1); // 0x22b88
    return debug_verify_property_5(
        i_a1,
        debug_verify_property_4(i_a1, debug_verify_property_2(i_a1, i_v1)));
}

// Address range: 0x22bb8 - 0x22c2c
int32_t debug_verify_property_1(int32_t i_a1, int32_t i_a2) {
    int32_t i_v1 = debug_node_color(i_a1, i_a2); // 0x22bc6
    int32_t i_v2 = 1;                            // 0x22bce
    int32_t i_v3 = i_a2;                         // 0x22bce
    if (i_v1 != 1) {
        int32_t i_v4 = debug_node_color(i_a1, i_a2); // 0x22bd4
        i_v2 = 0;
        i_v3 = i_a2;
        if (i_v4 != 0) {
            // 0x22bde
            __assert_fail("debug_node_color(pTree,n) == 1 || "
                          "debug_node_color(pTree,n) == 0",
                          "3rdparty/cstl/src/c_rb.c", 479,
                          "debug_verify_property_1");
            i_v2 = &i_g309;
            i_v3 = (int32_t) "3rdparty/cstl/src/c_rb.c";
        }
    }
    // 0x22bfe
    int32_t i_v5; // 0x22bb8
    if (i_a1 + 4 == i_a2) {
        // 0x22c22
        i_v5 = __asm_nop(i_v2, i_v3, i_a2, i_a2);
    } else {
        // 0x22c08
        debug_verify_property_1(i_a1, i_v3);
        i_v5 = debug_verify_property_1(i_a1, *(int32_t *)(i_a2 + 4));
    }
    // 0x22c24
    return i_v5;
}

// Address range: 0x22c2c - 0x22c6c
int32_t debug_verify_property_2(int32_t i_a1, int32_t i_a2) {
    int32_t i_v1 = 0; // 0x22c42
    if (debug_node_color(i_a1, i_a2) != 0) {
        // 0x22c44
        __assert_fail("debug_node_color(pTree,root) == 0",
                      "3rdparty/cstl/src/c_rb.c", 486,
                      "debug_verify_property_2");
        i_v1 = &i_g309;
    }
    // 0x22c64
    return i_v1;
}

// Address range: 0x22c6c - 0x22c94
int32_t debug_node_color(int32_t i_a1, int32_t i_a2) {
    int32_t i_v1 = 0; // 0x22c7e
    if (i_a1 + 4 != i_a2) {
        // 0x22c80
        i_v1 = *(int32_t *)(i_a2 + 12);
    }
    // 0x22c88
    return i_v1;
}

// Address range: 0x22c94 - 0x22d70
int32_t debug_verify_property_4(int32_t i_a1, int32_t i_a2) {
    int32_t i_v1 = debug_node_color(i_a1, i_a2); // 0x22ca2
    int32_t i_v2 = i_v1;                         // 0x22caa
    int32_t i_v3 = i_a2;                         // 0x22caa
    if (i_v1 == 1) {
        // 0x22cac
        if (debug_node_color(i_a1, i_a2) != 0) {
            // 0x22cbe
            __assert_fail("debug_node_color(pTree,n->left) == 0",
                          "3rdparty/cstl/src/c_rb.c", 495,
                          "debug_verify_property_4");
        }
        // 0x22cde
        if (debug_node_color(i_a1, *(int32_t *)(i_a2 + 4)) != 0) {
            // 0x22cf0
            __assert_fail("debug_node_color(pTree,n->right) == 0",
                          "3rdparty/cstl/src/c_rb.c", 496,
                          "debug_verify_property_4");
        }
        int32_t i_v4 = *(int32_t *)(i_a2 + 8);       // 0x22d12
        int32_t i_v5 = debug_node_color(i_a1, i_v4); // 0x22d18
        i_v2 = 0;
        i_v3 = i_v4;
        if (i_v5 != 0) {
            // 0x22d22
            __assert_fail("debug_node_color(pTree,n->parent) == 0",
                          "3rdparty/cstl/src/c_rb.c", 497,
                          "debug_verify_property_4");
            i_v2 = &i_g309;
            i_v3 = (int32_t) "3rdparty/cstl/src/c_rb.c";
        }
    }
    // 0x22d42
    int32_t i_v6; // 0x22c94
    if (i_a1 + 4 == i_a2) {
        // 0x22d66
        i_v6 = __asm_nop(i_v2, i_v3, i_a2, i_a2);
    } else {
        // 0x22d4c
        debug_verify_property_4(i_a1, i_v3);
        i_v6 = debug_verify_property_4(i_a1, *(int32_t *)(i_a2 + 4));
    }
    // 0x22d68
    return i_v6;
}

// Address range: 0x22d70 - 0x22d96
int32_t debug_verify_property_5(int32_t i_a1, int32_t i_a2) {
    int32_t i_v1 = -1; // bp-12, 0x22d7e
    return debug_verify_property_5_helper(i_a1, i_a2, 0, &i_v1);
}

// Address range: 0x22d98 - 0x22e2c
int32_t debug_verify_property_5_helper(int32_t i_a1, int32_t i_a2, int32_t i_a3,
                                       int32_t *p_a4) {
    int32_t i_v1 = debug_node_color(i_a1, i_a2); // 0x22daa
    int32_t i_v2 = (int32_t)(i_v1 == 0) + i_a3;
    int32_t i_v3 = i_a2; // 0x22dc2
    if (i_a1 + 4 == i_a2) {
        int32_t i_v4 = (int32_t)p_a4;
        if (p_a4 == (int32_t *)-1) {
            // 0x22dce
            *(int32_t *)-1 = i_v2;
            // 0x22e24
            return __asm_nop(i_v1, i_a2, i_v2, i_v4);
        }
        // 0x22dd6
        if (i_v2 == i_v4) {
            // 0x22e24
            return __asm_nop(i_v1, i_a2, i_v4, i_v4);
        }
        // 0x22de0
        __assert_fail("black_count == *path_black_count",
                      "3rdparty/cstl/src/c_rb.c", 517,
                      "debug_verify_property_5_helper");
        i_v3 = (int32_t) "3rdparty/cstl/src/c_rb.c";
    }
    // 0x22e00
    debug_verify_property_5_helper(i_a1, i_v3, i_v2, p_a4);
    // 0x22e24
    return debug_verify_property_5_helper(i_a1, *(int32_t *)(i_a2 + 4), i_v2,
                                          p_a4);
}

// Address range: 0x22e2c - 0x22e4a
int32_t clib_copy(int32_t i_a1, int32_t i_a2, int32_t i_a3) {
    // 0x22e2c
    return (int32_t)memcpy((int32_t *)i_a1, (int32_t *)i_a2, i_a3);
}

// Address range: 0x22e4c - 0x22e6a
int32_t clib_get(int32_t i_a1, int32_t i_a2, int32_t i_a3) {
    // 0x22e4c
    return (int32_t)memcpy((int32_t *)i_a1, (int32_t *)i_a2, i_a3);
}

// Address range: 0x22e6c - 0x22eca
int32_t new_clib_object(int32_t i_a1, int32_t i_a2) {
    int32_t *p_v1 = malloc(8); // 0x22e78
    if (p_v1 == NULL) {
        // 0x22ec0
        return 0;
    }
    int32_t i_v2 = (int32_t)p_v1; // 0x22e78
    *(int32_t *)(i_v2 + 4) = i_a2;
    int32_t *p_v3 = malloc(i_a2); // 0x22e92
    *p_v1 = (int32_t)p_v3;
    int32_t i_v4; // 0x22e6c
    if (p_v3 == NULL) {
        // 0x22ea6
        free(p_v1);
        i_v4 = 0;
    } else {
        // 0x22eb0
        memcpy(p_v3, (int32_t *)i_a1, i_a2);
        i_v4 = i_v2;
    }
    // 0x22ec0
    return i_v4;
}

// Address range: 0x22ecc - 0x22f16
int32_t get_raw_clib_object(int32_t i_a1, int32_t *p_a2) {
    int32_t *p_v1 = (int32_t *)(i_a1 + 4); // 0x22ed8
    int32_t *p_v2 = malloc(*p_v1);         // 0x22edc
    *p_a2 = (int32_t)p_v2;
    int32_t i_v3 = 3; // 0x22eee
    if (p_a2 != NULL) {
        // 0x22ef4
        memcpy(p_a2, p_v2, *p_v1);
        i_v3 = 0;
    }
    // 0x22f0c
    return i_v3;
}

// Address range: 0x22f18 - 0x22f52
int32_t replace_raw_clib_object(int32_t i_a1, int32_t i_a2, int32_t i_a3) {
    int32_t *p_v1 = (int32_t *)i_a1; // 0x22f2a
    free(p_v1);
    int32_t *p_v2 = malloc(i_a3); // 0x22f30
    *p_v1 = (int32_t)p_v2;
    return (int32_t)memcpy(p_v2, (int32_t *)i_a2, i_a3);
}

// Address range: 0x22f54 - 0x22f7a
int32_t delete_clib_object(int32_t i_a1) {
    int32_t i_v1 = 0; // 0x22f60
    if (i_a1 != 0) {
        int32_t *p_v2 = (int32_t *)i_a1; // 0x22f68
        free(p_v2);
        free(p_v2);
        i_v1 = &i_g309;
    }
    // 0x22f72
    return i_v1;
}

// Address range: 0x22f7c - 0x22f96
int32_t clib_strdup(int32_t i_a1) {
    // 0x22f7c
    return (int32_t)strdup((char *)i_a1);
}

// Address range: 0x22f98 - 0x22fba
int32_t dump_to_strbuffer(int32_t i_a1, int32_t i_a2, int32_t i_a3) {
    // 0x22f98
    return strbuffer_append_bytes(i_a3, i_a1, i_a2);
}

// Address range: 0x22fbc - 0x22ff0
int32_t dump_to_file(int32_t i_a1, int32_t i_a2, int32_t i_a3) {
    // 0x22fbc
    return fwrite((int32_t *)i_a1, i_a2, 1, (struct _IO_FILE *)i_a3) != 1;
}

// Address range: 0x22ff0 - 0x23090
int32_t dump_indent(uint32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4,
                    int32_t i_a5) {
    if (i_a1 % 32 == 0) {
        // 0x23060
        return (i_a1 & 32) == 0 == (i_a3 != 0) ? (int32_t)&i_g91 : 0;
    }
    // 0x23086
    return -1;
}

// Address range: 0x23090 - 0x23296
int32_t dump_string(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    // 0x23090
    return -1;
}

// Address range: 0x23298 - 0x232be
int32_t object_key_compare_keys(int32_t i_a1, int32_t i_a2) {
    int32_t i_v1 = *(int32_t *)(i_a2 + 4); // 0x232a8
    return strcmp((char *)*(int32_t *)(i_a1 + 4), (char *)i_v1);
}

// Address range: 0x232c0 - 0x232fe
int32_t object_key_compare_serials(uint32_t i_a1, uint32_t i_a2) {
    // 0x232c0
    if (i_a1 < i_a2) {
        // 0x232f2
        return -1;
    }
    if (i_a1 == i_a2) {
        __asm_ite();
    }
    // 0x232f2
    return i_a1 != i_a2;
}

// Address range: 0x23300 - 0x23970
int32_t do_dump(uint32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    if (i_a1 == 0) {
        // 0x23966
        return -1;
    }
    if (i_a1 >= 7 == (i_a1 != 7)) {
        // 0x23966
        return -1;
    }
    // 0x23324
    __asm_adr(4);
    return i_a1;
}

// Address range: 0x23970 - 0x239da
int32_t json_dumps(int32_t i_a1, int32_t i_a2) {
    // 0x23970
    int32_t i_v1; // bp-24, 0x23970
    if (strbuffer_init(&i_v1) != 0) {
        // 0x239d0
        return 0;
    }
    int32_t i_v2 = json_dump_callback(i_a1, 0x22f99, &i_v1, i_a2); // 0x239a0
    int32_t i_v3 = 0;                                              // 0x239a8
    if (i_v2 == 0) {
        int32_t i_v4 = strbuffer_value(&i_v1); // 0x239b6
        i_v3 = jsonp_strdup(i_v4);
    }
    // 0x239c4
    strbuffer_close(&i_v1);
    // 0x239d0
    return i_v3;
}

// Address range: 0x239dc - 0x23a06
int32_t json_dumpf(int32_t i_a1, int32_t i_a2, int32_t i_a3) {
    // 0x239dc
    return json_dump_callback(i_a1, 0x22fbd, (int32_t *)i_a2, i_a3);
}

// Address range: 0x23a08 - 0x23a4e
int32_t json_dump_file(int32_t i_a1, int32_t i_a2, int32_t i_a3) {
    struct _IO_FILE *p_v1 = fopen((char *)i_a2, "w"); // 0x23a1e
    int32_t i_v2 = -1;                                // 0x23a28
    if (p_v1 != NULL) {
        // 0x23a30
        i_v2 = json_dumpf(i_a1, (int32_t)p_v1, i_a3);
        fclose(p_v1);
    }
    // 0x23a44
    return i_v2;
}

// Address range: 0x23a50 - 0x23aa6
int32_t json_dump_callback(int32_t i_a1, int32_t i_a2, int32_t *p_a3,
                           int32_t i_a4) {
    int32_t i_v1 = -1; // 0x23a66
    if (i_a1 == 1 || (i_a4 & 512) != 0) {
        // 0x23a8a
        i_v1 = do_dump(i_a1, i_a4, 0, i_a2);
    }
    // 0x23a9c
    return i_v1;
}

// Address range: 0x23aa8 - 0x23ae0
int32_t json_decref2(int32_t i_a1) {
    // 0x23aa8
    if (i_a1 == 0) {
        // 0x23ad8
        return 0;
    }
    int32_t *p_v1 = (int32_t *)(i_a1 + 4); // 0x23ab8
    int32_t i_v2 = *p_v1;                  // 0x23ab8
    if (i_v2 == -1) {
        // 0x23ad8
        return i_a1;
    }
    int32_t i_v3 = i_v2 - 1; // 0x23ac4
    *p_v1 = i_v3;
    int32_t i_v4 = i_a1; // 0x23ad0
    if (i_v3 == 0) {
        // 0x23ad2
        i_v4 = json_delete(i_a1);
    }
    // 0x23ad8
    return i_v4;
}

// Address range: 0x23ae0 - 0x23b22
int32_t hash_str(int32_t i_a1) {
    char i_v1 = *(char *)i_a1; // 0x23b0a
    int32_t i_v2 = 0x1505;     // 0x23b12
    if (i_v1 == 0) {
        // 0x23b14
        return 0x1505;
    }
    int32_t i_v3 = i_a1; // 0x23b12
    i_v2 = 33 * i_v2 + (int32_t)i_v1;
    i_v3++;
    char i_v4 = *(char *)i_v3; // 0x23b0a
    while (i_v4 != 0) {
        // 0x23af4
        i_v2 = 33 * i_v2 + (int32_t)i_v4;
        i_v3++;
        i_v4 = *(char *)i_v3;
    }
    // 0x23b14
    return i_v2;
}

// Address range: 0x23b24 - 0x23b42
int32_t list_init(int32_t i_a1) {
    // 0x23b24
    *(int32_t *)(i_a1 + 4) = i_a1;
    *(int32_t *)i_a1 = i_a1;
    return i_a1;
}

// Address range: 0x23b44 - 0x23b74
int32_t list_insert(int32_t i_a1, int32_t i_a2) {
    // 0x23b44
    *(int32_t *)(i_a2 + 4) = i_a1;
    *(int32_t *)i_a2 = i_a1;
    *(int32_t *)(i_a1 + 4) = i_a2;
    *(int32_t *)i_a1 = i_a2;
    return i_a1;
}

// Address range: 0x23b74 - 0x23b9a
int32_t list_remove(int32_t i_a1) {
    // 0x23b74
    *(int32_t *)*(int32_t *)(i_a1 + 4) = i_a1;
    return i_a1;
}

// Address range: 0x23b9c - 0x23bd0
int32_t bucket_is_empty(int32_t i_a1, int32_t i_a2) {
    if (i_a1 + 12 == i_a2) {
        // 0x23bb2
        if (*(int32_t *)(i_a2 + 4) == i_a2) {
            // 0x23bc4
            return 1;
        }
    }
    // 0x23bc4
    return 0;
}

// Address range: 0x23bd0 - 0x23c20
int32_t insert_to_bucket(int32_t i_a1, int32_t i_a2, int32_t i_a3) {
    // 0x23bd0
    int32_t i_v1; // 0x23bd0
    if (bucket_is_empty(i_a1, i_a2) == 0) {
        int32_t i_v2 = list_insert(i_a2, i_a3); // 0x23c0e
        *(int32_t *)i_a2 = i_a3;
        i_v1 = i_v2;
    } else {
        int32_t i_v3 = list_insert(i_a1 + 12, i_a3); // 0x23bf2
        *(int32_t *)(i_a2 + 4) = i_a3;
        *(int32_t *)i_a2 = i_a3;
        i_v1 = i_v3;
    }
    // 0x23c18
    return i_v1;
}

// Address range: 0x23c20 - 0x23c44
int32_t num_buckets(int32_t i_a1) {
    int32_t i_v1 = *(int32_t *)(i_a1 + 8); // 0x23c2a
    return *(int32_t *)(4 * i_v1 + (int32_t)&i_g92);
}

// Address range: 0x23c44 - 0x23cb0
int32_t hashtable_find_pair(int32_t i_a1, int32_t i_a2, int32_t i_a3,
                            int32_t i_a4) {
    // 0x23c44
    if (bucket_is_empty(i_a1, i_a2) != 0) {
        // 0x23ca6
        return 0;
    }
    int32_t i_v1 = 0;
    int32_t i_v2 = i_a2;
    int32_t i_v3 = i_a2; // 0x23c9c
    int32_t i_v4;        // 0x23c44
    while (true) {
        int32_t i_v5 = i_v3;
        int32_t i_v6 = i_v5 - 4; // 0x23c6c
        int32_t i_v7 = i_v1;     // 0x23c78
        int32_t i_v8 = i_v2;     // 0x23c78
        if (*(int32_t *)i_v6 == i_a4) {
            // 0x23c7a
            i_v7 = strcmp((char *)(i_v5 + 16), (char *)i_a3);
            i_v8 = i_a3;
            i_v4 = i_v6;
            if (i_v7 == 0) {
                // break -> 0x23ca6
                break;
            }
        }
        // 0x23c90
        i_v2 = i_v8;
        i_v1 = i_v7;
        if (*(int32_t *)(i_a2 + 4) == i_v5) {
            // 0x23ca2
            __asm_nop(i_v1, i_v2, i_v5, i_v5);
            i_v4 = 0;
            return i_v4;
        }
        // 0x23c9a
        i_v3 = *(int32_t *)(i_v5 + 4);
    }
lab_0x23ca6:
    // 0x23ca6
    return i_v4;
}

// Address range: 0x23cb0 - 0x23d7e
int32_t hashtable_do_del(int32_t i_a1, int32_t i_a2, uint32_t i_a3) {
    int32_t i_v1 = *(int32_t *)(i_a1 + 4) +
                   8 * (i_a3 % (uint32_t)num_buckets(i_a1));    // 0x23cda
    int32_t i_v2 = hashtable_find_pair(i_a1, i_v1, i_a2, i_a3); // 0x23ce6
    if (i_v2 == 0) {
        // 0x23d74
        return -1;
    }
    int32_t i_v3 = i_v2 + 4;         // 0x23cfa
    int32_t *p_v4 = (int32_t *)i_v1; // 0x23cfe
    int32_t *p_v5 = (int32_t *)(i_v1 + 4);
    int32_t i_v6 = *p_v5;
    if (i_v3 == *p_v4) {
        if (i_v3 == i_v6) {
            int32_t i_v7 = i_a1 + 12; // 0x23d12
            *p_v5 = i_v7;
            *p_v4 = i_v7;
        } else {
            // 0x23d30
            *p_v4 = *(int32_t *)(i_v2 + 8);
        }
    } else {
        if (i_v3 == i_v6) {
            // 0x23d46
            *p_v5 = *(int32_t *)i_v3;
        }
    }
    // 0x23d4e
    list_remove(i_v3);
    json_decref2(*(int32_t *)(i_v2 + 12));
    *(int32_t *)i_a1 = jsonp_free(i_v2) - 1;
    // 0x23d74
    return 0;
}

// Address range: 0x23d80 - 0x23dc4
int32_t hashtable_do_clear(int32_t i_a1) {
    int32_t i_v1 = *(int32_t *)(i_a1 + 16); // 0x23d8a
    int32_t i_v2 = i_a1 + 12;               // 0x23db2
    if (i_v2 == i_v1) {
        // 0x23dbc
        return i_a1;
    }
    int32_t i_v3 = *(int32_t *)(i_v1 + 4); // 0x23d92
    json_decref2(*(int32_t *)(i_v1 + 8));
    int32_t i_v4 = jsonp_free(i_v1 - 4); // 0x23dba
    while (i_v2 != i_v3) {
        int32_t i_v5 = i_v3;
        i_v3 = *(int32_t *)(i_v5 + 4);
        json_decref2(*(int32_t *)(i_v5 + 8));
        i_v4 = jsonp_free(i_v5 - 4);
    }
    // 0x23dbc
    return i_v4;
}

// Address range: 0x23dc4 - 0x23ea0
int32_t hashtable_do_rehash(int32_t i_a1) {
    int32_t *p_v1 = (int32_t *)(i_a1 + 4); // 0x23dce
    jsonp_free(*p_v1);
    int32_t *p_v2 = (int32_t *)(i_a1 + 8); // 0x23dd8
    *p_v2 = *p_v2 + 1;
    uint32_t i_v3 = num_buckets(i_a1);     // 0x23de2
    int32_t i_v4 = jsonp_malloc(8 * i_v3); // 0x23dee
    *p_v1 = i_v4;
    if (i_v4 == 0) {
        // 0x23e96
        return -1;
    }
    int32_t i_v5 = num_buckets(i_a1); // 0x23e32
    int32_t i_v6 = i_a1 + 12;
    int32_t i_v7 = 0; // 0x23e3c
    if (i_v5 != 0) {
        int32_t i_v8 = *p_v1 + 8 * i_v7; // 0x23e14
        *(int32_t *)(i_v8 + 4) = i_v6;
        *(int32_t *)i_v8 = i_v6;
        i_v7++;
        uint32_t i_v9 = num_buckets(i_a1); // 0x23e32
        while (i_v9 >= i_v7 == (i_v9 != i_v7)) {
            // 0x23e0c
            i_v8 = *p_v1 + 8 * i_v7;
            *(int32_t *)(i_v8 + 4) = i_v6;
            *(int32_t *)i_v8 = i_v6;
            i_v7++;
            i_v9 = num_buckets(i_a1);
        }
    }
    int32_t i_v10 = *(int32_t *)(i_a1 + 16); // 0x23e40
    list_init(i_v6);
    if (i_v6 == i_v10) {
        // 0x23e96
        return 0;
    }
    int32_t i_v11 = *(int32_t *)(i_v10 + 4); // 0x23e52
    insert_to_bucket(i_a1, *p_v1 + 8 * (*(int32_t *)(i_v10 - 4) % i_v3), i_v10);
    while (i_v6 != i_v11) {
        int32_t i_v12 = i_v11;
        i_v11 = *(int32_t *)(i_v12 + 4);
        uint32_t i_v13 = *(int32_t *)(i_v12 - 4); // 0x23e5e
        insert_to_bucket(i_a1, *p_v1 + 8 * (i_v13 % i_v3), i_v12);
    }
    // 0x23e96
    return 0;
}

// Address range: 0x23ea0 - 0x23f26
int32_t hashtable_init(int32_t i_a1) {
    // 0x23ea0
    *(int32_t *)i_a1 = 0;
    *(int32_t *)(i_a1 + 8) = 0;
    int32_t i_v1 = jsonp_malloc(8 * num_buckets(i_a1)); // 0x23ec0
    int32_t *p_v2 = (int32_t *)(i_a1 + 4);              // 0x23ec8
    *p_v2 = i_v1;
    if (i_v1 == 0) {
        // 0x23f1c
        return -1;
    }
    int32_t i_v3 = i_a1 + 12; // 0x23eda
    list_init(i_v3);
    if (num_buckets(i_a1) == 0) {
        // 0x23f1c
        return 0;
    }
    int32_t i_v4 = 0;                // 0x23f18
    int32_t i_v5 = *p_v2 + 8 * i_v4; // 0x23ef0
    *(int32_t *)(i_v5 + 4) = i_v3;
    *(int32_t *)i_v5 = i_v3;
    i_v4++;
    uint32_t i_v6 = num_buckets(i_a1); // 0x23f0e
    while (i_v6 >= i_v4 == (i_v6 != i_v4)) {
        // 0x23ee8
        i_v5 = *p_v2 + 8 * i_v4;
        *(int32_t *)(i_v5 + 4) = i_v3;
        *(int32_t *)i_v5 = i_v3;
        i_v4++;
        i_v6 = num_buckets(i_a1);
    }
    // 0x23f1c
    return 0;
}

// Address range: 0x23f28 - 0x23f48
int32_t hashtable_close(int32_t i_a1) {
    // 0x23f28
    hashtable_do_clear(i_a1);
    return jsonp_free(*(int32_t *)(i_a1 + 4));
}

// Address range: 0x23f48 - 0x24032
int32_t hashtable_set(uint32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    // 0x23f48
    if ((uint32_t)num_buckets(i_a1) <= i_a1) {
        // 0x23f66
        if (hashtable_do_rehash(i_a1) != 0) {
            // 0x24028
            return -1;
        }
    }
    uint32_t i_v1 = hash_str(i_a2); // 0x23f7a
    int32_t i_v2 =
        *(int32_t *)(i_a1 + 4) + 8 * (i_v1 % num_buckets(i_a1)); // 0x23f9e
    int32_t i_v3 = hashtable_find_pair(i_a1, i_v2, i_a2, i_v1);  // 0x23faa
    if (i_v3 != 0) {
        int32_t *p_v4 = (int32_t *)(i_v3 + 12); // 0x23fb8
        json_decref2(*p_v4);
        *p_v4 = i_a4;
        // 0x24028
        return 0;
    }
    char *p_v5 = (char *)i_a2;                      // 0x23fca
    int32_t i_v6 = jsonp_malloc(strlen(p_v5) + 21); // 0x23fd4
    int32_t i_v7 = -1;                              // 0x23fde
    if (i_v6 != 0) {
        // 0x23fe6
        *(int32_t *)i_v6 = i_v1;
        *(int32_t *)(i_v6 + 16) = i_a3;
        strcpy((char *)(i_v6 + 20), p_v5);
        *(int32_t *)(i_v6 + 12) = i_a4;
        int32_t i_v8 = i_v6 + 4; // 0x24006
        list_init(i_v8);
        *(int32_t *)i_a1 = insert_to_bucket(i_a1, i_v2, i_v8) + 1;
        i_v7 = 0;
    }
    // 0x24028
    return i_v7;
}

// Address range: 0x24034 - 0x2408a
int32_t hashtable_get(int32_t i_a1, int32_t i_a2) {
    uint32_t i_v1 = hash_str(i_a2); // 0x24040
    int32_t i_v2 = hashtable_find_pair(
        i_a1, 8 * (i_v1 % num_buckets(i_a1)) + *(int32_t *)(i_a1 + 4), i_a2,
        i_v1);        // 0x2406c
    int32_t i_v3 = 0; // 0x24076
    if (i_v2 != 0) {
        // 0x2407c
        i_v3 = *(int32_t *)(i_v2 + 12);
    }
    // 0x24080
    return i_v3;
}

// Address range: 0x2408c - 0x240b4
int32_t hashtable_del(int32_t i_a1, int32_t i_a2) {
    // 0x2408c
    return hashtable_do_del(i_a1, i_a2, hash_str(i_a2));
}

// Address range: 0x240b4 - 0x24112
int32_t hashtable_clear(int32_t i_a1) {
    // 0x240b4
    hashtable_do_clear(i_a1);
    int32_t i_v1; // 0x24100
    if (num_buckets(i_a1) == 0) {
        // 0x240fa
        i_v1 = list_init(i_a1 + 12);
        *(int32_t *)i_a1 = 0;
        return i_v1;
    }
    int32_t i_v2 = i_a1 + 12;
    int32_t i_v3 = 0;                                 // 0x240e8
    int32_t i_v4 = *(int32_t *)(i_a1 + 4) + 8 * i_v3; // 0x240d0
    *(int32_t *)(i_v4 + 4) = i_v2;
    *(int32_t *)i_v4 = i_v2;
    i_v3++;
    uint32_t i_v5 = num_buckets(i_a1); // 0x240ee
    while (i_v5 >= i_v3 == (i_v5 != i_v3)) {
        // 0x240c8
        i_v4 = *(int32_t *)(i_a1 + 4) + 8 * i_v3;
        *(int32_t *)(i_v4 + 4) = i_v2;
        *(int32_t *)i_v4 = i_v2;
        i_v3++;
        i_v5 = num_buckets(i_a1);
    }
    // 0x240fa
    i_v1 = list_init(i_v2);
    *(int32_t *)i_a1 = 0;
    return i_v1;
}

// Address range: 0x24114 - 0x24134
int32_t hashtable_iter(int32_t i_a1) {
    // 0x24114
    return hashtable_iter_next(i_a1, i_a1 + 12);
}

// Address range: 0x24134 - 0x2418a
int32_t hashtable_iter_at(int32_t i_a1, int32_t i_a2) {
    uint32_t i_v1 = hash_str(i_a2); // 0x24140
    int32_t i_v2 = hashtable_find_pair(
        i_a1, 8 * (i_v1 % num_buckets(i_a1)) + *(int32_t *)(i_a1 + 4), i_a2,
        i_v1); // 0x2416c
    return i_v2 == 0 ? 0 : i_v2 + 4;
}

// Address range: 0x2418c - 0x241ba
int32_t hashtable_iter_next(int32_t i_a1, int32_t i_a2) {
    int32_t i_v1 = *(int32_t *)(i_a2 + 4); // 0x2419c
    return i_v1 == i_a1 + 12 ? 0 : i_v1;
}

// Address range: 0x241bc - 0x241da
int32_t hashtable_iter_key(int32_t i_a1) {
    // 0x241bc
    return i_a1 + 16;
}

// Address range: 0x241dc - 0x241fa
int32_t hashtable_iter_serial(int32_t i_a1) {
    // 0x241dc
    return *(int32_t *)(i_a1 + 12);
}

// Address range: 0x241fc - 0x2421a
int32_t hashtable_iter_value(int32_t i_a1) {
    // 0x241fc
    return *(int32_t *)(i_a1 + 8);
}

// Address range: 0x2421c - 0x24244
int32_t hashtable_iter_set(int32_t i_a1, int32_t i_a2) {
    int32_t *p_v1 = (int32_t *)(i_a1 + 8); // 0x2422e
    int32_t i_v2 = json_decref2(*p_v1);    // 0x24232
    *p_v1 = i_a2;
    return i_v2;
}

// Address range: 0x24244 - 0x24274
int32_t json_incref(int32_t i_a1) {
    if (i_a1 == 0) {
        // 0x24266
        return i_a1;
    }
    int32_t *p_v1 = (int32_t *)(i_a1 + 4); // 0x24254
    int32_t i_v2 = *p_v1;                  // 0x24254
    if (i_v2 != -1) {
        // 0x2425c
        *p_v1 = i_v2 + 1;
    }
    // 0x24266
    return i_a1;
}

// Address range: 0x24274 - 0x242ac
int32_t json_decref3(int32_t i_a1) {
    // 0x24274
    if (i_a1 == 0) {
        // 0x242a4
        return 0;
    }
    int32_t *p_v1 = (int32_t *)(i_a1 + 4); // 0x24284
    int32_t i_v2 = *p_v1;                  // 0x24284
    if (i_v2 == -1) {
        // 0x242a4
        return i_a1;
    }
    int32_t i_v3 = i_v2 - 1; // 0x24290
    *p_v1 = i_v3;
    int32_t i_v4 = i_a1; // 0x2429c
    if (i_v3 == 0) {
        // 0x2429e
        i_v4 = json_delete(i_a1);
    }
    // 0x242a4
    return i_v4;
}

// Address range: 0x242ac - 0x242d6
int32_t json_object_set_nocheck(int32_t i_a1, int32_t i_a2, int32_t i_a3) {
    // 0x242ac
    return json_object_set_new_nocheck(i_a1, i_a2, json_incref(i_a3));
}

// Address range: 0x242d8 - 0x242fe
int32_t json_array_append(int32_t i_a1, int32_t i_a2) {
    // 0x242d8
    return json_array_append_new(i_a1, json_incref(i_a2));
}

// Address range: 0x24300 - 0x24450
int32_t error_set(int32_t i_a1, int32_t i_a2, char *p_a3, int32_t i_a4) {
    int32_t i_v1 = i_a4; // bp-4, 0x24300
    if (i_a1 == 0) {
        // 0x24442
        return 0;
    }
    // 0x24338
    int32_t i_v2;         // bp-200, 0x24300
    int32_t i_v3 = &i_v2; // 0x2432a
    vsnprintf((char *)&i_v2, 160, p_a3, (int32_t)&i_v1);
    int32_t i_v4 = -1;   // 0x24360
    int32_t i_v5 = -1;   // 0x24360
    int32_t i_v6 = 0;    // 0x24360
    int32_t i_v7 = i_v3; // 0x24360
    int32_t i_v8;        // bp-360, 0x24300
    int32_t i_v9;        // 0x24376
    int32_t i_v10;       // 0x24380
    int32_t i_v11;       // 0x2438a
    if (i_a2 == 0) {
        return jsonp_error_set(i_a1, i_v4, i_v5, i_v6, (int32_t) "%s", i_v7);
    } else {
        int32_t i_v12 = strbuffer_value((int32_t *)(i_a2 + 40)); // 0x2436a
        i_v9 = *(int32_t *)(i_a2 + 24);
        i_v10 = *(int32_t *)(i_a2 + 28);
        i_v11 = *(int32_t *)(i_a2 + 36);
        if (i_v12 == 0) {
            goto lab_0x243de;
        } else {
            char *p_v13 = (char *)i_v12; // 0x2436e
            if (*p_v13 == 0) {
                goto lab_0x243de;
            } else {
                uint32_t i_v14 = *(int32_t *)(i_a2 + 44); // 0x243a6
                i_v4 = i_v9;
                i_v5 = i_v10;
                i_v6 = i_v11;
                i_v7 = i_v3;
                if (i_v14 >= 20 != i_v14 != 20) {
                    // 0x243ac
                    snprintf((char *)&i_v8, 160, "%s near '%s'", &i_v2, p_v13);
                    i_v4 = i_v9;
                    i_v5 = i_v10;
                    i_v6 = i_v11;
                    i_v7 = &i_v8;
                }
                return jsonp_error_set(i_a1, i_v4, i_v5, i_v6, (int32_t) "%s",
                                       i_v7);
            }
        }
    }
    // 0x24442
    return jsonp_error_set(i_a1, i_v4, i_v5, i_v6, (int32_t) "%s", i_v7);
lab_0x243de:
    // 0x243de
    i_v4 = i_v9;
    i_v5 = i_v10;
    i_v6 = i_v11;
    i_v7 = i_v3;
    if (*(int32_t *)(i_a2 + 20) != -2) {
        // 0x243f4
        snprintf((char *)&i_v8, 160, "%s near end of file", &i_v2);
        i_v4 = i_v9;
        i_v5 = i_v10;
        i_v6 = i_v11;
        i_v7 = &i_v8;
    }
    return jsonp_error_set(i_a1, i_v4, i_v5, i_v6, (int32_t) "%s", i_v7);
}

// Address range: 0x24450 - 0x24496
int32_t stream_init(int32_t i_a1, int32_t i_a2, int32_t i_a3) {
    // 0x24450
    *(int32_t *)i_a1 = i_a2;
    *(int32_t *)(i_a1 + 4) = i_a3;
    *(char *)(i_a1 + 8) = 0;
    *(int32_t *)(i_a1 + 16) = 0;
    *(int32_t *)(i_a1 + 20) = 0;
    *(int32_t *)(i_a1 + 24) = 1;
    *(int32_t *)(i_a1 + 28) = 0;
    *(int32_t *)(i_a1 + 36) = 0;
    return i_a1;
}

// Address range: 0x24498 - 0x24610
int32_t stream_get(int32_t i_a1, int32_t i_a2) {
    int32_t *p_v1 = (int32_t *)(i_a1 + 20); // 0x244a4
    int32_t i_v2 = *p_v1;                   // 0x244a4
    if (i_v2 != 0) {
        // 0x24606
        return i_v2;
    }
    int32_t *p_v3 = (int32_t *)(i_a1 + 16); // 0x244b2
    int32_t i_v4 = i_a1 + 8;
    if (*(char *)(*p_v3 + i_v4) == 0) {
        int32_t *p_v5 = (int32_t *)(i_a1 + 4); // 0x244c4
        uint32_t i_v6 = *p_v5;                 // 0x244c4
        if (i_v6 == -1) {
            // 0x244d4
            *p_v1 = -1;
            // 0x24606
            return -1;
        }
        // 0x244e2
        *(char *)i_v4 = (char)i_v6;
        *p_v3 = 0;
        if ((i_v6 & -128) == 128) {
            int32_t i_v7 = utf8_check_first(i_v6 % 256); // 0x24502
            if (i_v7 == 0) {
                // 0x245e2
                __asm_nop(0, i_a2, 0, 0);
                // 0x245e8
                *p_v1 = -2;
                error_set(i_a2, i_a1, "unable to decode byte 0x%x", i_v6);
                // 0x24606
                return -2;
            }
            int32_t i_v8 = 1; // 0x24512
            if (i_v7 > 1) {
                *(char *)(i_v8 + i_v4) = (char)*p_v5;
                int32_t i_v9 = i_v8 + 1; // 0x24554
                i_v8 = i_v9;
                while (i_v9 < i_v7) {
                    // 0x24538
                    *(char *)(i_v8 + i_v4) = (char)*p_v5;
                    i_v9 = i_v8 + 1;
                    i_v8 = i_v9;
                }
            } else {
                // 0x24532
                __assert_fail("count >= 2", "3rdparty/jansson-2.6/src/load.c",
                              175, "stream_get");
            }
            // 0x24560
            if (utf8_check_full(i_v4, i_v7, 0) == 0) {
                // 0x245e6
                __asm_nop(0, i_v7, 0, 0);
                // 0x245e8
                *p_v1 = -2;
                error_set(i_a2, i_a1, "unable to decode byte 0x%x", i_v6);
                // 0x24606
                return -2;
            }
            // 0x24574
            *(char *)(i_v7 + i_v4) = 0;
        } else {
            // 0x24582
            *(char *)(i_a1 + 9) = 0;
        }
    }
    int32_t i_v10 = *p_v3;                         // 0x2458a
    unsigned char i_v11 = *(char *)(i_v10 + i_v4); // 0x24590
    *p_v3 = i_v10 + 1;
    int32_t *p_v12 = (int32_t *)(i_a1 + 36); // 0x2459c
    *p_v12 = *p_v12 + 1;
    if (i_v11 != 10) {
        int32_t i_v13 = i_v11; // 0x24590
        if (utf8_check_first(i_v13) != 0) {
            int32_t *p_v14 = (int32_t *)(i_a1 + 28); // 0x245d6
            *p_v14 = *p_v14 + 1;
        }
        // 0x24606
        return i_v13;
    }
    int32_t *p_v15 = (int32_t *)(i_a1 + 24); // 0x245ac
    *p_v15 = *p_v15 + 1;
    int32_t *p_v16 = (int32_t *)(i_a1 + 28); // 0x245b6
    *(int32_t *)(i_a1 + 32) = *p_v16;
    *p_v16 = 0;
    // 0x24606
    return 10;
}

// Address range: 0x24610 - 0x246d2
int32_t stream_unget(int32_t i_a1, uint32_t i_a2) {
    int32_t i_v1 = i_a1; // 0x24610
    int32_t i_v2 = i_a2; // 0x24610
    int32_t i_v3 = i_a2; // 0x24610
    int32_t i_v4;        // 0x24610
    if (i_a2 <= 0xfffffffd) {
        int32_t *p_v5 = (int32_t *)(i_a1 + 36); // 0x2462c
        *p_v5 = *p_v5 - 1;
        int32_t i_v6; // 0x24610
        if (i_a2 == 10) {
            int32_t *p_v7 = (int32_t *)(i_a1 + 24); // 0x2463c
            *p_v7 = *p_v7 - 1;
            *(int32_t *)(i_a1 + 28) = *(int32_t *)(i_a1 + 32);
            i_v6 = i_a1;
        } else {
            int32_t i_v8 = utf8_check_first(i_a2 % 256); // 0x24654
            i_v6 = 0;
            if (i_v8 != 0) {
                int32_t *p_v9 = (int32_t *)(i_a1 + 28); // 0x24660
                *p_v9 = *p_v9 - 1;
                i_v6 = i_v8;
            }
        }
        int32_t *p_v10 = (int32_t *)(i_a1 + 16); // 0x2466a
        int32_t i_v11 = *p_v10;                  // 0x2466a
        int32_t i_v12 = i_v11;                   // 0x2466e
        int32_t i_v13 = i_v6;                    // 0x2466e
        if (i_v11 == 0) {
            // 0x24670
            __assert_fail("stream->buffer_pos > 0",
                          "3rdparty/jansson-2.6/src/load.c", 224,
                          "stream_unget");
            i_v12 = *p_v10;
            i_v13 = &i_g309;
        }
        int32_t i_v14 = i_v12 - 1; // 0x24692
        *p_v10 = i_v14;
        if ((int32_t) * (char *)(i_a1 + 8 + i_v14) == i_a2) {
            // 0x246ca
            return i_v13;
        }
        // 0x246aa
        __assert_fail("stream->buffer[stream->buffer_pos] == c",
                      "3rdparty/jansson-2.6/src/load.c", 226, "stream_unget");
        i_v1 = &i_g309;
        i_v2 = (int32_t) "3rdparty/jansson-2.6/src/load.c";
        i_v4 = 226;
        i_v3 = (int32_t) "stream_unget";
    }
    // 0x246ca
    return __asm_nop(i_v1, i_v2, i_v4, i_v3);
}

// Address range: 0x246d4 - 0x246f4
int32_t lex_get(int32_t i_a1, int32_t i_a2) {
    // 0x246d4
    return stream_get(i_a1, i_a2);
}

// Address range: 0x246f4 - 0x24718
int32_t lex_save(int32_t i_a1, uint32_t i_a2) {
    // 0x246f4
    return strbuffer_append_byte(i_a1 + 40, i_a2 % 256);
}

// Address range: 0x24718 - 0x24752
int32_t lex_get_save(int32_t i_a1, int32_t i_a2) {
    uint32_t i_v1 = stream_get(i_a1, i_a2); // 0x24728
    if (i_v1 <= 0xfffffffd) {
        // 0x2473e
        lex_save(i_a1, i_v1);
    }
    // 0x24746
    return i_v1;
}

// Address range: 0x24754 - 0x24770
int32_t lex_unget(int32_t i_a1, int32_t i_a2) {
    // 0x24754
    return stream_unget(i_a1, i_a2);
}

// Address range: 0x24770 - 0x247d2
int32_t lex_unget_unsave(int32_t i_a1, uint32_t i_a2) {
    // 0x24770
    if (i_a2 > 0xfffffffd) {
        // 0x247ca
        return i_a1;
    }
    // 0x2478a
    stream_unget(i_a1, i_a2);
    int32_t i_v1 = strbuffer_pop(i_a1 + 40); // 0x2479a
    int32_t i_v2 = i_v1;                     // 0x247a8
    if (i_v1 % 256 != i_a2) {
        // 0x247aa
        __assert_fail("c == d", "3rdparty/jansson-2.6/src/load.c", 268,
                      "lex_unget_unsave");
        i_v2 = &i_g309;
    }
    // 0x247ca
    return i_v2;
}

// Address range: 0x247d4 - 0x2481a
int32_t lex_save_cached(int32_t i_a1) {
    int32_t *p_v1 = (int32_t *)(i_a1 + 16); // 0x24806
    int32_t i_v2 = i_a1 + 8;                // 0x2480a
    char i_v3 = *(char *)(*p_v1 + i_v2);    // 0x2480c
    if (i_v3 == 0) {
        // 0x24812
        return i_a1;
    }
    int32_t *p_v4 = (int32_t *)(i_a1 + 36);
    int32_t i_v5 = lex_save(i_a1, (int32_t)i_v3); // 0x247ec
    *p_v1 = *p_v1 + 1;
    *p_v4 = *p_v4 + 1;
    char i_v6 = *(char *)(*p_v1 + i_v2); // 0x2480c
    while (i_v6 != 0) {
        // 0x247de
        i_v5 = lex_save(i_a1, (int32_t)i_v6);
        *p_v1 = *p_v1 + 1;
        *p_v4 = *p_v4 + 1;
        i_v6 = *(char *)(*p_v1 + i_v2);
    }
    // 0x24812
    return i_v5;
}

// Address range: 0x2481c - 0x248e6
int32_t decode_unicode_escape(int32_t i_a1) {
    // 0x2481c
    int32_t i_v1; // 0x2481c
    if ((char)i_v1 != 117) {
        // 0x24830
        __assert_fail("str[0] == 'u'", "3rdparty/jansson-2.6/src/load.c", 288,
                      "decode_unicode_escape");
    }
    int32_t i_v2 = 1; // 0x248d0
    int32_t i_v3 = 0;
    int32_t i_v4;       // 0x2481c
    unsigned char i_v5; // 0x2485c
    int32_t i_v6;       // 0x24862
    while (true) {
    lab_0x24856:
        // 0x24856
        i_v5 = *(char *)(i_v2 + i_a1);
        i_v6 = 16 * i_v3;
        if (i_v5 == 47 || i_v5 < 47) {
            goto lab_0x2487e;
        } else {
            if (i_v5 >= 57 == (i_v5 != 57)) {
                goto lab_0x2487e;
            } else {
                // 0x24872
                i_v4 = i_v6 - 48 + (int32_t)i_v5;
                goto lab_0x248ce;
            }
        }
    }
    // 0x248da
    return i_v3;
lab_0x2487e:
    if (i_v5 == 96 || i_v5 < 96) {
        goto lab_0x24896;
    } else {
        if (i_v5 >= 122 == (i_v5 != 122)) {
            goto lab_0x24896;
        } else {
            // 0x2488a
            i_v4 = i_v6 - 87 + (int32_t)i_v5;
            goto lab_0x248ce;
        }
    }
lab_0x24896:
    if (i_v5 == 64 || i_v5 < 64) {
        // 0x248ae
        __assert_fail("0", "3rdparty/jansson-2.6/src/load.c", 300,
                      "decode_unicode_escape");
        i_v4 = i_v6;
        goto lab_0x248ce;
    } else {
        if (i_v5 >= 90 == (i_v5 != 90)) {
            // 0x248ae
            __assert_fail("0", "3rdparty/jansson-2.6/src/load.c", 300,
                          "decode_unicode_escape");
            i_v4 = i_v6;
            goto lab_0x248ce;
        } else {
            // 0x248a2
            i_v4 = i_v6 - 55 + (int32_t)i_v5;
            goto lab_0x248ce;
        }
    }
lab_0x248ce:
    // 0x248ce
    i_v3 = i_v4;
    i_v2++;
    if (i_v2 >= 5) {
        return i_v3;
    }
    goto lab_0x24856;
}

// Address range: 0x248e8 - 0x24ca0
int32_t lex_scan_string(int32_t i_a1, int32_t i_a2) {
    int32_t *p_v1 = (int32_t *)(i_a1 + 56); // 0x248f6
    *p_v1 = 0;
    int32_t *p_v2 = (int32_t *)(i_a1 + 52); // 0x248fe
    *p_v2 = -1;
    int32_t i_v3 = lex_get_save(i_a1, i_a2); // 0x2490a
    int32_t i_v4;                            // 0x248e8
    int32_t i_v5;                            // 0x248e8
    int32_t i_v6;                            // 0x248e8
    int32_t i_v7;                            // 0x248e8
    int32_t i_v8;                            // 0x248e8
    int32_t i_v9;                            // 0x248e8
    int32_t i_v10;                           // 0x248e8
    char *p_v11;                             // 0x248e8
    char *p_v12;                             // 0x248e8
    char *p_v13;                             // 0x248e8
    char *p_v14;                             // 0x248e8
    int32_t i_v15;                           // 0x248e8
    int32_t i_v16;                           // 0x248e8
    int32_t i_v17;                           // 0x248e8
    int32_t i_v18;                           // 0x248e8
    int32_t i_v19;                           // bp-36, 0x248e8
    int32_t i_v20;                           // bp-40, 0x248e8
    int32_t i_v21;                           // 0x248e8
    char i_v22;                              // 0x24c70
    int32_t i_v23;                           // 0x24a84
    int32_t i_v24;                           // 0x24a86
    unsigned char i_v25;                     // 0x24a8c
    int32_t i_v26;                           // 0x249d2
    int32_t i_v27;                           // 0x249da
    int32_t i_v28;                           // 0x24a96
    char *p_v29;                             // 0x24aa0
    int32_t i_v30;                           // 0x24ac0
    int32_t *p_v31;                          // 0x24bba
    int32_t i_v32;                           // 0x24ad0
    int32_t i_v33;                           // 0x24af2
    int32_t i_v34;                           // 0x24b00
    int32_t i_v35;                           // 0x24a4e
    int32_t i_v36;                           // 0x24a6e
    while (true) {
        uint32_t i_v37 = i_v3;
        switch (i_v37) {
        case 34: {
            // 0x24a46
            i_v35 = jsonp_malloc(*(int32_t *)(i_a1 + 44) + 1);
            *p_v1 = i_v35;
            if (i_v35 == 0) {
                // 0x24c8c
                __asm_nop(0, i_a2, 0, 0);
            lab_0x24c8e:
                // 0x24c98
                return jsonp_free(*p_v1);
            }
            // 0x24a62
            i_v36 = strbuffer_value((int32_t *)(i_a1 + 40));
            i_v15 = i_v35;
            p_v12 = (char *)(i_v36 + 1);
            i_v5 = i_v36;
            i_v8 = i_a2;
            while (true) {
            lab_0x24c6e_3:
                // 0x24c6e
                i_v9 = i_v8;
                i_v6 = i_v5;
                i_v16 = i_v15;
                p_v13 = p_v12;
                while (true) {
                lab_0x24c6e:
                    // 0x24c6e
                    p_v14 = p_v13;
                    i_v17 = i_v16;
                    i_v22 = *p_v14;
                    switch (i_v22) {
                    case 34: {
                        goto lab_0x24c78;
                    }
                    case 92: {
                        goto lab_0x24a84;
                    }
                    default: {
                        // 0x24c5a
                        *(char *)i_v17 = i_v22;
                        i_v16 = i_v17 + 1;
                        p_v13 = (char *)((int32_t)p_v14 + 1);
                        goto lab_0x24c6e;
                    }
                    }
                }
            lab_0x24a84:
                // 0x24a84
                i_v23 = (int32_t)p_v14;
                i_v24 = i_v23 + 1;
                i_v25 = *(char *)i_v24;
                switch (i_v25) {
                case 117: {
                    // 0x24a94
                    i_v28 = decode_unicode_escape(i_v24);
                    p_v29 = (char *)(i_v23 + 6);
                    switch (i_v28 & -1024) {
                    case 0xd800: {
                        // 0x24ab6
                        if (*p_v29 != 92) {
                            // 0x24b22
                            error_set(i_a2, i_a1, "invalid Unicode '\\u%04X'",
                                      i_v28);
                            return jsonp_free(*p_v1);
                        }
                        // 0x24abe
                        i_v30 = i_v23 + 7;
                        if (*(char *)i_v30 != 117) {
                            // 0x24b22
                            error_set(i_a2, i_a1, "invalid Unicode '\\u%04X'",
                                      i_v28);
                            return jsonp_free(*p_v1);
                        }
                        // 0x24ac8
                        i_v32 = decode_unicode_escape(i_v30);
                        if ((i_v32 & -1024) != 0xdc00) {
                            // 0x24b0a
                            error_set(i_a2, i_a1,
                                      "invalid Unicode '\\u%04X\\u%04X'",
                                      i_v28);
                            return jsonp_free(*p_v1);
                        }
                        // 0x24af0
                        i_v33 = 1024 * i_v28;
                        i_v34 = i_v33 - 0x35fdc00 + i_v32;
                        __asm_nop(i_v32, i_v9, i_v33 - 0x3600000, i_v34);
                        p_v11 = (char *)(i_v23 + 12);
                        i_v18 = i_v34;
                        // break -> 0x24b76
                        break;
                    }
                    case 0xdc00: {
                        // 0x24b4a
                        error_set(i_a2, i_a1, "invalid Unicode '\\u%04X'",
                                  i_v28);
                        // 0x24c98
                        return jsonp_free(*p_v1);
                    }
                    default: {
                        // 0x24b5e
                        p_v11 = p_v29;
                        i_v18 = i_v28;
                        if (i_v28 == 0) {
                            // 0x24b64
                            error_set(i_a2, i_a1, "\\u0000 is not allowed", 0);
                            return jsonp_free(*p_v1);
                        }
                        // break -> 0x24b76
                        break;
                    }
                    }
                    // 0x24b76
                    if (utf8_encode(i_v18, &i_v19, &i_v20) != 0) {
                        // 0x24b8e
                        __assert_fail("0", "3rdparty/jansson-2.6/src/load.c",
                                      430, "lex_scan_string");
                    }
                    // 0x24bae
                    p_v31 = memcpy((int32_t *)i_v17, &i_v19, i_v20);
                    i_v15 = i_v20 + i_v17;
                    p_v12 = p_v11;
                    i_v5 = (int32_t)p_v31;
                    i_v8 = &i_v19;
                    goto lab_0x24c6e_3;
                }
                case 102: {
                    // 0x24c0c
                    *(char *)i_v17 = 12;
                    i_v4 = i_v6;
                    i_v7 = i_v9;
                    goto lab_0x24c4c;
                }
                default: {
                    if (i_v25 > 102) {
                        switch (i_v25) {
                        case 114: {
                            // 0x24c1c
                            *(char *)i_v17 = 13;
                            i_v4 = i_v6;
                            i_v7 = i_v9;
                            goto lab_0x24c4c;
                        }
                        case 116: {
                            // 0x24c24
                            *(char *)i_v17 = 9;
                            i_v4 = i_v6;
                            i_v7 = i_v9;
                            goto lab_0x24c4c;
                        }
                        case 110: {
                            // 0x24c14
                            *(char *)i_v17 = 10;
                            i_v4 = i_v6;
                            i_v7 = i_v9;
                            goto lab_0x24c4c;
                        }
                        default: {
                            goto lab_0x24c2c;
                        }
                        }
                    } else {
                        if (i_v25 == 92) {
                            goto lab_0x24bfa;
                        } else {
                            if (i_v25 > 92) {
                                if (i_v25 == 98) {
                                    // 0x24c04
                                    *(char *)i_v17 = 8;
                                    i_v4 = i_v6;
                                    i_v7 = i_v9;
                                    goto lab_0x24c4c;
                                } else {
                                    goto lab_0x24c2c;
                                }
                            } else {
                                switch (i_v25) {
                                case 47: {
                                    goto lab_0x24bfa;
                                }
                                case 34: {
                                    goto lab_0x24bfa;
                                }
                                default: {
                                    goto lab_0x24c2c;
                                }
                                }
                            }
                        }
                    }
                }
                }
            }
        lab_0x24c78:
            // 0x24c78
            *(char *)i_v17 = 0;
            *p_v2 = 256;
            // 0x24c98
            return i_v6;
        lab_0x24c6e_2:
            // 0x24c6e
            goto lab_0x24c6e_3;
        lab_0x24c4c:
            // 0x24c4c
            i_v15 = i_v17 + 1;
            p_v12 = (char *)(i_v23 + 2);
            i_v5 = i_v4;
            i_v8 = i_v7;
            goto lab_0x24c6e_2;
        lab_0x24c2c:
            // 0x24c2c
            __assert_fail("0", "3rdparty/jansson-2.6/src/load.c", 444,
                          "lex_scan_string");
            i_v4 = &i_g309;
            i_v7 = (int32_t) "3rdparty/jansson-2.6/src/load.c";
            goto lab_0x24c4c;
        lab_0x24bfa:
            // 0x24bfa
            *(char *)i_v17 = i_v25;
            i_v4 = i_v6;
            i_v7 = i_v9;
            goto lab_0x24c4c;
        lab_0x249ce:
            // 0x249ce
            i_v26 = lex_get_save(i_a1, i_a2);
            i_v27 = i_v21 + 1;
            i_v21 = i_v27;
            i_v10 = i_v26;
            i_v3 = i_v26;
            if (i_v27 >= 4) {
                // break -> 0x24a3e
                goto lab_0x24a3e;
            }
            goto lab_0x24998;
        }
        case -2: {
            // 0x24c88
            __asm_nop(-2, i_a2, -1, -2);
            // 0x24c98
            return jsonp_free(*p_v1);
        }
        case -1: {
            // 0x2491e
            error_set(i_a2, i_a1, "premature end of input", -1);
            // 0x24c98
            return jsonp_free(*p_v1);
        }
        }
        if (i_v37 <= 31) {
            // 0x2493c
            lex_unget_unsave(i_a1, i_v37);
            if (i_v37 == 10) {
                // 0x2494a
                error_set(i_a2, i_a1, "unexpected newline", 10);
                return jsonp_free(*p_v1);
            } else {
                // 0x2495e
                error_set(i_a2, i_a1, "control character 0x%x", i_v37);
                return jsonp_free(*p_v1);
            }
        }
        int32_t i_v38 = lex_get_save(i_a1, i_a2);
        i_v3 = i_v38;
        if (i_v37 == 92) {
            switch (i_v38) {
            case 117: {
                // 0x24988
                i_v21 = 0;
                i_v10 = lex_get_save(i_a1, i_a2);
                while (true) {
                lab_0x24998:;
                    int32_t i_v39 = i_v10;
                    if (i_v39 < 58) {
                        goto lab_0x249ce;
                    } else {
                        switch (i_v39) {
                        case 102: {
                            goto lab_0x249ce;
                        }
                        case 101: {
                            goto lab_0x249ce;
                        }
                        case 100: {
                            goto lab_0x249ce;
                        }
                        case 99: {
                            goto lab_0x249ce;
                        }
                        case 98: {
                            goto lab_0x249ce;
                        }
                        case 97: {
                            goto lab_0x249ce;
                        }
                        case 70: {
                            goto lab_0x249ce;
                        }
                        case 69: {
                            goto lab_0x249ce;
                        }
                        case 68: {
                            goto lab_0x249ce;
                        }
                        case 67: {
                            goto lab_0x249ce;
                        }
                        case 66: {
                            goto lab_0x249ce;
                        }
                        case 65: {
                            goto lab_0x249ce;
                        }
                        default: {
                            // 0x249bc
                            error_set(i_a2, i_a1, "invalid escape", i_v39);
                            // 0x24c98
                            return jsonp_free(*p_v1);
                        }
                        }
                    }
                }
            }
            case 114: {
            }
            case 110: {
            }
            case 102: {
            }
            case 98: {
            }
            case 92: {
            }
            case 47: {
            }
            case 34: {
            }
            case 116: {
                // 0x24a16
                i_v3 = lex_get_save(i_a1, i_a2);
                // break -> 0x24a3e
                break;
            }
            default: {
                // 0x24a22
                error_set(i_a2, i_a1, "invalid escape", i_v38);
                // 0x24c98
                return jsonp_free(*p_v1);
            }
            }
        }
    lab_0x24a3e:;
    }
    // 0x24a46
    i_v35 = jsonp_malloc(*(int32_t *)(i_a1 + 44) + 1);
    *p_v1 = i_v35;
    if (i_v35 == 0) {
        // 0x24c8c
        __asm_nop(0, i_a2, 0, 0);
    lab_0x24c8e:
        // 0x24c98
        return jsonp_free(*p_v1);
    }
    // 0x24a62
    i_v36 = strbuffer_value((int32_t *)(i_a1 + 40));
    i_v15 = i_v35;
    p_v12 = (char *)(i_v36 + 1);
    i_v5 = i_v36;
    i_v8 = i_a2;
    while (true) {
    lab_0x24c6e_3:
        // 0x24c6e
        i_v9 = i_v8;
        i_v6 = i_v5;
        i_v16 = i_v15;
        p_v13 = p_v12;
        while (true) {
        lab_0x24c6e:
            // 0x24c6e
            p_v14 = p_v13;
            i_v17 = i_v16;
            i_v22 = *p_v14;
            switch (i_v22) {
            case 34: {
                goto lab_0x24c78;
            }
            case 92: {
                goto lab_0x24a84;
            }
            default: {
                // 0x24c5a
                *(char *)i_v17 = i_v22;
                i_v16 = i_v17 + 1;
                p_v13 = (char *)((int32_t)p_v14 + 1);
                goto lab_0x24c6e;
            }
            }
        }
    lab_0x24a84:
        // 0x24a84
        i_v23 = (int32_t)p_v14;
        i_v24 = i_v23 + 1;
        i_v25 = *(char *)i_v24;
        switch (i_v25) {
        case 117: {
            // 0x24a94
            i_v28 = decode_unicode_escape(i_v24);
            p_v29 = (char *)(i_v23 + 6);
            switch (i_v28 & -1024) {
            case 0xd800: {
                // 0x24ab6
                if (*p_v29 != 92) {
                    // 0x24b22
                    error_set(i_a2, i_a1, "invalid Unicode '\\u%04X'", i_v28);
                    return jsonp_free(*p_v1);
                }
                // 0x24abe
                i_v30 = i_v23 + 7;
                if (*(char *)i_v30 != 117) {
                    // 0x24b22
                    error_set(i_a2, i_a1, "invalid Unicode '\\u%04X'", i_v28);
                    return jsonp_free(*p_v1);
                }
                // 0x24ac8
                i_v32 = decode_unicode_escape(i_v30);
                if ((i_v32 & -1024) != 0xdc00) {
                    // 0x24b0a
                    error_set(i_a2, i_a1, "invalid Unicode '\\u%04X\\u%04X'",
                              i_v28);
                    return jsonp_free(*p_v1);
                }
                // 0x24af0
                i_v33 = 1024 * i_v28;
                i_v34 = i_v33 - 0x35fdc00 + i_v32;
                __asm_nop(i_v32, i_v9, i_v33 - 0x3600000, i_v34);
                p_v11 = (char *)(i_v23 + 12);
                i_v18 = i_v34;
                // break -> 0x24b76
                break;
            }
            case 0xdc00: {
                // 0x24b4a
                error_set(i_a2, i_a1, "invalid Unicode '\\u%04X'", i_v28);
                // 0x24c98
                return jsonp_free(*p_v1);
            }
            default: {
                // 0x24b5e
                p_v11 = p_v29;
                i_v18 = i_v28;
                if (i_v28 == 0) {
                    // 0x24b64
                    error_set(i_a2, i_a1, "\\u0000 is not allowed", 0);
                    return jsonp_free(*p_v1);
                }
                // break -> 0x24b76
                break;
            }
            }
            // 0x24b76
            if (utf8_encode(i_v18, &i_v19, &i_v20) != 0) {
                // 0x24b8e
                __assert_fail("0", "3rdparty/jansson-2.6/src/load.c", 430,
                              "lex_scan_string");
            }
            // 0x24bae
            p_v31 = memcpy((int32_t *)i_v17, &i_v19, i_v20);
            i_v15 = i_v20 + i_v17;
            p_v12 = p_v11;
            i_v5 = (int32_t)p_v31;
            i_v8 = &i_v19;
            goto lab_0x24c6e_3;
        }
        case 102: {
            // 0x24c0c
            *(char *)i_v17 = 12;
            i_v4 = i_v6;
            i_v7 = i_v9;
            goto lab_0x24c4c;
        }
        default: {
            if (i_v25 > 102) {
                switch (i_v25) {
                case 114: {
                    // 0x24c1c
                    *(char *)i_v17 = 13;
                    i_v4 = i_v6;
                    i_v7 = i_v9;
                    goto lab_0x24c4c;
                }
                case 116: {
                    // 0x24c24
                    *(char *)i_v17 = 9;
                    i_v4 = i_v6;
                    i_v7 = i_v9;
                    goto lab_0x24c4c;
                }
                case 110: {
                    // 0x24c14
                    *(char *)i_v17 = 10;
                    i_v4 = i_v6;
                    i_v7 = i_v9;
                    goto lab_0x24c4c;
                }
                default: {
                    goto lab_0x24c2c;
                }
                }
            } else {
                if (i_v25 == 92) {
                    goto lab_0x24bfa;
                } else {
                    if (i_v25 > 92) {
                        if (i_v25 == 98) {
                            // 0x24c04
                            *(char *)i_v17 = 8;
                            i_v4 = i_v6;
                            i_v7 = i_v9;
                            goto lab_0x24c4c;
                        } else {
                            goto lab_0x24c2c;
                        }
                    } else {
                        switch (i_v25) {
                        case 47: {
                            goto lab_0x24bfa;
                        }
                        case 34: {
                            goto lab_0x24bfa;
                        }
                        default: {
                            goto lab_0x24c2c;
                        }
                        }
                    }
                }
            }
        }
        }
    }
lab_0x24c78:
    // 0x24c78
    *(char *)i_v17 = 0;
    *p_v2 = 256;
    // 0x24c98
    return i_v6;
lab_0x24c6e_2:
    // 0x24c6e
    goto lab_0x24c6e_3;
lab_0x24c4c:
    // 0x24c4c
    i_v15 = i_v17 + 1;
    p_v12 = (char *)(i_v23 + 2);
    i_v5 = i_v4;
    i_v8 = i_v7;
    goto lab_0x24c6e_2;
lab_0x24c2c:
    // 0x24c2c
    __assert_fail("0", "3rdparty/jansson-2.6/src/load.c", 444,
                  "lex_scan_string");
    i_v4 = &i_g309;
    i_v7 = (int32_t) "3rdparty/jansson-2.6/src/load.c";
    goto lab_0x24c4c;
lab_0x24bfa:
    // 0x24bfa
    *(char *)i_v17 = i_v25;
    i_v4 = i_v6;
    i_v7 = i_v9;
    goto lab_0x24c4c;
lab_0x249ce:
    // 0x249ce
    i_v26 = lex_get_save(i_a1, i_a2);
    i_v27 = i_v21 + 1;
    i_v21 = i_v27;
    i_v10 = i_v26;
    i_v3 = i_v26;
    if (i_v27 >= 4) {
        // break -> 0x24a3e
        goto lab_0x24a3e;
    }
    goto lab_0x24998;
}

// Address range: 0x24ca0 - 0x24ef2
int32_t lex_scan_number(int32_t i_a1, int32_t i_a2, int32_t i_a3) {
    int32_t *p_v1 = (int32_t *)(i_a1 + 52); // 0x24cb2
    *p_v1 = -1;
    int32_t i_v2 = i_a2; // 0x24cb8
    if (i_a2 == 45) {
        // 0x24cba
        i_v2 = lex_get_save(i_a1, i_a3);
    }
    // 0x24cc4
    int32_t i_v3; // 0x24ca0
    if (i_v2 == 48) {
        int32_t i_v4 = lex_get_save(i_a1, i_a3); // 0x24cce
        i_v3 = i_v4;
        if (i_v4 <= 57) {
            // 0x24ce0
            lex_unget_unsave(i_a1, i_v4);
            // 0x24ee8
            return -1;
        }
    } else {
        if (i_v2 > 57) {
            // 0x24d1a
            lex_unget_unsave(i_a1, i_v2);
            // 0x24ee8
            return -1;
        }
        int32_t i_v5 = lex_get_save(i_a1, i_a3); // 0x24cfa
        int32_t i_v6 = i_v5;                     // 0x24d10
        if (i_v5 < 58) {
            int32_t i_v7 = lex_get_save(i_a1, i_a3); // 0x24d06
            i_v6 = i_v7;
            while (i_v7 < 58) {
                // 0x24d02
                i_v7 = lex_get_save(i_a1, i_a3);
                i_v6 = i_v7;
            }
        }
        int32_t i_v8 = i_v6;
        __asm_nop(i_v8, i_a3, -1, i_v8);
        i_v3 = i_v8;
    }
    int32_t i_v9 = i_v3; // 0x24ca0
    switch (i_v3) {
    case 46: {
        int32_t i_v10 = lex_get(i_a1, i_a3); // 0x24df2
        if (i_v10 >= 58) {
            // 0x24e04
            lex_unget(i_a1, i_v10);
            // 0x24ee8
            return -1;
        }
        // 0x24e0e
        lex_save(i_a1, i_v10);
        int32_t i_v11 = lex_get_save(i_a1, i_a3); // 0x24e1a
        i_v9 = i_v11;
        if (i_v11 < 58) {
            int32_t i_v12 = lex_get_save(i_a1, i_a3); // 0x24e26
            i_v9 = i_v12;
            while (i_v12 < 58) {
                // 0x24e22
                i_v12 = lex_get_save(i_a1, i_a3);
                i_v9 = i_v12;
            }
        }
    }
    case 69: {
    }
    case 101: {
        int32_t i_v13 = i_v9; // 0x24e3c
        if ((i_v9 || 32) == 101) {
            int32_t i_v14 = lex_get_save(i_a1, i_a3); // 0x24e48
            int32_t i_v15 = i_v14;                    // 0x24ca0
            switch (i_v14) {
            case 45: {
            }
            case 43: {
                // 0x24e5a
                i_v15 = lex_get_save(i_a1, i_a3);
                // break -> 0x24e64
                break;
            }
            }
            // 0x24e64
            if (i_v15 >= 58) {
                // 0x24e70
                lex_unget_unsave(i_a1, i_v15);
                // 0x24ee8
                return -1;
            }
            int32_t i_v16 = lex_get_save(i_a1, i_a3); // 0x24e7e
            i_v13 = i_v16;
            if (i_v16 < 58) {
                int32_t i_v17 = lex_get_save(i_a1, i_a3); // 0x24e8a
                i_v13 = i_v17;
                while (i_v17 < 58) {
                    // 0x24e86
                    i_v17 = lex_get_save(i_a1, i_a3);
                    i_v13 = i_v17;
                }
            }
        }
        // 0x24e9c
        lex_unget_unsave(i_a1, i_v13);
        int64_t i_v18; // bp-40, 0x24ca0
        int32_t i_v19 = jsonp_strtod(i_a1 + 40, (int32_t *)&i_v18); // 0x24eb2
        int32_t i_v20;                                              // 0x24ca0
        if (i_v19 == 0) {
            // 0x24ece
            *p_v1 = 258;
            uint64_t i_v21 = 0x100000000 * i_v18 >> 32; // 0x24ed6
            *(int32_t *)(i_a1 + 56) = (int32_t)(i_v21 / 0x100000000);
            *(int32_t *)(i_a1 + 60) = (int32_t)i_v21;
            i_v20 = 0;
        } else {
            // 0x24ebc
            error_set(i_a3, i_a1, "real number overflow", i_v19);
            i_v20 = -1;
        }
        // 0x24ee8
        return i_v20;
    }
    default: {
        // 0x24d38
        lex_unget_unsave(i_a1, i_v3);
        int32_t i_v22 = strbuffer_value((int32_t *)(i_a1 + 40)); // 0x24d46
        *__errno_location() = 0;
        int32_t i_v23; // bp-28, 0x24ca0
        uint64_t i_v24 = strtoll((char *)i_v22, (char **)&i_v23, 10); // 0x24d60
        if (*__errno_location() == 34) {
            int32_t i_v25 = i_v24; // 0x24d74
            if (i_v24 % 2 == 0) {
                // 0x24d92
                error_set(i_a3, i_a1, "too big integer", i_v25);
            } else {
                // 0x24d80
                error_set(i_a3, i_a1, "too big negative integer", i_v25);
            }
            // 0x24ee8
            return -1;
        }
        // 0x24da4
        if (*(int32_t *)(i_a1 + 44) + i_v22 != i_v23) {
            // 0x24db2
            __assert_fail("end == saved_text + lex->saved_text.length",
                          "3rdparty/jansson-2.6/src/load.c", 518,
                          "lex_scan_number");
        }
        // 0x24dd2
        *p_v1 = 257;
        uint64_t i_v26 = 0x100000000 * i_v24 / 0x100000000; // 0x24ddc
        *(int32_t *)(i_a1 + 56) = (int32_t)(i_v26 / 0x100000000);
        *(int32_t *)(i_a1 + 60) = (int32_t)i_v26;
        // 0x24ee8
        return 0;
    }
    }
}

// Address range: 0x24ef4 - 0x250b2
int32_t lex_scan(int32_t i_a1, int32_t i_a2) {
    int32_t i_v1 = i_a1 + 40; // 0x24f00
    strbuffer_clear(i_v1);
    int32_t *p_v2 = (int32_t *)(i_a1 + 52); // 0x24f0a
    if (*p_v2 == 256) {
        int32_t *p_v3 = (int32_t *)(i_a1 + 56); // 0x24f14
        jsonp_free(*p_v3);
        *p_v3 = 0;
    }
    int32_t i_v4 = lex_get(i_a1, i_a2); // 0x24f2c
    int32_t i_v5;                       // 0x24ef4
    while (true) {
    lab_0x24f38:
        // 0x24f38
        i_v5 = i_v4;
        switch (i_v5) {
        case 32: {
            // 0x24f2e
            i_v4 = lex_get(i_a1, i_a2);
            goto lab_0x24f38;
        }
        case 13: {
            // 0x24f2e
            i_v4 = lex_get(i_a1, i_a2);
            goto lab_0x24f38;
        }
        case 10: {
            // 0x24f2e
            i_v4 = lex_get(i_a1, i_a2);
            goto lab_0x24f38;
        }
        case 9: {
            // 0x24f2e
            i_v4 = lex_get(i_a1, i_a2);
            goto lab_0x24f38;
        }
        case -1: {
            // 0x24f58
            *p_v2 = 0;
            // 0x250a4
            return *p_v2;
        }
        case -2: {
            // 0x24f68
            *p_v2 = -1;
            // 0x250a4
            return *p_v2;
        }
        default: {
            goto lab_0x24f72;
        }
        }
    }
lab_0x24f72:
    // 0x24f72
    lex_save(i_a1, i_v5);
    switch (i_v5) {
    case 125: {
    }
    case 123: {
    }
    case 93: {
    }
    case 91: {
    }
    case 58: {
    }
    case 44: {
        // 0x24f9e
        *p_v2 = i_v5;
        // 0x250a4
        return *p_v2;
    }
    case 34: {
        // 0x24fac
        lex_scan_string(i_a1, i_a2);
        // 0x250a4
        return *p_v2;
    }
    }
    if (i_v5 == 45 || i_v5 < 58) {
        // 0x24fc8
        lex_scan_number(i_a1, i_v5, i_a2);
        // 0x250a4
        return *p_v2;
    }
    if (i_v5 > 90 == i_v5 > 122) {
        // 0x25096
        lex_save_cached(i_a1);
        *p_v2 = -1;
        // 0x250a4
        return *p_v2;
    }
    int32_t i_v6 = lex_get_save(i_a1, i_a2); // 0x24ff4
    int32_t i_v7 = i_v6;                     // 0x2500a
    if ((i_v6 & -33) < 91) {
        int32_t i_v8 = lex_get_save(i_a1, i_a2); // 0x25000
        i_v7 = i_v8;
        while ((i_v8 & -33) < 91) {
            // 0x24ffc
            i_v8 = lex_get_save(i_a1, i_a2);
            i_v7 = i_v8;
        }
    }
    // 0x2501e
    lex_unget_unsave(i_a1, i_v7);
    char *p_v9 = (char *)strbuffer_value((int32_t *)i_v1); // 0x25030
    if (strcmp(p_v9, "true") == 0) {
        // 0x25046
        *p_v2 = 259;
        // 0x250a4
        return *p_v2;
    }
    // 0x25050
    if (strcmp(p_v9, "false") == 0) {
        // 0x25064
        *p_v2 = 260;
        // 0x250a4
        return *p_v2;
    }
    // 0x2506e
    if (strcmp(p_v9, "null") == 0) {
        // 0x25082
        *p_v2 = 261;
    } else {
        // 0x2508c
        *p_v2 = -1;
    }
    // 0x250a4
    return *p_v2;
}

// Address range: 0x250b4 - 0x250e4
int32_t lex_steal_string(int32_t i_a1) {
    int32_t i_v1 = 0; // 0x250c8
    if (*(int32_t *)(i_a1 + 52) == 256) {
        int32_t *p_v2 = (int32_t *)(i_a1 + 56); // 0x250cc
        i_v1 = *p_v2;
        *p_v2 = 0;
    }
    // 0x250d6
    return i_v1;
}

// Address range: 0x250e4 - 0x25126
int32_t lex_init(int32_t *p_a1, int32_t i_a2, int32_t *p_a3) {
    int32_t i_v1 = (int32_t)p_a1;
    stream_init(i_v1, i_a2, (int32_t)p_a3);
    int32_t i_v2 = -1; // 0x2510a
    if (strbuffer_init((int32_t *)(i_v1 + 40)) == 0) {
        // 0x25112
        *(int32_t *)(i_v1 + 52) = -1;
        i_v2 = 0;
    }
    // 0x2511c
    return i_v2;
}

// Address range: 0x25128 - 0x25156
int32_t lex_close(int32_t *p_a1) {
    int32_t i_v1 = (int32_t)p_a1;
    if (*(int32_t *)(i_v1 + 52) == 256) {
        // 0x2513a
        jsonp_free(*(int32_t *)(i_v1 + 56));
    }
    // 0x25144
    return strbuffer_close((int32_t *)(i_v1 + 40));
}

// Address range: 0x25158 - 0x252a6
int32_t parse_object(int32_t i_a1, uint32_t i_a2, int32_t i_a3) {
    int32_t i_v1 = json_object(); // 0x25164
    if (i_v1 == 0) {
        // 0x2529c
        return 0;
    }
    // 0x25174
    lex_scan(i_a1, i_a3);
    int32_t *p_v2 = (int32_t *)(i_a1 + 52); // 0x2517e
    int32_t i_v3 = *p_v2;
    int32_t i_v4 = i_v3; // 0x25158
    int32_t i_v5 = i_v1; // 0x25158
    switch (i_v3) {
    case 125: {
        return i_v5;
    }
    case 256: {
        int32_t i_v6 = lex_steal_string(i_a1); // 0x251a6
        i_v5 = 0;
        while (i_v6 != 0) {
            if (i_a2 % 2 != 0) {
                int32_t i_v7 = json_object_get(i_v1, (char *)i_v6); // 0x251c4
                if (i_v7 != 0) {
                    // 0x251ce
                    jsonp_free(i_v6);
                    error_set(i_a3, i_a1, "duplicate object key", i_v7);
                    goto lab_0x25294;
                }
            }
            // 0x251e6
            lex_scan(i_a1, i_a3);
            int32_t i_v8 = *p_v2; // 0x251f0
            if (i_v8 != 58) {
                // 0x251f6
                jsonp_free(i_v6);
                error_set(i_a3, i_a1, "':' expected", i_v8);
                goto lab_0x25294;
            }
            // 0x2520e
            lex_scan(i_a1, i_a3);
            int32_t i_v9 = parse_value(i_a1, i_a2, i_a3); // 0x2521c
            if (i_v9 == 0) {
                // 0x25228
                jsonp_free(i_v6);
                goto lab_0x25294;
            }
            // 0x25230
            if (json_object_set_nocheck(i_v1, i_v6, i_v9) != 0) {
                // 0x25240
                jsonp_free(i_v6);
                json_decref3(i_v9);
                goto lab_0x25294;
            }
            // 0x2524e
            json_decref3(i_v9);
            jsonp_free(i_v6);
            int32_t i_v10 = lex_scan(i_a1, i_a3); // 0x2525e
            int32_t i_v11 = *p_v2;                // 0x25264
            if (i_v11 != 44) {
                // 0x25274
                __asm_nop(i_v10, i_a3, i_v9, i_v11);
                int32_t i_v12 = *p_v2; // 0x25278
                i_v5 = i_v1;
                if (i_v12 == 125) {
                    return i_v5;
                } else {
                    // 0x2527e
                    error_set(i_a3, i_a1, "'}' expected", i_v12);
                    goto lab_0x25294;
                }
            }
            // 0x2526a
            lex_scan(i_a1, i_a3);
            int32_t i_v13 = *p_v2;
            i_v4 = i_v13;
            if (i_v13 != 256) {
                goto lab_0x25192;
            }
            i_v6 = lex_steal_string(i_a1);
            i_v5 = 0;
        }
    lab_0x2529c:
        // 0x2529c
        return i_v5;
    }
    default: {
        goto lab_0x25192;
    }
    }
lab_0x25192:
    // 0x25192
    error_set(i_a3, i_a1, "string or '}' expected", i_v4);
lab_0x25294:
    // 0x25294
    json_decref3(i_v1);
    // 0x2529c
    return 0;
}

// Address range: 0x252a8 - 0x25360
int32_t parse_array(int32_t i_a1, int32_t i_a2, int32_t i_a3) {
    int32_t i_v1 = json_array(); // 0x252b4
    if (i_v1 == 0) {
        // 0x25356
        return 0;
    }
    int32_t i_v2 = lex_scan(i_a1, i_a3);    // 0x252c8
    int32_t *p_v3 = (int32_t *)(i_a1 + 52); // 0x252ce
    int32_t i_v4 = *p_v3;                   // 0x252ce
    if (i_v4 == 93) {
        // 0x25356
        return i_v1;
    }
    // 0x25320
    __asm_nop(i_v2, i_a3, i_a3, i_v4);
    int32_t i_v5 = 0; // 0x25328
    int32_t i_v6;     // 0x252a8
    if (*p_v3 == 0) {
        goto lab_0x25336;
    lab_0x25336:
        // 0x25336
        error_set(i_a3, i_a1, "']' expected", i_v5);
        // 0x2534e
        json_decref3(i_v1);
        i_v6 = 0;
    lab_0x25356:
        // 0x25356
        return i_v6;
    }
    int32_t i_v7 = parse_value(i_a1, i_a2, i_a3); // 0x252de
    while (i_v7 != 0) {
        int32_t i_v8 = json_array_append(i_v1, i_v7); // 0x252ee
        json_decref3(i_v7);
        if (i_v8 != 0) {
            goto lab_0x2534e;
        }
        int32_t i_v9 = lex_scan(i_a1, i_a3); // 0x2530a
        int32_t i_v10 = *p_v3;               // 0x25310
        if (i_v10 != 44) {
            // 0x2532e
            __asm_nop(i_v9, i_a3, i_a3, i_v10);
            int32_t i_v11 = *p_v3;
            i_v5 = i_v11;
            i_v6 = i_v1;
            if (i_v11 == 93) {
                return i_v6;
            } else {
                goto lab_0x25336;
            }
        }
        // 0x25316
        lex_scan(i_a1, i_a3);
        i_v5 = 0;
        if (*p_v3 == 0) {
            goto lab_0x25336;
        }
        i_v7 = parse_value(i_a1, i_a2, i_a3);
    }
    // 0x2534c
    __asm_nop(0, i_a2, i_a3, 0);
lab_0x2534e:
    // 0x2534e
    json_decref3(i_v1);
    // 0x25356
    return 0;
}

// Address range: 0x25360 - 0x254a6
int32_t parse_value(int32_t i_a1, int32_t i_a2, int32_t i_a3) {
    int32_t i_v1 = *(int32_t *)(i_a1 + 52); // 0x2536e
    if (i_v1 == 257) {
        if ((i_a2 & 8) == 0) {
            uint64_t i_v2 = *(int64_t *)(i_a1 + 56); // 0x25412
            // 0x2549c
            return json_integer((int32_t)(i_v2 / 0x100000000), (int32_t)i_v2);
        }
        // 0x253d4
        int32_t i_v3;                                  // bp-24, 0x25360
        int32_t i_v4 = jsonp_strtod(i_a1 + 40, &i_v3); // 0x253e2
        if (i_v4 == 0) {
            // 0x25400
            __asm_vldr_70(i_v3);
            return 0;
        }
        // 0x253ec
        error_set(i_a3, i_a1, "real number overflow", i_v4);
        // 0x2549c
        return 0;
    }
    if (i_v1 > 257) {
        if (i_v1 == 259) {
            // 0x2549c
            return json_true();
        }
        if (i_v1 < 259) {
            // 0x25422
            __asm_vldr_70(*(int32_t *)(i_a1 + 56));
            return i_a1;
        }
        switch (i_v1) {
        case 260: {
            // 0x2549c
            return json_false();
        }
        case 261: {
            // 0x2549c
            return json_null();
        }
        }
        // 0x2547c
        error_set(i_a3, i_a1, "unexpected token", i_v1);
        // 0x2549c
        return 0;
    }
    if (i_v1 == 91) {
        // 0x2549c
        return parse_array(i_a1, i_a2, i_a3);
    }
    if (i_v1 > 91) {
        switch (i_v1) {
        case 123: {
            // 0x2549c
            return parse_object(i_a1, i_a2, i_a3);
        }
        case 256: {
            // 0x2549c
            return json_string_nocheck(*(int32_t *)(i_a1 + 56));
        }
        }
        // 0x2547c
        error_set(i_a3, i_a1, "unexpected token", i_v1);
        // 0x2549c
        return 0;
    }
    if (i_v1 == -1) {
        // 0x25468
        error_set(i_a3, i_a1, "invalid token", -1);
        // 0x2549c
        return 0;
    }
    // 0x2547c
    error_set(i_a3, i_a1, "unexpected token", i_v1);
    // 0x2549c
    return 0;
}

// Address range: 0x254a8 - 0x25550
int32_t parse_json(int32_t *p_a1, int32_t i_a2, int32_t i_a3) {
    int32_t i_v1 = (int32_t)p_a1;
    lex_scan(i_v1, i_a3);
    if ((i_a2 & 4) == 0) {
        int32_t i_v2 = *(int32_t *)(i_v1 + 52); // 0x254c8
        switch (i_v2) {
        case 91: {
            goto lab_0x254ea;
        }
        case 123: {
            goto lab_0x254ea;
        }
        default: {
            // 0x254d6
            error_set(i_a3, i_v1, "'[' or '{' expected", i_v2);
            // 0x25546
            return 0;
        }
        }
    } else {
        goto lab_0x254ea;
    }
lab_0x254ea:;
    int32_t i_v3 = parse_value(i_v1, i_a2, i_a3); // 0x254f0
    if (i_v3 == 0) {
        // 0x25546
        return 0;
    }
    if ((i_a2 & 2) == 0) {
        // 0x2550a
        lex_scan(i_v1, i_a3);
        int32_t i_v4 = *(int32_t *)(i_v1 + 52); // 0x25514
        if (i_v4 != 0) {
            // 0x2551a
            error_set(i_a3, i_v1, "end of file expected", i_v4);
            json_decref3(i_v3);
            // 0x25546
            return 0;
        }
    }
    // 0x25534
    if (i_a3 != 0) {
        // 0x2553a
        *(int32_t *)(i_a3 + 8) = *(int32_t *)(i_v1 + 36);
    }
    // 0x25546
    return i_v3;
}

// Address range: 0x25550 - 0x2558e
int32_t string_get(int32_t i_a1) {
    int32_t *p_v1 = (int32_t *)(i_a1 + 4);       // 0x25562
    int32_t i_v2 = *p_v1;                        // 0x25562
    unsigned char i_v3 = *(char *)(i_v2 + i_a1); // 0x25566
    int32_t i_v4 = -1;                           // 0x2556e
    if (i_v3 != 0) {
        // 0x25576
        *p_v1 = i_v2 + 1;
        i_v4 = i_v3;
    }
    // 0x25582
    return i_v4;
}

// Address range: 0x25590 - 0x25614
int32_t json_loads(int32_t i_a1, int32_t i_a2, int32_t i_a3) {
    // 0x25590
    jsonp_error_init(i_a3, "<string>");
    if (i_a1 == 0) {
        // 0x255b0
        error_set(i_a3, 0, "wrong arguments", 0);
        // 0x2560a
        return 0;
    }
    int32_t i_v1 = i_a1;                            // bp-88, 0x255c6
    int32_t i_v2;                                   // bp-80, 0x25590
    int32_t i_v3 = lex_init(&i_v2, 0x25551, &i_v1); // 0x255e0
    int32_t i_v4 = 0;                               // 0x255e8
    if (i_v3 == 0) {
        // 0x255ee
        i_v4 = parse_json(&i_v2, i_a2, i_a3);
        lex_close(&i_v2);
    }
    // 0x2560a
    return i_v4;
}

// Address range: 0x25614 - 0x25658
int32_t buffer_get(int32_t i_a1) {
    int32_t *p_v1 = (int32_t *)(i_a1 + 8); // 0x25622
    uint32_t i_v2 = *p_v1;                 // 0x25622
    int32_t i_v3 = -1;                     // 0x2562a
    if (i_v2 < *(int32_t *)(i_a1 + 4)) {
        // 0x25632
        *p_v1 = i_v2 + 1;
        i_v3 = (int32_t) * (char *)(i_v2 + i_a1);
    }
    // 0x2564c
    return i_v3;
}

// Address range: 0x25658 - 0x256e2
int32_t json_loadb(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    // 0x25658
    jsonp_error_init(i_a4, "<buffer>");
    if (i_a1 == 0) {
        // 0x2567a
        error_set(i_a4, 0, "wrong arguments", 0);
        // 0x256d8
        return 0;
    }
    int32_t i_v1 = i_a1;                            // bp-92, 0x25690
    int32_t i_v2;                                   // bp-80, 0x25658
    int32_t i_v3 = lex_init(&i_v2, 0x25615, &i_v1); // 0x256ae
    int32_t i_v4 = 0;                               // 0x256b6
    if (i_v3 == 0) {
        // 0x256bc
        i_v4 = parse_json(&i_v2, i_a3, i_a4);
        lex_close(&i_v2);
    }
    // 0x256d8
    return i_v4;
}

// Address range: 0x256e4 - 0x2577c
int32_t json_loadf(int32_t i_a1, int32_t i_a2, int32_t i_a3) {
    // 0x256e4
    jsonp_error_init(i_a3, i_g182 == i_a1 ? "<stdin>" : "<stream>");
    if (i_a1 == 0) {
        // 0x25724
        error_set(i_a3, 0, "wrong arguments", 0);
        // 0x25772
        return 0;
    }
    // 0x25738
    int32_t i_v1;                                            // bp-80, 0x256e4
    int32_t i_v2 = lex_init(&i_v1, 0x8e98, (int32_t *)i_a1); // 0x25748
    int32_t i_v3 = 0;                                        // 0x25750
    if (i_v2 == 0) {
        // 0x25756
        i_v3 = parse_json(&i_v1, i_a2, i_a3);
        lex_close(&i_v1);
    }
    // 0x25772
    return i_v3;
}

// Address range: 0x2577c - 0x25806
int32_t json_load_file(int32_t i_a1, int32_t i_a2, int32_t *p_a3) {
    int32_t i_v1 = (int32_t)p_a3;
    char *p_v2 = (char *)i_a1; // 0x2578c
    jsonp_error_init(i_v1, p_v2);
    if (i_a1 == 0) {
        // 0x25796
        error_set(i_v1, 0, "wrong arguments", 0);
        // 0x257fc
        return 0;
    }
    struct _IO_FILE *p_v3 = fopen(p_v2, "rb"); // 0x257b4
    int32_t i_v4;                              // 0x2577c
    if (p_v3 == NULL) {
        // 0x257c0
        strerror(*__errno_location());
        error_set(i_v1, 0, "unable to open %s: %s", i_a1);
        i_v4 = 0;
    } else {
        int32_t i_v5 = json_loadf((int32_t)p_v3, i_a2, i_v1); // 0x257ee
        fclose(p_v3);
        i_v4 = i_v5;
    }
    // 0x257fc
    return i_v4;
}

// Address range: 0x25808 - 0x2588c
int32_t callback_get(int32_t i_a1) {
    int32_t *p_v1 = (int32_t *)(i_a1 + 1028); // 0x25816
    uint32_t i_v2 = *p_v1;                    // 0x25816
    int32_t *p_v3 = (int32_t *)(i_a1 + 1024); // 0x2581c
    int32_t i_v4 = i_v2;                      // 0x25822
    if (i_v2 >= *p_v3) {
        // 0x25824
        *p_v1 = 0;
        *p_v3 = i_a1;
        switch (i_a1) {
        case 0: {
        }
        case -1: {
            // 0x25882
            return -1;
        }
        }
        // 0x25824
        i_v4 = *p_v1;
    }
    // 0x25866
    *p_v1 = i_v4 + 1;
    // 0x25882
    return (int32_t) * (char *)(i_v4 + i_a1);
}

// Address range: 0x2588c - 0x25958
int32_t json_load_callback(int32_t i_a1, int32_t i_a2, int32_t i_a3,
                           int32_t i_a4) {
    int32_t i_v1 = i_a4; // bp-1144, 0x258a6
    int32_t i_v2;        // bp-1128, 0x2588c
    memset(&i_v2, 0, 1040);
    jsonp_error_init(i_a4, "<callback>");
    if (i_a1 == 0) {
        // 0x258ee
        error_set(i_a4, 0, "wrong arguments", (int32_t)&i_v1);
        // 0x2594a
        return 0;
    }
    // 0x25904
    int32_t i_v3;                                   // bp-88, 0x2588c
    int32_t i_v4 = lex_init(&i_v3, 0x25809, &i_v2); // 0x25918
    int32_t i_v5 = 0;                               // 0x25920
    if (i_v4 == 0) {
        // 0x25926
        i_v5 = parse_json(&i_v3, i_a3, i_v1);
        lex_close(&i_v3);
    }
    // 0x2594a
    return i_v5;
}

// Address range: 0x25958 - 0x25984
int32_t jsonp_malloc(int32_t i_a1) {
    int32_t i_v1 = 0; // 0x25964
    if (i_a1 != 0) {
        // 0x2596a
        i_v1 = (int32_t)malloc(i_a1);
    }
    // 0x2597a
    return i_v1;
}

// Address range: 0x25984 - 0x259ac
int32_t jsonp_free(int32_t i_a1) {
    // 0x25984
    int32_t i_v1; // 0x25984
    if (i_a1 == 0) {
        // 0x259a2
        int32_t i_v2; // 0x25984
        i_v1 = __asm_nop(0, i_v2, i_v2, 0);
    } else {
        // 0x25992
        free((int32_t *)i_a1);
        i_v1 = &i_g309;
    }
    // 0x259a4
    return i_v1;
}

// Address range: 0x259ac - 0x259f8
int32_t jsonp_strdup(int32_t i_a1) {
    int32_t i_v1 = strlen((char *)i_a1); // 0x259b6
    if (i_v1 == -1) {
        // 0x259ee
        return 0;
    }
    int32_t i_v2 = i_v1 + 1; // 0x259ca
    jsonp_malloc(i_v2);
    int32_t i_v3 = 0; // 0x259d8
    if (i_v3 != 0) {
        // 0x259de
        memcpy((int32_t *)i_v3, (int32_t *)i_a1, i_v2);
    }
    // 0x259ee
    return i_v3;
}

// Address range: 0x259f8 - 0x25a24
int32_t json_set_alloc_funcs(int32_t i_a1, int32_t i_a2) {
    // 0x259f8
    i_g177 = i_a1;
    i_g178 = i_a2;
    return i_a1;
}

// Address range: 0x25a24 - 0x25a6a
int32_t strbuffer_init(int32_t *p_a1) {
    int32_t i_v1 = (int32_t)p_a1;
    int32_t *p_v2 = (int32_t *)(i_v1 + 8); // 0x25a30
    *p_v2 = 16;
    *(int32_t *)(i_v1 + 4) = 0;
    int32_t i_v3 = jsonp_malloc(*p_v2); // 0x25a3e
    *p_a1 = i_v3;
    int32_t i_v4 = -1; // 0x25a4e
    if (i_v3 != 0) {
        // 0x25a56
        *(char *)i_v3 = 0;
        i_v4 = 0;
    }
    // 0x25a60
    return i_v4;
}

// Address range: 0x25a6c - 0x25aa0
int32_t strbuffer_close(int32_t *p_a1) {
    int32_t i_v1 = (int32_t)p_a1;
    int32_t i_v2 = i_v1; // 0x25a7a
    if (p_a1 != NULL) {
        // 0x25a7c
        i_v2 = jsonp_free(i_v1);
    }
    // 0x25a86
    *(int32_t *)(i_v1 + 8) = 0;
    *(int32_t *)(i_v1 + 4) = 0;
    *p_a1 = 0;
    return i_v2;
}

// Address range: 0x25aa0 - 0x25ac0
int32_t strbuffer_clear(int32_t i_a1) {
    // 0x25aa0
    *(int32_t *)(i_a1 + 4) = 0;
    *(char *)i_a1 = 0;
    return i_a1;
}

// Address range: 0x25ac0 - 0x25ad8
int32_t strbuffer_value(int32_t *p_a1) {
    // 0x25ac0
    return (int32_t)p_a1;
}

// Address range: 0x25ad8 - 0x25afa
int32_t strbuffer_steal_value(int32_t i_a1) {
    // 0x25ad8
    *(int32_t *)i_a1 = 0;
    return i_a1;
}

// Address range: 0x25afc - 0x25b24
int32_t strbuffer_append(int32_t i_a1, int32_t i_a2) {
    // 0x25afc
    return strbuffer_append_bytes(i_a1, i_a2, strlen((char *)i_a2));
}

// Address range: 0x25b24 - 0x25b48
int32_t strbuffer_append_byte(int32_t i_a1, int32_t i_a2) {
    int32_t i_v1 = 0x1000000 * i_a2 >> 24; // bp-13, 0x25b2e
    return strbuffer_append_bytes(i_a1, (int32_t)&i_v1, 1);
}

// Address range: 0x25b48 - 0x25c1c
int32_t strbuffer_append_bytes(int32_t i_a1, int32_t i_a2, uint32_t i_a3) {
    int32_t *p_v1 = (int32_t *)(i_a1 + 8); // 0x25b56
    int32_t i_v2 = *p_v1;                  // 0x25b56
    int32_t *p_v3 = (int32_t *)(i_a1 + 4); // 0x25b5a
    uint32_t i_v4 = *p_v3;                 // 0x25b5a
    uint32_t i_v5 = i_v2 - i_v4;           // 0x25b5c
    int32_t i_v6 = i_v4;                   // 0x25b62
    int32_t i_v7 = i_a1;                   // 0x25b62
    if (i_v5 >= i_a3 != i_v5 != i_a3) {
        // 0x25b64
        if (i_a3 == -1 || i_v2 < 0) {
            // 0x25c12
            return -1;
        }
        uint32_t i_v8 = -2 - i_a3; // 0x25b82
        if (i_v4 != i_v8 && i_v4 >= i_v8) {
            // 0x25c12
            return -1;
        }
        uint32_t i_v9 = i_a3 + 1 + i_v4; // 0x25b96
        uint32_t i_v10 = 2 * i_v2;       // 0x25b9c
        if (i_v9 >= i_v10) {
            __asm_it();
        }
        int32_t i_v11 = i_v9 >= i_v10 ? i_v9 : i_v10;
        int32_t i_v12 = jsonp_malloc(i_v11); // 0x25ba8
        if (i_v12 == 0) {
            // 0x25c12
            return -1;
        }
        int32_t *p_v13 = (int32_t *)i_v12; // 0x25bc8
        i_v7 = jsonp_free((int32_t)memcpy(p_v13, p_v13, *p_v3));
        *(int32_t *)i_a1 = i_v12;
        *p_v1 = i_v11;
        i_v6 = *p_v3;
    }
    int32_t *p_v14 =
        memcpy((int32_t *)(i_v7 + i_v6), (int32_t *)i_a2, i_a3); // 0x25bf2
    int32_t i_v15 = *p_v3 + i_a3;                                // 0x25bfc
    *p_v3 = i_v15;
    *(char *)(i_v15 + (int32_t)p_v14) = 0;
    // 0x25c12
    return 0;
}

// Address range: 0x25c1c - 0x25c64
int32_t strbuffer_pop(int32_t i_a1) {
    int32_t *p_v1 = (int32_t *)(i_a1 + 4); // 0x25c26
    int32_t i_v2 = *p_v1;                  // 0x25c26
    int32_t i_v3 = 0;                      // 0x25c2a
    if (i_v2 != 0) {
        int32_t i_v4 = i_v2 - 1; // 0x25c34
        *p_v1 = i_v4;
        char *p_v5 = (char *)(i_v4 + i_a1); // 0x25c40
        *p_v5 = 0;
        i_v3 = (int32_t)*p_v5;
    }
    // 0x25c58
    return i_v3;
}

// Address range: 0x25c64 - 0x25ca6
int32_t to_locale(int32_t i_a1) {
    struct lconv *p_v1 = localeconv();     // 0x25c6c
    char *p_v2 = (char *)*(int32_t *)p_v1; // 0x25c74
    if (*p_v2 == 46) {
        // 0x25c9e
        int32_t i_v3; // 0x25c64
        return __asm_nop((int32_t)p_v1, i_v3, i_v3, 46);
    }
    char *p_v4 = strchr((char *)p_v1, 46); // 0x25c86
    if (p_v4 != NULL) {
        // 0x25c92
        *p_v4 = *p_v2;
    }
    // 0x25c9e
    return (int32_t)p_v4;
}

// Address range: 0x25ca8 - 0x25ce8
int32_t from_locale(int32_t i_a1) {
    struct lconv *p_v1 = localeconv();              // 0x25cb0
    unsigned char i_v2 = *(char *)*(int32_t *)p_v1; // 0x25cbc
    int32_t i_v3 = i_v2;
    if (i_v2 == 46) {
        // 0x25ce0
        int32_t i_v4; // 0x25ca8
        return __asm_nop((int32_t)p_v1, i_v4, i_v4, i_v3);
    }
    char *p_v5 = strchr((char *)i_a1, i_v3); // 0x25cca
    if (p_v5 != NULL) {
        // 0x25cd6
        *p_v5 = 46;
    }
    // 0x25ce0
    return (int32_t)p_v5;
}

// Address range: 0x25ce8 - 0x25d7a
int32_t jsonp_strtod(int32_t i_a1, int32_t *p_a2) {
    // 0x25ce8
    to_locale(i_a1);
    int32_t *p_v1 = __errno_location(); // 0x25cf8
    *p_v1 = 0;
    int32_t i_v2;                                          // bp-20, 0x25ce8
    float64_t f_v3 = strtod((char *)p_v1, (char **)&i_v2); // 0x25d0e
    int64_t i_v4;                                          // 0x25ce8
    int32_t i_v5 = i_v4;                                   // 0x25d12
    float64_t f_v6;                                        // 0x25ce8
    __asm_vstr_71(f_v6, i_v5);
    if (*(int32_t *)(i_a1 + 4) + (int32_t)(float32_t)f_v3 != i_v2) {
        // 0x25d26
        __assert_fail("end == strbuffer->value + strbuffer->length",
                      "3rdparty/jansson-2.6/src/strconv.c", 70, "jsonp_strtod");
    }
    int32_t *p_v7 = __errno_location(); // 0x25d44
    if (*p_v7 == 34) {
        // 0x25d50
        __asm_vldr_70(i_v5);
        return (int32_t)p_v7;
    }
    uint64_t i_v8 = 0x100000000 * i_v4 >> 32; // 0x25d66
    *p_a2 = (int32_t)(i_v8 / 0x100000000);
    *(int32_t *)((int32_t)p_a2 + 4) = (int32_t)i_v8;
    return 0;
}

// Address range: 0x25d7c - 0x25e90
int32_t jsonp_dtostr(int32_t i_a1, uint32_t i_a2) {
    // 0x25d7c
    float64_t f_v1; // 0x25d7c
    __asm_vstr_71(f_v1, (int32_t)(float32_t)f_v1);
    char *p_v2 = (char *)i_a1;                          // 0x25d9e
    int32_t i_v3 = snprintf(p_v2, i_a2, "%.17g", f_v1); // 0x25d9e
    if (i_v3 > -1 != i_v3 < i_a2) {
        // 0x25e86
        return -1;
    }
    // 0x25dc2
    from_locale(i_a1);
    int32_t i_v4 = i_v3; // 0x25dd4
    int32_t i_v5 = i_v3; // 0x25dd4
    if (strchr(p_v2, 46) == NULL) {
        // 0x25dd6
        i_v4 = i_v3;
        i_v5 = i_v3;
        if (strchr(p_v2, 101) == NULL) {
            // 0x25de4
            if (i_v3 + 3 >= i_a2) {
                // 0x25e86
                return -1;
            }
            int32_t i_v6 = i_v3 + i_a1;
            *(char *)i_v6 = 46;
            *(char *)(i_v6 + 1) = 48;
            int32_t i_v7 = i_v3 + 2; // 0x25e0c
            *(char *)(i_v7 + i_a1) = 0;
            i_v4 = i_v7;
            i_v5 = 0;
        }
    }
    char *p_v8 = strchr(p_v2, 101); // 0x25e20
    if (p_v8 == NULL) {
        // 0x25e86
        return i_v4;
    }
    int32_t i_v9 = (int32_t)p_v8;         // 0x25e20
    int32_t i_v10 = i_v9 + 1;             // 0x25e2e
    int32_t i_v11 = i_v9 + 2;             // 0x25e34
    unsigned char i_v12 = *(char *)i_v10; // 0x25e3a
    __asm_nop(i_v9, 101, i_v5, i_v12 == 45 ? i_v11 : (int32_t)i_v12);
    int32_t i_v13 = i_v11; // 0x25e50
    while (*(char *)i_v13 == 48) {
        // 0x25e52
        i_v13++;
    }
    int32_t i_v14 = i_v12 == 45 ? i_v11 : i_v10;
    int32_t i_v15 = i_v4; // 0x25e60
    if (i_v14 != i_v13) {
        // 0x25e62
        memmove((int32_t *)i_v14, (int32_t *)i_v13, i_v4 + i_a1 - i_v13);
        i_v15 = i_v14 + i_v4 - i_v13;
    }
    // 0x25e86
    return i_v15;
}

// Address range: 0x25e90 - 0x25fba
int32_t utf8_encode(uint32_t i_a1, int32_t *p_a2, int32_t *p_a3) {
    // 0x25e90
    if (i_a1 < 0) {
        // 0x25fae
        return -1;
    }
    if (i_a1 <= 127) {
        // 0x25eae
        *(char *)p_a2 = (char)i_a1;
        *p_a3 = 1;
        // 0x25fae
        return 0;
    }
    int32_t i_v1 = (int32_t)p_a2;
    if (i_a1 <= 2047) {
        // 0x25ec8
        *(char *)p_a2 = (char)(i_a1 / 64) % 32 | -64;
        *(char *)(i_v1 + 1) = (char)i_a1 % 64 | -128;
        *p_a3 = 2;
        // 0x25fae
        return 0;
    }
    if (i_a1 <= 0xffff) {
        // 0x25f00
        *(char *)p_a2 = (char)(i_a1 / 0x1000) % 16 | -32;
        *(char *)(i_v1 + 1) = (char)(i_a1 / 64) % 64 | -128;
        *(char *)(i_v1 + 2) = (char)i_a1 % 64 | -128;
        *p_a3 = 3;
        // 0x25fae
        return 0;
    }
    int32_t i_v2 = -1; // 0x25f4e
    if (i_a1 <= (int32_t)&i_g3) {
        // 0x25f50
        *(char *)p_a2 = (char)((i_a1 & (int32_t)&i_g4) / 0x40000) - 16;
        *(char *)(i_v1 + 1) = (char)((i_a1 & (int32_t)&i_g203) / 0x1000) ^ -128;
        *(char *)(i_v1 + 2) = (char)(i_a1 / 64) % 64 | -128;
        *(char *)(i_v1 + 3) = (char)i_a1 % 64 | -128;
        *p_a3 = 4;
        i_v2 = 0;
    }
    // 0x25fae
    return i_v2;
}

// Address range: 0x25fbc - 0x26036
int32_t utf8_check_first(uint32_t i_a1) {
    uint32_t i_v1 = i_a1 % 256; // 0x25fc6
    if (__asm_sxtb(i_v1) >= 0) {
        // 0x2602a
        return 1;
    }
    unsigned char i_v2 = (char)i_a1; // 0x25fc8
    if (__asm_sxtb(i_v1) < 0) {
        // 0x25fde
        if (i_v2 >= 191 != i_v2 != -65) {
            // 0x2602a
            return 0;
        }
    }
    // 0x25fe8
    if ((i_v2 || 1) == -63) {
        // 0x2602a
        return 0;
    }
    if (i_v2 < 193) {
        // 0x2602a
        return 0;
    }
    // 0x25ffe
    if (i_v2 >= 223 != i_v2 != -33) {
        // 0x2602a
        return 2;
    }
    if (i_v2 != -33 && i_v2 >= 223) {
        // 0x2600e
        if (i_v2 >= 239 != i_v2 != -17) {
            // 0x2602a
            return 3;
        }
    }
    if (i_v2 == -17 || i_v2 < 239) {
        // 0x2602a
        return 0;
    }
    // 0x2601e
    if (i_v2 >= 244 != i_v2 != -12) {
        // 0x2602a
        return 4;
    }
    // 0x2602a
    return 0;
}

// Address range: 0x26038 - 0x26134
int32_t utf8_check_full(int32_t i_a1, uint32_t i_a2, int32_t i_a3) {
    // 0x26038
    int32_t i_v1; // 0x26038
    unsigned char i_v2 = (char)i_v1;
    int32_t i_v3 = 0; // 0x26038
    char i_v4;        // 0x26038
    switch (i_a2) {
    case 2: {
        // 0x26054
        i_v4 = i_v2 % 32;
        goto lab_0x26088;
    }
    case 3: {
        // 0x26064
        i_v4 = i_v2 % 16;
        goto lab_0x26088;
    }
    case 4: {
        // 0x26074
        i_v4 = i_v2 % 8;
        goto lab_0x26088;
    }
    default: {
        return i_v3;
    }
    }
lab_0x26088:;
    int32_t i_v5 = 1;                            // 0x26038
    int32_t i_v6 = i_v4;                         // 0x26038
    unsigned char i_v7 = *(char *)(i_v5 + i_a1); // 0x2608e
    i_v3 = 0;
    while (__asm_sxtb((int32_t)i_v7) < 0) {
        // 0x2609a
        i_v3 = 0;
        if (i_v7 != -65 && i_v7 >= 191) {
            // break -> 0x26128
            break;
        }
        int32_t i_v8 = i_v6;
        int32_t i_v9 = 64 * i_v8 | (int32_t)(i_v7 % 64); // 0x260ae
        int32_t i_v10 = i_v5 + 1;                        // 0x260b4
        i_v5 = i_v10;
        i_v6 = i_v9;
        if (i_v10 >= i_a2) {
            // 0x260c0
            i_v3 = 0;
            if ((i_v8 & 0x3ffffe0) == 864 || i_v9 > (int32_t)&i_g3) {
                return i_v3;
            } else {
                // 0x260ea
                i_v3 = 0;
                if (i_a2 == 2 == i_v9 < 128) {
                    return i_v3;
                } else {
                    // 0x260f6
                    i_v3 = 0;
                    if (i_a2 == 3 == i_v9 < 2048) {
                        return i_v3;
                    } else {
                        // 0x26106
                        i_v3 = 0;
                        if (i_a2 != 4 || i_v9 > 0xffff) {
                            // 0x2611a
                            i_v3 = 1;
                            if (i_a3 == 0) {
                                return i_v3;
                            } else {
                                // 0x26120
                                *(int32_t *)i_a3 = i_v9;
                                i_v3 = 1;
                                return i_v3;
                            }
                        } else {
                            return i_v3;
                        }
                    }
                }
            }
        }
        i_v7 = *(char *)(i_v5 + i_a1);
        i_v3 = 0;
    }
lab_0x26128:
    // 0x26128
    return i_v3;
}

// Address range: 0x26134 - 0x261a2
int32_t utf8_iterate(int32_t i_a1, int32_t *p_a2) {
    // 0x26134
    int32_t i_v1; // 0x26134
    uint32_t i_v2 = i_v1;
    if ((char)i_v2 == 0) {
        // 0x26198
        return i_a1;
    }
    int32_t i_v3 = i_v2 % 256;
    uint32_t i_v4 = utf8_check_first(i_v3); // 0x26150
    if (i_v4 <= 0) {
        // 0x26198
        return 0;
    }
    int32_t i_v5; // bp-16, 0x26134
    if (i_v4 == 1) {
        // 0x26166
        i_v5 = i_v3;
    } else {
        // 0x2616e
        if (utf8_check_full(i_a1, i_v4, (int32_t)&i_v5) == 0) {
            // 0x26198
            return 0;
        }
    }
    if (p_a2 != NULL) {
        // 0x2618c
        *p_a2 = i_v5;
    }
    // 0x26198
    return i_v4 + i_a1;
}

// Address range: 0x261a4 - 0x26234
int32_t utf8_check_string(int32_t i_a1, int32_t i_a2) {
    int32_t i_v1 = i_a2; // 0x261b4
    if (i_a2 == -1) {
        // 0x261b6
        i_v1 = strlen((char *)i_a1);
    }
    // 0x261c0
    if (i_v1 <= 0) {
        // 0x2622a
        return 1;
    }
    int32_t i_v2 = 0;
    int32_t i_v3 = i_v2 + i_a1;                                 // 0x261ca
    uint32_t i_v4 = utf8_check_first((int32_t) * (char *)i_v3); // 0x261d0
    int32_t i_v5 = 0;                                           // 0x261da
    while (i_v4 != 0) {
        int32_t i_v6 = i_v2; // 0x261e4
        if (i_v4 >= 2) {
            int32_t i_v7 = i_v4 + i_v2;
            i_v5 = 0;
            if (i_v7 > i_v1) {
                // break -> 0x2622a
                break;
            }
            // 0x261f6
            i_v5 = 0;
            if (utf8_check_full(i_v3, i_v4, 0) == 0) {
                // break -> 0x2622a
                break;
            }
            // 0x26210
            i_v6 = i_v7 - 1;
        }
        int32_t i_v8 = i_v6 + 1; // 0x2621c
        i_v5 = 1;
        if (i_v8 >= i_v1) {
            // break -> 0x2622a
            break;
        }
        i_v2 = i_v8;
        i_v3 = i_v2 + i_a1;
        i_v4 = utf8_check_first((int32_t) * (char *)i_v3);
        i_v5 = 0;
    }
    // 0x2622a
    return i_v5;
}

// Address range: 0x26234 - 0x26264
int32_t json_incref2(int32_t i_a1) {
    if (i_a1 == 0) {
        // 0x26256
        return i_a1;
    }
    int32_t *p_v1 = (int32_t *)(i_a1 + 4); // 0x26244
    int32_t i_v2 = *p_v1;                  // 0x26244
    if (i_v2 != -1) {
        // 0x2624c
        *p_v1 = i_v2 + 1;
    }
    // 0x26256
    return i_a1;
}

// Address range: 0x26264 - 0x2629c
int32_t json_decref4(int32_t i_a1) {
    // 0x26264
    if (i_a1 == 0) {
        // 0x26294
        return 0;
    }
    int32_t *p_v1 = (int32_t *)(i_a1 + 4); // 0x26274
    int32_t i_v2 = *p_v1;                  // 0x26274
    if (i_v2 == -1) {
        // 0x26294
        return i_a1;
    }
    int32_t i_v3 = i_v2 - 1; // 0x26280
    *p_v1 = i_v3;
    int32_t i_v4 = i_a1; // 0x2628c
    if (i_v3 == 0) {
        // 0x2628e
        i_v4 = json_delete(i_a1);
    }
    // 0x26294
    return i_v4;
}

// Address range: 0x2629c - 0x262c6
int32_t json_object_set_nocheck2(int32_t i_a1, int32_t i_a2, int32_t i_a3) {
    // 0x2629c
    return json_object_set_new_nocheck(i_a1, i_a2, json_incref2(i_a3));
}

// Address range: 0x262c8 - 0x262ee
int32_t json_array_append2(int32_t i_a1, int32_t i_a2) {
    // 0x262c8
    return json_array_append_new(i_a1, json_incref2(i_a2));
}

// Address range: 0x262f0 - 0x26310
int32_t json_init(int32_t i_a1, int32_t i_a2) {
    // 0x262f0
    *(int32_t *)i_a1 = i_a2;
    *(int32_t *)(i_a1 + 4) = 1;
    return i_a1;
}

// Address range: 0x26310 - 0x26364
int32_t json_object(void) {
    int32_t i_v1 = jsonp_malloc(36); // 0x26318
    if (i_v1 == 0) {
        // 0x2635a
        return 0;
    }
    // 0x26328
    json_init(i_v1, 0);
    int32_t i_v2; // 0x26310
    if (hashtable_init(i_v1 + 8) == 0) {
        // 0x2634c
        *(int32_t *)(i_v1 + 28) = 0;
        *(int32_t *)(i_v1 + 32) = 0;
        i_v2 = i_v1;
    } else {
        // 0x26342
        jsonp_free(i_v1);
        i_v2 = 0;
    }
    // 0x2635a
    return i_v2;
}

// Address range: 0x26364 - 0x26384
int32_t json_delete_object(int32_t i_a1) {
    // 0x26364
    hashtable_close(i_a1 + 8);
    return jsonp_free(i_a1);
}

// Address range: 0x26384 - 0x263b2
int32_t json_object_size(int32_t i_a1) {
    // 0x26384
    return 0;
}

// Address range: 0x263b4 - 0x263ec
int32_t json_object_get(int32_t i_a1, char *p_a2) {
    // 0x263b4
    return 0;
}

// Address range: 0x263ec - 0x2646a
int32_t json_object_set_new_nocheck(int32_t i_a1, int32_t i_a2, int32_t i_a3) {
    if (i_a3 != 0) {
        // 0x26420
        json_decref4(i_a3);
    }
    // 0x26460
    return -1;
}

// Address range: 0x2646c - 0x264b0
int32_t json_object_set_new(int32_t i_a1, int32_t i_a2, int32_t i_a3) {
    if (i_a2 == 0) {
        // 0x2648e
        json_decref4(i_a3);
        // 0x264a6
        return -1;
    }
    // 0x2647e
    if (utf8_check_string(i_a2, -1) != 0) {
        // 0x264a6
        return json_object_set_new_nocheck(i_a1, i_a2, i_a3);
    }
    // 0x2648e
    json_decref4(i_a3);
    // 0x264a6
    return -1;
}

// Address range: 0x264b0 - 0x264ea
int32_t json_object_del(int32_t i_a1, int32_t i_a2) {
    // 0x264b0
    return -1;
}

// Address range: 0x264ec - 0x26528
int32_t json_object_clear(int32_t i_a1) {
    // 0x264ec
    return -1;
}

// Address range: 0x26528 - 0x265be
int32_t json_object_update(int32_t i_a1, int32_t i_a2) {
    // 0x26528
    return -1;
}

// Address range: 0x265c0 - 0x26658
int32_t json_object_update_existing(int32_t i_a1, int32_t i_a2) {
    // 0x265c0
    return -1;
}

// Address range: 0x26658 - 0x266f0
int32_t json_object_update_missing(int32_t i_a1, int32_t i_a2) {
    // 0x26658
    return -1;
}

// Address range: 0x266f0 - 0x26724
int32_t json_object_iter(int32_t i_a1) {
    // 0x266f0
    return 0;
}

// Address range: 0x26724 - 0x26762
int32_t json_object_iter_at(int32_t i_a1, int32_t i_a2) {
    // 0x26724
    return 0;
}

// Address range: 0x26764 - 0x267a2
int32_t json_object_iter_next(int32_t i_a1, int32_t i_a2) {
    // 0x26764
    return 0;
}

// Address range: 0x267a4 - 0x267c8
int32_t json_object_iter_key(int32_t i_a1) {
    int32_t i_v1 = 0; // 0x267b0
    if (i_a1 != 0) {
        // 0x267b6
        i_v1 = hashtable_iter_key(i_a1);
    }
    // 0x267be
    return i_v1;
}

// Address range: 0x267c8 - 0x267ec
int32_t json_object_iter_value(int32_t i_a1) {
    int32_t i_v1 = 0; // 0x267d4
    if (i_a1 != 0) {
        // 0x267da
        i_v1 = hashtable_iter_value(i_a1);
    }
    // 0x267e2
    return i_v1;
}

// Address range: 0x267ec - 0x2682c
int32_t json_object_iter_set_new(int32_t i_a1, int32_t i_a2, int32_t i_a3) {
    // 0x267ec
    return -1;
}

// Address range: 0x2682c - 0x26850
int32_t json_object_key_to_iter(int32_t i_a1) {
    // 0x2682c
    return i_a1 == 0 ? 0 : i_a1 - 16;
}

// Address range: 0x26850 - 0x268e2
int32_t json_object_equal(int32_t i_a1, int32_t i_a2) {
    int32_t i_v1 = json_object_size(i_a1); // 0x2685c
    if (i_v1 != json_object_size(i_a2)) {
        // 0x268d8
        return 0;
    }
    int32_t i_v2 = json_object_iter_key(json_object_iter(i_a1)); // 0x2687c
    if (i_v2 == 0) {
        // 0x268d8
        return 1;
    }
    int32_t i_v3 = i_v2; // 0x268be
    int32_t i_v4 =
        json_object_iter_value(json_object_key_to_iter(i_v3)); // 0x268ca
    int32_t i_v5 = 1;                                          // 0x268d4
    while (i_v4 != 0) {
        int32_t i_v6 = json_object_get(i_a2, (char *)i_v3); // 0x26888
        i_v5 = 0;
        if (json_equal(i_v4, i_v6) == 0) {
            // break -> 0x268d8
            break;
        }
        int32_t i_v7 = json_object_key_to_iter(i_v3); // 0x268a2
        i_v3 = json_object_iter_key(json_object_iter_next(i_a1, i_v7));
        i_v5 = 1;
        if (i_v3 == 0) {
            // break -> 0x268d8
            break;
        }
        i_v4 = json_object_iter_value(json_object_key_to_iter(i_v3));
        i_v5 = 1;
    }
    // 0x268d8
    return i_v5;
}

// Address range: 0x268e4 - 0x2695a
int32_t json_object_copy(int32_t i_a1) {
    int32_t i_v1 = json_object(); // 0x268ec
    if (i_v1 == 0) {
        // 0x26950
        return i_v1;
    }
    int32_t i_v2 = json_object_iter_key(json_object_iter(i_a1)); // 0x26906
    if (i_v2 == 0) {
        // 0x26950
        return i_v1;
    }
    int32_t i_v3 = i_v2; // 0x26936
    int32_t i_v4 =
        json_object_iter_value(json_object_key_to_iter(i_v3)); // 0x26942
    while (i_v4 != 0) {
        // 0x2690e
        json_object_set_nocheck2(i_v1, i_v3, i_v4);
        int32_t i_v5 = json_object_key_to_iter(i_v3); // 0x2691a
        i_v3 = json_object_iter_key(json_object_iter_next(i_a1, i_v5));
        if (i_v3 == 0) {
            // break -> 0x26950
            break;
        }
        i_v4 = json_object_iter_value(json_object_key_to_iter(i_v3));
    }
    // 0x26950
    return i_v1;
}

// Address range: 0x2695c - 0x269bc
int32_t json_object_deep_copy(int32_t i_a1) {
    int32_t i_v1 = json_object(); // 0x26964
    if (i_v1 == 0) {
        // 0x269b2
        return i_v1;
    }
    int32_t i_v2 = json_object_iter(i_a1); // 0x26976
    if (i_v2 == 0) {
        // 0x269b2
        return i_v1;
    }
    int32_t i_v3 = i_v2;                         // 0x269ae
    int32_t i_v4 = json_object_iter_key(i_v3);   // 0x26980
    int32_t i_v5 = json_object_iter_value(i_v3); // 0x26988
    json_object_set_new_nocheck(i_v1, i_v4, json_deep_copy(i_v5));
    i_v3 = json_object_iter_next(i_a1, i_v3);
    while (i_v3 != 0) {
        // 0x2697e
        i_v4 = json_object_iter_key(i_v3);
        i_v5 = json_object_iter_value(i_v3);
        json_object_set_new_nocheck(i_v1, i_v4, json_deep_copy(i_v5));
        i_v3 = json_object_iter_next(i_a1, i_v3);
    }
    // 0x269b2
    return i_v1;
}

// Address range: 0x269bc - 0x26a20
int32_t json_array(void) {
    int32_t i_v1 = jsonp_malloc(24); // 0x269c4
    if (i_v1 == 0) {
        // 0x26a16
        return 0;
    }
    // 0x269d4
    json_init(i_v1, 1);
    *(int32_t *)(i_v1 + 12) = 0;
    *(int32_t *)(i_v1 + 8) = 8;
    int32_t i_v2 = jsonp_malloc(32); // 0x269f2
    *(int32_t *)(i_v1 + 16) = i_v2;
    int32_t i_v3; // 0x269bc
    if (i_v2 == 0) {
        // 0x26a04
        jsonp_free(i_v1);
        i_v3 = 0;
    } else {
        // 0x26a0e
        *(int32_t *)(i_v1 + 20) = 0;
        i_v3 = i_v1;
    }
    // 0x26a16
    return i_v3;
}

// Address range: 0x26a20 - 0x26a68
int32_t json_delete_array(int32_t i_a1) {
    int32_t *p_v1 = (int32_t *)(i_a1 + 12); // 0x26a48
    int32_t *p_v2 = (int32_t *)(i_a1 + 16);
    int32_t i_v3 = *p_v2;
    int32_t i_v4 = 0; // 0x26a4e
    if (*p_v1 == 0) {
        // 0x26a50
        jsonp_free(i_v3);
        return jsonp_free(i_a1);
    }
    json_decref4(*(int32_t *)(4 * i_v4 + i_v3));
    i_v4++;
    uint32_t i_v5 = *p_v1; // 0x26a48
    int32_t i_v6 = *p_v2;
    int32_t i_v7 = i_v6; // 0x26a4e
    while (i_v5 >= i_v4 == (i_v5 != i_v4)) {
        // 0x26a2e
        json_decref4(*(int32_t *)(4 * i_v4 + i_v6));
        i_v4++;
        i_v5 = *p_v1;
        i_v6 = *p_v2;
        i_v7 = i_v6;
    }
    // 0x26a50
    jsonp_free(i_v7);
    return jsonp_free(i_a1);
}

// Address range: 0x26a68 - 0x26a92
int32_t json_array_size(int32_t i_a1) {
    int32_t i_v1 = 0; // 0x26a74
    if (i_a1 == 1) {
        // 0x26a82
        i_v1 = *(int32_t *)13;
    }
    // 0x26a86
    return i_v1;
}

// Address range: 0x26a94 - 0x26ada
int32_t json_array_get(int32_t i_a1, uint32_t i_a2) {
    // 0x26a94
    if (i_a1 != 1) {
        // 0x26ace
        return 0;
    }
    uint32_t i_v1 = *(int32_t *)13; // 0x26ab6
    int32_t i_v2 = 0;               // 0x26abc
    if (i_v1 >= i_a2 == (i_v1 != i_a2)) {
        // 0x26ac2
        i_v2 = *(int32_t *)(*(int32_t *)17 + 4 * i_a2);
    }
    // 0x26ace
    return i_v2;
}

// Address range: 0x26adc - 0x26b5c
int32_t json_array_set_new(int32_t i_a1, uint32_t i_a2, int32_t i_a3) {
    // 0x26adc
    if (i_a3 == 0) {
        // 0x26b52
        return -1;
    }
    if (i_a1 != 1 || i_a1 == i_a3) {
        // 0x26b0a
        json_decref4(i_a3);
        // 0x26b52
        return -1;
    }
    uint32_t i_v1 = *(int32_t *)13; // 0x26b1c
    int32_t i_v2;                   // 0x26adc
    if (i_v1 >= i_a2 == (i_v1 != i_a2)) {
        int32_t i_v3 = 4 * i_a2; // 0x26b36
        json_decref4(*(int32_t *)(*(int32_t *)17 + i_v3));
        *(int32_t *)(*(int32_t *)17 + i_v3) = i_a3;
        i_v2 = 0;
    } else {
        // 0x26b24
        json_decref4(i_a3);
        i_v2 = -1;
    }
    // 0x26b52
    return i_v2;
}

// Address range: 0x26b5c - 0x26b94
int32_t array_move(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    int32_t i_v1 = *(int32_t *)(i_a1 + 16); // 0x26b6c
    return (int32_t)memmove((int32_t *)(i_v1 + 4 * i_a2),
                            (int32_t *)(i_v1 + 4 * i_a3), 4 * i_a4);
}

// Address range: 0x26b94 - 0x26bc8
int32_t array_copy(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4,
                   int32_t i_a5) {
    // 0x26b94
    return (int32_t)memcpy((int32_t *)(4 * i_a2 + i_a1),
                           (int32_t *)(4 * i_a4 + i_a3), 4 * i_a5);
}

// Address range: 0x26bc8 - 0x26c5c
int32_t json_array_grow(int32_t i_a1, int32_t i_a2, int32_t i_a3) {
    int32_t *p_v1 = (int32_t *)(i_a1 + 12); // 0x26bd6
    uint32_t i_v2 = *p_v1 + i_a2;           // 0x26bda
    int32_t *p_v3 = (int32_t *)(i_a1 + 8);  // 0x26bde
    uint32_t i_v4 = *p_v3;                  // 0x26bde
    int32_t *p_v5 = (int32_t *)(i_a1 + 16);
    int32_t i_v6 = *p_v5;
    if (i_v2 >= i_v4 != i_v2 != i_v4) {
        // 0x26c52
        return i_v6;
    }
    uint32_t i_v7 = 2 * i_v4;    // 0x26bf4
    uint32_t i_v8 = i_v4 + i_a2; // 0x26bfc
    if (i_v7 >= i_v8) {
        __asm_it();
    }
    int32_t i_v9 = i_v7 >= i_v8 ? i_v7 : i_v8;
    int32_t i_v10 = jsonp_malloc(4 * i_v9); // 0x26c0c
    if (i_v10 == 0) {
        // 0x26c52
        return 0;
    }
    // 0x26c1c
    *p_v3 = i_v9;
    *p_v5 = i_v10;
    int32_t i_v11 = i_v6; // 0x26c2c
    if (i_a3 != 0) {
        // 0x26c2e
        array_copy(i_v10, 0, i_v6, 0, *p_v1);
        jsonp_free(i_v6);
        i_v11 = *p_v5;
    }
    // 0x26c52
    return i_v11;
}

// Address range: 0x26c5c - 0x26cda
int32_t json_array_append_new(int32_t i_a1, int32_t i_a2) {
    // 0x26c5c
    if (i_a2 == 0) {
        // 0x26cd0
        return -1;
    }
    if (i_a1 != 1 || i_a1 == i_a2) {
        // 0x26c88
        json_decref4(i_a2);
        // 0x26cd0
        return -1;
    }
    // 0x26c94
    int32_t i_v1; // 0x26c5c
    if (json_array_grow(1, 1, 1) == 0) {
        // 0x26ca8
        json_decref4(i_a2);
        i_v1 = -1;
    } else {
        // 0x26cb4
        *(int32_t *)(4 * *(int32_t *)13 + *(int32_t *)17) = i_a2;
        *(int32_t *)13 = *(int32_t *)13 + 1;
        i_v1 = 0;
    }
    // 0x26cd0
    return i_v1;
}

// Address range: 0x26cdc - 0x26dcc
int32_t json_array_insert_new(int32_t i_a1, uint32_t i_a2, int32_t i_a3) {
    // 0x26cdc
    if (i_a3 == 0) {
        // 0x26dc2
        return -1;
    }
    if (i_a1 != 1 || i_a1 == i_a3 || *(int32_t *)13 < i_a2) {
        // 0x26d0a
        json_decref4(i_a3);
        // 0x26dc2
        return -1;
    }
    int32_t i_v1 = json_array_grow(1, 1, 0); // 0x26d36
    if (i_v1 == 0) {
        // 0x26d42
        json_decref4(i_a3);
        // 0x26dc2
        return -1;
    }
    int32_t i_v2 = *(int32_t *)17; // 0x26d50
    if (i_v2 == i_v1) {
        // 0x26d92
        array_move(1, i_a2 + 1, i_a2, *(int32_t *)13 - i_a2);
    } else {
        // 0x26d58
        array_copy(i_v2, 0, i_v1, 0, i_a2);
        array_copy(*(int32_t *)17, i_a2 + 1, i_v1, i_a2, *(int32_t *)13 - i_a2);
        jsonp_free(i_v1);
    }
    // 0x26da8
    *(int32_t *)(*(int32_t *)17 + 4 * i_a2) = i_a3;
    *(int32_t *)13 = *(int32_t *)13 + 1;
    // 0x26dc2
    return 0;
}

// Address range: 0x26dcc - 0x26e48
int32_t json_array_remove(int32_t i_a1, uint32_t i_a2) {
    // 0x26dcc
    if (i_a1 != 1) {
        // 0x26e3e
        return -1;
    }
    uint32_t i_v1 = *(int32_t *)13; // 0x26df0
    if (i_v1 >= i_a2 != i_v1 != i_a2) {
        // 0x26e3e
        return -1;
    }
    // 0x26dfe
    json_decref4(*(int32_t *)(*(int32_t *)17 + 4 * i_a2));
    int32_t i_v2 = *(int32_t *)13; // 0x26e12
    int32_t i_v3 = i_v2 - 1;
    int32_t i_v4 = i_v3; // 0x26e1a
    if (i_v3 != i_a2 && i_v3 >= i_a2) {
        // 0x26e1c
        array_move(1, i_a2, i_a2 + 1, i_v2 + -1 - i_a2);
        i_v4 = *(int32_t *)13 - 1;
    }
    // 0x26e32
    *(int32_t *)13 = i_v4;
    // 0x26e3e
    return 0;
}

// Address range: 0x26e48 - 0x26ea2
int32_t json_array_clear(int32_t i_a1) {
    // 0x26e48
    if (i_a1 != 1) {
        // 0x26e98
        return -1;
    }
    int32_t i_v1 = 0; // 0x26e8e
    if (*(int32_t *)13 == 0) {
        // 0x26e90
        *(int32_t *)13 = 0;
        // 0x26e98
        return 0;
    }
    json_decref4(*(int32_t *)(*(int32_t *)17 + 4 * i_v1));
    i_v1++;
    uint32_t i_v2 = *(int32_t *)13; // 0x26e88
    while (i_v2 >= i_v1 == (i_v2 != i_v1)) {
        // 0x26e6e
        json_decref4(*(int32_t *)(*(int32_t *)17 + 4 * i_v1));
        i_v1++;
        i_v2 = *(int32_t *)13;
    }
    // 0x26e90
    *(int32_t *)13 = 0;
    // 0x26e98
    return 0;
}

// Address range: 0x26ea4 - 0x26f52
int32_t json_array_extend(int32_t i_a1, int32_t i_a2) {
    // 0x26ea4
    if (i_a1 == 1 != (i_a2 == 1) ||
        json_array_grow(1, *(int32_t *)13, 1) == 0) {
        // 0x26f48
        return -1;
    }
    int32_t i_v1 = 0; // 0x26f18
    int32_t i_v2 = 0; // 0x26f18
    if (*(int32_t *)13 != 0) {
        json_incref2(*(int32_t *)(*(int32_t *)17 + 4 * i_v1));
        i_v1++;
        uint32_t i_v3 = *(int32_t *)13; // 0x26f12
        i_v2 = i_v3;
        while (i_v3 >= i_v1 == (i_v3 != i_v1)) {
            // 0x26ef8
            json_incref2(*(int32_t *)(*(int32_t *)17 + 4 * i_v1));
            i_v1++;
            i_v3 = *(int32_t *)13;
            i_v2 = i_v3;
        }
    }
    int32_t i_v4 = i_v2; // 0x26f20
    int32_t i_v5 = *(int32_t *)17;
    array_copy(i_v5, i_v4, i_v5, 0, i_v4);
    *(int32_t *)13 = 2 * *(int32_t *)13;
    // 0x26f48
    return 0;
}

// Address range: 0x26f54 - 0x26fbe
int32_t json_array_equal(int32_t i_a1, int32_t i_a2) {
    uint32_t i_v1 = json_array_size(i_a1); // 0x26f60
    if (json_array_size(i_a2) != i_v1) {
        // 0x26fb4
        return 0;
    }
    // 0x26faa
    if (i_v1 == 0) {
        // 0x26fb4
        return 1;
    }
    int32_t i_v2 = 0;                          // 0x26fb0
    int32_t i_v3 = json_array_get(i_a1, i_v2); // 0x26f82
    int32_t i_v4 = json_array_get(i_a2, i_v2); // 0x26f8c
    int32_t i_v5 = 0;                          // 0x26f9e
    while (json_equal(i_v3, i_v4) != 0) {
        // 0x26faa
        i_v2++;
        i_v5 = 1;
        if (i_v2 >= i_v1) {
            // break -> 0x26fb4
            break;
        }
        i_v3 = json_array_get(i_a1, i_v2);
        i_v4 = json_array_get(i_a2, i_v2);
        i_v5 = 0;
    }
    // 0x26fb4
    return i_v5;
}

// Address range: 0x26fc0 - 0x27010
int32_t json_array_copy(int32_t i_a1) {
    int32_t i_v1 = json_array(); // 0x26fc8
    if (i_v1 == 0) {
        // 0x27006
        return i_v1;
    }
    // 0x26ff6
    if (json_array_size(i_a1) == 0) {
        // 0x27006
        return i_v1;
    }
    int32_t i_v2 = 0; // 0x27002
    json_array_append2(i_v1, json_array_get(i_a1, i_v2));
    i_v2++;
    uint32_t i_v3 = json_array_size(i_a1); // 0x26ff8
    while (i_v3 >= i_v2 == (i_v3 != i_v2)) {
        // 0x26fde
        json_array_append2(i_v1, json_array_get(i_a1, i_v2));
        i_v2++;
        i_v3 = json_array_size(i_a1);
    }
    // 0x27006
    return i_v1;
}

// Address range: 0x27010 - 0x27068
int32_t json_array_deep_copy(int32_t i_a1) {
    int32_t i_v1 = json_array(); // 0x27018
    if (i_v1 == 0) {
        // 0x2705e
        return i_v1;
    }
    // 0x2704e
    if (json_array_size(i_a1) == 0) {
        // 0x2705e
        return i_v1;
    }
    int32_t i_v2 = 0;                          // 0x2705a
    int32_t i_v3 = json_array_get(i_a1, i_v2); // 0x27032
    json_array_append_new(i_v1, json_deep_copy(i_v3));
    i_v2++;
    uint32_t i_v4 = json_array_size(i_a1); // 0x27050
    while (i_v4 >= i_v2 == (i_v4 != i_v2)) {
        // 0x2702e
        i_v3 = json_array_get(i_a1, i_v2);
        json_array_append_new(i_v1, json_deep_copy(i_v3));
        i_v2++;
        i_v4 = json_array_size(i_a1);
    }
    // 0x2705e
    return i_v1;
}

// Address range: 0x27068 - 0x270c0
int32_t json_string_nocheck(int32_t i_a1) {
    // 0x27068
    if (i_a1 == 0) {
        // 0x270b6
        return 0;
    }
    int32_t i_v1 = jsonp_malloc(12); // 0x2707c
    if (i_v1 == 0) {
        // 0x270b6
        return 0;
    }
    // 0x2708c
    json_init(i_v1, 2);
    int32_t i_v2 = jsonp_strdup(i_a1); // 0x27098
    *(int32_t *)(i_v1 + 8) = i_v2;
    int32_t i_v3 = i_v1; // 0x270a8
    if (i_v2 == 0) {
        // 0x270aa
        jsonp_free(i_v1);
        i_v3 = 0;
    }
    // 0x270b6
    return i_v3;
}

// Address range: 0x270c0 - 0x270f4
int32_t json_string(int32_t i_a1) {
    // 0x270c0
    if (i_a1 == 0) {
        // 0x270ea
        return 0;
    }
    int32_t i_v1 = 0; // 0x270dc
    if (utf8_check_string(i_a1, -1) != 0) {
        // 0x270e2
        i_v1 = json_string_nocheck(i_a1);
    }
    // 0x270ea
    return i_v1;
}

// Address range: 0x270f4 - 0x2711e
int32_t json_string_value(int32_t i_a1) {
    int32_t i_v1 = 0; // 0x27100
    if (i_a1 == 2) {
        // 0x2710e
        i_v1 = *(int32_t *)10;
    }
    // 0x27112
    return i_v1;
}

// Address range: 0x27120 - 0x27178
int32_t json_string_set_nocheck(int32_t i_a1, int32_t i_a2) {
    // 0x27120
    if (i_a1 != 2 || i_a2 == 0) {
        // 0x2716e
        return -1;
    }
    int32_t i_v1 = jsonp_strdup(i_a2); // 0x27146
    int32_t i_v2 = -1;                 // 0x27150
    if (i_v1 != 0) {
        // 0x27158
        jsonp_free(*(int32_t *)10);
        *(int32_t *)10 = i_v1;
        i_v2 = 0;
    }
    // 0x2716e
    return i_v2;
}

// Address range: 0x27178 - 0x271b2
int32_t json_string_set(int32_t i_a1, int32_t i_a2) {
    // 0x27178
    if (i_a2 == 0) {
        // 0x271a8
        return -1;
    }
    int32_t i_v1 = -1; // 0x27196
    if (utf8_check_string(i_a2, -1) != 0) {
        // 0x2719e
        i_v1 = json_string_set_nocheck(i_a1, i_a2);
    }
    // 0x271a8
    return i_v1;
}

// Address range: 0x271b4 - 0x271d4
int32_t json_delete_string(int32_t i_a1) {
    // 0x271b4
    jsonp_free(*(int32_t *)(i_a1 + 8));
    return jsonp_free(i_a1);
}

// Address range: 0x271d4 - 0x2720c
int32_t json_string_equal(int32_t i_a1, int32_t i_a2) {
    int32_t i_v1 = json_string_value(i_a1); // 0x271e0
    int32_t i_v2 =
        strcmp((char *)i_v1, (char *)json_string_value(i_a2)); // 0x271f2
    if (i_v2 != 0) {
        __asm_ite();
    }
    return i_v2 == 0;
}

// Address range: 0x2720c - 0x2722e
int32_t json_string_copy(int32_t i_a1) {
    // 0x2720c
    return json_string_nocheck(json_string_value(i_a1));
}

// Address range: 0x27230 - 0x2726c
int32_t json_integer(int32_t i_a1, int32_t i_a2) {
    int32_t i_v1 = jsonp_malloc(16); // 0x2723c
    if (i_v1 != 0) {
        // 0x2724c
        json_init(i_v1, 3);
        *(int32_t *)(i_v1 + 8) = i_a1 >> 31;
        *(int32_t *)(i_v1 + 12) = i_a1;
    }
    // 0x27262
    return i_v1;
}

// Address range: 0x2726c - 0x272a0
int32_t json_integer_value(int32_t i_a1) {
    int32_t i_v1 = 0; // 0x27278
    if (i_a1 == 3) {
        // 0x2728c
        i_v1 = (int32_t)(*(int64_t *)11 / 0x100000000);
    }
    // 0x27292
    return i_v1;
}

// Address range: 0x272a0 - 0x272d8
int32_t json_integer_set(int32_t i_a1, int32_t i_a2, int32_t i_a3,
                         int32_t i_a4) {
    int32_t i_v1 = -1; // 0x272b0
    if (i_a1 == 3) {
        // 0x272c0
        *(int32_t *)11 = i_a3 >> 31;
        *(int32_t *)15 = i_a3;
        i_v1 = 0;
    }
    // 0x272cc
    return i_v1;
}

// Address range: 0x272d8 - 0x272ee
int32_t json_delete_integer(int32_t i_a1) {
    // 0x272d8
    return jsonp_free(i_a1);
}

// Address range: 0x272f0 - 0x27326
int32_t json_integer_equal(int32_t i_a1, int32_t i_a2) {
    int32_t i_v1 = json_integer_value(i_a1); // 0x272fc
    int32_t i_v2 = json_integer_value(i_a2); // 0x27306
    __asm_it();
    if (i_v1 != i_v2) {
        __asm_ite();
    }
    return i_v1 == i_v2;
}

// Address range: 0x27328 - 0x2734e
int32_t json_integer_copy(int32_t i_a1, int32_t i_a2) {
    // 0x27328
    return json_integer(json_integer_value(i_a1), i_a2);
}

// Address range: 0x27350 - 0x273ac
int32_t json_real(void) {
    // 0x27350
    int64_t i_v1;        // 0x27350
    int32_t i_v2 = i_v1; // 0x27356
    float64_t f_v3;      // 0x27350
    __asm_vstr_71(f_v3, i_v2);
    __asm_vldr_70(i_v2);
    int32_t i_v4; // 0x27350
    if (__isnan((float64_t)(int64_t)i_v4) != 0) {
        // 0x273a2
        return 0;
    }
    // 0x27368
    __asm_vldr_70(i_v2);
    if (__isinf(0.0) != 0) {
        // 0x273a2
        return 0;
    }
    // 0x2737a
    jsonp_malloc(16);
    int32_t i_v5 = 0; // 0x27386
    if (i_v5 != 0) {
        // 0x2738c
        json_init(i_v5, 4);
        uint64_t i_v6 = 0x100000000 * i_v1 >> 32; // 0x27398
        *(int32_t *)(i_v5 + 8) = (int32_t)(i_v6 / 0x100000000);
        *(int32_t *)(i_v5 + 12) = (int32_t)i_v6;
    }
    // 0x273a2
    return i_v5;
}

// Address range: 0x273ac - 0x273d6
int32_t json_real_value(int32_t i_a1) {
    int32_t i_v1 = 0; // 0x273b8
    int32_t i_v2 = 0; // 0x273b8
    if (i_a1 == 4) {
        uint64_t i_v3 = *(int64_t *)12; // 0x273ce
        i_v1 = i_v3 / 0x100000000;
        i_v2 = i_v3;
    }
    // 0x273d2
    __asm_vmov_73(i_v1, i_v2);
    return i_a1;
}

// Address range: 0x273d6 - 0x273e4
int32_t function_273d6(void) {
    // 0x273d6
    int32_t i_v1; // 0x273d6
    bool i_v2;    // 0x273d6
    if (i_v2) {
        i_v1 = function_1222e9e();
    }
    // 0x273da
    return i_v1;
}

// Address range: 0x273e4 - 0x27436
int32_t json_real_set(int32_t i_a1) {
    // 0x273e4
    int64_t i_v1;        // 0x273e4
    int32_t i_v2 = i_v1; // 0x273ec
    float64_t f_v3;      // 0x273e4
    __asm_vstr_71(f_v3, i_v2);
    if (i_a1 != 4) {
        // 0x2742c
        return -1;
    }
    // 0x273fe
    __asm_vldr_70(i_v2);
    if (__isnan(1.9762625833649862e-323) != 0) {
        // 0x2742c
        return -1;
    }
    // 0x2740c
    __asm_vldr_70(i_v2);
    int32_t i_v4 = -1; // 0x27418
    if (__isinf(0.0) == 0) {
        uint64_t i_v5 = 0x100000000 * i_v1 >> 32; // 0x27422
        *(int32_t *)12 = (int32_t)(i_v5 / 0x100000000);
        *(int32_t *)16 = (int32_t)i_v5;
        i_v4 = 0;
    }
    // 0x2742c
    return i_v4;
}

// Address range: 0x27438 - 0x2744e
int32_t json_delete_real(int32_t i_a1) {
    // 0x27438
    return jsonp_free(i_a1);
}

// Address range: 0x27450 - 0x27464
int32_t json_real_equal(int32_t i_a1, int32_t i_a2) {
    // 0x27450
    float64_t f_v1; // 0x27450
    __asm_vpush(f_v1);
    return json_real_value(i_a1);
}

// Address range: 0x27464 - 0x27468
int32_t function_27464(void) {
    // 0x27464
    int32_t i_v1; // 0x27464
    bool i_v2;    // 0x27464
    if (i_v2 == !i_v2) {
        i_v1 = function_1062f2c();
    }
    // 0x27468
    return i_v1;
}

// Address range: 0x2746a - 0x2746e
int32_t function_2746a(void) {
    // 0x2746a
    int32_t i_v1; // 0x2746a
    return json_real_value(i_v1);
}

// Address range: 0x2746e - 0x27482
int32_t function_2746e(void) {
    // 0x2746e
    bool i_v1; // 0x2746e
    if (!i_v1) {
        function_1062f36();
    }
    if (i_v1 == !i_v1) {
        function_1222f4a();
    }
    // 0x27476
    return unknown_463042();
}

// Address range: 0x27482 - 0x27490
int32_t function_27482(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    // 0x27482
    float64_t f_v1; // 0x27482
    __asm_vpop(f_v1);
    return i_a4;
}

// Address range: 0x27490 - 0x2749e
int32_t json_real_copy(int32_t i_a1) {
    // 0x27490
    return json_real_value(i_a1);
}

// Address range: 0x2749e - 0x274a6
int32_t function_2749e(void) {
    // 0x2749e
    int32_t i_v1; // 0x2749e
    bool i_v2;    // 0x2749e
    if (!i_v2) {
        i_v1 = function_1062f66();
    }
    int32_t i_v3 = i_v1; // 0x274a2
    if (i_v2) {
        i_v3 = function_1222f6a();
    }
    // 0x274a6
    return i_v3;
}

// Address range: 0x274a8 - 0x274b6
int32_t function_274a8(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    // 0x274a8
    float64_t f_v1; // 0x274a8
    float64_t f_v2 = f_v1;
    __asm_vmax_u16(f_v2, f_v2);
    return i_a4;
}

// Address range: 0x274b8 - 0x2750c
int32_t json_number_value(int32_t i_a1, int32_t i_a2) {
    int32_t i_v1 = i_a1; // 0x274b8
    int32_t i_v2 = 0;    // 0x274b8
    int32_t i_v3 = 0;    // 0x274b8
    switch (i_a1) {
    case 3: {
        int32_t i_v4 = __aeabi_l2d(json_integer_value(3), i_a2); // 0x274dc
        i_v1 = i_v4;
        i_v2 = i_v4;
        i_v3 = i_a2;
        // break -> 0x27508
        break;
    }
    case 4: {
        int32_t i_v5 = json_real_value(4);  // 0x274f6
        float64_t f_v6;                     // 0x274b8
        int32_t i_v7 = __asm_vmov_74(f_v6); // 0x274fa
        i_v1 = i_v5;
        i_v2 = i_v7;
        i_v3 = i_v7;
        // break -> 0x27508
        break;
    }
    }
    // 0x27508
    __asm_vmov_73(i_v2, i_v3);
    return i_v1;
}

// Address range: 0x2750c - 0x27518
int32_t function_2750c(int32_t i_a1) {
    int32_t i_v1 = i_a1; // 0x2750c
    bool i_v2;           // 0x2750c
    if (i_v2) {
        i_v1 = function_1222fd4();
        int32_t i_v3; // 0x2750c
        *(int32_t *)(4 * i_v3 + i_v3) = 0x27518;
    }
    return i_v1;
}

// Address range: 0x27518 - 0x2752c
int32_t json_true(void) {
    // 0x27518
    return &i_g181;
}

// Address range: 0x2752c - 0x27540
int32_t json_false(void) {
    // 0x2752c
    return &i_g180;
}

// Address range: 0x27540 - 0x27554
int32_t json_null(void) {
    // 0x27540
    return &i_g179;
}

// Address range: 0x27554 - 0x275d0
int32_t json_delete(int32_t i_a1) {
    int32_t i_v1 = i_a1; // 0x27554
    switch (i_a1) {
    case 1: {
        // 0x27580
        i_v1 = json_delete_array(1);
        // break -> 0x275c8
        break;
    }
    case 2: {
        // 0x27596
        i_v1 = json_delete_string(2);
        // break -> 0x275c8
        break;
    }
    case 3: {
        // 0x275ac
        i_v1 = json_delete_integer(3);
        // break -> 0x275c8
        break;
    }
    case 4: {
        // 0x275c2
        i_v1 = json_delete_real(4);
        // break -> 0x275c8
        break;
    }
    }
    // 0x275c8
    return i_v1;
}

// Address range: 0x275d0 - 0x27694
int32_t json_equal(int32_t i_a1, int32_t i_a2) {
    // 0x275d0
    return (bool)(i_a1 == i_a2 == i_a1 != 0 == (i_a2 != 0));
}

// Address range: 0x27694 - 0x27758
int32_t json_copy(int32_t i_a1) {
    int32_t i_v1 = 0; // 0x27694
    switch (i_a1) {
    case 7: {
    }
    case 5: {
    }
    case 6: {
        // 0x27748
        i_v1 = i_a1;
        // break -> 0x2774e
        break;
    }
    case 1: {
        // 0x276cc
        i_v1 = json_array_copy(1);
        // break -> 0x2774e
        break;
    }
    case 2: {
        // 0x276e4
        i_v1 = json_string_copy(2);
        // break -> 0x2774e
        break;
    }
    case 3: {
        // 0x276fc
        int32_t i_v2; // 0x27694
        i_v1 = json_integer_copy(3, i_v2);
        // break -> 0x2774e
        break;
    }
    case 4: {
        // 0x27714
        i_v1 = json_real_copy(4);
        // break -> 0x2774e
        break;
    }
    }
    // 0x2774e
    return i_v1;
}

// Address range: 0x27758 - 0x2781c
int32_t json_deep_copy(int32_t i_a1) {
    int32_t i_v1 = 0; // 0x27758
    switch (i_a1) {
    case 7: {
    }
    case 5: {
    }
    case 6: {
        // 0x2780c
        i_v1 = i_a1;
        // break -> 0x27812
        break;
    }
    case 1: {
        // 0x27790
        i_v1 = json_array_deep_copy(1);
        // break -> 0x27812
        break;
    }
    case 2: {
        // 0x277a8
        i_v1 = json_string_copy(2);
        // break -> 0x27812
        break;
    }
    case 3: {
        // 0x277c0
        int32_t i_v2; // 0x27758
        i_v1 = json_integer_copy(3, i_v2);
        // break -> 0x27812
        break;
    }
    case 4: {
        // 0x277d8
        i_v1 = json_real_copy(4);
        // break -> 0x27812
        break;
    }
    }
    // 0x27812
    return i_v1;
}

// Address range: 0x2781c - 0x27868
int32_t jsonp_error_init(int32_t i_a1, char *p_a2) {
    // 0x2781c
    if (i_a1 == 0) {
        // 0x27860
        return 0;
    }
    // 0x2782c
    *(char *)(i_a1 + 92) = 0;
    *(int32_t *)i_a1 = -1;
    *(int32_t *)(i_a1 + 4) = -1;
    *(int32_t *)(i_a1 + 8) = 0;
    int32_t i_v1; // 0x2781c
    if (p_a2 == NULL) {
        // 0x2785a
        *(char *)(i_a1 + 12) = 0;
        i_v1 = i_a1;
    } else {
        // 0x27850
        i_v1 = jsonp_error_set_source(i_a1, (int32_t)p_a2);
    }
    // 0x27860
    return i_v1;
}

// Address range: 0x27868 - 0x278d2
int32_t jsonp_error_set_source(int32_t i_a1, int32_t i_a2) {
    // 0x27868
    if (i_a1 == 0 || i_a2 == 0) {
        // 0x278ca
        int32_t i_v1; // 0x27868
        return __asm_nop(i_a1, i_a2, i_v1, 0);
    }
    char *p_v2 = (char *)i_a2;    // 0x27880
    uint32_t i_v3 = strlen(p_v2); // 0x27880
    int32_t i_v4 = i_a1 + 12;
    int32_t i_v5; // 0x27868
    if (i_v3 >= 79 == (i_v3 != 79)) {
        // 0x2789a
        *(int32_t *)i_v4 = (int32_t)&i_g93;
        i_v5 = (int32_t)strcpy((char *)(i_a1 + 15), (char *)(i_a2 - 76 + i_v3));
    } else {
        // 0x2788c
        i_v5 = (int32_t)strcpy((char *)i_v4, p_v2);
    }
    // 0x278ca
    return i_v5;
}

// Address range: 0x278d4 - 0x27904
int32_t jsonp_error_set(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4,
                        int32_t i_a5, int32_t i_a6) {
    // 0x278d4
    int32_t i_v1; // 0x278d4
    return jsonp_error_vset(i_a1, i_a2, i_a3, i_a4, i_a5, (int32_t)&i_v1);
}

// Address range: 0x27904 - 0x2795c
int32_t jsonp_error_vset(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4,
                         int32_t i_a5, int32_t i_a6) {
    if (i_a1 == 0) {
        // 0x27954
        return __asm_nop(0, i_a2, i_a3, 0);
    }
    char *p_v1 = (char *)(i_a1 + 92); // 0x2791a
    unsigned char i_v2 = *p_v1;       // 0x2791a
    int32_t i_v3;                     // 0x27904
    if (i_v2 == 0) {
        // 0x27922
        *(int32_t *)i_a1 = i_a2;
        *(int32_t *)(i_a1 + 4) = i_a3;
        *(int32_t *)(i_a1 + 8) = i_a4;
        int32_t i_v4 = vsnprintf(p_v1, 160, (char *)i_a5, i_a6); // 0x27940
        *(char *)(i_a1 + 251) = 0;
        i_v3 = i_v4;
    } else {
        // 0x27952
        i_v3 = __asm_nop(i_a1, i_a2, i_a3, (int32_t)i_v2);
    }
    // 0x27954
    return i_v3;
}

// Address range: 0x27960 - 0x27bbc
int32_t __aeabi_uidiv(uint32_t i_a1, uint32_t i_a2, int32_t i_a3) {
    // 0x27960
    switch (i_a2) {
    case 1: {
        // 0x27bb2
        return __asm_it();
    }
    case 0: {
        // 0x27bb2
        return 0;
    }
    }
    if (i_a1 == i_a2 || i_a1 < i_a2) {
        if (i_a1 == i_a2) {
            __asm_ite();
        }
        // 0x27bb2
        return i_a1 == i_a2;
    }
    if ((i_a2 - 1 & i_a2) == 0) {
        // 0x27ba4
        return i_a1 >> (llvm_ctlz_i32(i_a2, true) ^ 31);
    }
    // 0x27976
    __asm_adr(16);
    return i_a1;
}

// Address range: 0x27bbc - 0x27bd6
int32_t __aeabi_uidivmod(uint32_t i_a1, uint32_t i_a2) {
    // 0x27bbc
    return i_a1 / i_a2;
}

// Address range: 0x27bd8 - 0x27e6c
int32_t __aeabi_idiv(int32_t i_a1, int32_t i_a2) {
    if (i_a2 == 0) {
        if (i_a1 > 0) {
            __asm_it();
        }
        if (i_a1 < 0) {
            __asm_it();
        }
        return 0;
    }
    int32_t i_v1 = i_a1; // 0x27be2
    if (i_a2 < 0) {
        i_v1 = __asm_it();
    }
    int32_t i_v2 = i_a2 ^ i_a1; // 0x27bde
    int32_t i_v3 = i_v1;
    uint32_t i_v4 = i_a2 < 0 ? -i_a2 : i_a2;
    if (i_v4 == 1) {
        int32_t i_v5 = i_v3; // 0x27e2e
        if ((i_v3 ^ i_v2) < 0) {
            i_v5 = __asm_it();
        }
        int32_t i_v6 = i_v5;
        return (i_v3 ^ i_v2) < 0 ? -i_v6 : i_v6;
    }
    int32_t i_v7 = i_v3; // 0x27bee
    if (i_v3 < 0) {
        i_v7 = __asm_it();
    }
    uint32_t i_v8 = i_v3 < 0 ? -i_v7 : i_v3;
    if (i_v8 == i_v4 || i_v8 < i_v4) {
        int32_t i_v9 = i_v7; // 0x27e34
        if (i_v8 < i_v4) {
            i_v9 = __asm_it();
        }
        int32_t i_v10 = i_v8 >= i_v4 ? i_v9 : 0; // 0x27e38
        if (i_v8 == i_v4) {
            i_v10 = __asm_itt();
        }
        return i_v8 == i_v4 ? i_v2 >> 31 | 1 : i_v10;
    }
    if ((i_v4 - 1 & i_v4) != 0) {
        // 0x27bfe
        __asm_adr(16);
        return 0;
    }
    int32_t i_v11 = i_v8 >> (llvm_ctlz_i32(i_v4, true) ^ 31); // 0x27e54
    if (i_v2 < 0) {
        i_v11 = __asm_it();
    }
    int32_t i_v12 = i_v11;
    return i_v2 < 0 ? -i_v12 : i_v12;
}

// Address range: 0x27e6c - 0x27e86
int32_t __aeabi_idivmod(int32_t i_a1, int32_t i_a2) {
    // 0x27e6c
    return i_a1;
}

// Address range: 0x27e88 - 0x27e8e
int32_t __aeabi_drsub(int32_t i_a1, int32_t i_a2, int32_t i_a3) {
    // 0x27e88
    return (float32_t)((float64_t)(int64_t)i_a1 + (float64_t)(int64_t)i_a3);
}

// Address range: 0x27e90 - 0x27e94
int32_t __aeabi_dsub(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    // 0x27e90
    return i_a1;
}

// Address range: 0x27e94 - 0x2810a
int32_t __adddf3(int32_t i_a1, uint32_t i_a2, int32_t i_a3, uint32_t i_a4) {
    uint32_t i_v1 = 2 * i_a2;
    uint32_t i_v2 = 2 * i_a4; // 0x27e9a
    int32_t i_v3;             // 0x27e94
    bool i_v4;                // 0x27e94
    if (i_v1 == i_v2) {
        i_v4 = true;
        i_v3 = i_a3;
        if (__asm_it() == i_a3) {
            goto lab_dec_label_pc_unknown;
        } else {
            goto lab__thread47;
        }
    } else {
        goto lab__thread47;
    }
lab__thread47:
    // .thread47
    i_v4 = false;
    i_v3 = __asm_itttt();
    goto lab_dec_label_pc_unknown;
lab_dec_label_pc_unknown:;
    bool i_v5;     // 0x27e94
    int32_t i_v6;  // 0x27e94
    bool i_v7;     // 0x27e94
    int32_t i_v8;  // 0x27e94
    int32_t i_v9;  // 0x27e94
    int32_t i_v10; // 0x27e94
    int32_t i_v11; // 0x27e94
    int32_t i_v12; // 0x27e94
    int32_t i_v13; // 0x27e94
    int32_t i_v14; // 0x27e94
    int32_t i_v15; // 0x27e94
    int32_t i_v16; // 0x27e94
    int32_t i_v17; // 0x27e94
    int32_t i_v18; // 0x27e94
    int32_t i_v19; // 0x27e94
    int32_t i_v20; // 0x27fb8
    int32_t i_v21; // 0x27fde
    if (i_v2 > 0xffdfffff || i_v1 > 0xffdfffff || (i_v2 || i_a3) == 0 || i_v4 ||
        (i_v3 || i_v1) == 0) {
        if (i_v1 > 0xffdfffff) {
            i_v17 = i_a2;
            i_v18 = i_a2;
            i_v13 = i_v3;
            if (i_v2 > 0xffdfffff) {
                goto lab_dec_label_pc_unknown_2;
            } else {
                goto lab_dec_label_pc_unknown_3;
            }
        } else {
            int32_t i_v22 = __asm_it(); // 0x28086
            if (i_v2 <= 0xffdfffff) {
                int32_t i_v23 = i_v22; // 0x28092
                if (i_v1 == i_v2) {
                    i_v23 = __asm_it();
                    if (i_v23 == i_a3) {
                        if (i_a2 != i_a4) {
                            __asm_ittt();
                            // 0x280d4
                            return 0;
                        }
                        if (i_v1 < 0x200000) {
                            // 0x280b8
                            i_v9 = 2 * i_a3;
                            if (i_a3 < 0 ? (i_v1 || (int32_t)(i_a3 < 0)) <= i_a2
                                         : i_v1 < i_a2) {
                                i_v9 = __asm_it();
                            }
                        } else {
                            // 0x280c4
                            i_v9 = 0;
                            if ((i_v1 ^ -0x400000) >= 0x400000) {
                                i_v9 = __asm_itt();
                            }
                        }
                        // 0x280d4
                        return i_v9;
                    }
                }
                int32_t i_v24 = i_v23; // 0x2809e
                if ((i_v23 || i_v1) == 0) {
                    i_v24 = __asm_itt();
                }
                // 0x280d4
                return (i_v23 | i_v1) == 0 ? i_a3 : i_v24;
            }
            // .thread57
            __asm_itte();
            i_v17 = i_a4;
            goto lab_dec_label_pc_unknown_3;
        }
    } else {
        uint32_t i_v25 = i_a2 / 0x100000 % 2048; // 0x27ebe
        uint32_t i_v26 = i_a4 / 0x100000 % 2048; // 0x27ec2
        int32_t i_v27 = i_v3;                    // 0x27ec6
        if (i_v26 < i_v25) {
            i_v27 = __asm_it();
        }
        int32_t i_v28 = i_v26 - i_v25; // 0x27ec2
        int32_t i_v29 = i_v26 < i_v25 ? -i_v28 : i_v28;
        if (i_v29 >= 54 == (i_v29 != 54)) {
            // 0x280d4
            return __asm_it();
        }
        int32_t i_v30 = i_v26 > i_v25 ? i_a3 : i_v27;
        uint32_t i_v31 = i_v26 > i_v25 ? i_a4 : i_a2;
        int32_t i_v32 = i_v31 % 0x100000 | (int32_t)&i_g1; // 0x27ef8
        int32_t i_v33 = i_v30;                             // 0x27efc
        int32_t i_v34 = i_v32;                             // 0x27efc
        if (i_v31 <= 0xffffffff) {
            // 0x27efe
            i_v33 = -i_v30;
            i_v34 = -1 * i_v32 - (int32_t)(i_v32 >= 0);
        }
        int32_t i_v35 = i_v26 > i_v25 ? i_v27 : i_a3;
        uint32_t i_v36 = i_v26 > i_v25 ? i_a2 : i_a4;
        int32_t i_v37 = i_v34;
        int32_t i_v38 = i_v36 % 0x100000 | (int32_t)&i_g1; // 0x27f0c
        int32_t i_v39 = i_v35;                             // 0x27f10
        int32_t i_v40 = i_v38;                             // 0x27f10
        if (i_v36 <= 0xffffffff) {
            // 0x27f12
            i_v39 = -i_v35;
            i_v40 = -1 * i_v38 - (int32_t)(i_v38 >= 0);
        }
        int32_t i_v41 = (i_v26 > i_v25 ? i_v29 : 0) + i_v25;
        int32_t i_v42 = i_v33; // 0x27f1c
        int32_t i_v43 = i_v37; // 0x27f1c
        int32_t i_v44 = i_v40; // 0x27f1c
        i_v16 = i_v41;
        int32_t i_v45 = i_v29; // 0x27f1c
        if (i_v41 == i_v29) {
            int32_t i_v46 = i_v33; // 0x28076
            if (i_v29 == 0) {
                i_v46 = __asm_itte();
            }
            i_v43 = i_v29 == 0 ? i_v37 ^ (int32_t)&i_g1 : i_v37;
            i_v42 = i_v46;
            i_v44 = i_v40 ^ (int32_t)&i_g1;
            i_v16 = i_v29 + (int32_t)(i_v29 == 0);
            i_v45 = i_v29 + (int32_t)(i_v29 != 0);
        }
        uint32_t i_v47 = i_v45;
        int32_t i_v48 = i_v44;
        uint32_t i_v49 = 32 - i_v47; // 0x27f24
        int32_t i_v50;               // 0x27e94
        int32_t i_v51;               // 0x27e94
        int32_t i_v52;               // 0x27e94
        if (i_v47 > 32) {
            int32_t i_v53 = i_v42; // 0x27f54
            if ((0x80000000 >> i_v49 + 31 & i_v48) != 0) {
                i_v53 = __asm_it();
            }
            int32_t i_v54 = i_v48 << i_v49 + 32; // 0x27f50
            int32_t i_v55 = i_v48 >> i_v47 - 32; // 0x27f5a
            i_v51 = i_v53 + i_v55;
            i_v50 = (0x80000000 >> i_v49 + 31 & i_v48) != 0 ? i_v54 | 2 : i_v54;
            i_v52 =
                (i_v55 >> 31) + i_v43 + (int32_t)((i_v55 & 0x40000000) != 0);
        } else {
            uint32_t i_v56 = (i_v39 >> i_v47) + i_v42; // 0x27f32
            i_v51 = i_v56 + (i_v48 << i_v49);
            i_v50 = i_v39 << i_v49;
            i_v52 = (i_v48 >> i_v47) + i_v43 + (int32_t)(i_v56 < i_v42) +
                    (int32_t)((1 << i_v47 - 1 & i_v48) != 0);
        }
        int32_t i_v57 = i_v50;
        int32_t i_v58 = i_v51;
        int32_t i_v59 = i_v58; // 0x27f68
        int32_t i_v60 = i_v52; // 0x27f68
        int32_t i_v61 = i_v57; // 0x27f68
        if (i_v52 < 0) {
            // 0x27f6a
            i_v59 = (int32_t)(i_v57 != 0) - i_v58;
            bool i_v62 = i_v57 != 0
                             ? i_v58 != -1 | i_v59 != (int32_t)(i_v57 != 0)
                             : i_v58 != 0; // 0x27f72
            i_v60 = (int32_t)i_v62 - i_v52;
            i_v61 = -i_v57;
        }
        int32_t i_v63 = i_v61;
        uint32_t i_v64 = i_v59;
        if (i_v60 < (int32_t)&i_g1) {
            // 0x27fb8
            i_v20 = 2 * i_v63;
            uint32_t i_v65 = 2 * i_v64;                              // 0x27fbc
            int32_t i_v66 = i_v65 | (int32_t)(i_v63 < 0);            // 0x27fbc
            bool i_v67 = i_v63 < 0 ? i_v66 <= i_v64 : i_v65 < i_v64; // 0x27fbc
            int32_t i_v68 = 2 * i_v60 | (int32_t)i_v67;              // 0x27fbe
            i_v10 = i_v66;
            i_v8 = i_v20;
            if ((i_v68 & (int32_t)&i_g1) == 0) {
                int32_t i_v69; // 0x27e94
                if (i_v68 == 0) {
                    int32_t i_v70 = __asm_itt(); // 0x27fd0
                    i_v69 = llvm_ctlz_i32(i_v70, true);
                    i_v19 = i_v70;
                    i_v11 = __asm_it();
                } else {
                    i_v69 = llvm_ctlz_i32(i_v68, true);
                    i_v19 = i_v68;
                    i_v11 = i_v66;
                }
                int32_t i_v71 = i_v69;
                int32_t i_v72 = i_v68 == 0 ? i_v71 | 32 : i_v71;
                i_v21 = i_v72 - 11;
                int32_t i_v73 = i_v72 - 43; // 0x27fe2
                i_v15 = i_v73;
                i_v5 = i_v73 < 0;
                i_v7 = i_v21 == 32;
                i_v6 = i_v21 & 42 - i_v72;
                if (i_v21 > 31) {
                    goto lab_0x28002;
                } else {
                    int32_t i_v74 = i_v72 - 31; // 0x27fe8
                    if (i_v74 < 1) {
                        // 0x27ffe
                        i_v15 = i_v21;
                        i_v5 = i_v74 != 0;
                        i_v7 = i_v74 == 0;
                        i_v6 = i_v74 & i_v72 + 0x7fffffd5;
                        goto lab_0x28002;
                    } else {
                        // 0x27fec
                        i_v12 = i_v19 << i_v21;
                        i_v14 = i_v19 >> 43 - i_v72;
                        goto lab_0x28018;
                    }
                }
            } else {
                goto lab_0x27fa0;
            }
        } else {
            // 0x27f80
            i_v10 = i_v64;
            i_v8 = i_v63;
            if (i_v60 >= (int32_t)&i_g6) {
                // 0x27f86
                i_v10 = (int32_t)(i_v60 % 2 != 0) << 32 - i_v64 |
                        (int32_t)((int64_t)i_v64 << (int64_t)(33 - i_v64));
                i_v8 = (int32_t)((1 << i_v64 - 1 & i_v64) != 0) << 32 - i_v63 |
                       (int32_t)((int64_t)i_v63 << (int64_t)(33 - i_v63));
                if ((0x200000 * i_v16 ^ -0x400000) < 0x400000) {
                    // 0x280d4
                    return 0;
                }
            }
            goto lab_0x27fa0;
        }
    }
lab_dec_label_pc_unknown_2:
    i_v9 = i_v13;
    if ((i_v13 || 0x1000 * i_v18) == 0) {
        i_v9 = __asm_itte();
    }
    // 0x280d4
    return i_v9;
lab_dec_label_pc_unknown_3:
    i_v18 = i_v17;
    i_v13 = __asm_itt();
    goto lab_dec_label_pc_unknown_2;
lab_0x27fa0:;
    int32_t i_v75 = i_v8;
    int32_t i_v76 = i_v10; // 0x27fa4
    if (i_v75 == -0x80000000) {
        i_v76 = __asm_it();
    }
    bool i_v77 = i_v75 == -0x80000000 ? i_v76 % 2 != 0 : i_v75 <= -1;
    return i_v76 + (int32_t)i_v77;
lab_0x28002:;
    bool i_v78 = i_v7 | i_v5 != i_v6 < 0; // 0x28002
    int32_t i_v79;                        // 0x27e94
    int32_t i_v80;                        // 0x27e94
    if (i_v78) {
        i_v79 = __asm_it() >> 32 - i_v15;
        i_v80 = __asm_itt();
    } else {
        i_v79 = i_v11 >> i_v20;
        i_v80 = i_v11;
    }
    i_v12 = i_v80 << (i_v78 ? i_v15 : 0);
    i_v14 = (i_v78 ? i_v79 : 0) | i_v19 << i_v15;
    goto lab_0x28018;
lab_0x28018:;
    uint32_t i_v81 = i_v16 - 2; // 0x27fc6
    if (i_v81 >= i_v21) {
        // 0x280d4
        return __asm_ittt();
    }
    int32_t i_v82 = i_v81 - i_v21; // 0x28018
    uint32_t i_v83 = -32 - i_v82;  // 0x28028
    if (i_v82 < -31) {
        // 0x28066
        return i_v14 >> i_v83;
    }
    // 0x2802c
    if (i_v83 > -12) {
        // 0x2804e
        return i_v14 << -i_v83 | i_v12 >> i_v83 + 32;
    }
    // 0x28030
    return i_v14 << -i_v83 | i_v12 >> i_v83 + 32;
}

// Address range: 0x2810c - 0x2812a
int32_t __aeabi_ui2d(int32_t i_a1) {
    int32_t i_v1 = i_a1; // 0x28110
    if (i_a1 == 0) {
        i_v1 = __asm_itt();
    }
    return i_v1;
}

// Address range: 0x2812c - 0x2814e
int32_t __aeabi_i2d(int32_t i_a1) {
    if (i_a1 == 0) {
        // .thread
        return __asm_itt();
    }
    int32_t i_v1 = i_a1; // 0x28144
    if (i_a1 < 0) {
        i_v1 = __asm_it();
    }
    int32_t i_v2 = i_v1;
    return i_a1 < 0 ? -i_v2 : i_v2;
}

// Address range: 0x28150 - 0x2818a
int32_t __aeabi_f2d(int32_t i_a1) {
    uint32_t i_v1 = 2 * i_a1; // 0x28150
    if (i_v1 == 0) {
        // .thread
        return 0x20000000 * i_a1;
    }
    int32_t i_v2 = __asm_itttt(); // 0x2816c
    if ((i_a1 & 0x7f800000) != 0 != i_v1 < 0xff000000) {
        i_v2 = __asm_ite();
    }
    // .thread
    return i_v2;
}

// Address range: 0x2818c - 0x2819c
int32_t __aeabi_ul2d(int32_t i_a1, int32_t i_a2) {
    int32_t i_v1 = i_a1; // 0x28190
    if ((i_a2 || i_a1) == 0) {
        i_v1 = __asm_it();
    }
    return i_v1;
}

// Address range: 0x2819c - 0x281f6
int32_t __aeabi_l2d(int32_t i_a1, int32_t i_a2) {
    if ((i_a2 || i_a1) == 0) {
        return __asm_it();
    }
    uint32_t i_v1 = i_a2 < 0 ? -1 * i_a2 : i_a2;
    uint32_t i_v2; // 0x281d6
    if (i_v1 < 0x2000000) {
        i_v2 = 3 + (int32_t)(i_v1 < 0);
        return i_v1 << 32 - i_v2 | (i_a2 < 0 ? -i_a1 : i_a1) >> i_v2;
    }
    int32_t i_v3 = __asm_it(); // 0x281d2
    int32_t i_v4 = 6;          // 0x281d2
    if (i_v1 >= 0x10000000) {
        // .thread3
        i_v3 = __asm_it();
        i_v4 = 9;
    }
    i_v2 = i_v4 + (int32_t)(i_v1 < 0);
    return i_v1 << 32 - i_v2 | i_v3 >> i_v2;
}

// Address range: 0x281f8 - 0x28204
int32_t __aeabi_idiv0(int32_t i_a1, int32_t i_a2) {
    // 0x281f8
    return raise(8);
}

// Address range: 0x28204 - 0x28240
int32_t __libc_csu_init(int32_t i_a1, int32_t i_a2, int32_t i_a3,
                        int32_t i_a4) {
    int32_t i_v1 = _init(i_a1, i_a2, i_a3, i_a4); // 0x28216
    int32_t i_v2 = (int32_t)&i_g205 - (int32_t)&i_g152 >> 2 == 0 ? i_v1 : i_a1;
    return i_v2;
}

// Address range: 0x28244 - 0x28248
int32_t function_28244(int32_t i_a1) {
    int32_t i_v1 = i_a1; // 0x28244
    bool i_v2;           // 0x28244
    if (!i_v2) {
        i_v1 = $d();
    }
    // 0x28246
    return i_v1;
}

// Address range: 0x28248 - 0x28249
int32_t __libc_csu_fini(void) {
    // 0x28248
    int32_t i_v1; // 0x28248
    return i_v1;
}

// Address range: 0x2824c - 0x28252
int32_t _fini(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    // 0x2824c
    return __asm_nop(i_a1, i_a2, i_a3, i_a4);
}

// Address range: 0x2825c - 0x2825d
int32_t $d(void) {
    // 0x2825c
    int32_t i_v1; // 0x2825c
    return i_v1;
}

// Address range: 0x2f2c0 - 0x2f2c1
int32_t function_2f2c0(void) {
    // 0x2f2c0
    int32_t i_v1; // 0x2f2c0
    return i_v1;
}

// Address range: 0x44958 - 0x44959
int32_t function_44958(void) {
    // 0x44958
    int32_t i_v1; // 0x44958
    return i_v1;
}

// Address range: 0x4495c - 0x4495d
int32_t function_4495c(void) {
    // 0x4495c
    int32_t i_v1; // 0x4495c
    return i_v1;
}

// Address range: 0x46268 - 0x46269
int32_t function_46268(void) {
    // 0x46268
    int32_t i_v1; // 0x46268
    return i_v1;
}

// Address range: 0x4626c - 0x4626d
int32_t function_4626c(void) {
    // 0x4626c
    int32_t i_v1; // 0x4626c
    return i_v1;
}

// Address range: 0x4b824 - 0x4b825
int32_t function_4b824(void) {
    // 0x4b824
    int32_t i_v1; // 0x4b824
    return i_v1;
}

// Address range: 0x4bb34 - 0x4bb35
int32_t function_4bb34(void) {
    // 0x4bb34
    int32_t i_v1; // 0x4bb34
    return i_v1;
}

// Address range: 0x1499e0 - 0x1499e1
int32_t function_1499e0(void) {
    // 0x1499e0
    int32_t i_v1; // 0x1499e0
    return i_v1;
}

// Address range: 0x149a18 - 0x149a19
int32_t function_149a18(void) {
    // 0x149a18
    int32_t i_v1; // 0x149a18
    return i_v1;
}

// Address range: 0x149a78 - 0x149a79
int32_t function_149a78(void) {
    // 0x149a78
    int32_t i_v1; // 0x149a78
    return i_v1;
}

// Address range: 0x18bc54 - 0x18bc55
int32_t function_18bc54(void) {
    // 0x18bc54
    int32_t i_v1; // 0x18bc54
    return i_v1;
}

// Address range: 0x209c48 - 0x209c49
int32_t function_209c48(void) {
    // 0x209c48
    int32_t i_v1; // 0x209c48
    return i_v1;
}

// Address range: 0x209c80 - 0x209c81
int32_t function_209c80(void) {
    // 0x209c80
    int32_t i_v1; // 0x209c80
    return i_v1;
}

// Address range: 0x209dd0 - 0x209dd1
int32_t function_209dd0(void) {
    // 0x209dd0
    int32_t i_v1; // 0x209dd0
    return i_v1;
}

// Address range: 0x209e08 - 0x209e09
int32_t function_209e08(void) {
    // 0x209e08
    int32_t i_v1; // 0x209e08
    return i_v1;
}

// Address range: 0x28b944 - 0x28b945
int32_t function_28b944(void) {
    // 0x28b944
    int32_t i_v1; // 0x28b944
    return i_v1;
}

// Address range: 0x30b968 - 0x30b969
int32_t function_30b968(void) {
    // 0x30b968
    int32_t i_v1; // 0x30b968
    return i_v1;
}

// Address range: 0x5cb350 - 0x5cb351
int32_t function_5cb350(void) {
    // 0x5cb350
    int32_t i_v1; // 0x5cb350
    return i_v1;
}

// Address range: 0x5cb660 - 0x5cb661
int32_t function_5cb660(void) {
    // 0x5cb660
    int32_t i_v1; // 0x5cb660
    return i_v1;
}

// Address range: 0x5cbc78 - 0x5cbc79
int32_t function_5cbc78(void) {
    // 0x5cbc78
    int32_t i_v1; // 0x5cbc78
    return i_v1;
}

// Address range: 0x604434 - 0x604435
int32_t function_604434(void) {
    // 0x604434
    int32_t i_v1; // 0x604434
    return i_v1;
}

// Address range: 0x605d44 - 0x605d45
int32_t function_605d44(void) {
    // 0x605d44
    int32_t i_v1; // 0x605d44
    return i_v1;
}

// Address range: 0x90b9b6 - 0x90b9b7
int32_t function_90b9b6(void) {
    // 0x90b9b6
    int32_t i_v1; // 0x90b9b6
    return i_v1;
}

// Address range: 0xd49a68 - 0xd49a69
int32_t function_d49a68(void) {
    // 0xd49a68
    int32_t i_v1; // 0xd49a68
    return i_v1;
}

// Address range: 0xdc7064 - 0xdc7065
int32_t function_dc7064(void) {
    // 0xdc7064
    int32_t i_v1; // 0xdc7064
    return i_v1;
}

// Address range: 0xe49a70 - 0xe49a71
int32_t function_e49a70(void) {
    // 0xe49a70
    int32_t i_v1; // 0xe49a70
    return i_v1;
}

// Address range: 0xec9a60 - 0xec9a61
int32_t function_ec9a60(void) {
    // 0xec9a60
    int32_t i_v1; // 0xec9a60
    return i_v1;
}

// Address range: 0x102f2c0 - 0x102f2c1
int32_t function_102f2c0(void) {
    // 0x102f2c0
    int32_t i_v1; // 0x102f2c0
    return i_v1;
}

// Address range: 0x1061830 - 0x1061831
int32_t function_1061830(void) {
    // 0x1061830
    int32_t i_v1; // 0x1061830
    return i_v1;
}

// Address range: 0x1062f2c - 0x1062f2d
int32_t function_1062f2c(void) {
    // 0x1062f2c
    int32_t i_v1; // 0x1062f2c
    return i_v1;
}

// Address range: 0x1062f36 - 0x1062f37
int32_t function_1062f36(void) {
    // 0x1062f36
    int32_t i_v1; // 0x1062f36
    return i_v1;
}

// Address range: 0x1062f66 - 0x1062f67
int32_t function_1062f66(void) {
    // 0x1062f66
    int32_t i_v1; // 0x1062f66
    return i_v1;
}

// Address range: 0x10c9a28 - 0x10c9a29
int32_t function_10c9a28(void) {
    // 0x10c9a28
    int32_t i_v1; // 0x10c9a28
    return i_v1;
}

// Address range: 0x10c9a30 - 0x10c9a31
int32_t function_10c9a30(void) {
    // 0x10c9a30
    int32_t i_v1; // 0x10c9a30
    return i_v1;
}

// Address range: 0x10c9a38 - 0x10c9a39
int32_t function_10c9a38(void) {
    // 0x10c9a38
    int32_t i_v1; // 0x10c9a38
    return i_v1;
}

// Address range: 0x1209c98 - 0x1209c99
int32_t function_1209c98(void) {
    // 0x1209c98
    int32_t i_v1; // 0x1209c98
    return i_v1;
}

// Address range: 0x1209cd0 - 0x1209cd1
int32_t function_1209cd0(void) {
    // 0x1209cd0
    int32_t i_v1; // 0x1209cd0
    return i_v1;
}

// Address range: 0x1220ecc - 0x1220ecd
int32_t function_1220ecc(void) {
    // 0x1220ecc
    int32_t i_v1; // 0x1220ecc
    return i_v1;
}

// Address range: 0x1220ef0 - 0x1220ef1
int32_t function_1220ef0(void) {
    // 0x1220ef0
    int32_t i_v1; // 0x1220ef0
    return i_v1;
}

// Address range: 0x1222e9e - 0x1222e9f
int32_t function_1222e9e(void) {
    // 0x1222e9e
    int32_t i_v1; // 0x1222e9e
    return i_v1;
}

// Address range: 0x1222f4a - 0x1222f4b
int32_t function_1222f4a(void) {
    // 0x1222f4a
    int32_t i_v1; // 0x1222f4a
    return i_v1;
}

// Address range: 0x1222f6a - 0x1222f6b
int32_t function_1222f6a(void) {
    // 0x1222f6a
    int32_t i_v1; // 0x1222f6a
    return i_v1;
}

// Address range: 0x1222fd4 - 0x1222fd5
int32_t function_1222fd4(void) {
    // 0x1222fd4
    int32_t i_v1; // 0x1222fd4
    return i_v1;
}

// Address range: 0x145e726 - 0x145e727
int32_t function_145e726(void) {
    // 0x145e726
    int32_t i_v1; // 0x145e726
    return i_v1;
}

// Address range: 0x1a09e88 - 0x1a09e89
int32_t function_1a09e88(void) {
    // 0x1a09e88
    int32_t i_v1; // 0x1a09e88
    return i_v1;
}

// Address range: 0x1a09ec0 - 0x1a09ec1
int32_t function_1a09ec0(void) {
    // 0x1a09ec0
    int32_t i_v1; // 0x1a09ec0
    return i_v1;
}

// Address range: 0x1b4b890 - 0x1b4b891
int32_t function_1b4b890(void) {
    // 0x1b4b890
    int32_t i_v1; // 0x1b4b890
    return i_v1;
}

// Address range: 0x20cf107 - 0x20cf108
int32_t function_20cf107(void) {
    // 0x20cf107
    int32_t i_v1; // 0x20cf107
    return i_v1;
}

// Address range: 0x303f2c0 - 0x303f2c1
int32_t function_303f2c0(void) {
    // 0x303f2c0
    int32_t i_v1; // 0x303f2c0
    return i_v1;
}

// Address range: 0x30cf107 - 0x30cf108
int32_t function_30cf107(void) {
    // 0x30cf107
    int32_t i_v1; // 0x30cf107
    return i_v1;
}

// Address range: 0x18d368fa - 0x18d368fb
int32_t function_18d368fa(void) {
    // 0x18d368fa
    int32_t i_v1; // 0x18d368fa
    return i_v1;
}

// Address range: 0x21000303 - 0x21000304
int32_t function_21000303(void) {
    // 0x21000303
    int32_t i_v1; // 0x21000303
    return i_v1;
}

// Address range: 0x230060fb - 0x230060fc
int32_t function_230060fb(void) {
    // 0x230060fb
    int32_t i_v1; // 0x230060fb
    return i_v1;
}

// Address range: 0x230071fb - 0x230071fc
int32_t function_230071fb(void) {
    // 0x230071fb
    int32_t i_v1; // 0x230071fb
    return i_v1;
}

// Address range: 0x2300ff7f - 0x2300ff80
int32_t function_2300ff7f(void) {
    // 0x2300ff7f
    int32_t i_v1; // 0x2300ff7f
    return i_v1;
}

// Address range: 0x23e0f645 - 0x23e0f646
int32_t function_23e0f645(void) {
    // 0x23e0f645
    int32_t i_v1; // 0x23e0f645
    return i_v1;
}

// Address range: 0x23e8f645 - 0x23e8f646
int32_t function_23e8f645(void) {
    // 0x23e8f645
    int32_t i_v1; // 0x23e8f645
    return i_v1;
}

// Address range: 0x303cf248 - 0x303cf249
int32_t function_303cf248(void) {
    // 0x303cf248
    int32_t i_v1; // 0x303cf248
    return i_v1;
}

// Address range: 0x30ccf8c7 - 0x30ccf8c8
int32_t function_30ccf8c7(void) {
    // 0x30ccf8c7
    int32_t i_v1; // 0x30ccf8c7
    return i_v1;
}

// Address range: 0x429a68bb - 0x429a68bc
int32_t function_429a68bb(void) {
    // 0x429a68bb
    int32_t i_v1; // 0x429a68bb
    return i_v1;
}

// Address range: 0x4603af00 - 0x4603af01
int32_t function_4603af00(void) {
    // 0x4603af00
    int32_t i_v1; // 0x4603af00
    return i_v1;
}

// Address range: 0x4603af02 - 0x4603af03
int32_t function_4603af02(void) {
    // 0x4603af02
    int32_t i_v1; // 0x4603af02
    return i_v1;
}

// Address range: 0x461023b8 - 0x461023b9
int32_t function_461023b8(void) {
    // 0x461023b8
    int32_t i_v1; // 0x461023b8
    return i_v1;
}

// Address range: 0x461079fa - 0x461079fb
int32_t function_461079fa(void) {
    // 0x461079fa
    int32_t i_v1; // 0x461079fa
    return i_v1;
}

// Address range: 0x46197080 - 0x46197081
int32_t function_46197080(void) {
    // 0x46197080
    int32_t i_v1; // 0x46197080
    return i_v1;
}

// Address range: 0x461a0102 - 0x461a0103
int32_t function_461a0102(void) {
    // 0x461a0102
    int32_t i_v1; // 0x461a0102
    return i_v1;
}

// Address range: 0x461a2100 - 0x461a2101
int32_t function_461a2100(void) {
    // 0x461a2100
    int32_t i_v1; // 0x461a2100
    return i_v1;
}

// Address range: 0x461a4603 - 0x461a4604
int32_t function_461a4603(void) {
    // 0x461a4603
    int32_t i_v1; // 0x461a4603
    return i_v1;
}

// Address range: 0x46bd0710 - 0x46bd0711
int32_t function_46bd0710(void) {
    // 0x46bd0710
    int32_t i_v1; // 0x46bd0710
    return i_v1;
}

// Address range: 0x54992101 - 0x54992102
int32_t function_54992101(void) {
    // 0x54992101
    int32_t i_v1; // 0x54992101
    return i_v1;
}

// Address range: 0x60bb3301 - 0x60bb3302
int32_t function_60bb3301(void) {
    // 0x60bb3301
    int32_t i_v1; // 0x60bb3301
    return i_v1;
}

// Address range: 0x610cf248 - 0x610cf249
int32_t function_610cf248(void) {
    // 0x610cf248
    int32_t i_v1; // 0x610cf248
    return i_v1;
}

// Address range: 0x681b0303 - 0x681b0304
int32_t function_681b0303(void) {
    // 0x681b0303
    int32_t i_v1; // 0x681b0303
    return i_v1;
}

// Address range: 0x68bbec68 - 0x68bbec69
int32_t function_68bbec68(void) {
    // 0x68bbec68
    int32_t i_v1; // 0x68bbec68
    return i_v1;
}

// Address range: 0x71ba460a - 0x71ba460b
int32_t function_71ba460a(void) {
    // 0x71ba460a
    int32_t i_v1; // 0x71ba460a
    return i_v1;
}

// Address range: 0x733b2320 - 0x733b2321
int32_t function_733b2320(void) {
    // 0x733b2320
    int32_t i_v1; // 0x733b2320
    return i_v1;
}

// Address range: 0x733b23ff - 0x733b2400
int32_t function_733b23ff(void) {
    // 0x733b23ff
    int32_t i_v1; // 0x733b23ff
    return i_v1;
}

// Address range: 0x737b2300 - 0x737b2301
int32_t function_737b2300(void) {
    // 0x737b2300
    int32_t i_v1; // 0x737b2300
    return i_v1;
}

// Address range: 0x79fa5499 - 0x79fa549a
int32_t function_79fa5499(void) {
    // 0x79fa5499
    int32_t i_v1; // 0x79fa5499
    return i_v1;
}

// Address range: 0x79fb60bb - 0x79fb60bc
int32_t function_79fb60bb(void) {
    // 0x79fb60bb
    int32_t i_v1; // 0x79fb60bb
    return i_v1;
}

// Address range: 0x79fbec16 - 0x79fbec17
int32_t function_79fbec16(void) {
    // 0x79fbec16
    int32_t i_v1; // 0x79fbec16
    return i_v1;
}

// Address range: 0xb084b580 - 0xb084b581
int32_t function_b084b580(void) {
    // 0xb084b580
    int32_t i_v1; // 0xb084b580
    return i_v1;
}

// Address range: 0xb0b6b580 - 0xb0b6b581
int32_t function_b0b6b580(void) {
    // 0xb0b6b580
    int32_t i_v1; // 0xb0b6b580
    return i_v1;
}

// Address range: 0xb2db68fb - 0xb2db68fc
int32_t function_b2db68fb(void) {
    // 0xb2db68fb
    int32_t i_v1; // 0xb2db68fb
    return i_v1;
}

// Address range: 0xbf00bd80 - 0xbf00bd81
int32_t function_bf00bd80(void) {
    // 0xbf00bd80
    int32_t i_v1; // 0xbf00bd80
    return i_v1;
}

// Address range: 0xe01560bb - 0xe01560bc
int32_t function_e01560bb(void) {
    // 0xe01560bb
    int32_t i_v1; // 0xe01560bb
    return i_v1;
}

// Address range: 0xebc6f7ff - 0xebc6f800
int32_t function_ebc6f7ff(void) {
    // 0xebc6f7ff
    int32_t i_v1; // 0xebc6f7ff
    return i_v1;
}

// Address range: 0xecb4f7ff - 0xecb4f800
int32_t function_ecb4f7ff(void) {
    // 0xecb4f7ff
    int32_t i_v1; // 0xecb4f7ff
    return i_v1;
}

// Address range: 0xf107d8da - 0xf107d8db
int32_t function_f107d8da(void) {
    // 0xf107d8da
    int32_t i_v1; // 0xf107d8da
    return i_v1;
}

// Address range: 0xf24160fb - 0xf24160fc
int32_t function_f24160fb(void) {
    // 0xf24160fb
    int32_t i_v1; // 0xf24160fb
    return i_v1;
}

// Address range: 0xf2480002 - 0xf2480003
int32_t function_f2480002(void) {
    // 0xf2480002
    int32_t i_v1; // 0xf2480002
    return i_v1;
}

// Address range: 0xf24879fb - 0xf24879fc
int32_t function_f24879fb(void) {
    // 0xf24879fb
    int32_t i_v1; // 0xf24879fb
    return i_v1;
}

// Address range: 0xf2c023dc - 0xf2c023dd
int32_t function_f2c023dc(void) {
    // 0xf2c023dc
    int32_t i_v1; // 0xf2c023dc
    return i_v1;
}

// Address range: 0xf2c023e8 - 0xf2c023e9
int32_t function_f2c023e8(void) {
    // 0xf2c023e8
    int32_t i_v1; // 0xf2c023e8
    return i_v1;
}

// Address range: 0xf2c0303c - 0xf2c0303d
int32_t function_f2c0303c(void) {
    // 0xf2c0303c
    int32_t i_v1; // 0xf2c0303c
    return i_v1;
}

// Address range: 0xf2c051f8 - 0xf2c051f9
int32_t function_f2c051f8(void) {
    // 0xf2c051f8
    int32_t i_v1; // 0xf2c051f8
    return i_v1;
}

// Address range: 0xf44f681b - 0xf44f681c
int32_t function_f44f681b(void) {
    // 0xf44f681b
    int32_t i_v1; // 0xf44f681b
    return i_v1;
}

// Address range: 0xf64579fa - 0xf64579fb
int32_t function_f64579fa(void) {
    // 0xf64579fa
    int32_t i_v1; // 0xf64579fa
    return i_v1;
}

// Address range: 0xf645ffaf - 0xf645ffb0
int32_t function_f645ffaf(void) {
    // 0xf645ffaf
    int32_t i_v1; // 0xf645ffaf
    return i_v1;
}

// Address range: 0xf7ff3088 - 0xf7ff3089
int32_t function_f7ff3088(void) {
    // 0xf7ff3088
    int32_t i_v1; // 0xf7ff3088
    return i_v1;
}

// Address range: 0xf7ff4618 - 0xf7ff4619
int32_t function_f7ff4618(void) {
    // 0xf7ff4618
    int32_t i_v1; // 0xf7ff4618
    return i_v1;
}

// Address range: 0xf7ff4619 - 0xf7ff461a
int32_t function_f7ff4619(void) {
    // 0xf7ff4619
    int32_t i_v1; // 0xf7ff4619
    return i_v1;
}

// Address range: 0xf7ff461a - 0xf7ff461b
int32_t function_f7ff461a(void) {
    // 0xf7ff461a
    int32_t i_v1; // 0xf7ff461a
    return i_v1;
}

// Address range: 0xfa44f01e - 0xfa44f01f
int32_t function_fa44f01e(void) {
    // 0xfa44f01e
    int32_t i_v1; // 0xfa44f01e
    return i_v1;
}

// Address range: 0xfe449c96 - 0xfe449c97
int32_t function_fe449c96(void) {
    // 0xfe449c96
    int32_t i_v1; // 0xfe449c96
    return i_v1;
}

// Address range: 0xfe80b7be - 0xfe80b7bf
int32_t function_fe80b7be(void) {
    // 0xfe80b7be
    int32_t i_v1; // 0xfe80b7be
    return i_v1;
}

// Address range: 0xfeadea6e - 0xfeadea6f
int32_t function_feadea6e(void) {
    // 0xfeadea6e
    int32_t i_v1; // 0xfeadea6e
    return i_v1;
}

// Address range: 0xff049ef4 - 0xff049ef5
int32_t function_ff049ef4(void) {
    // 0xff049ef4
    int32_t i_v1; // 0xff049ef4
    return i_v1;
}

// Address range: 0xff209ed8 - 0xff209ed9
int32_t function_ff209ed8(void) {
    // 0xff209ed8
    int32_t i_v1; // 0xff209ed8
    return i_v1;
}

// Address range: 0xff20a02a - 0xff20a02b
int32_t function_ff20a02a(void) {
    // 0xff20a02a
    int32_t i_v1; // 0xff20a02a
    return i_v1;
}

// Address range: 0xff20bc16 - 0xff20bc17
int32_t function_ff20bc16(void) {
    // 0xff20bc16
    int32_t i_v1; // 0xff20bc16
    return i_v1;
}

// Address range: 0xff20bce8 - 0xff20bce9
int32_t function_ff20bce8(void) {
    // 0xff20bce8
    int32_t i_v1; // 0xff20bce8
    return i_v1;
}

// Address range: 0xff20be0e - 0xff20be0f
int32_t function_ff20be0e(void) {
    // 0xff20be0e
    int32_t i_v1; // 0xff20be0e
    return i_v1;
}

// Address range: 0xff2dea72 - 0xff2dea73
int32_t function_ff2dea72(void) {
    // 0xff2dea72
    int32_t i_v1; // 0xff2dea72
    return i_v1;
}

// Address range: 0xffa04db0 - 0xffa04db1
int32_t function_ffa04db0(void) {
    // 0xffa04db0
    int32_t i_v1; // 0xffa04db0
    return i_v1;
}

// Address range: 0xffa04e00 - 0xffa04e01
int32_t function_ffa04e00(void) {
    // 0xffa04e00
    int32_t i_v1; // 0xffa04e00
    return i_v1;
}

// Address range: 0xffa066c0 - 0xffa066c1
int32_t function_ffa066c0(void) {
    // 0xffa066c0
    int32_t i_v1; // 0xffa066c0
    return i_v1;
}

// Address range: 0xffa06710 - 0xffa06711
int32_t function_ffa06710(void) {
    // 0xffa06710
    int32_t i_v1; // 0xffa06710
    return i_v1;
}

// Address range: 0xffa0bc1a - 0xffa0bc1b
int32_t function_ffa0bc1a(void) {
    // 0xffa0bc1a
    int32_t i_v1; // 0xffa0bc1a
    return i_v1;
}

// Address range: 0xffa0bcc0 - 0xffa0bcc1
int32_t function_ffa0bcc0(void) {
    // 0xffa0bcc0
    int32_t i_v1; // 0xffa0bcc0
    return i_v1;
}

// Address range: 0xffa0bcc8 - 0xffa0bcc9
int32_t function_ffa0bcc8(void) {
    // 0xffa0bcc8
    int32_t i_v1; // 0xffa0bcc8
    return i_v1;
}

// Address range: 0xffa0bcec - 0xffa0bced
int32_t function_ffa0bcec(void) {
    // 0xffa0bcec
    int32_t i_v1; // 0xffa0bcec
    return i_v1;
}

// Address range: 0xffa0be12 - 0xffa0be13
int32_t function_ffa0be12(void) {
    // 0xffa0be12
    int32_t i_v1; // 0xffa0be12
    return i_v1;
}

// Address range: 0xffa0bfd0 - 0xffa0bfd1
int32_t function_ffa0bfd0(void) {
    // 0xffa0bfd0
    int32_t i_v1; // 0xffa0bfd0
    return i_v1;
}

// Address range: 0xffa0bfd8 - 0xffa0bfd9
int32_t function_ffa0bfd8(void) {
    // 0xffa0bfd8
    int32_t i_v1; // 0xffa0bfd8
    return i_v1;
}

// Address range: 0xffa0bffc - 0xffa0bffd
int32_t function_ffa0bffc(void) {
    // 0xffa0bffc
    int32_t i_v1; // 0xffa0bffc
    return i_v1;
}

// Address range: 0xffb5ea76 - 0xffb5ea77
int32_t function_ffb5ea76(void) {
    // 0xffb5ea76
    int32_t i_v1; // 0xffb5ea76
    return i_v1;
}

// Address range: 0xffe6b02e - 0xffe6b02f
int32_t function_ffe6b02e(void) {
    // 0xffe6b02e
    int32_t i_v1; // 0xffe6b02e
    return i_v1;
}

// Address range: 0xfffccc36 - 0xfffccc37
int32_t function_fffccc36(void) {
    // 0xfffccc36
    int32_t i_v1; // 0xfffccc36
    return i_v1;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (4.7.3)
// Detected functions: 675

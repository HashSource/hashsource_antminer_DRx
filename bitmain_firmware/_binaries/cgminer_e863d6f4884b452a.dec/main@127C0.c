int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v3; // r0
  int (*v4)(void); // r2
  int (**v5)(void); // r3
  bool v6; // zf
  int v7; // r0
  char *v8; // r0
  int v9; // r3
  char *v10; // r5
  char *v11; // r6
  int v12; // r4
  char *v13; // r8
  const char *v14; // t1
  char *v15; // r0
  int v16; // r0
  const char *v17; // r0
  char *v18; // r0
  char *v19; // r6
  char *v20; // r5
  char *v21; // r0
  int v22; // r4
  size_t v23; // r0
  __int16 v24; // r3
  char *v25; // r6
  int v26; // r8
  size_t v27; // r0
  char *v28; // r3
  int v29; // r3
  int v30; // r2
  unsigned int v31; // r5
  char *v32; // r9
  int v33; // r3
  size_t v34; // r8
  int v35; // r3
  unsigned __int8 *v36; // lr
  int v37; // r4
  int v38; // r2
  int v39; // r9
  int v40; // r1
  unsigned __int8 *v41; // r12
  int v42; // r0
  unsigned int v43; // r2
  unsigned int v44; // r5
  int v45; // r4
  unsigned int v46; // r5
  unsigned int v47; // r2
  int v48; // r4
  unsigned int v49; // r5
  unsigned int v50; // r3
  unsigned __int8 *v51; // r10
  size_t v52; // r0
  size_t v53; // r2
  int v54; // r3
  unsigned int v55; // r5
  unsigned int v56; // r2
  int v57; // r3
  unsigned int v58; // r5
  unsigned int v59; // r2
  int v60; // r3
  unsigned int v61; // r3
  int v62; // r0
  int v63; // r3
  _DWORD *v64; // r2
  int v65; // r3
  __int64 v66; // kr08_8
  int v67; // r4
  int v68; // r4
  int v69; // r5
  char *v70; // r0
  int *v71; // r3
  int v72; // r3
  int v73; // r3
  char *v74; // r9
  int v75; // r4
  char *v76; // r5
  char *v77; // r0
  char *v78; // r1
  const char *v79; // r0
  FILE *v80; // r5
  signed int v81; // r0
  char *v82; // r0
  char *v83; // r5
  char *v84; // r11
  char *v85; // r3
  char *v86; // r3
  char *v87; // r3
  char *v88; // r3
  int *v89; // r4
  const char *v90; // r1
  const char *v91; // r1
  char *v92; // r11
  const char *v93; // r6
  const char *v94; // r0
  int v95; // r0
  FILE *v96; // r0
  int v97; // r3
  int v98; // r3
  int v99; // r4
  char *v100; // r11
  FILE *v101; // r0
  char *v102; // r3
  int v103; // r3
  char *v104; // r8
  int v105; // r4
  FILE *v106; // r0
  int v107; // r3
  const char *v108; // r3
  int v109; // r3
  int *v110; // r4
  int v111; // r2
  void *v112; // r4
  char *v113; // r3
  int *v114; // r2
  char *v115; // r0
  int v116; // r2
  int v117; // r3
  char *v118; // r0
  int *v119; // r0
  int v120; // r2
  int v121; // r3
  int v122; // r12
  int v123; // r0
  int v124; // r12
  int v125; // r12
  int v126; // r12
  int v127; // r12
  int v128; // r12
  int v129; // r12
  int v130; // r12
  int v131; // r12
  int v132; // r1
  int v133; // r5
  size_t *v134; // r3
  int v135; // r0
  char *v136; // r0
  int v137; // r4
  unsigned int v138; // r5
  char *i; // r0
  _DWORD *v140; // r8
  unsigned int v141; // r0
  unsigned int v142; // r3
  int v143; // r0
  char *v144; // r11
  _DWORD *v145; // r5
  _DWORD *v146; // r6
  int v147; // r4
  char *v148; // r9
  unsigned int v149; // r2
  int v150; // r3
  _DWORD *v151; // r3
  unsigned int v152; // r2
  unsigned int v153; // r1
  bool v154; // cc
  int v155; // r2
  int v156; // r3
  char *v157; // r3
  _DWORD *v158; // r0
  _DWORD *v159; // r4
  void *v160; // r0
  void *v161; // r0
  int *v162; // r5
  int *v163; // r5
  char *v164; // r4
  char *v165; // r5
  int v166; // r0
  int v167; // r1
  int v168; // r2
  int v169; // r3
  _DWORD *v170; // r4
  _DWORD *v171; // r5
  int v172; // r1
  char v173; // r3
  char *v174; // r5
  FILE *v175; // r0
  int v176; // r3
  int v177; // r0
  int v178; // r2
  int v179; // r4
  int v180; // r3
  int v181; // r0
  int v182; // r4
  int j; // r3
  int v184; // r2
  int v185; // r5
  const char *v186; // r3
  int v187; // r9
  int v188; // r3
  size_t v189; // r4
  size_t v190; // r4
  char *v191; // r0
  __int64 v192; // kr10_8
  int v193; // r2
  __sighandler_t v194; // r5
  __sighandler_t v195; // r0
  __pid_t v196; // r0
  __pid_t v197; // r5
  void *v198; // r4
  int *v199; // r6
  int v200; // r5
  int *v201; // r9
  int v202; // r4
  _DWORD *v203; // r5
  size_t v204; // r4
  char *v205; // r0
  char *v206; // r3
  int v207; // r4
  int v208; // r6
  _DWORD *v209; // r0
  _DWORD *v210; // r9
  int *v211; // r0
  const char *v212; // r1
  int v213; // r4
  int v214; // r2
  int v215; // r3
  int v216; // r1
  int *v217; // r0
  int v218; // r4
  int v219; // r1
  int v220; // r0
  int v221; // r5
  int v222; // r4
  char *v223; // r9
  int v224; // r5
  char *v225; // r9
  int k; // r4
  int v227; // r3
  int v228; // r4
  int v229; // r9
  int v230; // r3
  int v231; // r3
  int v232; // r4
  int v233; // r3
  char *v234; // r6
  int v235; // r0
  int v236; // r0
  int v237; // r5
  int v238; // r3
  _DWORD *v239; // r4
  int v240; // r5
  _DWORD *v241; // r5
  int v242; // r3
  int v243; // r3
  int v244; // r2
  const char *v245; // r1
  __int64 v246; // kr18_8
  int jj; // r3
  int v248; // r5
  int v249; // r3
  int kk; // r3
  int v251; // r5
  int v252; // r2
  int v253; // r3
  int v254; // r0
  int v255; // r3
  _DWORD *v256; // r5
  int mm; // r4
  int v258; // r0
  int v259; // r3
  int v260; // r2
  int v261; // r1
  int v262; // r3
  int v263; // r4
  int v264; // r3
  int n; // r3
  int v266; // r9
  __int64 v267; // kr30_8
  int v268; // r3
  int v269; // r0
  signed int v270; // r1
  int v271; // r3
  int v272; // r4
  int *v273; // r0
  int m; // r4
  _DWORD *v275; // r12
  int v276; // r1
  int ii; // r9
  char v279; // [sp+10h] [bp-2010h] BYREF
  char v280[4088]; // [sp+1018h] [bp-1008h] BYREF
  const char *v281; // [sp+2010h] [bp-10h]
  int *v282; // [sp+2020h] [bp+0h]
  char *v283; // [sp+2024h] [bp+4h]
  size_t *v284; // [sp+2028h] [bp+8h]
  int v285; // [sp+202Ch] [bp+Ch]
  int v286; // [sp+2030h] [bp+10h]
  int v287; // [sp+2034h] [bp+14h]
  int v288; // [sp+2038h] [bp+18h]
  int v289; // [sp+203Ch] [bp+1Ch]
  int v290; // [sp+2040h] [bp+20h]
  int v291; // [sp+2044h] [bp+24h]
  int v292; // [sp+2048h] [bp+28h]
  int v293; // [sp+204Ch] [bp+2Ch]
  int v294; // [sp+2050h] [bp+30h]
  int v295; // [sp+2054h] [bp+34h]
  int v296; // [sp+2058h] [bp+38h]
  const char **v297; // [sp+205Ch] [bp+3Ch]
  char *v298; // [sp+2060h] [bp+40h]
  __int64 v299; // [sp+2064h] [bp+44h]
  int v300; // [sp+206Ch] [bp+4Ch]
  char *v301; // [sp+2070h] [bp+50h]
  int *v302; // [sp+2074h] [bp+54h]
  char *format; // [sp+2078h] [bp+58h]
  char *v304; // [sp+207Ch] [bp+5Ch]
  int *v305; // [sp+2080h] [bp+60h]
  int v306; // [sp+2084h] [bp+64h] BYREF
  struct sigaction act; // [sp+208Ch] [bp+6Ch] BYREF
  char v308[256]; // [sp+2118h] [bp+F8h] BYREF
  char s[2052]; // [sp+2218h] [bp+1F8h] BYREF

  format = (char *)argv;
  v306 = argc;
  strcpy((char *)&dword_6F970, "cgminer.log");
  v302 = (int *)&byte_6F948;
  strcpy((char *)&word_6F950, "a+");
  byte_6F948 = 0;
  LODWORD(v299) = &word_6F950;
  v3 = sysconf(84);
  v6 = v3 == 1;
  if ( v3 == 1 )
  {
    v5 = &off_6CB70;
    v4 = sched_yield;
  }
  v7 = v306 + 1;
  if ( v6 )
    *v5 = v4;
  v305 = &dword_6D850;
  v8 = (char *)malloc(4 * v7);
  v9 = v306;
  v10 = v8;
  dword_6DB98 = (int)v8;
  if ( v306 > 0 )
  {
    v11 = v8 - 4;
    v12 = 0;
    v13 = format - 4;
    do
    {
      v14 = (const char *)*((_DWORD *)v13 + 1);
      v13 += 4;
      ++v12;
      v15 = _strdup(v14);
      v9 = v306;
      *((_DWORD *)v11 + 1) = v15;
      v11 += 4;
    }
    while ( v9 > v12 );
  }
  *(_DWORD *)&v10[4 * v9] = 0;
  sub_1BE84(&unk_73CEC, "main", 11308);
  sub_1BE84(&unk_73B88, "main", 11309);
  sub_1BE84(&unk_73AA4, "main", 11310);
  sub_1BE9C(&unk_73460, "main", 11311);
  sub_1BE84(&unk_73A00, "main", 11312);
  v304 = (char *)&unk_6E948;
  sub_1BE84(&stru_6DDD8, "main", 11313);
  sub_1BE9C(&unk_733A8, "main", 11314);
  sub_1BE84(&stru_6DDB4, "main", 11315);
  sub_1BE28(&stru_6F318, "main", 11316);
  sub_1BE28(&unk_735C8, "main", 11317);
  sub_1BE28(&stru_732CC, "main", 11318);
  sub_1BE28(&stru_73CCC, "main", 11319);
  sub_1BE84(&mutex, "main", 11321);
  if ( pthread_cond_init(&cond, 0) )
  {
    strcpy(s, "Failed to pthread_cond_init lp_cond");
    sub_343C4(3, s, 1);
    sub_1B070(1, 0);
  }
  sub_1BE84(&unk_73CB4, "main", 11325);
  if ( pthread_cond_init(&stru_73AC0, 0) )
  {
    strcpy(s, "Failed to pthread_cond_init restart_cond");
    goto LABEL_170;
  }
  v300 = pthread_cond_init(&stru_732F0, 0);
  if ( v300 )
  {
    strcpy(s, "Failed to pthread_cond_init gws_cond");
  }
  else
  {
    v16 = sub_2A1F4();
    dword_73798 = v16;
    if ( v16 )
    {
      v281 = (const char *)&unk_513B8;
      v305[275] = v16 + 12;
      snprintf(::s, 0x100u, "%s %s", "cgminer", v281);
      act.sa_handler = (__sighandler_t)(sub_1B1D8 + 1);
      act.sa_flags = v300;
      sigemptyset(&act.sa_mask);
      sigaction(15, &act, &stru_737B0);
      sigaction(2, &act, &stru_73AF0);
      signal(13, (__sighandler_t)1);
      dword_735EC = (int)v280;
      v297 = (const char **)&dword_735EC;
      strcpy(v280, "/usr/local/bin");
      dword_73524 = (int)&v279;
      v17 = *(const char **)format;
      HIDWORD(v299) = &word_4D754;
      v18 = _strdup(v17);
      v19 = (char *)dword_73524;
      v20 = v18;
      v21 = dirname(v18);
      strcpy(v19, v21);
      free(v20);
      v22 = dword_73524;
      v23 = strlen((const char *)dword_73524);
      v24 = *(_WORD *)HIDWORD(v299);
      *((_DWORD *)v304 + 664) = 9;
      *(_WORD *)(v22 + v23) = v24;
      v25 = (char *)calloc(0x68u, 1u);
      if ( !v25 )
      {
        strcpy(s, "main OOM");
        goto LABEL_175;
      }
      v26 = 36;
      do
      {
        --v26;
        *(_WORD *)&v25[strlen(v25)] = 48;
      }
      while ( v26 );
      *((_DWORD *)v25 + 19) = 0;
      *((_DWORD *)v25 + 22) = v25;
      v27 = strlen(v25);
      v28 = v304;
      *((_DWORD *)v25 + 23) = v27;
      v29 = *((_DWORD *)v28 + 636);
      if ( v29 )
      {
        v30 = *(_DWORD *)(v29 + 68);
        v301 = v25 + 68;
        *(_DWORD *)(*(_DWORD *)(v30 + 16) + 8) = v25;
        *((_DWORD *)v25 + 18) = *(_DWORD *)(*(_DWORD *)(v29 + 68) + 16) - *(_DWORD *)(*(_DWORD *)(v29 + 68) + 20);
        *(_DWORD *)(*(_DWORD *)(v29 + 68) + 16) = v25 + 68;
      }
      else
      {
        v157 = v304;
        *((_DWORD *)v25 + 18) = 0;
        *((_DWORD *)v157 + 636) = v25;
        v158 = malloc(0x2Cu);
        v159 = v158;
        *((_DWORD *)v25 + 17) = v158;
        if ( !v158 )
          goto LABEL_165;
        memset(v158 + 3, 0, 0x20u);
        v159[1] = 32;
        v301 = v25 + 68;
        v159[2] = 5;
        v159[4] = v25 + 68;
        v159[5] = 68;
        v160 = calloc(0x180u, 1u);
        *v159 = v160;
        if ( !v160 )
          goto LABEL_165;
        v159[10] = -1609490463;
      }
      LOWORD(v31) = 31161;
      v32 = (char *)*((_DWORD *)v304 + 636);
      ++*(_DWORD *)(*((_DWORD *)v32 + 17) + 12);
      v33 = *((_DWORD *)v32 + 17);
      *((_DWORD *)v25 + 24) = -17973521;
      *((_DWORD *)v25 + 17) = v33;
      v34 = strlen(v25);
      if ( v34 <= 0xB )
      {
        HIWORD(v31) = -25033;
        v51 = (unsigned __int8 *)v25;
        v37 = v31;
      }
      else
      {
        HIWORD(v31) = -25033;
        v35 = -17973521;
        v36 = (unsigned __int8 *)(v25 + 12);
        v37 = v31;
        v298 = v32;
        do
        {
          v38 = *(v36 - 2);
          v34 -= 12;
          v39 = *(v36 - 3);
          v40 = *(v36 - 6);
          v41 = v36;
          v42 = *(v36 - 10);
          v36 += 12;
          v43 = (v38 << 16) + (v39 << 8) + *(v36 - 16) + (*(v36 - 13) << 24) + v35;
          v44 = v31 + (v40 << 16) + (*(v36 - 19) << 8) + *(v36 - 20) + (*(v36 - 17) << 24);
          v45 = (v37 + (v42 << 16) + (*(v36 - 23) << 8) + *(v36 - 24) + (*(v36 - 21) << 24) - v43 - v44) ^ (v43 >> 13);
          v46 = (v44 - v43 - v45) ^ (v45 << 8);
          v47 = (v43 - v45 - v46) ^ (v46 >> 13);
          v48 = (v45 - v46 - v47) ^ (v47 >> 12);
          v49 = (v46 - v47 - v48) ^ (v48 << 16);
          v50 = (v47 - v48 - v49) ^ (v49 >> 5);
          v37 = (v48 - v49 - v50) ^ (v50 >> 3);
          v31 = (v49 - v50 - v37) ^ (v37 << 10);
          v35 = (v50 - v37 - v31) ^ (v31 >> 15);
          *((_DWORD *)v25 + 24) = v35;
        }
        while ( v34 > 0xB );
        v32 = v298;
        v51 = v41;
      }
      v52 = strlen(v25) + *((_DWORD *)v25 + 24);
      *((_DWORD *)v25 + 24) = v52;
      v53 = v52;
      switch ( v34 )
      {
        case 1u:
          goto LABEL_32;
        case 2u:
          goto LABEL_31;
        case 3u:
          goto LABEL_30;
        case 4u:
          goto LABEL_29;
        case 5u:
          goto LABEL_28;
        case 6u:
          goto LABEL_27;
        case 7u:
          goto LABEL_26;
        case 8u:
          goto LABEL_25;
        case 9u:
          goto LABEL_24;
        case 0xAu:
          goto LABEL_23;
        case 0xBu:
          v53 = v52 + (v51[10] << 24);
          *((_DWORD *)v25 + 24) = v53;
LABEL_23:
          v53 += v51[9] << 16;
          *((_DWORD *)v25 + 24) = v53;
LABEL_24:
          v53 += v51[8] << 8;
          *((_DWORD *)v25 + 24) = v53;
LABEL_25:
          v31 += v51[7] << 24;
LABEL_26:
          v31 += v51[6] << 16;
LABEL_27:
          v31 += v51[5] << 8;
LABEL_28:
          v31 += v51[4];
LABEL_29:
          v37 += v51[3] << 24;
LABEL_30:
          v37 += v51[2] << 16;
LABEL_31:
          v37 += v51[1] << 8;
LABEL_32:
          v37 += *v51;
          break;
        default:
          break;
      }
      v54 = (v37 - v31 - v53) ^ (v53 >> 13);
      v55 = (v31 - v53 - v54) ^ (v54 << 8);
      v56 = (v53 - v54 - v55) ^ (v55 >> 13);
      v57 = (v54 - v55 - v56) ^ (v56 >> 12);
      v58 = (v55 - v56 - v57) ^ (v57 << 16);
      v59 = (v56 - v57 - v58) ^ (v58 >> 5);
      v60 = (v57 - v58 - v59) ^ (v59 >> 3);
      v61 = (v59 - v60 - ((v58 - v59 - v60) ^ (v60 << 10))) ^ (((v58 - v59 - v60) ^ (v60 << 10)) >> 15);
      *((_DWORD *)v25 + 24) = v61;
      v62 = 12 * (v61 & (*(_DWORD *)(*((_DWORD *)v32 + 17) + 4) - 1));
      ++*(_DWORD *)(**((_DWORD **)v32 + 17) + v62 + 4);
      v63 = *(_DWORD *)(**((_DWORD **)v32 + 17) + v62);
      *((_DWORD *)v25 + 20) = 0;
      *((_DWORD *)v25 + 21) = v63;
      v64 = (_DWORD *)*((_DWORD *)v32 + 17);
      v65 = *(_DWORD *)(*v64 + v62);
      if ( v65 )
      {
        *(_DWORD *)(v65 + 12) = v301;
        v64 = (_DWORD *)*((_DWORD *)v32 + 17);
      }
      *(_DWORD *)(*v64 + v62) = v301;
      v66 = *(_QWORD *)(v62 + **((_DWORD **)v32 + 17) + 4);
      if ( (unsigned int)v66 < 10 * HIDWORD(v66) + 10 || (v67 = *((_DWORD *)v25 + 17), *(_DWORD *)(v67 + 36) == 1) )
      {
LABEL_37:
        strcpy(byte_72C40, v25);
        dword_73B80 = (int)&dword_73B80;
        dword_73B84 = (int)&dword_73B80;
        sub_49118(&off_6C2C8, "Options for both config file and command line");
        sub_49118(&off_6CAAC, "Options for command line only");
        sub_49194(&v306, format, sub_17404);
        if ( v306 != 1 )
        {
          strcpy(s, "Unexpected extra commandline arguments");
          sub_343C4(3, s, 1);
          sub_1B070(1, 0);
        }
        v68 = *((unsigned __int8 *)v305 + 864);
        if ( !*((_BYTE *)v305 + 864) )
        {
          v161 = malloc(0x1000u);
          v162 = v305;
          v305[217] = (int)v161;
          sub_1A918();
          if ( access((const char *)v162[217], 4) )
          {
            v163 = v305;
            free((void *)v305[217]);
            v163[217] = v68;
          }
          else
          {
            sub_1B7FC((char *)v162[217]);
          }
        }
        if ( *((_BYTE *)v305 + 1377) || v305[271] )
        {
          if ( byte_73D04 )
          {
            strcpy(s, "Cannot use benchmark mode with scrypt");
            sub_343C4(3, s, 1);
            sub_1B070(1, 1);
          }
          v69 = sub_1E3F0();
          v70 = (char *)malloc(0xFFu);
          v71 = v305;
          *(_DWORD *)(v69 + 172) = v70;
          if ( v71[271] )
            strcpy(v70, "Benchfile");
          else
            strcpy(v70, "Benchmark");
          v72 = *(_DWORD *)(v69 + 172);
          *(_DWORD *)(v69 + 180) = v72;
          *(_DWORD *)(v69 + 184) = v72;
          *(_DWORD *)(v69 + 176) = v72;
          *(_DWORD *)(v69 + 600) = v72;
          strncpy((char *)(v69 + 48), "?", 7u);
          v73 = *(_DWORD *)(v69 + 100);
          *(_BYTE *)(v69 + 55) = 0;
          if ( v73 != 1 )
            sub_1747C(v69 + 100);
          v74 = (char *)&unk_6DDF4;
          v75 = 0;
          *(_BYTE *)(v69 + 97) = 0;
          v76 = (char *)&unk_6E7FC;
          byte_6F915 = 1;
          do
          {
            v77 = v74;
            v74 += 160;
            sub_28324(v77, &a000000029c6bf4[v75]);
            v78 = &a00000002c01f50[v75];
            v75 += 324;
            sub_28324(v76, v78);
            v76 += 160;
          }
          while ( v75 != 5184 );
          sub_1A9C0(&unk_6F3AC);
        }
        v79 = (const char *)v305[5];
        if ( !v79 )
          goto LABEL_65;
        v80 = fopen(v79, "rb");
        memset(v308, 0, sizeof(v308));
        if ( v80 )
        {
          v81 = fread(v308, 1u, 0x100u, v80);
          if ( v81 <= 0 )
          {
            v84 = &byte_73320;
            if ( !byte_73320 && !byte_6FA70 && dword_6D35C <= 2 )
              goto LABEL_197;
            snprintf(s, 0x800u, "Read miner version file %s error %d", (const char *)v305[5], v81);
            sub_343C4(3, s, 0);
          }
          else
          {
            v82 = strchr(v308, 10);
            v83 = v82;
            if ( v82 )
            {
              memcpy(byte_6F3CC, v308, v82 - v308);
              strcpy(dest, v83 + 1);
            }
            else
            {
              strcpy(byte_6F3CC, v308);
            }
            LOWORD(v84) = 13088;
            v85 = &v304[strlen(byte_6F3CC) - 1];
            if ( v85[2692] == 10 )
              v85[2692] = 0;
            v86 = &v304[strlen(byte_6F3CC) - 1];
            if ( v86[2692] == 13 )
              v86[2692] = 0;
            v87 = &v304[strlen(dest) - 1];
            if ( v87[2948] == 10 )
              v87[2948] = 0;
            v88 = &v304[strlen(dest) - 1];
            HIWORD(v84) = 7;
            if ( v88[2948] == 13 )
              v88[2948] = 0;
          }
        }
        else
        {
          v84 = &byte_73320;
          if ( !byte_73320 && !byte_6FA70 && dword_6D35C <= 2 )
            goto LABEL_197;
          snprintf(s, 0x800u, "Open miner version file %s error", (const char *)v305[5]);
          sub_343C4(3, s, 0);
        }
        if ( *v84 || byte_6FA70 )
          goto LABEL_64;
LABEL_197:
        if ( dword_6D35C > 2 )
        {
LABEL_64:
          snprintf(s, 0x800u, "Miner compile time: %s type: %s", byte_6F3CC, dest);
          sub_343C4(3, s, 0);
        }
LABEL_65:
        v89 = v305;
        v90 = (const char *)v305[1];
        if ( v90 )
        {
          *(_BYTE *)v302 = 1;
          strcpy((char *)&dword_6F970, v90);
          v91 = (const char *)v89[4];
          if ( v91 )
            strcpy((char *)&word_6F950, v91);
          v92 = &byte_73320;
          if ( !byte_73320 && !byte_6FA70 && dword_6D35C <= 2 )
          {
            v93 = (const char *)v305[3];
            if ( !v93 )
            {
LABEL_179:
              if ( dword_6D35C <= 3 )
              {
LABEL_104:
                v108 = (const char *)v305[217];
                if ( !v108 )
                  goto LABEL_117;
                if ( byte_6FA71 )
                {
                  if ( !*v92 && !byte_6FA70 && dword_6D35C <= 6 )
                  {
                    v109 = v305[269];
                    if ( v109 != -1 )
                    {
LABEL_110:
                      if ( !v109 )
                      {
                        if ( (*v92 || byte_6FA70 || dword_6D35C > 3)
                          && ((strcpy(s, "Fatal JSON error in configuration file."), sub_343C4(4, s, 0), *v92)
                           || byte_6FA70)
                          || dword_6D35C > 3 )
                        {
                          strcpy(s, "Configuration file could not be used.");
                          sub_343C4(4, s, 0);
                        }
                      }
                      goto LABEL_116;
                    }
LABEL_188:
                    if ( !byte_6FA70 && dword_6D35C <= 3 )
                    {
                      if ( !byte_73228 )
                        goto LABEL_116;
                      goto LABEL_191;
                    }
LABEL_209:
                    strcpy(s, "Error in configuration file, partially loaded.");
                    sub_343C4(4, s, 0);
                    if ( !byte_73228 )
                      goto LABEL_116;
                    if ( *v92 || byte_6FA70 )
                      goto LABEL_192;
LABEL_191:
                    if ( dword_6D35C > 3 )
                    {
LABEL_192:
                      strcpy(s, "Start cgminer with -T to see what failed to load.");
                      sub_343C4(4, s, 0);
                    }
LABEL_116:
                    v110 = v305;
                    free((void *)v305[217]);
                    v110[217] = 0;
LABEL_117:
                    *(_WORD *)&(*v297)[strlen(*v297)] = *(_WORD *)HIDWORD(v299);
                    if ( byte_72E28 )
                      byte_6FA70 = 1;
                    if ( dword_6CA98 < 0 )
                    {
                      if ( byte_73D04 )
                        v111 = 30;
                      else
                        v111 = 60;
                      dword_6CA98 = v111;
                    }
                    *((_DWORD *)v304 + 934) = 8;
                    v112 = calloc(8u, 0x40u);
                    v282 = &dword_735C0;
                    dword_735C0 = (int)v112;
                    if ( v112 )
                    {
                      format = (char *)&unk_738C8;
                      sub_26BEC(&unk_73C20);
                      v283 = format;
                      sub_26BEC(format);
                      sub_26BEC(&unk_72EF8);
                      sub_26BEC(&unk_73118);
                      sub_26BEC(&unk_72D10);
                      format = (char *)(unsigned __int16)&unk_733E0;
                      sub_26BEC(&unk_72C88);
                      sub_26BEC(&unk_73840);
                      LOWORD(v113) = (_WORD)format;
                      v301 = (char *)(unsigned __int16)&unk_73328;
                      HIWORD(v113) = (unsigned int)&unk_733E0 >> 16;
                      v302 = (int *)(unsigned __int16)&unk_73090;
                      format = v113;
                      sub_26BEC(&unk_6D768);
                      LOWORD(v114) = (_WORD)v302;
                      HIWORD(v114) = (unsigned int)&unk_73090 >> 16;
                      v302 = v114;
                      sub_26BEC(format);
                      LOWORD(v115) = (_WORD)v301;
                      LODWORD(v299) = (unsigned __int16)&unk_73A20;
                      HIDWORD(v299) = (unsigned __int16)&unk_73D90;
                      HIWORD(v115) = (unsigned int)&unk_73328 >> 16;
                      v301 = v115;
                      sub_26BEC(v302);
                      LOWORD(v116) = WORD2(v299);
                      HIWORD(v116) = (unsigned int)&unk_73D90 >> 16;
                      HIDWORD(v299) = v116;
                      sub_26BEC(v301);
                      LOWORD(v117) = v299;
                      v298 = (char *)(unsigned __int16)&unk_73710;
                      HIWORD(v117) = (unsigned int)&unk_73A20 >> 16;
                      v297 = (const char **)(unsigned __int16)&unk_73198;
                      LODWORD(v299) = v117;
                      sub_26BEC(HIDWORD(v299));
                      LOWORD(v118) = (_WORD)v298;
                      HIWORD(v118) = (unsigned int)&unk_73710 >> 16;
                      v298 = v118;
                      sub_26BEC(v299);
                      LOWORD(v119) = (_WORD)v297;
                      v296 = (unsigned __int16)&unk_72E40;
                      v295 = (unsigned __int16)&unk_72DA8;
                      HIWORD(v119) = (unsigned int)&unk_73198 >> 16;
                      v297 = (const char **)v119;
                      sub_26BEC(v298);
                      LOWORD(v120) = v296;
                      HIWORD(v120) = (unsigned int)&unk_72E40 >> 16;
                      v296 = v120;
                      sub_26BEC(v297);
                      LOWORD(v121) = v295;
                      v294 = (unsigned __int16)&unk_73D08;
                      HIWORD(v121) = (unsigned int)&unk_72DA8 >> 16;
                      v293 = (unsigned __int16)&unk_73968;
                      v295 = v121;
                      sub_26BEC(v296);
                      LOWORD(v122) = v294;
                      HIWORD(v122) = (unsigned int)&unk_73D08 >> 16;
                      v294 = v122;
                      sub_26BEC(v295);
                      LOWORD(v123) = v293;
                      v292 = (unsigned __int16)&unk_73008;
                      v291 = (unsigned __int16)&unk_73230;
                      HIWORD(v123) = (unsigned int)&unk_73968 >> 16;
                      v293 = v123;
                      sub_26BEC(v294);
                      LOWORD(v124) = v292;
                      HIWORD(v124) = (unsigned int)&unk_73008 >> 16;
                      v292 = v124;
                      sub_26BEC(v293);
                      LOWORD(v125) = v291;
                      HIWORD(v125) = (unsigned int)&unk_73230 >> 16;
                      v291 = v125;
                      v290 = (unsigned __int16)&unk_73688;
                      v289 = (unsigned __int16)&unk_735F8;
                      sub_26BEC(v292);
                      LOWORD(v126) = v290;
                      HIWORD(v126) = (unsigned int)&unk_73688 >> 16;
                      v290 = v126;
                      sub_26BEC(v291);
                      LOWORD(v127) = v289;
                      HIWORD(v127) = (unsigned int)&unk_735F8 >> 16;
                      v289 = v127;
                      v288 = (unsigned __int16)&unk_73530;
                      v287 = (unsigned __int16)&unk_72F80;
                      sub_26BEC(v290);
                      LOWORD(v128) = v288;
                      HIWORD(v128) = (unsigned int)&unk_73530 >> 16;
                      v288 = v128;
                      sub_26BEC(v289);
                      LOWORD(v129) = v287;
                      HIWORD(v129) = (unsigned int)&unk_72F80 >> 16;
                      v287 = v129;
                      v286 = (unsigned __int16)&unk_734A0;
                      v285 = (unsigned __int16)&unk_73BA0;
                      sub_26BEC(v288);
                      LOWORD(v130) = v286;
                      HIWORD(v130) = (unsigned int)&unk_734A0 >> 16;
                      v286 = v130;
                      sub_26BEC(v287);
                      LOWORD(v131) = v285;
                      HIWORD(v131) = (unsigned int)&unk_73BA0 >> 16;
                      v285 = v131;
                      sub_26BEC(v286);
                      v284 = (size_t *)(unsigned __int16)&dword_735B0;
                      sub_26BEC(v285);
                      (*(void (__fastcall **)(_DWORD))(v132 + 12))(0);
                      (*((void (__fastcall **)(_DWORD))v283 + 3))(0);
                      off_72F04(0);
                      off_73124(0);
                      ((void (__fastcall *)(_DWORD))off_72D1C)(0);
                      ((void (__fastcall *)(_DWORD))off_72C94)(0);
                      ((void (__fastcall *)(_DWORD))off_7384C)(0);
                      ((void (__fastcall *)(_DWORD))off_6D774)(0);
                      v133 = 0;
                      (*((void (__fastcall **)(_DWORD))format + 3))(0);
                      ((void (__fastcall *)(_DWORD))v302[3])(0);
                      (*((void (__fastcall **)(_DWORD))v301 + 3))(0);
                      (*(void (__fastcall **)(_DWORD))(HIDWORD(v299) + 0xC))(0);
                      (*(void (__fastcall **)(_DWORD))(v299 + 0xC))(0);
                      (*((void (__fastcall **)(_DWORD))v298 + 3))(0);
                      ((void (__fastcall *)(_DWORD))v297[3])(0);
                      (*(void (__fastcall **)(_DWORD))(v296 + 0xC))(0);
                      (*(void (__fastcall **)(_DWORD))(v295 + 0xC))(0);
                      (*(void (__fastcall **)(_DWORD))(v294 + 0xC))(0);
                      (*(void (__fastcall **)(_DWORD))(v293 + 0xC))(0);
                      (*(void (__fastcall **)(_DWORD))(v292 + 0xC))(0);
                      (*(void (__fastcall **)(_DWORD))(v291 + 0xC))(0);
                      (*(void (__fastcall **)(_DWORD))(v290 + 0xC))(0);
                      (*(void (__fastcall **)(_DWORD))(v289 + 0xC))(0);
                      (*(void (__fastcall **)(_DWORD))(v288 + 0xC))(0);
                      (*(void (__fastcall **)(_DWORD))(v287 + 0xC))(0);
                      (*(void (__fastcall **)(_DWORD))(v286 + 0xC))(0);
                      (*(void (__fastcall **)(_DWORD))(v285 + 0xC))(0);
                      LOWORD(v134) = (_WORD)v284;
                      HIWORD(v134) = (unsigned int)&dword_735B0 >> 16;
                      v284 = v134;
                      *v134 = 0;
                      while ( dword_735E8 > v133 )
                      {
                        v135 = *(_DWORD *)(dword_73110 + 4 * v133++);
                        sub_26E3C(v135);
                      }
                      if ( dword_735E8 )
                      {
                        v136 = (char *)v305[202];
                        *((_DWORD *)v304 + 663) = dword_735E8;
                        if ( v136 )
                        {
                          v137 = 0;
                          v138 = 0;
                          for ( i = strtok(v136, ","); i; i = strtok(format, ",") )
                          {
                            if ( dword_735E8 <= v137 )
                            {
                              strcpy(s, "Too many values passed to set temp cutoff");
LABEL_175:
                              sub_343C4(3, s, 1);
                              sub_1B070(1, 1);
                            }
                            v138 = strtol(i, 0, 10);
                            if ( v138 > 0xC8 )
                            {
                              v164 = "ssed to set temp cutoff";
                              qmemcpy(s, "Invalid value pa", 16);
                              v165 = &s[16];
                              goto LABEL_207;
                            }
                            if ( pthread_rwlock_rdlock(&stru_73CCC) )
                              sub_1C994("load_temp_cutoffs", 1443);
                            *(_DWORD *)(*(_DWORD *)(dword_73110 + 4 * v137) + 184) = v138;
                            if ( pthread_rwlock_unlock(&stru_73CCC) )
                            {
                              v211 = _errno_location();
                              v212 = "load_temp_cutoffs";
                              v213 = 1445;
LABEL_296:
                              snprintf(
                                s,
                                0x800u,
                                "WTF RWLOCK ERROR ON UNLOCK! errno=%d in %s %s():%d",
                                *v211,
                                "cgminer.c",
                                v212,
                                v213);
                              goto LABEL_208;
                            }
                            ++v137;
                            format = 0;
                            off_6CB70();
                          }
                          if ( v137 > 1 )
                          {
                            v302 = &dword_73110;
                            goto LABEL_233;
                          }
                          if ( pthread_rwlock_rdlock(&stru_73CCC) )
                            sub_1C994("load_temp_cutoffs", 1462);
                          v214 = dword_735E8;
                          v302 = &dword_73110;
                          v215 = dword_73110;
                          while ( v137 < v214 )
                          {
                            v216 = *(_DWORD *)(v215 + 4 * v137++);
                            *(_DWORD *)(v216 + 184) = v138;
                          }
                          if ( pthread_rwlock_unlock(&stru_73CCC) )
                            sub_1C70C("load_temp_cutoffs", 1465);
                        }
                        else
                        {
                          v177 = pthread_rwlock_rdlock(&stru_73CCC);
                          if ( v177 )
                            sub_1C994("load_temp_cutoffs", 1450);
                          v178 = dword_735E8;
                          v302 = &dword_73110;
                          v179 = dword_73110;
                          while ( v177 < v178 )
                          {
                            v180 = *(_DWORD *)(v179 + 4 * v177);
                            if ( !*(_DWORD *)(v180 + 184) )
                              *(_DWORD *)(v180 + 184) = 95;
                            ++v177;
                          }
                          if ( pthread_rwlock_unlock(&stru_73CCC) )
                            sub_1C70C("load_temp_cutoffs", 1456);
                        }
                        off_6CB70();
LABEL_233:
                        v181 = dword_735E8;
                        v182 = *v302;
                        for ( j = 0; v181 > j; ++j )
                        {
                          v184 = *(_DWORD *)(v182 + 4 * j);
                          *(_DWORD *)(v184 + 312) = 99999999;
                        }
                        if ( !byte_739F0 )
                          *((_DWORD *)v304 + 664) += *((_DWORD *)v304 + 663);
                        if ( !dword_72EF0 )
                        {
                          if ( *v92 || byte_6FA70 || dword_6D35C > 3 )
                          {
                            strcpy(s, "Need to specify at least one pool server.");
                            sub_343C4(4, s, 0);
                          }
                          strcpy(s, "Pool setup failed");
                          sub_343C4(3, s, 1);
                          sub_1B070(1, 0);
                        }
                        v185 = 0;
                        format = (char *)&dword_732EC;
                        v301 = "%s:%s";
                        while ( 1 )
                        {
                          v186 = *(const char **)format;
                          if ( dword_72EF0 <= v185 )
                            break;
                          v187 = *(_DWORD *)&v186[4 * v185];
                          v188 = *(_DWORD *)(v187 + 176);
                          *(_DWORD *)(v187 + 404) = 99999999;
                          *(_DWORD *)(v187 + 440) = 99999999;
                          if ( !v188 )
                          {
                            if ( !*(_DWORD *)(v187 + 184) )
                              *(_DWORD *)(v187 + 184) = calloc(1u, 1u);
                            if ( !*(_DWORD *)(v187 + 180) )
                            {
                              snprintf(
                                s,
                                0x800u,
                                "No login credentials supplied for pool %u %s",
                                v185,
                                *(const char **)(v187 + 172));
                              sub_343C4(3, s, 1);
                              sub_1B070(1, 0);
                            }
                            LODWORD(v299) = *(_DWORD *)(v187 + 180);
                            v189 = strlen((const char *)v299);
                            HIDWORD(v299) = *(_DWORD *)(v187 + 184);
                            v190 = v189 + strlen((const char *)HIDWORD(v299)) + 2;
                            v191 = (char *)malloc(v190);
                            v192 = v299;
                            *(_DWORD *)(v187 + 176) = v191;
                            if ( !v191 )
                            {
                              strcpy(s, "Failed to malloc userpass");
                              goto LABEL_300;
                            }
                            snprintf(v191, v190, v301, (_DWORD)v192, HIDWORD(v192));
                          }
                          ++v185;
                        }
                        v193 = (unsigned __int8)*v92;
                        v305[318] = *(_DWORD *)v186;
                        if ( v193 )
                          openlog("cgminer", 1, 8);
                        if ( *((_DWORD *)v304 + 935) )
                        {
                          if ( pipe((int *)s) < 0 )
                          {
                            perror("pipe - failed to create pipe for --monitor");
                            exit(1);
                          }
                          fflush((FILE *)stderr);
                          if ( dup2(*(int *)&s[4], 2) < 0 )
                          {
                            perror("dup2 - failed to alias stderr to write end of pipe for --monitor");
                            exit(1);
                          }
                          if ( close(*(int *)&s[4]) < 0 )
                          {
                            perror("close - failed to close write end of pipe for --monitor");
                            exit(1);
                          }
                          v194 = signal(13, (__sighandler_t)1);
                          v195 = signal(13, (__sighandler_t)1);
                          if ( v194 == (__sighandler_t)-1 || v195 == (__sighandler_t)-1 )
                          {
                            perror("signal - failed to edit signal mask for --monitor");
                            exit(1);
                          }
                          v196 = fork();
                          v197 = v196;
                          v305[209] = v196;
                          if ( v196 < 0 )
                          {
                            perror("fork - failed to fork child process for --monitor");
                            exit(1);
                          }
                          if ( !v196 )
                          {
                            if ( dup2(*(int *)s, v196) >= 0 )
                            {
                              close(*(int *)s);
                              execl("/bin/bash", "/bin/bash", "-c", *((_DWORD *)v304 + 935), v197);
                              perror("execl - in child failed to exec user specified command for --monitor");
                              exit(1);
                            }
                            perror("dup2 - in child, failed to alias read end of pipe to stdin for --monitor");
                            exit(1);
                          }
                          if ( close(*(int *)s) < 0 )
                          {
                            perror("close - failed to close read end of pipe for --monitor");
                            exit(1);
                          }
                        }
                        v198 = calloc(*v284, 4u);
                        LODWORD(v299) = &dword_732C8;
                        dword_732C8 = (int)v198;
                        if ( !v198 )
                        {
                          strcpy(s, "Failed to calloc mining_thr");
LABEL_278:
                          sub_343C4(3, s, 1);
                          sub_1B070(1, 0);
                        }
                        v199 = (int *)v299;
                        v200 = 0;
                        v201 = (int *)v284;
                        while ( *v201 > v200 )
                        {
                          v202 = *v199;
                          *(_DWORD *)(v202 + 4 * v200) = calloc(1u, 0x40u);
                          if ( !*(_DWORD *)(*v199 + 4 * v200) )
                          {
                            snprintf(s, 0x800u, "Failed to calloc mining_thr[%d]", v200);
                            goto LABEL_278;
                          }
                          ++v200;
                        }
                        v301 = 0;
                        HIDWORD(v299) = 0;
                        v298 = (char *)sub_17300;
                        v297 = (const char **)&byte_6FA71;
                        while ( dword_735E8 > (int)v301 )
                        {
                          v203 = *(_DWORD **)(*v302 + 4 * (_DWORD)v301);
                          v204 = 4 * (v203[37] + 1);
                          v205 = (char *)malloc(v204);
                          v206 = &v205[v204];
                          v207 = 0;
                          v203[38] = v205;
                          *((_DWORD *)v206 - 1) = 0;
                          v203[24] = 4;
                          while ( 1 )
                          {
                            v208 = HIDWORD(v299) + v207;
                            if ( v203[37] <= v207 )
                              break;
                            v209 = (_DWORD *)sub_1DD14(HIDWORD(v299) + v207);
                            *v209 = v208;
                            v210 = v209;
                            v209[9] = v203;
                            v209[1] = v207;
                            if ( (*(int (**)(void))(v203[1] + 44))() )
                            {
                              if ( sub_2D7E0(v210, 0, v298) )
                              {
                                snprintf(s, 0x800u, "thread %d create failed", *v210);
                                sub_343C4(3, s, 1);
                                sub_1B070(1, 0);
                              }
                              *(_DWORD *)(v203[38] + 4 * v207) = v210;
                              if ( v203[8] != 1 )
                              {
                                if ( *(_BYTE *)v297 && (*v92 || byte_6FA70 || dword_6D35C > 6) )
                                {
                                  snprintf(s, 0x800u, "Pushing sem post to thread %d", *v210);
                                  sub_343C4(7, s, 0);
                                }
                                sub_2D818(v210 + 4, "cgminer.c", "main", 11713);
                              }
                            }
                            ++v207;
                          }
                          HIDWORD(v299) += v207;
                          ++v301;
                        }
                        if ( !*((_BYTE *)v305 + 1377) )
                        {
                          v222 = v305[271];
                          if ( !v222 )
                          {
                            v223 = format;
                            while ( dword_72EF0 > v222 )
                            {
                              v224 = *(_DWORD *)(*(_DWORD *)v223 + 4 * v222);
                              if ( *(_DWORD *)(v224 + 100) != 1 )
                                sub_1747C(v224 + 100);
                              ++v222;
                              *(_BYTE *)(v224 + 97) = 1;
                            }
                            if ( byte_6FA71 && (*v92 || byte_6FA70 || dword_6D35C > 6) )
                            {
                              strcpy(s, "Probing for an alive pool");
                              sub_343C4(7, s, 0);
                            }
                            v225 = format;
                            for ( k = 0; k < dword_72EF0; ++k )
                            {
                              v227 = *(_DWORD *)(*(_DWORD *)v225 + 4 * k);
                              *(_BYTE *)(v227 + 292) = 1;
                              pthread_create((pthread_t *)(v227 + 288), 0, (void *(*)(void *))sub_1F5E0, (void *)v227);
                            }
                            v232 = 0;
                            do
                            {
                              ++v232;
                              sleep(1u);
                              if ( v232 == 60 )
                                v233 = 0;
                              else
                                v233 = (*((_BYTE *)v305 + 1376) ^ 1) & 1;
                            }
                            while ( v233 );
                            HIDWORD(v299) = "Pool: %d  URL: %s  User: %s  Password: %s";
                            v301 = &byte_73228;
                            while ( 1 )
                            {
                              if ( *((_BYTE *)v305 + 1376) )
                                goto LABEL_311;
                              if ( v233 )
                                goto LABEL_344;
                              if ( ((*v92 || byte_6FA70 || dword_6D35C > 2)
                                 && ((strcpy(s, "No servers were found that could be used to get work from."),
                                      sub_343C4(3, s, 0),
                                      *v92)
                                  || byte_6FA70)
                                 || dword_6D35C > 2)
                                && ((strcpy(
                                       s,
                                       "Please check the details from the list below of the servers you have input"),
                                     sub_343C4(3, s, 0),
                                     *v92)
                                 || byte_6FA70)
                                || dword_6D35C > 2 )
                              {
                                strcpy(
                                  s,
                                  "Most likely you have input the wrong URL, forgotten to add a port, or have not set up workers");
                                sub_343C4(3, s, 0);
                              }
                              for ( m = 0; dword_72EF0 > m; ++m )
                              {
                                v275 = *(_DWORD **)(*(_DWORD *)format + 4 * m);
                                if ( *v92 || byte_6FA70 || dword_6D35C > 3 )
                                {
                                  v276 = v275[46];
                                  v298 = s;
                                  snprintf(s, 0x800u, (const char *)HIDWORD(v299), m, v275[43], v275[45], v276);
                                  sub_343C4(4, v298, 0);
                                }
                              }
                              if ( !*v301 )
                              {
LABEL_459:
                                sub_424C8(&byte_6DDB0);
                                strcpy(s, "Pool is activing, exiting and restart cgminer.");
                                sub_343C4(3, s, 1);
                                sub_1B070(0, 0);
                              }
                              if ( *v92 || byte_6FA70 || dword_6D35C > 2 )
                                break;
LABEL_345:
                              v233 = 1;
                            }
                            strcpy(s, "Press any key to exit, or cgminer will wait indefinitely for an alive pool.");
                            sub_343C4(3, s, 0);
LABEL_344:
                            if ( !*v301 )
                              goto LABEL_459;
                            goto LABEL_345;
                          }
                        }
LABEL_311:
                        v217 = (int *)&unk_6DCB0;
                        dbl_739E8 = 0.0;
                        do
                        {
                          *(_QWORD *)v217 = 0;
                          v217 += 2;
                        }
                        while ( &dword_6DD10 != v217 );
                        v218 = dword_735E8;
                        v219 = v300;
                        v220 = *v302;
                        v305[304] = 0;
                        while ( v218 > v219 )
                        {
                          v221 = *(_DWORD *)(v220 + 4 * v219++);
                          *(_QWORD *)(v221 + 80) = 0;
                          *(_QWORD *)(v221 + 48) = 0;
                        }
                        sub_2A69C(&dword_6DCA0);
                        sub_2A69C(&dword_6DB8C);
                        sub_2A69C(&unk_6DCA8);
                        sub_19C2C(&unk_6DD14, 40);
                        v228 = *v282;
                        v305[316] = 2;
                        if ( sub_2D7E0(v228 + 128, 0, sub_1F7BC) )
                        {
                          strcpy(s, "watchpool thread create failed");
                          sub_343C4(3, s, 1);
                          sub_1B070(1, 0);
                        }
                        pthread_detach(*(_DWORD *)(v228 + 140));
                        v229 = *v282;
                        v305[317] = 3;
                        if ( sub_2D7E0(v229 + 192, 0, sub_226B0) )
                        {
                          strcpy(s, "watchdog thread create failed");
                          sub_343C4(3, s, 1);
                          sub_1B070(1, 0);
                        }
                        pthread_detach(*(_DWORD *)(v229 + 204));
                        v230 = *v282;
                        v305[200] = 5;
                        if ( sub_2D7E0(v230 + 320, 0, 96485) )
                        {
                          strcpy(s, "API thread create failed");
LABEL_300:
                          sub_343C4(3, s, 1);
                          sub_1B070(1, 0);
                        }
                        v231 = *((_DWORD *)v304 + 934);
                        if ( v231 == 8 )
                        {
                          if ( !nice(-10) && byte_6FA71 && (*v92 || byte_6FA70 || dword_6D35C > 6) )
                          {
                            strcpy(s, "Unable to set thread to high priority");
                            sub_343C4(7, s, 0);
                          }
                          v234 = v304;
                          v304 = &byte_73680;
                          v301 = &byte_73CB0;
                          while ( 1 )
                          {
                            if ( *v301 )
                            {
                              if ( byte_6FA71 && (*v92 || byte_6FA70 || dword_6D35C > 6) )
                              {
                                strcpy(s, "Work update message received");
                                sub_343C4(7, s, 0);
                              }
                              sub_2A69C(&unk_6DB84);
                              v269 = pthread_rwlock_rdlock(&stru_732CC);
                              if ( v269 )
                              {
                                v273 = _errno_location();
                                snprintf(
                                  s,
                                  0x800u,
                                  "WTF RDLOCK ERROR ON LOCK! errno=%d in %s %s():%d",
                                  *v273,
                                  "cgminer.c",
                                  "signal_work_update",
                                  5624);
LABEL_208:
                                sub_343C4(3, s, 1);
                                sub_1B070(1, 1);
                              }
                              v270 = *v284;
                              v271 = *(_DWORD *)v299;
                              while ( v269 < v270 )
                              {
                                v272 = *(_DWORD *)(v271 + 4 * v269++);
                                *(_BYTE *)(v272 + 63) = 1;
                              }
                              if ( pthread_rwlock_unlock(&stru_732CC) )
                              {
                                v211 = _errno_location();
                                v212 = "signal_work_update";
                                v213 = 5627;
                                goto LABEL_296;
                              }
                              off_6CB70();
                            }
                            *v301 = 0;
                            v235 = ((int (*)(void))sub_1E098)();
                            v236 = sub_1E098(v235);
                            v237 = v236;
                            v238 = v305[201];
                            if ( v238 == 4 )
                            {
                              v236 = sub_17B90();
                              v239 = (_DWORD *)v236;
                            }
                            else if ( v238 == 3 )
                            {
                              v259 = 0;
                              v260 = dword_72EF0;
                              v261 = *(_DWORD *)format;
                              while ( v259 < dword_72EF0 )
                              {
                                v236 = *(_DWORD *)(*(_DWORD *)(v261 + 4 * v259) + 60);
                                if ( *(_DWORD *)(*(_DWORD *)(v261 + 4 * v259) + 64) < v236 )
                                  goto LABEL_426;
                                ++v259;
                              }
                              v262 = 0;
                              v236 = 0;
                              while ( v260 > v262 )
                              {
                                v263 = *(_DWORD *)(v261 + 4 * v262++);
                                *(_DWORD *)(v263 + 64) = 0;
                              }
                              v264 = *((_DWORD *)v234 + 936) + 1;
                              *((_DWORD *)v234 + 936) = v264;
                              if ( v260 <= v264 )
                                *((_DWORD *)v234 + 936) = 0;
LABEL_426:
                              for ( n = 0; ; n = v266 )
                              {
                                v266 = n + 1;
                                if ( n >= dword_72EF0 )
                                  break;
                                v239 = *(_DWORD **)(*(_DWORD *)format + 4 * *((_DWORD *)v234 + 936));
                                v267 = *(_QWORD *)(v239 + 15);
                                v261 = HIDWORD(v267) + 1;
                                v239[16] = HIDWORD(v267) + 1;
                                if ( SHIDWORD(v267) < (int)v267 )
                                {
                                  if ( !*((_BYTE *)v239 + 97)
                                    && v239[25] == 1
                                    && (!*((_BYTE *)v239 + 640) || *((_BYTE *)v239 + 641)) )
                                  {
                                    goto LABEL_357;
                                  }
                                  if ( *v304 )
                                  {
                                    v236 = sub_174F4(0, v261);
                                    --*(_DWORD *)(v236 + 64);
                                  }
                                }
                                v268 = *((_DWORD *)v234 + 936) + 1;
                                v154 = v268 < dword_72EF0;
                                *((_DWORD *)v234 + 936) = v268;
                                if ( !v154 )
                                  *((_DWORD *)v234 + 936) = 0;
                              }
                              for ( ii = 0; ; ++ii )
                              {
                                if ( ii >= dword_72EF0 )
                                  goto LABEL_356;
                                v236 = sub_174F4(ii, v261);
                                if ( !*(_BYTE *)(v236 + 97) && *(_DWORD *)(v236 + 100) == 1 )
                                  break;
                              }
                              v239 = (_DWORD *)v236;
                            }
                            else
                            {
LABEL_356:
                              v239 = (_DWORD *)v237;
                            }
LABEL_357:
                            if ( byte_6FA71 && (*v92 || byte_6FA70 || dword_6D35C > 6) )
                            {
                              snprintf(s, 0x800u, "Selecting pool %d for work", *v239);
                              v236 = sub_343C4(7, s, 0);
                            }
LABEL_362:
                            v240 = *((unsigned __int8 *)v239 + 640);
                            if ( *((_BYTE *)v239 + 640) )
                            {
                              while ( !*((_BYTE *)v239 + 641) || !*((_BYTE *)v239 + 643) )
                              {
                                v302 = (int *)sub_1E098(v236);
                                v242 = v305[201];
                                if ( v242 == 4 )
                                {
                                  v241 = (_DWORD *)sub_17B90();
                                  goto LABEL_365;
                                }
                                if ( v242 != 3 && *v304 )
                                {
                                  v241 = v302;
                                }
                                else
                                {
                                  v243 = 0;
                                  v244 = dword_72EF0;
                                  v245 = *(const char **)format;
                                  while ( v243 < dword_72EF0 )
                                  {
                                    v246 = *(_QWORD *)(*(_DWORD *)&v245[4 * v243] + 60);
                                    if ( SHIDWORD(v246) < (int)v246 )
                                      goto LABEL_385;
                                    ++v243;
                                  }
                                  for ( jj = 0; v244 > jj; ++jj )
                                  {
                                    v248 = *(_DWORD *)&v245[4 * jj];
                                    *(_DWORD *)(v248 + 64) = 0;
                                  }
                                  v249 = *((_DWORD *)v234 + 936) + 1;
                                  *((_DWORD *)v234 + 936) = v249;
                                  if ( v244 <= v249 )
                                    *((_DWORD *)v234 + 936) = 0;
LABEL_385:
                                  for ( kk = 0; ; kk = v251 )
                                  {
                                    v251 = kk + 1;
                                    if ( kk >= dword_72EF0 )
                                      break;
                                    v252 = *(_DWORD *)(*(_DWORD *)format + 4 * *((_DWORD *)v234 + 936));
                                    v245 = *(const char **)(v252 + 64);
                                    v253 = *(_DWORD *)(v252 + 60);
                                    *(_DWORD *)(v252 + 64) = v245 + 1;
                                    if ( (int)v245 < v253 )
                                    {
                                      if ( !*(_BYTE *)(v252 + 97)
                                        && *(_DWORD *)(v252 + 100) == 1
                                        && (!*(_BYTE *)(v252 + 640) || *(_BYTE *)(v252 + 641)) )
                                      {
                                        v241 = (_DWORD *)v252;
                                        goto LABEL_365;
                                      }
                                      if ( *v304 )
                                      {
                                        v254 = sub_174F4(0, v245);
                                        --*(_DWORD *)(v254 + 64);
                                      }
                                    }
                                    v255 = *((_DWORD *)v234 + 936) + 1;
                                    v154 = v255 < dword_72EF0;
                                    *((_DWORD *)v234 + 936) = v255;
                                    if ( !v154 )
                                      *((_DWORD *)v234 + 936) = 0;
                                  }
                                  v256 = v239;
                                  for ( mm = 0; mm < dword_72EF0; ++mm )
                                  {
                                    v258 = sub_174F4(mm, v245);
                                    if ( !*(_BYTE *)(v258 + 97) && *(_DWORD *)(v258 + 100) == 1 )
                                    {
                                      v239 = v256;
                                      v241 = (_DWORD *)v258;
                                      goto LABEL_365;
                                    }
                                  }
                                  v239 = v256;
                                  v241 = v302;
                                }
LABEL_365:
                                if ( byte_6FA71 && (*v92 || byte_6FA70 || dword_6D35C > 6) )
                                {
                                  snprintf(s, 0x800u, "Selecting pool %d for work", *v241);
                                  sub_343C4(7, s, 0);
                                }
                                v236 = sub_2A7F4(5000);
                                if ( v239 != v241 )
                                {
                                  v239 = v241;
                                  goto LABEL_362;
                                }
                              }
                              if ( byte_6FA71 && (*v92 || byte_6FA70 || dword_6D35C > 6) )
                              {
                                strcpy(s, "Generated stratum work");
                                sub_343C4(7, s, 0);
                              }
                              sub_2A7F4(10);
                            }
                            else
                            {
                              if ( v305[271] )
                              {
                                sub_1BAA8();
                                *(_BYTE *)(v240 + 338) = v240;
                                __und(0xFFu);
                              }
                              if ( *((_BYTE *)v305 + 1377) )
                              {
                                MEMORY[0x1B8] = 0x4040000000000000LL;
                                __und(0xFFu);
                              }
                            }
                          }
                        }
                        snprintf(s, 0x800u, "incorrect total_control_threads (%d) should be 8", v231);
LABEL_170:
                        sub_343C4(3, s, 1);
                        sub_1B070(1, 0);
                      }
                      qmemcpy(s, "All devices disabled, cannot mine!", 34);
                      v173 = aAllDevicesDisa[34];
                      v174 = &s[34];
                    }
                    else
                    {
                      qmemcpy(s, "Failed to calloc control_thr", 28);
                      v173 = aFailedToCalloc[28];
                      v174 = &s[28];
                    }
                    *v174 = v173;
                    sub_343C4(3, s, 1);
                    sub_1B070(1, 0);
                  }
                  snprintf(s, 0x800u, "Loaded configuration file %s", v108);
                  sub_343C4(7, s, 0);
                }
                v109 = v305[269];
                if ( v109 != -1 )
                  goto LABEL_110;
                if ( *v92 )
                  goto LABEL_209;
                goto LABEL_188;
              }
LABEL_103:
              snprintf(s, 0x800u, "Started %s", ::s);
              sub_343C4(4, s, 0);
              goto LABEL_104;
            }
            goto LABEL_72;
          }
          snprintf(s, 0x800u, "Log file path: %s Open flag: %s", (const char *)&dword_6F970, (const char *)v299);
          sub_343C4(3, s, 0);
        }
        v93 = (const char *)v305[3];
        if ( !v93 )
        {
          v92 = &byte_73320;
          goto LABEL_101;
        }
LABEL_72:
        memset(v308, 0, sizeof(v308));
        v94 = (const char *)v305[2];
        if ( v94 )
        {
          if ( !*v94 )
          {
            v164 = "Log work asic num empty";
            v165 = s;
LABEL_207:
            v166 = *(_DWORD *)v164;
            v167 = *((_DWORD *)v164 + 1);
            v168 = *((_DWORD *)v164 + 2);
            v169 = *((_DWORD *)v164 + 3);
            v170 = v164 + 16;
            *(_DWORD *)v165 = v166;
            *((_DWORD *)v165 + 1) = v167;
            *((_DWORD *)v165 + 2) = v168;
            *((_DWORD *)v165 + 3) = v169;
            v171 = v165 + 16;
            v172 = v170[1];
            *v171 = *v170;
            v171[1] = v172;
            goto LABEL_208;
          }
          v95 = strtol(v94, 0, 10);
          *((_DWORD *)v304 + 801) = v95;
          if ( ((v95 - 32) & 0xFFFFFFDF) != 0 && v95 != 1 )
          {
            strcpy(s, "Log work asic num must be 1, 32, 64");
            sub_343C4(3, s, 1);
            sub_1B070(1, 1);
          }
          v92 = &byte_73320;
          if ( byte_73320 || byte_6FA70 || dword_6D35C > 2 )
          {
            snprintf(s, 0x800u, "Log work path: %s Asic num: %s", (const char *)v305[3], (const char *)v305[2]);
            sub_343C4(3, s, 0);
          }
        }
        else
        {
          v92 = &byte_73320;
          if ( byte_73320 || byte_6FA70 || dword_6D35C > 2 )
          {
            snprintf(s, 0x800u, "Log work path: %s", v93);
            sub_343C4(3, s, 0);
          }
        }
        sprintf(v308, "%s.txt", (const char *)v305[3]);
        v96 = fopen(v308, "a+");
        v97 = (unsigned __int8)byte_73320;
        *((_DWORD *)v304 + 802) = v96;
        if ( v97 || byte_6FA70 || dword_6D35C > 2 )
        {
          snprintf(s, 0x800u, "Log work open file %s", v308);
          sub_343C4(3, s, 0);
        }
        v98 = *((_DWORD *)v304 + 801);
        if ( v98 == 1 )
        {
          sprintf(v308, "%s%02d.txt", (const char *)v305[3], 1);
          v175 = fopen(v308, "a+");
          v176 = (unsigned __int8)byte_73320;
          *((_DWORD *)v304 + 803) = v175;
          if ( v176 || byte_6FA70 || dword_6D35C > 2 )
          {
            snprintf(s, 0x800u, "Log work open asic %d file %s", *((_DWORD *)v304 + 801), v308);
            sub_343C4(3, s, 0);
          }
        }
        else if ( ((v98 - 32) & 0xFFFFFFDF) == 0 )
        {
          format = &byte_73320;
          v99 = 0;
          v100 = v304;
          while ( 1 )
          {
            v103 = *((_DWORD *)v100 + 801);
            if ( v103 < v99 )
              break;
            sprintf(v308, "%s%02d_%02d.txt", (const char *)v305[3], v103, v99);
            v101 = fopen(v308, "a+");
            v102 = format;
            dword_6F5D4[v99] = (int)v101;
            if ( *v102 || byte_6FA70 || dword_6D35C > 2 )
            {
              snprintf(s, 0x800u, "Log work open asic %d file %s", *((_DWORD *)v100 + 801), v308);
              sub_343C4(3, s, 0);
            }
            ++v99;
          }
          v92 = format;
        }
        if ( v304[3472] )
        {
          v104 = &byte_6F6D8;
          v105 = 0;
          format = "Log work open diff file %s";
          do
          {
            sprintf(v308, "%s_diff_%02d.txt", (const char *)v305[3], v105);
            v106 = fopen(v308, "a+");
            v107 = (unsigned __int8)*v92;
            *((_DWORD *)v104 + 1) = v106;
            v104 += 4;
            if ( v107 || byte_6FA70 || dword_6D35C > 2 )
            {
              snprintf(s, 0x800u, format, v308);
              sub_343C4(3, s, 0);
            }
            ++v105;
          }
          while ( v105 != 65 );
        }
LABEL_101:
        if ( *v92 || byte_6FA70 )
          goto LABEL_103;
        goto LABEL_179;
      }
      v140 = calloc(24 * *(_DWORD *)(v67 + 4), 1u);
      if ( v140 )
      {
        v141 = *(_DWORD *)(v67 + 12);
        v142 = v141 >> (*(_QWORD *)(v67 + 8) + 1);
        if ( ((2 * *(_DWORD *)(v67 + 4) - 1) & v141) != 0 )
          ++v142;
        *(_DWORD *)(v67 + 24) = v142;
        *(_DWORD *)(*((_DWORD *)v25 + 17) + 28) = 0;
        v143 = *((_DWORD *)v25 + 17);
        if ( *(_DWORD *)(v143 + 4) )
        {
          v144 = v25;
          v301 = 0;
          do
          {
            v145 = *(_DWORD **)(*(_DWORD *)v143 + 12 * (_DWORD)v301);
            if ( v145 )
            {
              do
              {
                v146 = (_DWORD *)v145[4];
                v147 = 3 * ((2 * *(_DWORD *)(v143 + 4) - 1) & v145[7]);
                v148 = (char *)&v140[3 * ((2 * *(_DWORD *)(v143 + 4) - 1) & v145[7])];
                v149 = *((_DWORD *)v148 + 1) + 1;
                *((_DWORD *)v148 + 1) = v149;
                if ( v149 > *(_DWORD *)(v143 + 24) )
                {
                  ++*(_DWORD *)(v143 + 28);
                  *((_DWORD *)v148 + 2) = sub_49878(*((_DWORD *)v148 + 1), *(_DWORD *)(*((_DWORD *)v144 + 17) + 24));
                }
                v145[3] = 0;
                v145[4] = v140[v147];
                v150 = v140[v147];
                if ( v150 )
                  *(_DWORD *)(v150 + 12) = v145;
                v140[v147] = v145;
                v145 = v146;
                v143 = *((_DWORD *)v144 + 17);
              }
              while ( v146 );
            }
            v154 = *(_DWORD *)(v143 + 4) > (unsigned int)++v301;
          }
          while ( v154 );
          v25 = v144;
        }
        free(*(void **)v143);
        *(_DWORD *)(*((_DWORD *)v25 + 17) + 4) *= 2;
        ++*(_DWORD *)(*((_DWORD *)v25 + 17) + 8);
        **((_DWORD **)v25 + 17) = v140;
        v151 = (_DWORD *)*((_DWORD *)v25 + 17);
        v152 = v151[7];
        v153 = v151[3];
        v154 = v152 > v153 >> 1;
        if ( v152 <= v153 >> 1 )
          v155 = 0;
        else
          v155 = v151[8];
        if ( v154 )
          ++v155;
        v151[8] = v155;
        v156 = *((_DWORD *)v25 + 17);
        if ( *(_DWORD *)(v156 + 32) > 1u )
          *(_DWORD *)(v156 + 36) = 1;
        goto LABEL_37;
      }
LABEL_165:
      exit(-1);
    }
    strcpy(s, "Failed to create getq");
  }
  sub_343C4(3, s, 1);
  sub_1B070(1, 0);
}

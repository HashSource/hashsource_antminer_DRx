/* This file was generated by the Hex-Rays decompiler version 9.2.0.250908.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

int init_proc();
void sub_8C70();
// int pthread_mutex_unlock(pthread_mutex_t *mutex);
// char *strstr(const char *haystack, const char *needle);
// int raise(int sig);
// int strcmp(const char *s1, const char *s2);
// int printf(const char *format, ...);
// FILE *fopen(const char *filename, const char *modes);
// ssize_t read(int fd, void *buf, size_t nbytes);
// int pthread_mutex_destroy(pthread_mutex_t *mutex);
// void *memmove(void *dest, const void *src, size_t n);
// void free(void *ptr);
// char *fgets(char *s, int n, FILE *stream);
// int pthread_mutex_lock(pthread_mutex_t *mutex);
// void *memcpy(void *dest, const void *src, size_t n);
// int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *mutexattr);
// __off_t lseek(int fd, __off_t offset, int whence);
// unsigned int sleep(unsigned int seconds);
// char *strdup(const char *s);
// int _isinf(double value);
// void perror(const char *s);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// int ioctl(int fd, unsigned int request, ...);
// __int64 strtoll(const char *nptr, char **endptr, int base);
// int usleep(__useconds_t useconds);
// char *strcpy(char *dest, const char *src);
// int gettimeofday(struct timeval *tv, __timezone_ptr_t tz);
// int pthread_create(pthread_t *newthread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg);
// char *getenv(const char *name);
// int puts(const char *s);
// void *malloc(size_t size);
// int _libc_start_main(int (*main)(int, char **, char **), int argc, char **ubp_av, void (*init)(), void (*fini)(), void (*rtld_fini)(), void *stack_end);
// char *strerror(int errnum);
// int system(const char *command);
int j___gmon_start__();
// int _gmon_start__(void); weak
// int open(const char *file, int oflag, ...);
// unsigned int strtoul(const char *nptr, char **endptr, int base);
// size_t strlen(const char *s);
// void *mmap(void *addr, size_t len, int prot, int flags, int fd, __off_t offset);
// char *strchr(const char *s, int c);
// int *_errno_location(void);
// int snprintf(char *s, size_t maxlen, const char *format, ...);
// int _isoc99_sscanf(_DWORD, const char *, ...); weak
// void *memset(void *s, int c, size_t n);
// int putchar(int c);
// int pthread_cancel(pthread_t th);
// int fgetc(FILE *stream);
// double strtod(const char *nptr, char **endptr);
// ssize_t write(int fd, const void *buf, size_t n);
// int _isnan(double value);
// int access(const char *name, int type);
// int fclose(FILE *stream);
// int munmap(void *addr, size_t len);
// int pthread_join(pthread_t th, void **thread_return);
// struct lconv *localeconv(void);
// int sprintf(char *s, const char *format, ...);
// int vsnprintf(char *s, size_t maxlen, const char *format, __gnuc_va_list arg);
// int atoi(const char *nptr);
// void qsort(void *base, size_t nmemb, size_t size, __compar_fn_t compar);
// int socket(int domain, int type, int protocol);
// int fseek(FILE *stream, int off, int whence);
// void abort(void);
// int close(int fd);
// void _assert_fail(const char *assertion, const char *file, unsigned int line, const char *function);
void __noreturn start(void (*a1)(), int a2, int a3, int a4, ...); // idb
int call_gmon_start();
int *deregister_tm_clones();
__int64 register_tm_clones();
int *_do_global_dtors_aux();
__int64 frame_dummy();
int __fastcall main(int argc, const char **argv, const char **envp);
size_t __fastcall get_BM1722_asic_register(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 a3, char a4);
size_t __fastcall set_BM1722_asic_register(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 a3, char a4, int a5);
size_t __fastcall set_BM1722_freq(unsigned __int8 a1, unsigned __int8 a2, char a3);
int __fastcall BM1722_chain_inactive(unsigned __int8 a1); // idb
size_t __fastcall BM1722_set_address(unsigned __int8 a1, unsigned __int8 a2);
unsigned int __fastcall BM1722_set_address_all(unsigned __int8 a1); // idb
int __fastcall BM1722_open_core(unsigned __int8 a1); // idb
unsigned int __fastcall check_BM1722_asic_reg(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 a3, char a4);
int singleAsicTest_BM1722(); // idb
int singleBoardTest_BBD12601(); // idb
size_t __fastcall get_BM1725_asic_register(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 a3, char a4);
size_t __fastcall set_BM1725_asic_register(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 a3, char a4, int a5);
size_t __fastcall BM1725_set_address(unsigned __int8 a1, unsigned __int8 a2);
int __fastcall BM1725_chain_inactive(unsigned __int8 a1);
int __fastcall BM1725_set_address_all(unsigned __int8 a1); // idb
size_t __fastcall set_BM1725_freq(unsigned __int8 a1, unsigned __int8 a2, char a3);
int __fastcall BM1725_open_core(unsigned __int8 a1); // idb
unsigned int __fastcall check_BM1725_asic_reg(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 a3, char a4);
int singleAsicTest_BM1725(); // idb
int singleBoardTest_BBD25601(); // idb
int __fastcall calculate_asic_number(unsigned int a1); // idb
int read_config(); // idb
unsigned __int8 __cdecl CRC5(unsigned __int8 *ptr, unsigned __int8 len);
int __fastcall crc_itu_t_byte(__int16 a1, char a2); // idb
int __fastcall CRC16(char *a1, int a2); // idb
int InitElapsedTime();
int __fastcall PrintElapsedTime(const char *a1); // idb
int cgpu_init(); // idb
void *malloc_register_buf(); // idb
int configMiner(); // idb
int display_arguments(); // idb
void *clear_register_value_buf(); // idb
int __fastcall calculate_core_number(unsigned int a1); // idb
int __fastcall calculate_how_many_nonce_per_asic_get(unsigned __int8 a1, unsigned __int8 a2, unsigned int a3); // idb
int display_level_result_on_lcd(); // idb
void *reset_global_arg(); // idb
int __fastcall rev(int result, char a2); // idb
int __fastcall target_to_dcrdiff(int a1); // idb
void *__fastcall decred_hash_simple(int a1, char *a2); // idb
int __fastcall check_hw(int a1, int a2, char a3, char a4); // idb
int calculate_timeout_and_baud(); // idb
void __fastcall __noreturn show_status_func(unsigned __int8 *a1); // idb
int __fastcall set_voltage(char a1, char a2, char a3); // idb
int __fastcall set_baud(unsigned __int8 a1, unsigned __int8 a2); // idb
bool __fastcall is_nonce_or_reg_value(char a1); // idb
int __fastcall check_nonce(unsigned __int8 a1, unsigned __int8 *a2); // idb
int __fastcall check_register_value(char a1, const void *a2); // idb
_DWORD *__fastcall add_point(_DWORD *result, unsigned int a2); // idb
int __fastcall use_point_sub_1(int a1, int a2); // idb
unsigned int __fastcall use_point_add_1(unsigned int a1, int a2); // idb
void *__fastcall receive_func(unsigned __int8 *a1); // idb
int __fastcall send_func(unsigned __int8 *a1); // idb
void __fastcall __noreturn read_temp_func(unsigned __int8 *a1); // idb
int __fastcall single_asic_print_lcd(int a1, char a2); // idb
int __fastcall single_board_print_lcd(char a1); // idb
int __fastcall single_asic_get_result(unsigned __int8 a1); // idb
int __fastcall single_board_get_result(unsigned __int8 a1); // idb
int __fastcall get_pllparam_divider(int *a1, unsigned __int8 *a2, float *a3); // idb
size_t __fastcall enable_read_temperature_from_asic_chain(size_t result, unsigned __int8 a2);
size_t __fastcall enable_extended_mode_of_temperature_sensor_chain(unsigned __int8 a1); // idb
int __fastcall get_temperature_offset_value_from_asic_chain(unsigned __int8 a1); // idb
size_t __fastcall set_default_temperature_offset_value_chain(unsigned __int8 a1); // idb
int __fastcall read_asic_temperature(unsigned __int8 a1); // idb
bool test_eeprom(); // idb
int __fastcall save_eeprom_N(unsigned __int8 a1, char a2); // idb
bool __fastcall get_eeprom_N(unsigned __int8 a1, int a2); // idb
int __fastcall save_byte_to_eeprom(unsigned __int8 a1, char a2);
int __fastcall save_voltage_info_to_eeprom(unsigned int a1, unsigned int a2); // idb
int open_i2c(); // idb
int close_i2c(); // idb
int __fastcall iic_i2c_write(int a1, unsigned int a2); // idb
int __fastcall iic_i2c_read(int a1, unsigned int a2);
int __fastcall iic_i2c_write_reg(unsigned __int8 a1, int a2, unsigned int a3); // idb
int __fastcall iic_i2c_read_reg(unsigned __int8 a1, int a2, unsigned int a3);
size_t __fastcall dcr_uart_send(unsigned __int8 a1, const void *a2, size_t a3); // idb
int __fastcall uart_set_baud(unsigned __int8 a1, int a2); // idb
const char *__fastcall key_callback(int a1, int a2); // idb
int open_key();
int close_key();
int __fastcall read_key(_BYTE *a1); // idb
int __fastcall write_lcd(unsigned __int8 a1, int a2, unsigned int a3); // idb
int __fastcall write_lcd_no_memset(unsigned __int8 a1, int a2, unsigned int a3); // idb
int __fastcall c2hex(unsigned __int8 a1); // idb
unsigned __int8 __cdecl twoc2hex(unsigned __int8 high, unsigned __int8 low);
int __fastcall s2hex(_BYTE *a1, _BYTE *a2, int a3); // idb
int print_works(); // idb
unsigned int __fastcall get_work(int a1, int a2, FILE *a3, unsigned int a4); // idb
int get_works(); // idb
int __fastcall write_pic(char a1, char a2, char a3); // idb
int read_pic(); // idb
int __fastcall set_PIC16F1704_flash_point32_ter(char a1, char a2, unsigned __int8 a3, unsigned __int8 a4); // idb
int __fastcall send_data_to_PIC16F1704(char a1, char a2, int a3); // idb
int __fastcall read_PIC16F1704_flash_point32_ter(char a1, char a2, unsigned __int8 *a3, unsigned __int8 *a4); // idb
int __fastcall read_PIC16F1704_flash_data(char a1, char a2, int a3); // idb
int __fastcall erase_PIC16F1704_flash(char a1, char a2); // idb
int __fastcall write_data_int32_to_PIC16F1704_flash(char a1, char a2); // idb
int __fastcall jump_from_loader_to_app_PIC16F1704(char a1, char a2); // idb
int __fastcall reset_PIC16F1704_pic(char a1, char a2); // idb
int __fastcall set_PIC16F1704_voltage(char a1, char a2, unsigned __int8 a3); // idb
int __fastcall write_hash_ID_PIC16F1704(char a1, char a2, int a3); // idb
int __fastcall read_hash_id_PIC16F1704(char a1, char a2, int a3); // idb
int __fastcall enable_PIC16F1704_dc_dc(char a1, char a2, unsigned __int8 a3); // idb
int __fastcall heart_beat_PIC16F1704(char a1, char a2); // idb
void __fastcall __noreturn pic_heart_beat_func(char *a1); // idb
int __fastcall get_PIC16F1704_software_version(char a1, char a2, unsigned __int8 *a3); // idb
int __fastcall get_PIC16F1704_voltage(char a1, char a2, unsigned __int8 *a3); // idb
int __fastcall write_temperature_offset_PIC16F1704(char a1, char a2, int a3); // idb
int __fastcall read_temperature_offset_PIC16F1704(char a1, char a2, int a3); // idb
int __fastcall erase_PIC16F1704_app_flash(char a1, char a2); // idb
int __fastcall PIC1704_update_pic_app_program(char a1, char a2); // idb
int __fastcall save_freq_PIC16F1704(char a1, char a2, unsigned __int16 a3); // idb
int __fastcall get_PIC16F1704_freq(char a1, char a2, unsigned __int16 *a3); // idb
int __fastcall set_temperature_offset_value(char a1, char a2, int a3); // idb
int __fastcall write_sensor_info_int32_to_pic(char a1, char a2); // idb
int check_chain(); // idb
int __fastcall fan_control(unsigned __int8 a1); // idb
int set_PWM_according_to_temperature(); // idb
int znyq_set_iic(int a1, int a2, char a3, int a4, unsigned __int8 a5, ...); // idb
unsigned int power_on(); // idb
unsigned int power_off();
int power_check_protocal_type(); // idb
unsigned int power_init();
int __fastcall power_check_reply(unsigned __int8 *a1, unsigned __int8 *a2, unsigned __int8 a3); // idb
bool __fastcall power_send_cmd(unsigned __int8 *a1, unsigned __int8 a2, unsigned __int8 *a3, unsigned __int8 a4); // idb
int power_get_firmware_version(); // idb
int power_get_device_no();
int power_get_da_value(); // idb
int power_get_da_value_simple(); // idb
int power_get_adc_value(); // idb
bool __fastcall power_set_da_value(unsigned __int8 a1); // idb
int __fastcall power_set_da_value_simple(unsigned __int8 a1); // idb
int __fastcall power_save_eeprom_data(char a1, int a2, unsigned __int8 a3);
int __fastcall power_read_eeprom_data(char a1, int a2, unsigned __int8 a3);
bool power_is_support_cmd_package(); // idb
_BYTE *__fastcall power_get_voltage(_BYTE *a1); // idb
int __fastcall power_set_voltage(unsigned __int8 a1); // idb
unsigned int __fastcall sph_bswap32(int a1); // idb
__int64 __fastcall sph_bswap64(unsigned int a1, unsigned int a2); // idb
_BYTE *__fastcall sph_enc32be(_BYTE *result, int a2); // idb
unsigned int __fastcall sph_enc32be_aligned(unsigned int *a1, int a2);
unsigned int __fastcall sph_dec32be_aligned(int *a1);
int __fastcall sph_enc64be(_BYTE *a1, int a2, int a3, int a4); // idb
int __fastcall sph_enc64be_aligned(__int64 *a1, int a2, unsigned int a3, unsigned int a4); // idb
__int64 __fastcall sph_dec64be_aligned(unsigned int *a1); // idb
void *__fastcall blake32_init(_DWORD *a1, const void *a2, const void *a3); // idb
unsigned int __fastcall blake32(unsigned int result, char *a2, size_t a3); // idb
_BYTE *__fastcall blake32_close(_DWORD *a1, char a2, int a3, int a4, unsigned int a5);
void *__fastcall blake64_init(int a1, const void *a2, const void *a3); // idb
__int64 *__fastcall blake64(int a1, char *a2, size_t a3); // idb
__int64 *__fastcall blake64_close(int a1, char a2, int a3, int a4, unsigned int a5); // idb
void *__fastcall sph_blake224_init(_DWORD *a1); // idb
unsigned int __fastcall sph_blake224(unsigned int a1, char *a2, size_t a3);
void *__fastcall sph_blake224_close(_DWORD *a1, int a2);
void *__fastcall sph_blake224_addbits_and_close(_DWORD *a1, char a2, int a3, int a4); // idb
void *__fastcall sph_blake256_init(_DWORD *a1);
unsigned int __fastcall sph_blake256(unsigned int a1, char *a2, size_t a3);
void *__fastcall sph_blake256_close(_DWORD *a1, int a2);
void *__fastcall sph_blake256_addbits_and_close(_DWORD *a1, char a2, int a3, int a4); // idb
void *__fastcall sph_blake384_init(int a1);
__int64 *__fastcall sph_blake384(int a1, char *a2, size_t a3);
void *__fastcall sph_blake384_close(int a1, int a2);
void *__fastcall sph_blake384_addbits_and_close(int a1, char a2, int a3, int a4); // idb
void *__fastcall sph_blake512_init(int a1);
__int64 *__fastcall sph_blake512(int a1, char *a2, size_t a3);
void *__fastcall sph_blake512_close(int a1, int a2);
void *__fastcall sph_blake512_addbits_and_close(int a1, char a2, int a3, int a4);
unsigned int *__fastcall platform_dump_capability(unsigned int *result);
int platform_init(); // idb
int platform_uninit(); // idb
void *__fastcall get_system_capability(void *result); // idb
int __fastcall get_eth_mac(const char *a1, int a2); // idb
int __fastcall get_uuid(void *a1); // idb
int __fastcall get_mac(int a1); // idb
int __fastcall chain_reset(char a1); // idb
int __fastcall chain_reset_low(char a1); // idb
int __fastcall chain_reset_high(char a1); // idb
void board_reset(); // idb
void board_reset_low();
void board_reset_high();
int get_hardware_type(); // idb
int __fastcall set_hardware_type(int a1); // idb
int enable_bypass_mode(); // idb
int disable_bypass_mode(); // idb
bool is_bypass_mode_enable(); // idb
int get_hardware_version(); // idb
int fan_init(); // idb
void fan_uninit();
int __fastcall fan_get_realtime_speed(int a1); // idb
int fan_get_max_num();
int __fastcall fan_get_max_speed(int a1);
int reset(); // idb
int fpga_init(); // idb
void fpga_uninit(); // idb
int __fastcall fpga_read(int a1, _DWORD *a2); // idb
int __fastcall fpga_write(int a1, int a2); // idb
int __fastcall gpio_compare_e(_DWORD *a1, _DWORD *a2); // idb
int gpio_thread_function(); // weak
int gpio_init(); // idb
int gpio_uninit(); // idb
int __fastcall gpio_reg_callback(int a1, int a2); // idb
int __fastcall gpio_unreg_callback(int a1, int a2); // idb
int __fastcall gpio_export(int a1); // idb
int __fastcall gpio_unexport(int a1); // idb
int __fastcall gpio_direction(int a1, int a2); // idb
int __fastcall gpio_read(int a1, _BYTE *a2); // idb
int __fastcall gpio_write(int a1, char a2); // idb
int __fastcall iic_init(int a1); // idb
int __fastcall iic_uninit(int a1); // idb
int __fastcall iic_read(int a1, int a2, unsigned int a3); // idb
int __fastcall iic_write(int a1, int a2, unsigned int a3); // idb
int __fastcall iic_read_reg(int a1, unsigned __int8 *a2, int a3, int a4, unsigned int a5); // idb
int __fastcall iic_write_reg(int a1, unsigned __int8 *a2, int a3, int a4, unsigned int a5); // idb
int __fastcall pwm_init(unsigned int a1, int a2); // idb
int __fastcall pwm_uninit(int result); // idb
int __fastcall pwm_set(int a1, unsigned int a2); // idb
int __fastcall pwm_get(int a1, _DWORD *a2); // idb
int __fastcall get_send_address_info(int a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5); // idb
int __fastcall get_read_address_info(int a1, _DWORD *a2, _DWORD *a3); // idb
int __fastcall check_how_many_uart_data_in_fpga(unsigned __int8 a1); // idb
int __fastcall read_uart_data_in_fpga(int a1, int a2, unsigned int a3); // idb
int uart_init(); // idb
void uart_uninit();
int __fastcall hexdump(const char *a1, unsigned __int8 *a2, int a3); // idb
size_t __fastcall uart_send(int a1, const void *a2, size_t a3); // idb
int __fastcall uart_receive(int a1, int a2, unsigned int a3); // idb
int __fastcall uart_set_config(int a1, int a2, int *a3); // idb
int __fastcall uart_get_config(int a1, int a2, _DWORD *a3, int a4); // idb
int __fastcall clear_uart_tx_fifo(int a1); // idb
int __fastcall clear_uart_rx_fifo(int a1); // idb
int __fastcall uart_flush(int a1); // idb
int __fastcall uart_flush_tx(int a1);
int __fastcall uart_flush_rx(int a1);
int __fastcall uart_get_readable_byte_num(int a1); // idb
int ui_pull_function(); // weak
int __fastcall gpio_compare_e_0(_DWORD *a1, _DWORD *a2);
int __fastcall convert_ui_type_to_port(unsigned int a1); // idb
int __fastcall convert_port_to_ui_type(int a1); // idb
int __fastcall gpio_key_callback(int a1, char a2); // idb
int ui_init(); // idb
void ui_uninit(); // idb
int __fastcall remove_port_form_gpio_map(int result, int *a2); // idb
int __fastcall add_port_to_gpio_map(int result, int a2, int *a3); // idb
void __fastcall update_filcker_freq(int a1, int a2, int a3); // idb
int __fastcall gpio_ctrl_ui(unsigned int a1, int a2); // idb
int __fastcall gpio_set_led_filker_freq(unsigned int a1, int a2); // idb
int red_led_on();
int red_led_off();
int red_led_flicker();
int green_led_on();
int green_led_off();
int green_led_flicker();
int beeper_on();
int beeper_off();
int beeper_flicker();
int __fastcall reg_key_callback(int a1); // idb
int __fastcall unreg_key_callback(int a1); // idb
int __fastcall lcd_show_result(unsigned __int8 a1, int a2, unsigned int a3); // idb
int lcd_clear_result(); // idb
int __fastcall lcd_init(const char *a1); // idb
int __fastcall lcd_write(int a1, unsigned __int8 a2, int a3, unsigned int a4); // idb
int lcd_flush();
int __fastcall lcd_clear(int a1); // idb
int __fastcall lcd_uninit(int a1); // idb
int __fastcall i2c_compare_e(_DWORD *a1, _DWORD *a2);
int i2c_init(); // idb
int __fastcall i2c_uninit(int a1); // idb
int wait4i2c_ready(); // idb
int __fastcall wait4i2c_data(_BYTE *a1); // idb
int __fastcall i2c_read(int a1, int a2, unsigned int a3); // idb
int __fastcall i2c_write(int a1, int a2, unsigned int a3); // idb
int __fastcall i2c_read_reg(int a1, unsigned __int8 *a2, int a3, int a4, unsigned int a5); // idb
int __fastcall i2c_write_reg(int a1, unsigned __int8 *a2, int a3, int a4, unsigned int a5); // idb
int __fastcall i2c_ioctl(int a1, __int16 a2, int a3); // idb
int __fastcall i2c_select(int a1, int a2); // idb
void __cdecl json_decref(json_t *json);
int __fastcall hal_load_conf(const char *a1); // idb
int hal_led_red_addr(); // idb
int hal_led_green_addr();
int hal_key_reset_addr();
int hal_key_ipreport_addr();
int __fastcall hal_chain_uart_addr(int a1); // idb
int __fastcall hal_chain_plug_addr(int a1); // idb
int __fastcall hal_chain_reset_addr(int a1); // idb
int hal_chain_max_num(); // idb
int __fastcall hal_fan_addr(int a1); // idb
int __fastcall hal_fan_max_speed(int a1); // idb
int hal_fan_number(); // idb
_DWORD *__fastcall new_c_map(int a1, int a2, int a3); // idb
int __fastcall insert_c_map(int *a1, const void *a2, size_t a3, const void *a4, size_t a5); // idb
bool __fastcall exists_c_map(int *a1, int a2); // idb
int __fastcall remove_c_map(int *a1, int a2); // idb
int __fastcall find_c_map(int *a1, int a2, void **a3); // idb
int __fastcall delete_c_map(void ****a1);
_DWORD *__fastcall minimum_c_map(int *a1); // idb
int __fastcall get_next_c_map(int a1); // idb
void *__fastcall get_value_c_map(int a1); // idb
void *__fastcall replace_value_c_map(int a1, const void *a2, size_t a3); // idb
_DWORD *__fastcall new_iterator_c_map(int a1); // idb
void __fastcall delete_iterator_c_map(void *a1);
_DWORD *__fastcall _left_rotate(_DWORD *result, _DWORD *a2); // idb
_DWORD *__fastcall _right_rotate(_DWORD *result, _DWORD *a2); // idb
_DWORD *__fastcall new_c_rb(int a1, int a2, int a3); // idb
_DWORD *__fastcall _rb_insert_fixup(_DWORD *result, _DWORD *a2); // idb
_DWORD *__fastcall find_c_rb(int a1, int a2); // idb
int __fastcall insert_c_rb(int a1, const void *a2, size_t a3, const void *a4, size_t a5); // idb
int *__fastcall _rb_remove_fixup(int *result, int a2); // idb
int *__fastcall _remove_c_rb(int *a1, int **a2);
int *__fastcall remove_c_rb(int a1, int a2); // idb
void __fastcall _delete_c_rb_node(int a1, int a2); // idb
int __fastcall delete_c_rb(void ***a1);
_DWORD *__fastcall minimum_c_rb(int a1, _DWORD *a2); // idb
int __fastcall maximum_c_rb(int a1, int a2); // idb
bool __fastcall empty_c_rb(_DWORD *a1); // idb
int *__fastcall tree_successor(int *a1, int a2); // idb
int __fastcall debug_verify_properties(int *a1); // idb
int __fastcall debug_verify_property_1(int a1, _DWORD *a2); // idb
int __fastcall debug_verify_property_2(int a1, int a2); // idb
int __fastcall debug_node_color(int a1, int a2); // idb
int __fastcall debug_verify_property_4(int a1, int *a2); // idb
int __fastcall debug_verify_property_5(int a1, _DWORD *a2); // idb
int __fastcall debug_verify_property_5_helper(int a1, _DWORD *a2, int a3, _DWORD *a4); // idb
void *__fastcall clib_copy(void *a1, const void *a2, size_t a3);
void *__fastcall clib_get(void *a1, const void *a2, size_t a3);
void **__fastcall new_clib_object(const void *a1, size_t a2); // idb
int __fastcall get_raw_clib_object(int a1, void **a2); // idb
void *__fastcall replace_raw_clib_object(void **a1, const void *a2, size_t a3); // idb
void __fastcall delete_clib_object(void **a1); // idb
char *__fastcall clib_strdup(const char *a1);
int __cdecl dump_to_strbuffer(const char *buffer, size_t size, void *data);
int __cdecl dump_to_file(const char *buffer, size_t size, void *data);
int __fastcall dump_indent(char a1, int a2, int a3, int (__fastcall *a4)(const char *, int, int), int a5); // idb
int __fastcall dump_string(char *a1, int (__fastcall *a2)(unsigned __int8 *, int, int), int a3, __int16 a4);
int __fastcall object_key_compare_keys(int a1, int a2); // idb
int __fastcall object_key_compare_serials(_DWORD *a1, _DWORD *a2); // idb
int __fastcall do_dump(json_t *a1, int a2, int a3, int (__fastcall *a4)(const char *, int, int), int a5);
char *__cdecl json_dumps(const json_t *json, size_t flags);
int __cdecl json_dumpf(const json_t *json, FILE *output, size_t flags);
int __cdecl json_dump_file(const json_t *json, const char *path, size_t flags);
int __fastcall json_dump_callback(json_t *a1, int (__fastcall *a2)(const char *, int, int), int a3, __int16 a4);
void __fastcall json_decref_0(int a1);
int __fastcall hash_str(_BYTE *a1); // idb
_DWORD *__fastcall list_init(_DWORD *result);
void __cdecl list_insert(list_t *list, list_t *node);
void __cdecl list_remove(list_t *list);
int __cdecl bucket_is_empty(hashtable_t *hashtable, bucket_t *bucket);
void __cdecl insert_to_bucket(hashtable_t *hashtable, bucket_t *bucket, list_t *list);
int __fastcall num_buckets(int a1); // idb
int __fastcall hashtable_find_pair(hashtable_t *a1, bucket_t *a2, const char *a3, int a4);
int __fastcall hashtable_do_del(hashtable_t *a1, const char *a2, unsigned int a3);
void __fastcall hashtable_do_clear(int a1); // idb
int __fastcall hashtable_do_rehash(int a1); // idb
int __fastcall hashtable_init(_DWORD *a1); // idb
void __cdecl hashtable_close(hashtable_t *hashtable);
int __fastcall hashtable_set(hashtable_t *a1, char *a2, int a3, int a4);
int __fastcall hashtable_get(int a1, char *a2); // idb
int __fastcall hashtable_del(hashtable_t *a1, char *a2);
_DWORD *__fastcall hashtable_clear(_DWORD *a1); // idb
int __fastcall hashtable_iter(int a1); // idb
int __fastcall hashtable_iter_at(int a1, char *a2); // idb
int __fastcall hashtable_iter_next(int a1, int a2); // idb
int __fastcall hashtable_iter_key(int a1);
int __fastcall hashtable_iter_serial(int a1);
int __fastcall hashtable_iter_value(int a1);
void __fastcall hashtable_iter_set(int a1, int a2);
json_t *__cdecl json_incref(json_t *json);
void __fastcall json_decref_1(int a1);
int __cdecl json_object_set_nocheck(json_t *object, const char *key, json_t *value);
int __cdecl json_array_append(json_t *array, json_t *value);
void error_set(json_error_t *error, const lex_t *lex, const char *msg, ...);
int __fastcall stream_init(int result, int a2, int a3);
int __fastcall stream_get(int a1, json_error_t *a2);
_DWORD *__fastcall stream_unget(_DWORD *result, int a2); // idb
int __cdecl lex_get(lex_t *lex, json_error_t *error);
void __cdecl lex_save(lex_t *lex, int c);
int __cdecl lex_get_save(lex_t *lex, json_error_t *error);
_DWORD *__fastcall lex_unget(_DWORD *a1, int a2);
_DWORD *__fastcall lex_unget_unsave(_DWORD *result, int a2); // idb
void __cdecl lex_save_cached(lex_t *lex);
int __fastcall decode_unicode_escape(_BYTE *a1); // idb
void __fastcall lex_scan_string(int a1, json_error_t *a2);
int __fastcall lex_scan_number(int a1, int a2, json_error_t *a3);
int __fastcall lex_scan(int a1, json_error_t *a2);
int __fastcall lex_steal_string(int a1); // idb
int __fastcall lex_init(int a1, int a2, int a3); // idb
void __fastcall lex_close(int a1); // idb
json_t *__fastcall parse_object(const lex_t *a1, unsigned int a2, json_error_t *a3);
json_t *__fastcall parse_array(const lex_t *a1, unsigned int a2, json_error_t *a3);
_DWORD *__fastcall parse_value(double a1, json_error_t *a2);
_DWORD *__fastcall parse_json(const lex_t *a1, unsigned int a2, int a3);
int __cdecl string_get(void *data);
_DWORD *__fastcall json_loads(int a1, unsigned int a2, json_error_t *a3);
int __cdecl buffer_get(void *data);
_DWORD *__fastcall json_loadb(int a1, int a2, unsigned int a3, json_error_t *a4);
_DWORD *__fastcall json_loadf(int a1, unsigned int a2, json_error_t *a3);
json_t *__cdecl json_load_file(const char *path, size_t flags, json_error_t *error);
int __cdecl callback_get(void *data);
_DWORD *__fastcall json_load_callback(int a1, int a2, unsigned int a3, json_error_t *a4);
void *__cdecl jsonp_malloc(size_t size);
void __cdecl jsonp_free(void *ptr);
void *__fastcall jsonp_strdup(const char *a1); // idb
void *(*__fastcall json_set_alloc_funcs(void *(*result)(size_t size), void (*a2)(void *ptr)))(size_t size);
int __cdecl strbuffer_init(strbuffer_t *strbuff);
void __cdecl strbuffer_close(strbuffer_t *strbuff);
void __cdecl strbuffer_clear(strbuffer_t *strbuff);
int __fastcall strbuffer_value(int a1);
char *__cdecl strbuffer_steal_value(strbuffer_t *strbuff);
int __fastcall strbuffer_append(strbuffer_t *a1, const char *a2);
int __cdecl strbuffer_append_byte(strbuffer_t *strbuff, char byte);
int __cdecl strbuffer_append_bytes(strbuffer_t *strbuff, const char *data, size_t size);
char __cdecl strbuffer_pop(strbuffer_t *strbuff);
void __cdecl to_locale(strbuffer_t *strbuffer);
void __cdecl from_locale(char *buffer);
int __fastcall jsonp_strtod(int a1, double *a2); // idb
int __fastcall jsonp_dtostr(char *a1, size_t a2); // idb
int __cdecl utf8_encode(int32_t codepoint, char *buffer, size_t *size);
size_t __cdecl utf8_check_first(char byte);
int __fastcall utf8_check_full(char *a1, int a2, int *a3); // idb
char *__fastcall utf8_iterate(char *a1, _DWORD *a2);
int __fastcall utf8_check_string(const char *a1, signed int a2); // idb
int __fastcall json_incref_0(int result);
void __fastcall json_decref_2(int a1);
int __fastcall json_object_set_nocheck_0(_DWORD *a1, char *a2, int a3);
int __fastcall json_array_append_0(json_t *a1, int a2);
_DWORD *__fastcall json_init(_DWORD *result, int a2);
_DWORD *json_object(); // idb
void __cdecl json_delete_object(json_object_t *object);
size_t __cdecl json_object_size(const json_t *json);
int __fastcall json_object_get(_DWORD *a1, char *a2); // idb
int __fastcall json_object_set_new_nocheck(_DWORD *a1, char *a2, _DWORD *a3);
int __fastcall json_object_set_new(_DWORD *a1, char *a2, _DWORD *a3);
int __fastcall json_object_del(_DWORD *a1, char *a2); // idb
int __fastcall json_object_clear(_DWORD *a1); // idb
int __cdecl json_object_update(json_t *object, json_t *other);
int __cdecl json_object_update_existing(json_t *object, json_t *other);
int __cdecl json_object_update_missing(json_t *object, json_t *other);
void *__cdecl json_object_iter(json_t *json);
json_t *__cdecl json_object_iter_at_0(const json_t *json, const char *key);
void *__cdecl json_object_iter_next(json_t *json, void *iter);
const char *__cdecl json_object_iter_key(void *iter);
int __fastcall json_object_iter_value(int a1);
int __cdecl json_object_iter_set_new(json_t *json, void *iter, json_t *value);
int __fastcall json_object_key_to_iter(int a1); // idb
int __cdecl json_object_equal(json_t *object1, json_t *object2);
json_t *__cdecl json_object_copy(json_t *object);
json_t *__cdecl json_object_deep_copy(const json_t *object);
_DWORD *json_array(); // idb
void __cdecl json_delete_array(json_array_t *array);
size_t __cdecl json_array_size(const json_t *json);
json_t *__cdecl json_array_get(const json_t *json, size_t index);
int __cdecl json_array_set_new(json_t *json, size_t index, json_t *value);
void __cdecl array_move(json_array_t *array, size_t dest, size_t src, size_t count);
void __cdecl array_copy(json_t **dest, size_t dpos, json_t **src, size_t spos, size_t count);
json_t **__cdecl json_array_grow(json_array_t *array, size_t amount, int copy);
int __cdecl json_array_append_new(json_t *json, json_t *value);
int __cdecl json_array_insert_new(json_t *json, size_t index, json_t *value);
int __cdecl json_array_remove(json_t *json, size_t index);
int __cdecl json_array_clear(json_t *json);
int __cdecl json_array_extend(json_t *json, json_t *other_json);
int __cdecl json_array_equal(json_t *array1, json_t *array2);
json_t *__cdecl json_array_copy(json_t *array);
json_t *__cdecl json_array_deep_copy(const json_t *array);
_DWORD *__fastcall json_string_nocheck(const char *a1); // idb
_DWORD *__fastcall json_string(const char *a1); // idb
const char *__cdecl json_string_value(const json_t *json);
int __fastcall json_string_set_nocheck(int a1, const char *a2); // idb
int __fastcall json_string_set(int a1, const char *a2); // idb
void __cdecl json_delete_string(json_string_t *string);
bool __fastcall json_string_equal(const json_t *a1, const json_t *a2);
_DWORD *__fastcall json_string_copy(const json_t *a1);
_QWORD *__fastcall json_integer(__int64 a1);
__int64 __fastcall json_integer_value(int a1);
int __fastcall json_integer_set(int a1, __int64 a2);
void __fastcall json_delete_integer(void *a1);
int __cdecl json_integer_equal(json_t *integer1, json_t *integer2);
json_t *__cdecl json_integer_copy(const json_t *integer);
json_t *__cdecl json_real(double value);
double __cdecl json_real_value(const json_t *json);
int __cdecl json_real_set(json_t *json, double value);
void __fastcall json_delete_real(void *a1);
int __cdecl json_real_equal(json_t *real1, json_t *real2);
json_t *__cdecl json_real_copy(const json_t *real);
double __cdecl json_number_value(const json_t *json);
void *json_true();
void *json_false();
void *json_null();
void __fastcall json_delete(void **a1); // idb
int __fastcall json_equal(json_t *a1, json_t *a2);
json_t *__fastcall json_copy(json_t *a1);
json_t *__fastcall json_deep_copy(const json_t *a1);
void __cdecl jsonp_error_init(json_error_t *error, const char *source);
char *__fastcall jsonp_error_set_source(char *result, const char *a2); // idb
void jsonp_error_set(json_error_t *error, int line, int column, size_t position, const char *msg, ...);
void __cdecl jsonp_error_vset(json_error_t *error, int line, int column, size_t position, const char *msg, va_list ap);
int __fastcall divsi3_skip_div0_test(int result, unsigned int a2); // idb
int _aeabi_ldiv0();
int __fastcall init(int a1, int a2, int a3);
int _libc_csu_fini(); // weak
void term_proc();

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_1A3E0; // weak
_UNKNOWN loc_1A3E8; // weak
_UNKNOWN loc_1A3F0; // weak
_UNKNOWN loc_1A3F8; // weak
_UNKNOWN loc_1A400; // weak
_UNKNOWN loc_1A408; // weak
_UNKNOWN loc_1A410; // weak
_UNKNOWN loc_1A418; // weak
_UNKNOWN loc_27C20; // weak
_WORD crc_itu_t_table[256] =
{
  0,
  4129,
  8258,
  12387,
  16516,
  20645,
  24774,
  28903,
  -32504,
  -28375,
  -24246,
  -20117,
  -15988,
  -11859,
  -7730,
  -3601,
  4657,
  528,
  12915,
  8786,
  21173,
  17044,
  29431,
  25302,
  -27847,
  -31976,
  -19589,
  -23718,
  -11331,
  -15460,
  -3073,
  -7202,
  9314,
  13379,
  1056,
  5121,
  25830,
  29895,
  17572,
  21637,
  -23190,
  -19125,
  -31448,
  -27383,
  -6674,
  -2609,
  -14932,
  -10867,
  13907,
  9842,
  5649,
  1584,
  30423,
  26358,
  22165,
  18100,
  -18597,
  -22662,
  -26855,
  -30920,
  -2081,
  -6146,
  -10339,
  -14404,
  18628,
  22757,
  26758,
  30887,
  2112,
  6241,
  10242,
  14371,
  -13876,
  -9747,
  -5746,
  -1617,
  -30392,
  -26263,
  -22262,
  -18133,
  23285,
  19156,
  31415,
  27286,
  6769,
  2640,
  14899,
  10770,
  -9219,
  -13348,
  -1089,
  -5218,
  -25735,
  -29864,
  -17605,
  -21734,
  27814,
  31879,
  19684,
  23749,
  11298,
  15363,
  3168,
  7233,
  -4690,
  -625,
  -12820,
  -8755,
  -21206,
  -17141,
  -29336,
  -25271,
  32407,
  28342,
  24277,
  20212,
  15891,
  11826,
  7761,
  3696,
  -97,
  -4162,
  -8227,
  -12292,
  -16613,
  -20678,
  -24743,
  -28808,
  -28280,
  -32343,
  -20022,
  -24085,
  -12020,
  -16083,
  -3762,
  -7825,
  4224,
  161,
  12482,
  8419,
  20484,
  16421,
  28742,
  24679,
  -31815,
  -27752,
  -23557,
  -19494,
  -15555,
  -11492,
  -7297,
  -3234,
  689,
  4752,
  8947,
  13010,
  16949,
  21012,
  25207,
  29270,
  -18966,
  -23093,
  -27224,
  -31351,
  -2706,
  -6833,
  -10964,
  -15091,
  13538,
  9411,
  5280,
  1153,
  29798,
  25671,
  21540,
  17413,
  -22565,
  -18438,
  -30823,
  -26696,
  -6305,
  -2178,
  -14563,
  -10436,
  9939,
  14066,
  1681,
  5808,
  26199,
  30326,
  17941,
  22068,
  -9908,
  -13971,
  -1778,
  -5841,
  -26168,
  -30231,
  -18038,
  -22101,
  22596,
  18533,
  30726,
  26663,
  6336,
  2273,
  14466,
  10403,
  -13443,
  -9380,
  -5313,
  -1250,
  -29703,
  -25640,
  -21573,
  -17510,
  19061,
  23124,
  27191,
  31254,
  2801,
  6864,
  10931,
  14994,
  -722,
  -4849,
  -8852,
  -12979,
  -16982,
  -21109,
  -25112,
  -29239,
  31782,
  27655,
  23652,
  19525,
  15522,
  11395,
  7392,
  3265,
  -4321,
  -194,
  -12451,
  -8324,
  -20581,
  -16454,
  -28711,
  -24584,
  28183,
  32310,
  20053,
  24180,
  11923,
  16050,
  3793,
  7920
}; // weak
char gI2c = '\0'; // weak
_UNKNOWN IV224; // weak
_UNKNOWN IV256; // weak
_UNKNOWN IV384; // weak
_UNKNOWN IV512; // weak
_DWORD sigma[256] =
{
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  14,
  10,
  4,
  8,
  9,
  15,
  13,
  6,
  1,
  12,
  0,
  2,
  11,
  7,
  5,
  3,
  11,
  8,
  12,
  0,
  5,
  2,
  15,
  13,
  10,
  14,
  3,
  6,
  7,
  1,
  9,
  4,
  7,
  9,
  3,
  1,
  13,
  12,
  11,
  14,
  2,
  6,
  5,
  10,
  4,
  0,
  15,
  8,
  9,
  0,
  5,
  7,
  2,
  4,
  10,
  15,
  14,
  1,
  11,
  12,
  6,
  8,
  3,
  13,
  2,
  12,
  6,
  10,
  0,
  11,
  8,
  3,
  4,
  13,
  7,
  5,
  15,
  14,
  1,
  9,
  12,
  5,
  1,
  15,
  14,
  13,
  4,
  10,
  0,
  7,
  6,
  3,
  9,
  2,
  8,
  11,
  13,
  11,
  7,
  14,
  12,
  1,
  3,
  9,
  5,
  0,
  15,
  4,
  8,
  6,
  2,
  10,
  6,
  15,
  14,
  9,
  11,
  3,
  0,
  8,
  12,
  2,
  13,
  7,
  1,
  4,
  10,
  5,
  10,
  2,
  8,
  4,
  7,
  6,
  1,
  5,
  15,
  11,
  9,
  14,
  3,
  12,
  13,
  0,
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  14,
  10,
  4,
  8,
  9,
  15,
  13,
  6,
  1,
  12,
  0,
  2,
  11,
  7,
  5,
  3,
  11,
  8,
  12,
  0,
  5,
  2,
  15,
  13,
  10,
  14,
  3,
  6,
  7,
  1,
  9,
  4,
  7,
  9,
  3,
  1,
  13,
  12,
  11,
  14,
  2,
  6,
  5,
  10,
  4,
  0,
  15,
  8,
  9,
  0,
  5,
  7,
  2,
  4,
  10,
  15,
  14,
  1,
  11,
  12,
  6,
  8,
  3,
  13,
  2,
  12,
  6,
  10,
  0,
  11,
  8,
  3,
  4,
  13,
  7,
  5,
  15,
  14,
  1,
  9
}; // weak
_QWORD CB[16] =
{
  2611923443488327891LL,
  1376283091369227076LL,
  -6626703657320631856LL,
  589684135938649225LL,
  4983270260364809079LL,
  -4732044268327596948LL,
  -4563226453097033507LL,
  4577018097722394903LL,
  -7919907764393346277LL,
  -3372901835766516308LL,
  3458046377305235383LL,
  -5124621466747896170LL,
  -5008970055469465703LL,
  2639559389850201335LL,
  577009281997405206LL,
  7163292796296056425LL
}; // weak
_UNKNOWN salt_zero_small; // weak
_UNKNOWN salt_zero_big; // weak
char values_str_6753[3] = "01"; // weak
char dir_str_6737[3] = "in"; // weak
_DWORD primes[29] =
{
  5,
  13,
  23,
  53,
  97,
  193,
  389,
  769,
  1543,
  3079,
  6151,
  12289,
  24593,
  49157,
  98317,
  196613,
  393241,
  786433,
  1572869,
  3145739,
  6291469,
  12582917,
  25165843,
  50331653,
  100663319,
  201326611,
  402653189,
  805306457,
  1610612741
}; // weak
_UNKNOWN *_frame_dummy_init_array_entry = (_UNKNOWN *)0x9029; // weak
_UNKNOWN *_do_global_dtors_aux_fini_array_entry = (_UNKNOWN *)0x9011; // weak
char gChain = '\xFF'; // weak
char *BM1722_WorkDataPathPrefix[3] =
{
  "/media/card/minertest-BM1722/dcr-asic-",
  "/media/card/minertest-BM1725/dcr-asic-",
  "/core_"
}; // weak
char *BM1725_WorkDataPathPrefix[2] = { "/media/card/minertest-BM1725/dcr-asic-", "/core_" }; // weak
char *DCR_WorkDataFilePrefix = "/core_"; // weak
_BYTE Sensor1_OK[4] = { 1, 0, 0, 0 }; // weak
_BYTE Sensor2_OK[4] = { 1, 0, 0, 0 }; // weak
_BYTE Sensor3_OK[4] = { 1, 0, 0, 0 }; // weak
__int16 power_protocal_type = 1; // weak
char power_iic_addr = '\x10'; // weak
char power_iic_no = '\x01'; // weak
int t9_fpga_map = 0; // weak
int dword_35554 = 1; // weak
int dword_3557C = 12; // weak
int dword_35580 = 13; // weak
int dword_35588 = 15; // weak
int dword_35598 = 33; // weak
int dword_355FC = 96; // weak
int dword_35600 = 97; // weak
int dword_35604 = 98; // weak
int dword_35608 = 99; // weak
int dword_3560C = 100; // weak
int dword_35614 = 102; // weak
int dword_35618 = 103; // weak
int dword_3561C = 104; // weak
int dword_35620 = 105; // weak
int dword_35624 = 106; // weak
int dword_35628 = 107; // weak
int dword_3562C = 108; // weak
int dword_35630 = 109; // weak
int dword_35634 = 110; // weak
int dword_35638 = 111; // weak
int dword_3563C = 112; // weak
int dword_35640 = 113; // weak
int dword_35644 = 114; // weak
int dword_35648 = 115; // weak
int dword_3564C = 116; // weak
int dword_35650 = 117; // weak
int dword_35654 = 118; // weak
int dword_35658 = 119; // weak
int dword_3565C = 124; // weak
int dword_35660 = 125; // weak
int dword_35664 = 126; // weak
int dword_35668 = 127; // weak
int dword_3566C = 128; // weak
int dword_35670 = 129; // weak
int dword_35674 = 130; // weak
int dword_35678 = 132; // weak
int dword_3567C = 133; // weak
int dword_35680 = 134; // weak
int dword_35684 = 135; // weak
int dword_35688 = 136; // weak
int dword_3568C = 137; // weak
int dword_35690 = 138; // weak
int dword_35694 = 139; // weak
int dword_356B8 = 148; // weak
int dword_356BC = 149; // weak
int dword_356C0 = 150; // weak
int dword_356C4 = 151; // weak
int dword_356C8 = 152; // weak
int dword_356CC = 153; // weak
int dword_356D0 = 154; // weak
int dword_356D4 = 155; // weak
int dword_356D8 = 156; // weak
int dword_356DC = 157; // weak
int dword_356E0 = 158; // weak
int dword_356E4 = 159; // weak
int dword_356E8 = 164; // weak
int dword_356EC = 165; // weak
int dword_356F0 = 166; // weak
int dword_356F4 = 167; // weak
int dword_356F8 = 168; // weak
int dword_356FC = 169; // weak
int dword_35700 = 170; // weak
int dword_35704 = 171; // weak
int v9_fpga_map = 0; // weak
int dword_357E8 = 1; // weak
int dword_35810 = 12; // weak
int dword_35814 = 13; // weak
int dword_3581C = 15; // weak
int dword_3582C = 33; // weak
int dword_35890 = 96; // weak
int dword_35894 = 97; // weak
int dword_35898 = 98; // weak
int dword_358A0 = 100; // weak
int dword_358A4 = 101; // weak
int dword_358A8 = 102; // weak
int dword_358AC = 103; // weak
int dword_358B0 = 104; // weak
int dword_358B4 = 105; // weak
int dword_358B8 = 106; // weak
int dword_358BC = 107; // weak
int dword_358C0 = 108; // weak
int dword_358C4 = 109; // weak
int dword_358C8 = 110; // weak
int dword_358CC = 111; // weak
int dword_358D0 = 112; // weak
int dword_358D4 = 113; // weak
int dword_358D8 = 114; // weak
int dword_358DC = 115; // weak
int dword_358E0 = 116; // weak
int dword_358E4 = 117; // weak
int dword_358E8 = 118; // weak
int dword_358EC = 119; // weak
int dword_358F0 = 124; // weak
int dword_358F4 = 125; // weak
int dword_358F8 = 126; // weak
int dword_358FC = 127; // weak
int dword_35900 = 128; // weak
int dword_3590C = 132; // weak
int dword_35910 = 133; // weak
int dword_35914 = 134; // weak
int dword_35918 = 135; // weak
int dword_3591C = 136; // weak
int dword_35920 = 137; // weak
int dword_35924 = 138; // weak
int dword_35928 = 139; // weak
int dword_3592C = 140; // weak
int dword_35930 = 141; // weak
int dword_35934 = 142; // weak
int dword_35938 = 143; // weak
int dword_3593C = 144; // weak
int dword_35940 = 145; // weak
int dword_35944 = 146; // weak
int dword_35948 = 147; // weak
int dword_3594C = 148; // weak
int dword_35950 = 149; // weak
int dword_35954 = 150; // weak
int dword_35958 = 151; // weak
int lcd_ctx = -1; // weak
char *lcd_path = "/dev/bitmain-lcd"; // weak
void *(*do_malloc)(size_t size) = &malloc; // weak
void (*do_free)(void *ptr) = &free; // weak
_UNKNOWN the_null_7288; // weak
_UNKNOWN the_false_7284; // weak
_UNKNOWN the_true_7280; // weak
int stdin; // weak
char completed_8605; // weak
char gHashBoard_BBD12601; // weak
char gHashBoard_BBD25601; // weak
pthread_mutex_t i2c_mutex_0; // weak
char gHowManyVoltageLevel; // weak
char pattern_test_time; // weak
_DWORD time_counter[4]; // weak
_BYTE gStartTest[4]; // weak
_BYTE gIsOpenCoreEnd[4]; // weak
_BYTE gIsOpeningCore[4]; // weak
_BYTE start_receive[4]; // weak
int gChain_Asic_Interval; // weak
int gName_len; // weak
int gSensor_number; // weak
_DWORD gReceive_Nonce_Num[4]; // weak
_DWORD gValid_Nonce_Num[4]; // weak
_DWORD gHw_Nonce_Num[4]; // weak
_DWORD gSend_Work_Num[4]; // weak
_UNKNOWN gAsic_Core_Nonce_Num; // weak
_UNKNOWN unk_493E0; // weak
_UNKNOWN unk_61A80; // weak
_UNKNOWN unk_7A120; // weak
_UNKNOWN unk_F4240; // weak
_UNKNOWN unk_FFC00; // weak
_UNKNOWN unk_1004C4; // weak
_DWORD gRepeated_Nonce_Id[4]; // weak
_BYTE gWork_Num_For_Hw_Check[4]; // weak
_BYTE gNotReadOutTemp[4]; // weak
_BYTE gT1_offset_value[4]; // weak
_BYTE gT2_offset_value[4]; // weak
_BYTE gT3_offset_value[4]; // weak
_DWORD Sensor1_temp[4]; // weak
_DWORD Sensor2_temp[4]; // weak
_DWORD Sensor3_temp[4]; // weak
_DWORD last_Sensor1_temp[4]; // weak
_DWORD last_Sensor2_temp[4]; // weak
_DWORD last_Sensor3_temp[4]; // weak
_DWORD highest_temp[4]; // weak
_DWORD lowest_temp[4]; // weak
_DWORD gGlobalHighestTemp[4]; // weak
_DWORD temp_change[4]; // weak
_BYTE gHigherThanAlarmTemp[4]; // weak
_BYTE gHigherThanMaxTempGap[4]; // weak
_DWORD gMaxTempGap_value[4]; // weak
_BYTE gIsReadTemp[4]; // weak
_BYTE gReadingTemp[4]; // weak
int start_time; // weak
int dword_235C28; // weak
int end_time; // weak
int dword_235C30; // weak
int diff_time; // weak
int dword_235C38; // weak
char g_test_epprom; // weak
int i2c_fd; // weak
int power_fd; // weak
int e2prom_fd; // weak
int key_pressed; // weak
int fan_pwm_handle; // weak
int platform_inited; // weak
int platform_is_t9; // weak
unsigned int capability[73]; // weak
int fpga_inited; // weak
int fpga_fd; // weak
int axi_fpga_addr; // weak
int gpio_inited; // weak
int gpio_thread; // weak
int thread; // weak
pthread_mutex_t api_mutex; // weak
pthread_mutex_t gpio_ctrl_map; // weak
int dword_235DC8; // weak
pthread_mutex_t iic_mutex; // weak
_UNKNOWN pwm_param; // weak
pthread_mutex_t uart_send_mutex[16]; // weak
pthread_mutex_t uart_receive_mutex[16]; // weak
pthread_mutex_t ui_api_mutex; // weak
int ui_flicker_map; // weak
int ui_inited; // weak
int ui_pull_thread; // weak
int ui_thread; // weak
_DWORD ui_callback[5]; // weak
int lcd_fd; // weak
int lcd_inited; // weak
pthread_mutex_t lcd_mutex; // weak
_UNKNOWN lcd_output; // weak
pthread_mutex_t i2c_mutex; // weak
int i2c_ctx_map; // weak
int i2c_index; // weak
int conf_loaded; // weak
_DWORD chains[64]; // weak
_DWORD fans[18]; // weak
int red_addr; // weak
int green_addr; // weak
int reset_addr; // weak
int ipreport_addr; // weak
_UNKNOWN cgpu; // weak
pthread_t dword_2B630C; // idb
pthread_t dword_2B6310; // idb
pthread_t newthread; // idb
pthread_t dword_2B6318; // idb
pthread_t dword_2B631C; // idb
char dest[64]; // idb
char byte_2B636C[64]; // idb
int dword_2B63AC; // weak
int dword_2B67AC; // weak
int dword_3367AC; // weak
int dword_3367C8; // weak
char byte_3367CC; // weak
char byte_3367CD; // weak
char byte_3367CE; // weak
_BYTE chain_info[8]; // weak
int reg_value_buf; // weak
char Conf; // weak
int dword_33681C; // weak
float flt_336820; // weak
int dword_336824; // weak
int dword_336828; // weak
int dword_33682C; // weak
int dword_336830; // weak
int dword_336834; // weak
int dword_336838; // weak
int dword_33683C; // weak
int dword_336840; // weak
int dword_336844; // weak
int dword_336848; // weak
int dword_33684C; // weak
int dword_336850; // weak
int dword_336878; // weak
int dword_33687C; // weak
int dword_336880; // weak
int dword_336884; // weak
int dword_336888; // weak
int dword_33688C; // weak
int dword_336890; // weak
int dword_336894; // weak
int dword_336898; // weak
int dword_33689C; // weak
int dword_3368A0; // weak
int dword_3368A4; // weak
char byte_3368AC; // weak
char byte_3368AD; // weak
char byte_3368AE; // weak
char byte_3368AF; // weak
char byte_3368B0; // weak
char byte_3368B1; // weak
char byte_3368B2; // weak
int dword_3368B4; // weak
int dword_3368B8; // weak
char byte_3368BC; // weak
_UNKNOWN unk_3368C0; // weak
int dword_3368C4; // weak
int dword_3368C8; // weak
int dword_3368CC; // weak
int dword_3368D0; // weak
int dword_3368D4; // weak
char byte_3368D8; // weak
int dword_3368DC; // weak
int dword_3368E0; // weak
int dword_3368E4; // weak
pthread_mutex_t HW_check_mutex[4]; // weak
_UNKNOWN gWorks_For_Hw_Check; // weak
pthread_mutex_t reg_mutex; // weak
char lcd_output_0[16]; // weak
char s[16]; // idb
char byte_338960[16]; // idb
char byte_338970[16]; // idb
_BYTE lcd_buffer[16]; // weak
// extern _UNKNOWN __gmon_start__; weak


//----- (00008C64) --------------------------------------------------------
// Alternative name is '_init'
int init_proc()
{
  return call_gmon_start();
}

//----- (00008C70) --------------------------------------------------------
void sub_8C70()
{
  JUMPOUT(0);
}
// 8C7C: control flows out of bounds to 0

//----- (00008E04) --------------------------------------------------------
// attributes: thunk
int j___gmon_start__()
{
  return _gmon_start__();
}
// 8E08: using guessed type int _gmon_start__(void);

//----- (00008F70) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __noreturn start(void (*a1)(), int a2, int a3, int a4, ...)
{
  int v4; // [sp-4h] [bp-4h]
  va_list va; // [sp+0h] [bp+0h] BYREF

  va_start(va, a4);
  _libc_start_main(
    (int (*)(int, char **, char **))main,
    v4,
    (char **)va,
    (void (*)())init,
    (void (*)())_libc_csu_fini,
    a1,
    va);
  abort();
}
// 8F7C: positive sp value 4 has been found
// 8F92: variable 'v4' is possibly undefined
// 28204: using guessed type int init();
// 28248: using guessed type int _libc_csu_fini();

//----- (00008FA8) --------------------------------------------------------
int call_gmon_start()
{
  int result; // r0

  if ( &__gmon_start__ )
    return j___gmon_start__();
  return result;
}

//----- (00008FC0) --------------------------------------------------------
int *deregister_tm_clones()
{
  return &stdin;
}
// 35AA0: using guessed type int stdin;

//----- (00008FE4) --------------------------------------------------------
__int64 register_tm_clones()
{
  __int64 result; // r0

  LODWORD(result) = &stdin;
  HIDWORD(result) = 0;
  return result;
}
// 35AA0: using guessed type int stdin;

//----- (00009010) --------------------------------------------------------
int *_do_global_dtors_aux()
{
  int *result; // r0

  if ( !completed_8605 )
  {
    result = deregister_tm_clones();
    completed_8605 = 1;
  }
  return result;
}
// 35AA4: using guessed type char completed_8605;

//----- (00009028) --------------------------------------------------------
__int64 frame_dummy()
{
  return register_tm_clones();
}

//----- (00009048) --------------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  _BYTE s[64]; // [sp+4h] [bp+4h] BYREF
  int key; // [sp+44h] [bp+44h]

  memset(s, 0, sizeof(s));
  key = cgpu_init();
  if ( key < 0 )
    return key;
  key = configMiner();
  if ( key >= 0 )
  {
    display_arguments();
    puts("press key to test!");
    while ( 1 )
    {
      while ( 1 )
      {
        key = read_key(s);
        if ( dword_336848 != 1 )
          break;
        if ( key > 0 && s[0] == 1 )
        {
          if ( dword_336850 == 1722 )
          {
            singleAsicTest_BM1722();
          }
          else if ( dword_336850 == 1725 )
          {
            singleAsicTest_BM1725();
          }
          else
          {
            printf("Single ASIC test: Can't find ASIC type!!! AsicType = %d\n", dword_336850);
          }
        }
      }
      if ( key > 0 && s[0] == 1
        || (unsigned __int8)pattern_test_time < (unsigned int)(unsigned __int8)gHowManyVoltageLevel && pattern_test_time )
      {
        if ( gHashBoard_BBD12601 )
        {
          singleBoardTest_BBD12601();
        }
        else if ( gHashBoard_BBD25601 )
        {
          singleBoardTest_BBD25601();
        }
        else
        {
          printf("%s: Please config HashBoard name in Config.ini\n", "main");
        }
      }
      if ( (unsigned __int8)pattern_test_time >= (unsigned int)(unsigned __int8)gHowManyVoltageLevel )
        pattern_test_time = 0;
    }
  }
  return key;
}
// 35AA8: using guessed type char gHashBoard_BBD12601;
// 35AA9: using guessed type char gHashBoard_BBD25601;
// 35AC4: using guessed type char gHowManyVoltageLevel;
// 35AC5: using guessed type char pattern_test_time;
// 336848: using guessed type int dword_336848;
// 336850: using guessed type int dword_336850;

//----- (0000919C) --------------------------------------------------------
size_t __fastcall get_BM1722_asic_register(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 a3, char a4)
{
  unsigned __int8 v6[4]; // [sp+8h] [bp+8h] BYREF
  unsigned __int8 v7; // [sp+Ch] [bp+Ch]

  v7 = 0;
  v6[0] = 66;
  v6[1] = 5;
  v6[2] = a2;
  v6[3] = a3;
  if ( a4 )
    v6[0] |= 0x10u;
  v7 = CRC5(v6, 0x20u);
  return dcr_uart_send(a1, v6, 5u);
}

//----- (00009208) --------------------------------------------------------
size_t __fastcall set_BM1722_asic_register(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 a3, char a4, int a5)
{
  unsigned __int8 v7[4]; // [sp+Ch] [bp+Ch] BYREF
  char v8; // [sp+10h] [bp+10h]
  char v9; // [sp+11h] [bp+11h]
  char v10; // [sp+12h] [bp+12h]
  char v11; // [sp+13h] [bp+13h]
  unsigned __int8 v12; // [sp+14h] [bp+14h]

  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  qmemcpy(v7, "A\t", 2);
  v7[2] = a2;
  v7[3] = a3;
  if ( a4 )
    v7[0] |= 0x10u;
  v8 = HIBYTE(a5);
  v9 = BYTE2(a5);
  v10 = BYTE1(a5);
  v11 = a5;
  v12 = CRC5(v7, 0x40u);
  return dcr_uart_send(a1, v7, 9u);
}

//----- (000092A0) --------------------------------------------------------
size_t __fastcall set_BM1722_freq(unsigned __int8 a1, unsigned __int8 a2, char a3)
{
  float v3; // s0
  float v8; // [sp+10h] [bp+8h] BYREF
  unsigned __int8 v9; // [sp+17h] [bp+Fh] BYREF
  int v10; // [sp+18h] [bp+10h] BYREF
  int pllparam_divider; // [sp+1Ch] [bp+14h]

  v10 = 0;
  v9 = 0;
  pllparam_divider = 0;
  v8 = 0.0;
  printf("\n--- %s: freq = %f\n", "set_BM1722_freq", v3);
  pllparam_divider = get_pllparam_divider(&v10, &v9, &v8);
  v10 |= 0xC0000000;
  printf("\n%s: pll_param = %08x, divider = %02x, pll_freq = %f\n", "set_BM1722_freq", v10, --v9, v8);
  set_BM1722_asic_register(a1, a2, 0xCu, a3, v10);
  usleep(0x3E8u);
  set_BM1722_asic_register(a1, a2, 0x70u, a3, v9);
  usleep(0x3E8u);
  return set_BM1722_asic_register(a1, a2, 0xCu, a3, v10);
}
// 92A0: too many cbuild loops
// 92E0: variable 'v3' is possibly undefined

//----- (00009390) --------------------------------------------------------
int __fastcall BM1722_chain_inactive(unsigned __int8 a1)
{
  unsigned __int8 v3[4]; // [sp+8h] [bp+8h] BYREF
  unsigned __int8 v4; // [sp+Ch] [bp+Ch]

  v4 = 0;
  printf("\n--- %s\n", "BM1722_chain_inactive");
  v3[0] = 83;
  v3[1] = 5;
  v3[2] = 0;
  v3[3] = 0;
  v4 = CRC5(v3, 0x20u);
  dcr_uart_send(a1, v3, 5u);
  return usleep(0x1388u);
}

//----- (00009404) --------------------------------------------------------
size_t __fastcall BM1722_set_address(unsigned __int8 a1, unsigned __int8 a2)
{
  unsigned __int8 v4[4]; // [sp+8h] [bp+8h] BYREF
  unsigned __int8 v5; // [sp+Ch] [bp+Ch]

  v5 = 0;
  v4[0] = 64;
  v4[1] = 5;
  v4[2] = a2;
  v4[3] = 0;
  v5 = CRC5(v4, 0x20u);
  return dcr_uart_send(a1, v4, 5u);
}

//----- (00009460) --------------------------------------------------------
unsigned int __fastcall BM1722_set_address_all(unsigned __int8 a1)
{
  unsigned int result; // r0
  unsigned int i; // [sp+8h] [bp+8h]
  int v4; // [sp+Ch] [bp+Ch]

  v4 = 0;
  printf("\n--- %s: Chain : %d\n", "BM1722_set_address_all", a1);
  BM1722_chain_inactive(a1);
  for ( i = 0; ; ++i )
  {
    result = 0x100u / gChain_Asic_Interval;
    if ( 0x100u / gChain_Asic_Interval <= i )
      break;
    BM1722_set_address(a1, v4);
    v4 += gChain_Asic_Interval;
    usleep(0x1388u);
  }
  return result;
}
// 35AE8: using guessed type int gChain_Asic_Interval;

//----- (000094EC) --------------------------------------------------------
int __fastcall BM1722_open_core(unsigned __int8 a1)
{
  int result; // r0
  char s[186]; // [sp+14h] [bp+Ch] BYREF
  __int16 v4; // [sp+CEh] [bp+C6h]
  int v5; // [sp+D0h] [bp+C8h]
  unsigned int i; // [sp+D4h] [bp+CCh]

  i = 0;
  memset(s, 0, 0xB8u);
  s[0] = -1;
  printf("\n--- %s: Chain : %d\n", "BM1722_open_core", a1);
  gIsOpenCoreEnd[a1] = 0;
  gIsOpeningCore[a1] = 1;
  strcpy(s, " ");
  memset(&s[2], 0, 0xB4u);
  v4 = CRC16(s, 182);
  s[182] = HIBYTE(v4);
  s[183] = v4;
  for ( i = 0; dword_33684C > i; ++i )
  {
    if ( i > 0x1F )
    {
      if ( i > 0x3F )
      {
        if ( i > 0x5F )
        {
          if ( i <= 0x7F )
          {
            if ( i == 96 )
              v5 = 0;
            v5 = (2 * v5) | 1;
            set_BM1722_asic_register(a1, 0, 0x5Cu, 1, v5);
          }
        }
        else
        {
          if ( i == 64 )
            v5 = 0;
          v5 = (2 * v5) | 1;
          set_BM1722_asic_register(a1, 0, 0x58u, 1, v5);
        }
      }
      else
      {
        if ( i == 32 )
          v5 = 0;
        v5 = (2 * v5) | 1;
        set_BM1722_asic_register(a1, 0, 0x54u, 1, v5);
      }
    }
    else
    {
      if ( !i )
        v5 = 0;
      v5 = (2 * v5) | 1;
      set_BM1722_asic_register(a1, 0, 0x50u, 1, v5);
    }
    dcr_uart_send(a1, s, 0xB8u);
    usleep(dword_3368A0);
  }
  result = uart_flush_rx(a1);
  gIsOpeningCore[a1] = 0;
  gIsOpenCoreEnd[a1] = 1;
  return result;
}
// 95D6: conditional instruction was optimized away because %var_4.4 is in (20..3F)
// 9618: conditional instruction was optimized away because %var_4.4 is in (40..5F)
// 965A: conditional instruction was optimized away because %var_4.4 is in (60..7F)
// 35ADC: using guessed type _BYTE gIsOpenCoreEnd[4];
// 35AE0: using guessed type _BYTE gIsOpeningCore[4];
// 33684C: using guessed type int dword_33684C;
// 3368A0: using guessed type int dword_3368A0;

//----- (000096F8) --------------------------------------------------------
unsigned int __fastcall check_BM1722_asic_reg(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 a3, char a4)
{
  int v4; // r2
  __int16 v5; // r1
  int v6; // r0
  _DWORD s[2]; // [sp+8h] [bp+8h] BYREF
  unsigned int v13; // [sp+10h] [bp+10h]
  unsigned int v14; // [sp+14h] [bp+14h]
  unsigned int i; // [sp+18h] [bp+18h]
  unsigned int v16; // [sp+1Ch] [bp+1Ch]

  s[0] = 0;
  LOWORD(s[1]) = 0;
  BYTE2(s[1]) = 0;
  v16 = 0;
  v13 = 0;
  i = 0;
  v14 = 0x80000000;
  clear_register_value_buf();
  get_BM1722_asic_register(a1, a2, a3, a4);
  if ( !a3 )
    *((_BYTE *)&cgpu + a1 + 1049784) = 0;
  while ( v16 <= 2 )
  {
    usleep(0xC350u);
    pthread_mutex_lock(&reg_mutex);
    v13 = *(_DWORD *)(reg_value_buf + 8);
    pthread_mutex_unlock(&reg_mutex);
    if ( v13 )
    {
      v16 = 0;
      for ( i = 0; i < v13; ++i )
      {
        pthread_mutex_lock(&reg_mutex);
        if ( a1 == *(unsigned __int8 *)(reg_value_buf + 10 * *(_DWORD *)(reg_value_buf + 4) + 25) )
        {
          memset(s, 0, 7u);
          v4 = reg_value_buf + 10 * *(_DWORD *)(reg_value_buf + 4) + 16;
          s[0] = *(_DWORD *)v4;
          v5 = *(_WORD *)(v4 + 4);
          LOBYTE(v4) = *(_BYTE *)(v4 + 6);
          LOWORD(s[1]) = v5;
          BYTE2(s[1]) = v4;
          if ( CRC5((unsigned __int8 *)s, 0x33u) == *(unsigned __int8 *)(reg_value_buf
                                                                       + 10 * *(_DWORD *)(reg_value_buf + 4)
                                                                       + 24) )
          {
            if ( !a3 )
              ++*((_BYTE *)&cgpu + a1 + 1049784);
            v14 = _byteswap_ulong(*(_DWORD *)(reg_value_buf + 10 * (*(_DWORD *)(reg_value_buf + 4))++ + 16));
            --*(_DWORD *)(reg_value_buf + 8);
            if ( *(_DWORD *)(reg_value_buf + 4) == 513 )
              *(_DWORD *)(reg_value_buf + 4) = 0;
            pthread_mutex_unlock(&reg_mutex);
          }
          else
          {
            ++*(_DWORD *)(reg_value_buf + 4);
            --*(_DWORD *)(reg_value_buf + 8);
            if ( *(_DWORD *)(reg_value_buf + 4) == 513 )
              *(_DWORD *)(reg_value_buf + 4) = 0;
            v6 = CRC5((unsigned __int8 *)s, 0x33u);
            printf(
              "%s: crc is 0x%x, but it should be 0x%x\n",
              "check_BM1722_asic_reg",
              v6,
              *(unsigned __int8 *)(reg_value_buf + 10 * *(_DWORD *)(reg_value_buf + 4) + 24));
            pthread_mutex_unlock(&reg_mutex);
          }
        }
        else
        {
          ++*(_DWORD *)(reg_value_buf + 4);
          --*(_DWORD *)(reg_value_buf + 8);
          if ( *(_DWORD *)(reg_value_buf + 4) == 513 )
            *(_DWORD *)(reg_value_buf + 4) = 0;
          printf(
            "%s: the return data is from chain%d, but it should be from chain%d\n",
            "check_BM1722_asic_reg",
            *(unsigned __int8 *)(reg_value_buf + 10 * *(_DWORD *)(reg_value_buf + 4) + 25),
            a1);
          pthread_mutex_unlock(&reg_mutex);
        }
      }
    }
    else
    {
      ++v16;
    }
  }
  v16 = 0;
  if ( !a3 )
  {
    if ( *((unsigned __int8 *)&cgpu + a1 + 1049784) > (unsigned int)dword_3367C8 )
      dword_3367C8 = *((unsigned __int8 *)&cgpu + a1 + 1049784);
    printf("%s: chain J%d has %d ASIC\n", "check_BM1722_asic_reg", a1 + 1, *((unsigned __int8 *)&cgpu + a1 + 1049784));
  }
  clear_register_value_buf();
  return v14;
}
// 3367C8: using guessed type int dword_3367C8;
// 3367D8: using guessed type int reg_value_buf;
// 338928: using guessed type pthread_mutex_t reg_mutex;

//----- (00009B5C) --------------------------------------------------------
int singleAsicTest_BM1722()
{
  int result; // r0
  char v1[16]; // [sp+Ch] [bp+4h] BYREF
  int v2; // [sp+1Ch] [bp+14h]
  int v3; // [sp+20h] [bp+18h]
  int v4; // [sp+24h] [bp+1Ch]

  v4 = 0;
  v3 = 0;
  v2 = 123456;
  qmemcpy(v1, "                ", sizeof(v1));
  printf("\nBegin %s test\n", "singleAsicTest_BM1722");
  system("date");
  putchar(10);
  reset_global_arg();
  chain_reset(gChain);
  fan_control(0x32u);
  pthread_create(&newthread, 0, (void *(*)(void *))show_status_func, (char *)&chain_info + 2 * (unsigned __int8)gChain);
  start_receive[(unsigned __int8)gChain] = 1;
  pthread_create(&dword_2B6310, 0, (void *(*)(void *))receive_func, (char *)&chain_info + 2 * (unsigned __int8)gChain);
  set_baud(gChain, 0x1Au);
  puts("\n--- check asic number");
  check_BM1722_asic_reg(gChain, 0, 0, 1);
  printf("\n--- check chain: asicNum = %d\n", *((unsigned __int8 *)&cgpu + (unsigned __int8)gChain + 1049784));
  if ( *((unsigned __int8 *)&cgpu + (unsigned __int8)gChain + 1049784) == dword_336848 )
  {
    calculate_timeout_and_baud();
    set_baud(gChain, dword_3368E0);
    set_BM1722_freq(gChain, 0, 1);
    BM1722_set_address_all(gChain);
    check_BM1722_asic_reg(gChain, 0, 0, 1);
    if ( byte_3368D8 == 1 )
    {
      if ( !pattern_test_time )
        get_temperature_offset_value_from_asic_chain(gChain);
      set_default_temperature_offset_value_chain(gChain);
    }
    pthread_create(
      &dword_2B631C,
      0,
      (void *(*)(void *))read_temp_func,
      (char *)&chain_info + 2 * (unsigned __int8)gChain);
    set_BM1725_asic_register(gChain, 0, 0x14u, 1, 38);
    BM1722_open_core(gChain);
    puts("\nBegin send test pattern");
    system("date");
    putchar(10);
    while ( gStartTest[(unsigned __int8)gChain] != 1 )
    {
      if ( time_counter[(unsigned __int8)gChain] >= (unsigned int)dword_3368B4 )
      {
        pthread_cancel(dword_2B631C);
        pthread_cancel(dword_2B6310);
        pthread_cancel(newthread);
        puts("Can't open core, change to next voltage and freq");
        write_lcd(0, (int)"Can't open core ", 0x10u);
        write_lcd_no_memset(1u, (int)"change  to  next", 0x10u);
        result = write_lcd_no_memset(2u, (int)"voltage and freq", 0x10u);
        ++pattern_test_time;
        return result;
      }
      usleep(0x2710u);
    }
    pthread_create(&dword_2B630C, 0, (void *(*)(void *))send_func, (char *)&chain_info + 2 * (unsigned __int8)gChain);
    pthread_join(dword_2B630C, 0);
    pthread_join(dword_2B6310, 0);
    pthread_cancel(newthread);
    pthread_cancel(dword_2B631C);
    LOBYTE(v3) = single_asic_get_result(gChain);
    single_asic_print_lcd((unsigned __int8)gChain, v3);
    return fan_control(0);
  }
  else
  {
    pthread_cancel(dword_2B6310);
    pthread_cancel(newthread);
    sprintf(&v1[7], "%d", *((unsigned __int8 *)&cgpu + (unsigned __int8)gChain + 1049784));
    write_lcd(0, (int)"   Only have    ", 0x10u);
    write_lcd_no_memset(1u, (int)v1, 0x10u);
    write_lcd_no_memset(2u, (int)"      ASIC      ", 0x10u);
    return printf(
             "\n\n%s: Only have %d ASIC\n",
             "singleAsicTest_BM1722",
             *((unsigned __int8 *)&cgpu + (unsigned __int8)gChain + 1049784));
  }
}
// 35530: using guessed type char gChain;
// 35AC5: using guessed type char pattern_test_time;
// 35AC8: using guessed type _DWORD time_counter[4];
// 35AD8: using guessed type _BYTE gStartTest[4];
// 35AE4: using guessed type _BYTE start_receive[4];
// 336820: using guessed type float flt_336820;
// 336848: using guessed type int dword_336848;
// 3368B4: using guessed type int dword_3368B4;
// 3368D8: using guessed type char byte_3368D8;
// 3368E0: using guessed type int dword_3368E0;

//----- (0000A064) --------------------------------------------------------
int singleBoardTest_BBD12601()
{
  _DWORD v1[5]; // [sp+Ch] [bp+4h] BYREF
  int v2; // [sp+20h] [bp+18h]
  int v3; // [sp+24h] [bp+1Ch]

  v3 = 0;
  v2 = 0;
  BYTE1(v1[4]) = 0;
  HIWORD(v1[4]) = 0;
  strcpy((char *)v1, "                ");
  printf("\nBegin %s test\n", "singleBoardTest_BBD12601");
  system("date");
  putchar(10);
  reset_global_arg();
  chain_reset(gChain);
  pthread_create(&newthread, 0, (void *(*)(void *))show_status_func, (char *)&chain_info + 2 * (unsigned __int8)gChain);
  chain_reset_low(gChain);
  usleep((__useconds_t)&unk_493E0);
  reset_PIC16F1704_pic(gChain, gI2c);
  jump_from_loader_to_app_PIC16F1704(gChain, gI2c);
  set_voltage(gChain, gI2c, 0);
  enable_PIC16F1704_dc_dc(gChain, gI2c, 1u);
  pthread_create(
    &dword_2B6318,
    0,
    (void *(*)(void *))pic_heart_beat_func,
    (char *)&chain_info + 2 * (unsigned __int8)gChain);
  usleep(0x64u);
  chain_reset_high(gChain);
  usleep((__useconds_t)&unk_493E0);
  fan_control(0x32u);
  set_baud(gChain, 0x1Au);
  start_receive[(unsigned __int8)gChain] = 1;
  pthread_create(&dword_2B6310, 0, (void *(*)(void *))receive_func, (char *)&chain_info + 2 * (unsigned __int8)gChain);
  usleep(0x1388u);
  puts("\n--- BBD25601 check asic number");
  check_BM1722_asic_reg(gChain, 0, 0, 1);
  printf(
    "\n--- check chain: J%d has asicNum = %d\n",
    (unsigned __int8)gChain,
    *((unsigned __int8 *)&cgpu + (unsigned __int8)gChain + 1049784));
  if ( *((unsigned __int8 *)&cgpu + (unsigned __int8)gChain + 1049784) == dword_336848
    && (chain_reset(gChain),
        uart_flush((unsigned __int8)gChain),
        uart_set_baud(gChain, 26),
        puts("\n--- double check asic number"),
        check_BM1722_asic_reg(gChain, 0, 0, 1),
        printf(
          "\n--- check chain: J%d has asicNum = %d\n",
          (unsigned __int8)gChain,
          *((unsigned __int8 *)&cgpu + (unsigned __int8)gChain + 1049784)),
        *((unsigned __int8 *)&cgpu + (unsigned __int8)gChain + 1049784) == dword_336848) )
  {
    calculate_timeout_and_baud();
    set_baud(gChain, dword_3368E0);
    set_BM1722_freq(gChain, 0, 1);
    BM1722_set_address_all(gChain);
    if ( byte_3368D8 == 1 )
    {
      if ( !pattern_test_time )
        get_temperature_offset_value_from_asic_chain(gChain);
      set_default_temperature_offset_value_chain(gChain);
    }
    pthread_create(
      &dword_2B631C,
      0,
      (void *(*)(void *))read_temp_func,
      (char *)&chain_info + 2 * (unsigned __int8)gChain);
    set_BM1722_asic_register(gChain, 0, 0x14u, 1, 38);
    BM1722_open_core(gChain);
    puts("\nBegin send test pattern");
    gStartTest[(unsigned __int8)gChain] = 1;
    while ( gStartTest[(unsigned __int8)gChain] != 1 )
    {
      if ( time_counter[(unsigned __int8)gChain] >= (unsigned int)dword_3368B4 )
      {
        pthread_cancel(dword_2B631C);
        pthread_cancel(dword_2B6310);
        pthread_cancel(newthread);
        pthread_cancel(dword_2B6318);
        puts("Can't open core, change to next voltage and freq");
        write_lcd(0, (int)"Can't open core ", 0x10u);
        write_lcd_no_memset(1u, (int)"change    to    next", 0x10u);
        write_lcd_no_memset(2u, (int)"voltage and freq", 0x10u);
        ++pattern_test_time;
        return enable_PIC16F1704_dc_dc(gChain, gI2c, 0);
      }
      usleep(0x2710u);
    }
    pthread_create(&dword_2B630C, 0, (void *(*)(void *))send_func, (char *)&chain_info + 2 * (unsigned __int8)gChain);
    pthread_join(dword_2B630C, 0);
    v1[4] = pthread_join(dword_2B6310, 0);
    pthread_cancel(newthread);
    pthread_cancel(dword_2B631C);
    v2 = single_board_get_result(gChain);
    single_board_print_lcd(v2);
    if ( v2 == 7 && byte_3368BC )
      set_voltage(gChain, gI2c, 1);
    if ( (v2 & 1) != 0 || (unsigned __int8)pattern_test_time >= (unsigned int)(unsigned __int8)gHowManyVoltageLevel )
      enable_PIC16F1704_dc_dc(gChain, gI2c, 0);
    pthread_mutex_lock(&i2c_mutex_0);
    pthread_cancel(dword_2B6318);
    pthread_mutex_unlock(&i2c_mutex_0);
    return fan_control(0);
  }
  else
  {
    pthread_cancel(dword_2B6310);
    pthread_cancel(newthread);
    pthread_mutex_lock(&i2c_mutex_0);
    pthread_cancel(dword_2B6318);
    pthread_mutex_unlock(&i2c_mutex_0);
    sprintf((char *)&v1[1] + 3, "%d", *((unsigned __int8 *)&cgpu + (unsigned __int8)gChain + 1049784));
    write_lcd(0, (int)"   Only have    ", 0x10u);
    write_lcd_no_memset(1u, (int)v1, 0x10u);
    write_lcd_no_memset(2u, (int)"      ASIC      ", 0x10u);
    printf(
      "\n\n---%s: Only have %d ASIC\n",
      "singleBoardTest_BBD12601",
      *((unsigned __int8 *)&cgpu + (unsigned __int8)gChain + 1049784));
    sleep(dword_3368E4);
    return enable_PIC16F1704_dc_dc(gChain, gI2c, 0);
  }
}
// 28F10: using guessed type char gI2c;
// 35530: using guessed type char gChain;
// 35AAC: using guessed type pthread_mutex_t i2c_mutex_0;
// 35AC4: using guessed type char gHowManyVoltageLevel;
// 35AC5: using guessed type char pattern_test_time;
// 35AC8: using guessed type _DWORD time_counter[4];
// 35AD8: using guessed type _BYTE gStartTest[4];
// 35AE4: using guessed type _BYTE start_receive[4];
// 336820: using guessed type float flt_336820;
// 336848: using guessed type int dword_336848;
// 3368B4: using guessed type int dword_3368B4;
// 3368BC: using guessed type char byte_3368BC;
// 3368D8: using guessed type char byte_3368D8;
// 3368E0: using guessed type int dword_3368E0;
// 3368E4: using guessed type int dword_3368E4;

//----- (0000A960) --------------------------------------------------------
size_t __fastcall get_BM1725_asic_register(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 a3, char a4)
{
  unsigned __int8 v6[4]; // [sp+8h] [bp+8h] BYREF
  unsigned __int8 v7; // [sp+Ch] [bp+Ch]

  v7 = 0;
  v6[0] = 66;
  v6[1] = 5;
  v6[2] = a2;
  v6[3] = a3;
  if ( a4 )
    v6[0] |= 0x10u;
  v7 = CRC5(v6, 0x20u);
  return dcr_uart_send(a1, v6, 5u);
}

//----- (0000A9CC) --------------------------------------------------------
size_t __fastcall set_BM1725_asic_register(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 a3, char a4, int a5)
{
  unsigned __int8 v7[4]; // [sp+Ch] [bp+Ch] BYREF
  char v8; // [sp+10h] [bp+10h]
  char v9; // [sp+11h] [bp+11h]
  char v10; // [sp+12h] [bp+12h]
  char v11; // [sp+13h] [bp+13h]
  unsigned __int8 v12; // [sp+14h] [bp+14h]

  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  qmemcpy(v7, "A\t", 2);
  v7[2] = a2;
  v7[3] = a3;
  if ( a4 )
    v7[0] |= 0x10u;
  v8 = HIBYTE(a5);
  v9 = BYTE2(a5);
  v10 = BYTE1(a5);
  v11 = a5;
  v12 = CRC5(v7, 0x40u);
  return dcr_uart_send(a1, v7, 9u);
}

//----- (0000AA64) --------------------------------------------------------
size_t __fastcall BM1725_set_address(unsigned __int8 a1, unsigned __int8 a2)
{
  unsigned __int8 v4[4]; // [sp+8h] [bp+8h] BYREF
  unsigned __int8 v5; // [sp+Ch] [bp+Ch]

  v5 = 0;
  v4[0] = 64;
  v4[1] = 5;
  v4[2] = a2;
  v4[3] = 0;
  v5 = CRC5(v4, 0x20u);
  return dcr_uart_send(a1, v4, 5u);
}

//----- (0000AAC0) --------------------------------------------------------
int __fastcall BM1725_chain_inactive(unsigned __int8 a1)
{
  unsigned __int8 v3[4]; // [sp+8h] [bp+8h] BYREF
  unsigned __int8 v4; // [sp+Ch] [bp+Ch]

  v4 = 0;
  printf("\n--- %s\n", "BM1725_chain_inactive");
  v3[0] = 83;
  v3[1] = 5;
  v3[2] = 0;
  v3[3] = 0;
  v4 = CRC5(v3, 0x20u);
  dcr_uart_send(a1, v3, 5u);
  return usleep(0x1388u);
}

//----- (0000AB34) --------------------------------------------------------
int __fastcall BM1725_set_address_all(unsigned __int8 a1)
{
  int result; // r0
  unsigned __int8 i; // [sp+Eh] [bp+Eh]
  unsigned __int8 v4; // [sp+Fh] [bp+Fh]

  v4 = 0;
  printf("\n--- %s: Chain : %d\n", "BM1725_set_address_all", a1);
  result = BM1725_chain_inactive(a1);
  for ( i = 0; i < (unsigned int)dword_336848; ++i )
  {
    BM1725_set_address(a1, v4);
    v4 += gChain_Asic_Interval;
    result = usleep(0x1388u);
  }
  return result;
}
// 35AE8: using guessed type int gChain_Asic_Interval;
// 336848: using guessed type int dword_336848;

//----- (0000ABB0) --------------------------------------------------------
size_t __fastcall set_BM1725_freq(unsigned __int8 a1, unsigned __int8 a2, char a3)
{
  float v3; // s0
  float v8; // [sp+10h] [bp+8h] BYREF
  unsigned __int8 v9; // [sp+17h] [bp+Fh] BYREF
  int v10; // [sp+18h] [bp+10h] BYREF
  int pllparam_divider; // [sp+1Ch] [bp+14h]

  v10 = 0;
  v9 = 0;
  pllparam_divider = 0;
  v8 = 0.0;
  printf("\n%s: freq = %f\n", "set_BM1725_freq", v3);
  pllparam_divider = get_pllparam_divider(&v10, &v9, &v8);
  v10 |= 0xC0000000;
  printf("\n%s: pll_param = %08x, divider = %02x, pll_freq = %f\n", "set_BM1725_freq", v10, --v9, v8);
  set_BM1725_asic_register(a1, a2, 0xCu, a3, v10);
  usleep(0x3E8u);
  set_BM1725_asic_register(a1, a2, 0x70u, a3, v9);
  usleep(0x3E8u);
  return set_BM1725_asic_register(a1, a2, 0xCu, a3, v10);
}
// ABB0: too many cbuild loops
// ABF0: variable 'v3' is possibly undefined

//----- (0000ACA0) --------------------------------------------------------
int __fastcall BM1725_open_core(unsigned __int8 a1)
{
  int result; // r0
  char s[184]; // [sp+14h] [bp+Ch] BYREF
  unsigned int v4; // [sp+CCh] [bp+C4h]
  __int16 v5; // [sp+D2h] [bp+CAh]
  unsigned int i; // [sp+D4h] [bp+CCh]

  i = 0;
  memset(s, 0, sizeof(s));
  s[0] = -1;
  printf("\n--- %s: Chain : %d\n", "BM1725_open_core", a1);
  gIsOpenCoreEnd[a1] = 0;
  gIsOpeningCore[a1] = 1;
  s[0] = 32;
  s[1] = 0x80;
  memset(&s[2], 0, 0xB4u);
  v5 = CRC16(s, 182);
  s[182] = HIBYTE(v5);
  s[183] = v5;
  for ( i = 0; i <= 0x113; ++i )
  {
    v4 = (i << 16) | 0x8201;
    set_BM1725_asic_register(a1, 0, 0x24u, 1, v4);
    usleep(0x64u);
    dcr_uart_send(a1, s, 0xB8u);
    usleep(dword_3368A0);
  }
  result = uart_flush_rx(a1);
  gIsOpeningCore[a1] = 0;
  gIsOpenCoreEnd[a1] = 1;
  return result;
}
// 35ADC: using guessed type _BYTE gIsOpenCoreEnd[4];
// 35AE0: using guessed type _BYTE gIsOpeningCore[4];
// 3368A0: using guessed type int dword_3368A0;

//----- (0000ADD4) --------------------------------------------------------
unsigned int __fastcall check_BM1725_asic_reg(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 a3, char a4)
{
  int v4; // r3
  int v5; // r1
  int v6; // r0
  _DWORD s[2]; // [sp+28h] [bp+8h] BYREF
  unsigned int v13; // [sp+30h] [bp+10h]
  unsigned int v14; // [sp+34h] [bp+14h]
  unsigned int i; // [sp+38h] [bp+18h]
  unsigned int v16; // [sp+3Ch] [bp+1Ch]

  s[0] = 0;
  s[1] = 0;
  v16 = 0;
  v13 = 0;
  i = 0;
  v14 = 0x80000000;
  clear_register_value_buf();
  get_BM1725_asic_register(a1, a2, a3, a4);
  if ( !a3 )
    *((_BYTE *)&cgpu + a1 + 1049784) = 0;
  while ( v16 <= 2 )
  {
    usleep(0xC350u);
    pthread_mutex_lock(&reg_mutex);
    v13 = *(_DWORD *)(reg_value_buf + 8);
    pthread_mutex_unlock(&reg_mutex);
    if ( v13 )
    {
      v16 = 0;
      for ( i = 0; i < v13; ++i )
      {
        pthread_mutex_lock(&reg_mutex);
        if ( a1 == *(unsigned __int8 *)(reg_value_buf + 10 * *(_DWORD *)(reg_value_buf + 4) + 25) )
        {
          memset(s, 0, sizeof(s));
          v4 = 10 * *(_DWORD *)(reg_value_buf + 4) + 16;
          v5 = *(_DWORD *)(reg_value_buf + v4 + 4);
          s[0] = *(_DWORD *)(reg_value_buf + v4);
          s[1] = v5;
          if ( CRC5((unsigned __int8 *)s, 0x3Bu) == *(unsigned __int8 *)(reg_value_buf
                                                                       + 10 * *(_DWORD *)(reg_value_buf + 4)
                                                                       + 24) )
          {
            if ( !a3 )
              printf(
                "%s: the asic num is %d, the asic address is 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x\n",
                "check_BM1725_asic_reg",
                (unsigned __int8)++*((_BYTE *)&cgpu + a1 + 1049784),
                *(unsigned __int8 *)(reg_value_buf + 10 * *(_DWORD *)(reg_value_buf + 4) + 16),
                *(unsigned __int8 *)(reg_value_buf + 10 * *(_DWORD *)(reg_value_buf + 4) + 17),
                *(unsigned __int8 *)(reg_value_buf + 10 * *(_DWORD *)(reg_value_buf + 4) + 18),
                *(unsigned __int8 *)(reg_value_buf + 10 * *(_DWORD *)(reg_value_buf + 4) + 19),
                *(unsigned __int8 *)(reg_value_buf + 10 * *(_DWORD *)(reg_value_buf + 4) + 20),
                *(unsigned __int8 *)(reg_value_buf + 10 * *(_DWORD *)(reg_value_buf + 4) + 21),
                *(unsigned __int8 *)(reg_value_buf + 10 * *(_DWORD *)(reg_value_buf + 4) + 22),
                *(unsigned __int8 *)(10 * *(_DWORD *)(reg_value_buf + 4) + reg_value_buf + 23));
            v14 = _byteswap_ulong(*(_DWORD *)(reg_value_buf + 10 * (*(_DWORD *)(reg_value_buf + 4))++ + 16));
            --*(_DWORD *)(reg_value_buf + 8);
            if ( *(_DWORD *)(reg_value_buf + 4) == 513 )
              *(_DWORD *)(reg_value_buf + 4) = 0;
            pthread_mutex_unlock(&reg_mutex);
          }
          else
          {
            ++*(_DWORD *)(reg_value_buf + 4);
            --*(_DWORD *)(reg_value_buf + 8);
            if ( *(_DWORD *)(reg_value_buf + 4) == 513 )
              *(_DWORD *)(reg_value_buf + 4) = 0;
            v6 = CRC5((unsigned __int8 *)s, 0x3Bu);
            printf(
              "%s: crc is 0x%x, but it should be 0x%x\n",
              "check_BM1725_asic_reg",
              v6,
              *(unsigned __int8 *)(reg_value_buf + 10 * *(_DWORD *)(reg_value_buf + 4) + 24));
            pthread_mutex_unlock(&reg_mutex);
          }
        }
        else
        {
          ++*(_DWORD *)(reg_value_buf + 4);
          --*(_DWORD *)(reg_value_buf + 8);
          if ( *(_DWORD *)(reg_value_buf + 4) == 513 )
            *(_DWORD *)(reg_value_buf + 4) = 0;
          printf(
            "%s: the return data is from chain%d, but it should be from chain%d\n",
            "check_BM1725_asic_reg",
            *(unsigned __int8 *)(reg_value_buf + 10 * *(_DWORD *)(reg_value_buf + 4) + 25),
            a1);
          pthread_mutex_unlock(&reg_mutex);
        }
      }
    }
    else
    {
      ++v16;
    }
  }
  v16 = 0;
  if ( !a3 )
  {
    if ( *((unsigned __int8 *)&cgpu + a1 + 1049784) > (unsigned int)dword_3367C8 )
      dword_3367C8 = *((unsigned __int8 *)&cgpu + a1 + 1049784);
    printf("%s: chain J%d has %d ASIC\n", "check_BM1725_asic_reg", a1 + 1, *((unsigned __int8 *)&cgpu + a1 + 1049784));
  }
  clear_register_value_buf();
  return v14;
}
// 3367C8: using guessed type int dword_3367C8;
// 3367D8: using guessed type int reg_value_buf;
// 338928: using guessed type pthread_mutex_t reg_mutex;

//----- (0000B398) --------------------------------------------------------
int singleAsicTest_BM1725()
{
  int result; // r0
  char v1[16]; // [sp+Ch] [bp+4h] BYREF
  int v2; // [sp+1Ch] [bp+14h]
  int v3; // [sp+20h] [bp+18h]
  int v4; // [sp+24h] [bp+1Ch]

  v4 = 0;
  v3 = 0;
  v2 = 123456;
  qmemcpy(v1, "                ", sizeof(v1));
  printf("\nBegin %s test\n", "singleAsicTest_BM1725");
  system("date");
  putchar(10);
  reset_global_arg();
  chain_reset(gChain);
  fan_control(0x32u);
  pthread_create(&newthread, 0, (void *(*)(void *))show_status_func, (char *)&chain_info + 2 * (unsigned __int8)gChain);
  start_receive[(unsigned __int8)gChain] = 1;
  pthread_create(&dword_2B6310, 0, (void *(*)(void *))receive_func, (char *)&chain_info + 2 * (unsigned __int8)gChain);
  set_baud(gChain, 0x1Au);
  puts("\n--- check asic number");
  check_BM1725_asic_reg(gChain, 0, 0, 1);
  printf("\n--- check chain: asicNum = %d\n", *((unsigned __int8 *)&cgpu + (unsigned __int8)gChain + 1049784));
  if ( *((unsigned __int8 *)&cgpu + (unsigned __int8)gChain + 1049784) == dword_336848 )
  {
    calculate_timeout_and_baud();
    set_baud(gChain, dword_3368E0);
    set_BM1725_freq(gChain, 0, 1);
    BM1725_set_address_all(gChain);
    check_BM1725_asic_reg(gChain, 0, 0, 1);
    if ( byte_3368D8 == 1 )
    {
      set_BM1725_asic_register(gChain, 0, 0x40u, 0, 1);
      if ( !pattern_test_time )
        get_temperature_offset_value_from_asic_chain(gChain);
      set_default_temperature_offset_value_chain(gChain);
    }
    pthread_create(
      &dword_2B631C,
      0,
      (void *(*)(void *))read_temp_func,
      (char *)&chain_info + 2 * (unsigned __int8)gChain);
    set_BM1725_asic_register(gChain, 0, 0x14u, 1, 38);
    BM1725_open_core(gChain);
    puts("\nBegin send test pattern");
    system("date");
    putchar(10);
    while ( gStartTest[(unsigned __int8)gChain] != 1 )
    {
      if ( time_counter[(unsigned __int8)gChain] >= (unsigned int)dword_3368B4 )
      {
        pthread_cancel(dword_2B631C);
        pthread_cancel(dword_2B6310);
        pthread_cancel(newthread);
        puts("Can't open core, change to next voltage and freq");
        write_lcd(0, (int)"Can't open core ", 0x10u);
        write_lcd_no_memset(1u, (int)"change  to  next", 0x10u);
        result = write_lcd_no_memset(2u, (int)"voltage and freq", 0x10u);
        ++pattern_test_time;
        return result;
      }
      usleep(0x2710u);
    }
    pthread_create(&dword_2B630C, 0, (void *(*)(void *))send_func, (char *)&chain_info + 2 * (unsigned __int8)gChain);
    pthread_join(dword_2B630C, 0);
    pthread_join(dword_2B6310, 0);
    pthread_cancel(newthread);
    pthread_cancel(dword_2B631C);
    LOBYTE(v3) = single_asic_get_result(gChain);
    single_asic_print_lcd((unsigned __int8)gChain, v3);
    return fan_control(0);
  }
  else
  {
    pthread_cancel(dword_2B6310);
    pthread_cancel(newthread);
    sprintf(&v1[7], "%d", *((unsigned __int8 *)&cgpu + (unsigned __int8)gChain + 1049784));
    write_lcd(0, (int)"   Only have    ", 0x10u);
    write_lcd_no_memset(1u, (int)v1, 0x10u);
    write_lcd_no_memset(2u, (int)"      ASIC      ", 0x10u);
    return printf(
             "\n\n%s: Only have %d ASIC\n",
             "singleAsicTest_BM1725",
             *((unsigned __int8 *)&cgpu + (unsigned __int8)gChain + 1049784));
  }
}
// 35530: using guessed type char gChain;
// 35AC5: using guessed type char pattern_test_time;
// 35AC8: using guessed type _DWORD time_counter[4];
// 35AD8: using guessed type _BYTE gStartTest[4];
// 35AE4: using guessed type _BYTE start_receive[4];
// 336820: using guessed type float flt_336820;
// 336848: using guessed type int dword_336848;
// 3368B4: using guessed type int dword_3368B4;
// 3368D8: using guessed type char byte_3368D8;
// 3368E0: using guessed type int dword_3368E0;

//----- (0000B8B8) --------------------------------------------------------
int singleBoardTest_BBD25601()
{
  _DWORD v1[5]; // [sp+Ch] [bp+4h] BYREF
  int v2; // [sp+20h] [bp+18h]
  int v3; // [sp+24h] [bp+1Ch]

  v3 = 0;
  v2 = 0;
  BYTE1(v1[4]) = 0;
  HIWORD(v1[4]) = 0;
  strcpy((char *)v1, "                ");
  printf("\nBegin %s test\n", "singleBoardTest_BBD25601");
  system("date");
  putchar(10);
  reset_global_arg();
  chain_reset(gChain);
  pthread_create(&newthread, 0, (void *(*)(void *))show_status_func, (char *)&chain_info + 2 * (unsigned __int8)gChain);
  chain_reset_low(gChain);
  usleep((__useconds_t)&unk_493E0);
  power_init();
  reset_PIC16F1704_pic(gChain, gI2c);
  jump_from_loader_to_app_PIC16F1704(gChain, gI2c);
  pthread_create(
    &dword_2B6318,
    0,
    (void *(*)(void *))pic_heart_beat_func,
    (char *)&chain_info + 2 * (unsigned __int8)gChain);
  usleep(0x64u);
  set_voltage(gChain, 255, 0);
  enable_PIC16F1704_dc_dc(gChain, gI2c, 1u);
  chain_reset_high(gChain);
  usleep((__useconds_t)&unk_493E0);
  fan_control(0x50u);
  set_baud(gChain, 0x1Au);
  start_receive[(unsigned __int8)gChain] = 1;
  pthread_create(&dword_2B6310, 0, (void *(*)(void *))receive_func, (char *)&chain_info + 2 * (unsigned __int8)gChain);
  usleep(0x1388u);
  puts("\n--- BBD25601 check asic number");
  check_BM1725_asic_reg(gChain, 0, 0, 1);
  printf(
    "\n--- check chain: J%d has asicNum = %d\n",
    (unsigned __int8)gChain,
    *((unsigned __int8 *)&cgpu + (unsigned __int8)gChain + 1049784));
  if ( *((unsigned __int8 *)&cgpu + (unsigned __int8)gChain + 1049784) == dword_336848
    && (chain_reset(gChain),
        uart_flush((unsigned __int8)gChain),
        uart_set_baud(gChain, 26),
        puts("\n--- double check asic number"),
        check_BM1725_asic_reg(gChain, 0, 0, 1),
        printf(
          "\n--- check chain: J%d has asicNum = %d\n",
          (unsigned __int8)gChain,
          *((unsigned __int8 *)&cgpu + (unsigned __int8)gChain + 1049784)),
        *((unsigned __int8 *)&cgpu + (unsigned __int8)gChain + 1049784) == dword_336848) )
  {
    calculate_timeout_and_baud();
    set_baud(gChain, dword_3368E0);
    set_BM1725_freq(gChain, 0, 1);
    BM1725_set_address_all(gChain);
    check_BM1725_asic_reg(gChain, 0, 0, 1);
    if ( byte_3368D8 == 1 )
    {
      if ( !pattern_test_time )
        get_temperature_offset_value_from_asic_chain(gChain);
      set_default_temperature_offset_value_chain(gChain);
    }
    pthread_create(
      &dword_2B631C,
      0,
      (void *(*)(void *))read_temp_func,
      (char *)&chain_info + 2 * (unsigned __int8)gChain);
    set_BM1725_asic_register(gChain, 0, 0x14u, 1, 38);
    BM1725_open_core(gChain);
    puts("\nBegin send test pattern");
    while ( gStartTest[(unsigned __int8)gChain] != 1 )
    {
      if ( time_counter[(unsigned __int8)gChain] >= (unsigned int)dword_3368B4 )
      {
        pthread_cancel(dword_2B631C);
        pthread_cancel(dword_2B6310);
        pthread_cancel(newthread);
        pthread_cancel(dword_2B6318);
        puts("Can't open core, change to next voltage and freq");
        write_lcd(0, (int)"Can't open core ", 0x10u);
        write_lcd_no_memset(1u, (int)"change  to  next", 0x10u);
        write_lcd_no_memset(2u, (int)"voltage and freq", 0x10u);
        ++pattern_test_time;
        enable_PIC16F1704_dc_dc(gChain, gI2c, 0);
        return power_off();
      }
      usleep(0x2710u);
    }
    pthread_create(&dword_2B630C, 0, (void *(*)(void *))send_func, (char *)&chain_info + 2 * (unsigned __int8)gChain);
    pthread_join(dword_2B630C, 0);
    v1[4] = pthread_join(dword_2B6310, 0);
    pthread_cancel(newthread);
    pthread_cancel(dword_2B631C);
    v2 = single_board_get_result(gChain);
    if ( v2 == 7 )
    {
      g_test_epprom = save_voltage_info_to_eeprom(LODWORD(flt_336820), dword_336878);
      if ( g_test_epprom != 1 )
        g_test_epprom = save_voltage_info_to_eeprom(LODWORD(flt_336820), dword_336878);
    }
    single_board_print_lcd(v2);
    if ( (v2 & 1) != 0 || (unsigned __int8)pattern_test_time >= (unsigned int)(unsigned __int8)gHowManyVoltageLevel )
    {
      enable_PIC16F1704_dc_dc(gChain, gI2c, 0);
      power_off();
      fan_control(0);
      printf("power off %d\n", (unsigned __int8)pattern_test_time);
    }
    pthread_mutex_lock(&i2c_mutex_0);
    pthread_cancel(dword_2B6318);
    return pthread_mutex_unlock(&i2c_mutex_0);
  }
  else
  {
    pthread_cancel(dword_2B6310);
    pthread_cancel(newthread);
    pthread_mutex_lock(&i2c_mutex_0);
    pthread_cancel(dword_2B6318);
    pthread_mutex_unlock(&i2c_mutex_0);
    sprintf((char *)&v1[1] + 3, "%d", *((unsigned __int8 *)&cgpu + (unsigned __int8)gChain + 1049784));
    write_lcd(0, (int)"   Only have    ", 0x10u);
    write_lcd_no_memset(1u, (int)v1, 0x10u);
    write_lcd_no_memset(2u, (int)"      ASIC      ", 0x10u);
    printf(
      "\n\n---%s: Only have %d ASIC\n",
      "singleBoardTest_BBD25601",
      *((unsigned __int8 *)&cgpu + (unsigned __int8)gChain + 1049784));
    sleep(dword_3368E4);
    enable_PIC16F1704_dc_dc(gChain, gI2c, 0);
    return power_off();
  }
}
// 28F10: using guessed type char gI2c;
// 35530: using guessed type char gChain;
// 35AAC: using guessed type pthread_mutex_t i2c_mutex_0;
// 35AC4: using guessed type char gHowManyVoltageLevel;
// 35AC5: using guessed type char pattern_test_time;
// 35AC8: using guessed type _DWORD time_counter[4];
// 35AD8: using guessed type _BYTE gStartTest[4];
// 35AE4: using guessed type _BYTE start_receive[4];
// 235C3C: using guessed type char g_test_epprom;
// 336820: using guessed type float flt_336820;
// 336848: using guessed type int dword_336848;
// 336878: using guessed type int dword_336878;
// 3368B4: using guessed type int dword_3368B4;
// 3368D8: using guessed type char byte_3368D8;
// 3368E0: using guessed type int dword_3368E0;
// 3368E4: using guessed type int dword_3368E4;

//----- (0000C214) --------------------------------------------------------
int __fastcall calculate_asic_number(unsigned int a1)
{
  if ( a1 == 1 )
    return 1;
  if ( a1 == 2 )
    return 2;
  if ( a1 > 2 && a1 <= 4 )
    return 4;
  if ( a1 > 4 && a1 <= 8 )
    return 8;
  if ( a1 > 8 && a1 <= 0x10 )
    return 16;
  if ( a1 > 0x10 && a1 <= 0x20 )
    return 32;
  if ( a1 > 0x20 && a1 <= 0x40 )
    return 64;
  if ( a1 > 0x40 && a1 <= 0x80 )
    return 128;
  printf("actual_asic_number = %d, but it is error\n", a1);
  return -1;
}

//----- (0000C2C4) --------------------------------------------------------
int read_config()
{
  int v0; // r3
  int v1; // r0
  int v2; // r0
  char s[1024]; // [sp+4h] [bp+4h] BYREF
  FILE *stream; // [sp+404h] [bp+404h]
  int v6; // [sp+408h] [bp+408h]
  char *v7; // [sp+40Ch] [bp+40Ch]
  int i; // [sp+410h] [bp+410h]
  char *v9; // [sp+414h] [bp+414h]

  v7 = &Conf;
  memset(s, 0, sizeof(s));
  v6 = 0;
  stream = fopen("/media/card/Config.ini", "r");
  while ( fgets(s, 1023, stream) )
  {
    if ( s[0] != 35 && s[1] != 35 )
    {
      v9 = strstr(s, "Name=");
      if ( v9 )
      {
        v9 += 5;
        for ( i = 0; i <= 63; ++i )
        {
          v7[i] = *v9;
          if ( *++v9 == 10 || *v9 == 13 )
            break;
        }
        gName_len = ++i;
        v7[i] = 0;
        gHashBoard_BBD12601 = 0;
        gHashBoard_BBD25601 = 0;
        if ( *v7 == 66
          && v7[1] == 66
          && v7[2] == 68
          && v7[3] == 49
          && v7[4] == 50
          && v7[5] == 54
          && v7[6] == 48
          && v7[7] == 49 )
        {
          gHashBoard_BBD12601 = 1;
          printf("\n---%s: gHashBoard_BBD12601\n\n", "read_config");
        }
        else if ( *v7 == 66
               && v7[1] == 66
               && v7[2] == 68
               && v7[3] == 50
               && v7[4] == 53
               && v7[5] == 54
               && v7[6] == 48
               && v7[7] == 49 )
        {
          gHashBoard_BBD25601 = 1;
          printf("\n---%s: gHashBoard_BBD25601\n\n", "read_config");
        }
      }
      else
      {
        v9 = strstr(s, "pattern_number=");
        if ( v9 )
        {
          v9 += 15;
          _isoc99_sscanf(v9, "%d", v7 + 64);
        }
        else
        {
          v9 = strstr(s, "AsicNum=");
          if ( v9 )
          {
            v9 += 8;
            _isoc99_sscanf(v9, "%d", v7 + 108);
          }
          else
          {
            v9 = strstr(s, "AsicType=");
            if ( v9 )
            {
              v9 += 9;
              _isoc99_sscanf(v9, "%d", v7 + 116);
            }
            else
            {
              v9 = strstr(s, "Timeout=");
              if ( v9 )
              {
                v9 += 8;
                _isoc99_sscanf(v9, "%d", v7 + 200);
              }
              else
              {
                v9 = strstr(s, "Freq1=");
                if ( v9 )
                {
                  v9 += 6;
                  _isoc99_sscanf(v9, "%d", v7 + 72);
                }
                else
                {
                  v9 = strstr(s, "Freq2=");
                  if ( v9 )
                  {
                    v9 += 6;
                    _isoc99_sscanf(v9, "%d", v7 + 76);
                  }
                  else
                  {
                    v9 = strstr(s, "Freq3=");
                    if ( v9 )
                    {
                      v9 += 6;
                      _isoc99_sscanf(v9, "%d", v7 + 80);
                    }
                    else
                    {
                      v9 = strstr(s, "Freq4=");
                      if ( v9 )
                      {
                        v9 += 6;
                        _isoc99_sscanf(v9, "%d", v7 + 84);
                      }
                      else
                      {
                        v9 = strstr(s, "Freq5=");
                        if ( v9 )
                        {
                          v9 += 6;
                          _isoc99_sscanf(v9, "%d", v7 + 88);
                        }
                        else
                        {
                          v9 = strstr(s, "Freq6=");
                          if ( v9 )
                          {
                            v9 += 6;
                            _isoc99_sscanf(v9, "%d", v7 + 92);
                          }
                          else
                          {
                            v9 = strstr(s, "Freq7=");
                            if ( v9 )
                            {
                              v9 += 6;
                              _isoc99_sscanf(v9, "%d", v7 + 96);
                            }
                            else
                            {
                              v9 = strstr(s, "Freq8=");
                              if ( v9 )
                              {
                                v9 += 6;
                                _isoc99_sscanf(v9, "%d", v7 + 100);
                              }
                              else
                              {
                                v9 = strstr(s, "Freq9=");
                                if ( v9 )
                                {
                                  v9 += 6;
                                  _isoc99_sscanf(v9, "%d", v7 + 104);
                                }
                                else
                                {
                                  v9 = strstr(s, "Voltage1=");
                                  if ( v9 )
                                  {
                                    v9 += 9;
                                    _isoc99_sscanf(v9, "%d", v7 + 160);
                                    if ( *((_DWORD *)v7 + 40) )
                                      ++gHowManyVoltageLevel;
                                  }
                                  else
                                  {
                                    v9 = strstr(s, "Voltage2=");
                                    if ( v9 )
                                    {
                                      v9 += 9;
                                      _isoc99_sscanf(v9, "%d", v7 + 164);
                                      if ( *((_DWORD *)v7 + 41) )
                                        ++gHowManyVoltageLevel;
                                    }
                                    else
                                    {
                                      v9 = strstr(s, "Voltage3=");
                                      if ( v9 )
                                      {
                                        v9 += 9;
                                        _isoc99_sscanf(v9, "%d", v7 + 168);
                                        if ( *((_DWORD *)v7 + 42) )
                                          ++gHowManyVoltageLevel;
                                      }
                                      else
                                      {
                                        v9 = strstr(s, "Voltage4=");
                                        if ( v9 )
                                        {
                                          v9 += 9;
                                          _isoc99_sscanf(v9, "%d", v7 + 172);
                                          if ( *((_DWORD *)v7 + 43) )
                                            ++gHowManyVoltageLevel;
                                        }
                                        else
                                        {
                                          v9 = strstr(s, "Voltage5=");
                                          if ( v9 )
                                          {
                                            v9 += 9;
                                            _isoc99_sscanf(v9, "%d", v7 + 176);
                                            if ( *((_DWORD *)v7 + 44) )
                                              ++gHowManyVoltageLevel;
                                          }
                                          else
                                          {
                                            v9 = strstr(s, "Voltage6=");
                                            if ( v9 )
                                            {
                                              v9 += 9;
                                              _isoc99_sscanf(v9, "%d", v7 + 180);
                                              if ( *((_DWORD *)v7 + 45) )
                                                ++gHowManyVoltageLevel;
                                            }
                                            else
                                            {
                                              v9 = strstr(s, "Voltage7=");
                                              if ( v9 )
                                              {
                                                v9 += 9;
                                                _isoc99_sscanf(v9, "%d", v7 + 184);
                                                if ( *((_DWORD *)v7 + 46) )
                                                  ++gHowManyVoltageLevel;
                                              }
                                              else
                                              {
                                                v9 = strstr(s, "Voltage8=");
                                                if ( v9 )
                                                {
                                                  v9 += 9;
                                                  _isoc99_sscanf(v9, "%d", v7 + 188);
                                                  if ( *((_DWORD *)v7 + 47) )
                                                    ++gHowManyVoltageLevel;
                                                }
                                                else
                                                {
                                                  v9 = strstr(s, "Voltage9=");
                                                  if ( v9 )
                                                  {
                                                    v9 += 9;
                                                    _isoc99_sscanf(v9, "%d", v7 + 192);
                                                    if ( *((_DWORD *)v7 + 48) )
                                                      ++gHowManyVoltageLevel;
                                                  }
                                                  else
                                                  {
                                                    v9 = strstr(s, "OpenCoreGap=");
                                                    if ( v9 )
                                                    {
                                                      v9 += 12;
                                                      _isoc99_sscanf(v9, "%d", v7 + 196);
                                                    }
                                                    else
                                                    {
                                                      v9 = strstr(s, "CheckTemp=");
                                                      if ( v9 )
                                                      {
                                                        v9 += 10;
                                                        _isoc99_sscanf(v9, "%d", v7 + 204);
                                                      }
                                                      else
                                                      {
                                                        v9 = strstr(s, "sensor_model=");
                                                        if ( v9 )
                                                        {
                                                          v9 += 13;
                                                          _isoc99_sscanf(v9, "%ud", v7 + 252);
                                                        }
                                                        else
                                                        {
                                                          v9 = strstr(s, "remote_local_gap=");
                                                          if ( v9 )
                                                          {
                                                            v9 += 17;
                                                            _isoc99_sscanf(v9, "%ud", v7 + 256);
                                                          }
                                                          else
                                                          {
                                                            v9 = strstr(s, "TempSensor1=");
                                                            if ( v9 )
                                                            {
                                                              v9 += 12;
                                                              _isoc99_sscanf(v9, "%ud", v7 + 208);
                                                              if ( v7[208] )
                                                                ++gSensor_number;
                                                            }
                                                            else
                                                            {
                                                              v9 = strstr(s, "TempSensor2=");
                                                              if ( v9 )
                                                              {
                                                                v9 += 12;
                                                                _isoc99_sscanf(v9, "%ud", v7 + 209);
                                                                if ( v7[209] )
                                                                  ++gSensor_number;
                                                              }
                                                              else
                                                              {
                                                                v9 = strstr(s, "TempSensor3=");
                                                                if ( v9 )
                                                                {
                                                                  v9 += 12;
                                                                  _isoc99_sscanf(v9, "%ud", v7 + 210);
                                                                  if ( v7[210] )
                                                                    ++gSensor_number;
                                                                }
                                                                else
                                                                {
                                                                  v9 = strstr(s, "StartSensor=");
                                                                  if ( v9 )
                                                                  {
                                                                    v9 += 12;
                                                                    _isoc99_sscanf(v9, "%d", v7 + 211);
                                                                  }
                                                                  else
                                                                  {
                                                                    v9 = strstr(s, "StartTemp=");
                                                                    if ( v9 )
                                                                    {
                                                                      v9 += 10;
                                                                      _isoc99_sscanf(v9, "%d", v7 + 212);
                                                                    }
                                                                    else
                                                                    {
                                                                      v9 = strstr(s, "TargetTemp=");
                                                                      if ( v9 )
                                                                      {
                                                                        v9 += 11;
                                                                        _isoc99_sscanf(v9, "%d", v7 + 213);
                                                                      }
                                                                      else
                                                                      {
                                                                        v9 = strstr(s, "add_voltage_after_test_ok=");
                                                                        if ( v9 )
                                                                        {
                                                                          v9 += 26;
                                                                          _isoc99_sscanf(v9, "%d", v7 + 224);
                                                                        }
                                                                        else
                                                                        {
                                                                          v9 = strstr(s, "add_voltage_value=");
                                                                          if ( v9 )
                                                                          {
                                                                            v9 += 18;
                                                                            _isoc99_sscanf(v9, "%d", v7 + 228);
                                                                          }
                                                                          else
                                                                          {
                                                                            v9 = strstr(s, "AlarmTemp=");
                                                                            if ( v9 )
                                                                            {
                                                                              v9 += 10;
                                                                              _isoc99_sscanf(v9, "%d", v7 + 214);
                                                                            }
                                                                            else
                                                                            {
                                                                              v9 = strstr(s, "HeatingUpTime=");
                                                                              if ( v9 )
                                                                              {
                                                                                v9 += 14;
                                                                                _isoc99_sscanf(v9, "%d", v7 + 216);
                                                                              }
                                                                              else
                                                                              {
                                                                                v9 = strstr(s, "MaxTempGap=");
                                                                                if ( v9 )
                                                                                {
                                                                                  v9 += 11;
                                                                                  _isoc99_sscanf(v9, "%d", v7 + 220);
                                                                                }
                                                                                else
                                                                                {
                                                                                  v9 = strstr(s, "Invalid_Asic_Num=");
                                                                                  if ( v9 )
                                                                                  {
                                                                                    v9 += 17;
                                                                                    _isoc99_sscanf(v9, "%d", v7 + 232);
                                                                                  }
                                                                                  else
                                                                                  {
                                                                                    v9 = strstr(s, "Invalid_Core_Num=");
                                                                                    if ( v9 )
                                                                                    {
                                                                                      v9 += 17;
                                                                                      _isoc99_sscanf(v9, "%d", v7 + 236);
                                                                                    }
                                                                                    else
                                                                                    {
                                                                                      v9 = strstr(
                                                                                             s,
                                                                                             "Least_nonce_per_core=");
                                                                                      if ( v9 )
                                                                                      {
                                                                                        v9 += 21;
                                                                                        _isoc99_sscanf(
                                                                                          v9,
                                                                                          "%d",
                                                                                          v7 + 240);
                                                                                      }
                                                                                      else
                                                                                      {
                                                                                        v9 = strstr(
                                                                                               s,
                                                                                               "Most_lost_nonce_total=");
                                                                                        if ( v9 )
                                                                                        {
                                                                                          v9 += 22;
                                                                                          _isoc99_sscanf(
                                                                                            v9,
                                                                                            "%d",
                                                                                            v7 + 244);
                                                                                        }
                                                                                        else
                                                                                        {
                                                                                          v9 = strstr(s, "Most_HW_Num=");
                                                                                          if ( v9 )
                                                                                          {
                                                                                            v9 += 12;
                                                                                            _isoc99_sscanf(
                                                                                              v9,
                                                                                              "%d",
                                                                                              v7 + 248);
                                                                                          }
                                                                                          else
                                                                                          {
                                                                                            v9 = strstr(
                                                                                                   s,
                                                                                                   "close_power_delay=");
                                                                                            if ( v9 )
                                                                                            {
                                                                                              v9 += 18;
                                                                                              _isoc99_sscanf(
                                                                                                v9,
                                                                                                "%d",
                                                                                                v7 + 264);
                                                                                            }
                                                                                          }
                                                                                        }
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                }
                                                                              }
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  if ( *((_DWORD *)v7 + 27) == 1 )
  {
    gChain_Asic_Interval = 256;
    if ( *((_DWORD *)v7 + 29) == 1722 )
    {
      strcpy(dest, BM1722_WorkDataPathPrefix[0]);
      strcpy(byte_2B636C, DCR_WorkDataFilePrefix);
      v0 = (int)v7;
      *((_DWORD *)v7 + 28) = 120;
    }
    else
    {
      v0 = 1725;
      if ( *((_DWORD *)v7 + 29) == 1725 )
      {
        strcpy(dest, BM1725_WorkDataPathPrefix[0]);
        strcpy(byte_2B636C, DCR_WorkDataFilePrefix);
        v0 = (int)v7;
        *((_DWORD *)v7 + 28) = 276;
      }
    }
  }
  else if ( gHashBoard_BBD12601 || (v0 = (unsigned __int8)gHashBoard_BBD25601, gHashBoard_BBD25601) )
  {
    if ( *((_DWORD *)v7 + 29) == 1722 )
    {
      strcpy(dest, BM1722_WorkDataPathPrefix[0]);
      strcpy(byte_2B636C, DCR_WorkDataFilePrefix);
      *((_DWORD *)v7 + 28) = 120;
      *((_DWORD *)v7 + 29) = 1722;
      v1 = 256 / calculate_asic_number(dword_336848);
      v0 = (int)&gChain_Asic_Interval;
      gChain_Asic_Interval = v1;
    }
    else
    {
      v0 = 1725;
      if ( *((_DWORD *)v7 + 29) == 1725 )
      {
        strcpy(dest, BM1725_WorkDataPathPrefix[0]);
        strcpy(byte_2B636C, DCR_WorkDataFilePrefix);
        *((_DWORD *)v7 + 28) = 276;
        *((_DWORD *)v7 + 29) = 1725;
        v2 = 256 / calculate_asic_number(dword_336848);
        v0 = (int)&gChain_Asic_Interval;
        gChain_Asic_Interval = v2;
      }
    }
  }
  return v0;
}
// 8E68: using guessed type int _isoc99_sscanf(_DWORD, const char *, ...);
// 35534: using guessed type char *BM1722_WorkDataPathPrefix[3];
// 35538: using guessed type char *BM1725_WorkDataPathPrefix[2];
// 3553C: using guessed type char *DCR_WorkDataFilePrefix;
// 35AA8: using guessed type char gHashBoard_BBD12601;
// 35AA9: using guessed type char gHashBoard_BBD25601;
// 35AC4: using guessed type char gHowManyVoltageLevel;
// 35AE8: using guessed type int gChain_Asic_Interval;
// 35AEC: using guessed type int gName_len;
// 35AF0: using guessed type int gSensor_number;
// 3367DC: using guessed type char Conf;
// 336848: using guessed type int dword_336848;

//----- (0000D334) --------------------------------------------------------
unsigned __int8 __cdecl CRC5(unsigned __int8 *ptr, unsigned __int8 len)
{
  _BYTE v4[5]; // [sp+Ch] [bp+Ch]
  int v5; // [sp+14h] [bp+14h]
  char v6; // [sp+18h] [bp+18h]
  bool v7; // [sp+1Bh] [bp+1Bh]
  unsigned __int8 v8; // [sp+1Ch] [bp+1Ch]
  char v9; // [sp+1Dh] [bp+1Dh]
  unsigned __int8 v10; // [sp+1Eh] [bp+1Eh]
  unsigned __int8 i; // [sp+1Fh] [bp+1Fh]

  v5 = 16843009;
  v6 = 1;
  v10 = 0x80;
  v9 = 0;
  for ( i = 0; i < (unsigned int)len; ++i )
  {
    v7 = (v10 & *ptr) != 0;
    v4[0] = v7 ^ v6;
    v4[1] = v5;
    v4[2] = v7 ^ v6 ^ BYTE1(v5);
    *(_WORD *)&v4[3] = HIWORD(v5);
    v10 >>= 1;
    if ( ++v9 == 8 )
    {
      v10 = 0x80;
      v9 = 0;
      ++ptr;
    }
    v5 = *(_DWORD *)v4;
    v6 = v4[4];
  }
  v8 = 0;
  if ( v6 )
    v8 = 16;
  if ( HIBYTE(v5) )
    v8 |= 8u;
  if ( BYTE2(v5) )
    v8 |= 4u;
  if ( BYTE1(v5) )
    v8 |= 2u;
  if ( (_BYTE)v5 )
    v8 |= 1u;
  return v8;
}

//----- (0000D454) --------------------------------------------------------
int __fastcall crc_itu_t_byte(__int16 a1, char a2)
{
  return crc_itu_t_table[(unsigned __int8)(a2 ^ HIBYTE(a1))] ^ (unsigned __int16)(a1 << 8);
}
// 28D10: using guessed type _WORD crc_itu_t_table[256];

//----- (0000D498) --------------------------------------------------------
int __fastcall CRC16(char *a1, int a2)
{
  char v2; // r3
  unsigned __int16 i; // [sp+Eh] [bp+Eh]

  for ( i = -1; a2-- != 0; i = crc_itu_t_byte(i, v2) )
    v2 = *a1++;
  return i;
}

//----- (0000D4E8) --------------------------------------------------------
int InitElapsedTime()
{
  return gettimeofday((struct timeval *)&start_time, 0);
}
// 235C24: using guessed type int start_time;

//----- (0000D4FC) --------------------------------------------------------
int __fastcall PrintElapsedTime(const char *a1)
{
  gettimeofday((struct timeval *)&end_time, 0);
  diff_time = end_time - start_time;
  dword_235C38 = dword_235C30 - dword_235C28;
  if ( dword_235C30 - dword_235C28 < 0 )
  {
    --diff_time;
    dword_235C38 += 1000000;
  }
  return printf("Timestamp %s : %d sec\n", a1, diff_time);
}
// 235C24: using guessed type int start_time;
// 235C28: using guessed type int dword_235C28;
// 235C2C: using guessed type int end_time;
// 235C30: using guessed type int dword_235C30;
// 235C34: using guessed type int diff_time;
// 235C38: using guessed type int dword_235C38;

//----- (0000D5B4) --------------------------------------------------------
int cgpu_init()
{
  int v2; // [sp+4h] [bp+4h]

  v2 = 0;
  printf("\n%s\n", "cgpu_init");
  memset(&cgpu, 0, (size_t)&unk_1004C4);
  if ( check_chain() )
  {
    printf("!!! %s: check chain error\n", "cgpu_init");
    v2 = 1;
  }
  if ( open_key() > 0 )
  {
    if ( open_i2c() > 0 )
    {
      memset(&lcd_output_0, 32, 0x40u);
      write_lcd(0, (int)&lcd_output_0, 0x40u);
      if ( v2 == 1 )
      {
        printf("no hashboard %d\n", 1);
        write_lcd(0, (int)"No Hashboard", 0x10u);
      }
      return 0;
    }
    else
    {
      printf("!!! %s: open i2c error\n", "cgpu_init");
      close_i2c();
      close_key();
      return -1;
    }
  }
  else
  {
    printf("!!! %s: open start key error\n", "cgpu_init");
    close_key();
    return -1;
  }
}

//----- (0000D6B8) --------------------------------------------------------
void *malloc_register_buf()
{
  reg_value_buf = (int)malloc(0x1410u);
  if ( reg_value_buf )
    return memset((void *)reg_value_buf, 0, 0x1410u);
  else
    return (void *)printf("%s: malloc reg_value_buf failed\n", "malloc_register_buf");
}
// 3367D8: using guessed type int reg_value_buf;

//----- (0000D710) --------------------------------------------------------
int configMiner()
{
  read_config();
  if ( get_works() < 0 )
    return -14;
  malloc_register_buf();
  return 0;
}

//----- (0000D73C) --------------------------------------------------------
int display_arguments()
{
  char v1[64]; // [sp+0h] [bp+0h] BYREF

  memset(v1, 32, sizeof(v1));
  memcpy(v1, &Conf, gName_len);
  sprintf(&v1[16], "IC:%2d P:%2d", dword_336848, dword_33681C);
  sprintf(&v1[32], "FREQ: %d  CORE:%d", dword_336824, dword_33684C);
  sprintf(&v1[48], "Voltage: %d", dword_33687C);
  return write_lcd(0, (int)v1, 0x40u);
}
// 35AEC: using guessed type int gName_len;
// 3367DC: using guessed type char Conf;
// 33681C: using guessed type int dword_33681C;
// 336824: using guessed type int dword_336824;
// 336848: using guessed type int dword_336848;
// 33684C: using guessed type int dword_33684C;
// 33687C: using guessed type int dword_33687C;

//----- (0000D7F8) --------------------------------------------------------
void *clear_register_value_buf()
{
  pthread_mutex_lock(&reg_mutex);
  *(_DWORD *)reg_value_buf = 0;
  *(_DWORD *)(reg_value_buf + 4) = 0;
  *(_DWORD *)(reg_value_buf + 8) = 0;
  *(_DWORD *)(reg_value_buf + 12) = 0;
  pthread_mutex_unlock(&reg_mutex);
  return memset((void *)(reg_value_buf + 16), 0, 0x1400u);
}
// 3367D8: using guessed type int reg_value_buf;
// 338928: using guessed type pthread_mutex_t reg_mutex;

//----- (0000D868) --------------------------------------------------------
int __fastcall calculate_core_number(unsigned int a1)
{
  if ( a1 == 1 )
    return 1;
  if ( a1 == 2 )
    return 2;
  if ( a1 > 2 && a1 <= 4 )
    return 4;
  if ( a1 > 4 && a1 <= 8 )
    return 8;
  if ( a1 > 8 && a1 <= 0x10 )
    return 16;
  if ( a1 > 0x10 && a1 <= 0x20 )
    return 32;
  if ( a1 > 0x20 && a1 <= 0x40 )
    return 64;
  if ( a1 > 0x40 && a1 <= 0x80 )
    return 128;
  if ( a1 > 0x80 && a1 <= 0x100 )
    return 256;
  if ( a1 > 0x100 && a1 <= 0x200 )
    return 512;
  printf("%s: actual_core_number = %d, but it is error\n", "calculate_core_number", a1);
  return -1;
}

//----- (0000D950) --------------------------------------------------------
int __fastcall calculate_how_many_nonce_per_asic_get(unsigned __int8 a1, unsigned __int8 a2, unsigned int a3)
{
  unsigned int i; // [sp+8h] [bp+8h]
  int v5; // [sp+Ch] [bp+Ch]

  v5 = 0;
  for ( i = 0; i < a3; ++i )
    v5 += *((_DWORD *)&gAsic_Core_Nonce_Num + 512 * ((a1 << 8) + a2) + i);
  return v5;
}

//----- (0000D9AC) --------------------------------------------------------
int display_level_result_on_lcd()
{
  char s[8]; // [sp+4h] [bp+4h] BYREF
  unsigned int i; // [sp+Ch] [bp+Ch]

  qmemcpy(s, "     ", 5);
  sprintf(s, "%2d", (unsigned __int8)pattern_test_time + 1);
  for ( i = 0; i <= 2; ++i )
    lcd_buffer[i + 10] = s[i];
  write_lcd(0, (int)lcd_buffer, 0x10u);
  return printf("Level: %d\n\n", (unsigned __int8)pattern_test_time + 1);
}
// 35AC5: using guessed type char pattern_test_time;
// 338980: using guessed type _BYTE lcd_buffer[16];

//----- (0000DA40) --------------------------------------------------------
void *reset_global_arg()
{
  int v1; // [sp+4h] [bp+4h]
  unsigned int m; // [sp+8h] [bp+8h]
  unsigned int k; // [sp+Ch] [bp+Ch]
  unsigned int j; // [sp+10h] [bp+10h]
  unsigned int i; // [sp+14h] [bp+14h]

  printf("\n--- %s\n", "reset_global_arg");
  memset(&lcd_output_0, 32, 0x40u);
  write_lcd(0, (int)&lcd_output_0, 0x40u);
  memset(gReceive_Nonce_Num, 0, sizeof(gReceive_Nonce_Num));
  memset(gValid_Nonce_Num, 0, sizeof(gValid_Nonce_Num));
  memset(gHw_Nonce_Num, 0, sizeof(gHw_Nonce_Num));
  memset((void *)reg_value_buf, 0, 0x1410u);
  memset(&gWorks_For_Hw_Check, 0, 0x7F8u);
  pthread_mutex_init(&reg_mutex, 0);
  for ( i = 0; i <= 3; ++i )
  {
    time_counter[i] = 0;
    gWork_Num_For_Hw_Check[i] = 0;
    gIsOpenCoreEnd[i] = 0;
    gStartTest[i] = 0;
    if ( !pattern_test_time )
    {
      gT1_offset_value[i] = 0;
      gT2_offset_value[i] = 0;
      gT3_offset_value[i] = 0;
    }
    Sensor1_OK[i] = 1;
    Sensor2_OK[i] = 1;
    Sensor3_OK[i] = 1;
    Sensor1_temp[i] = 0;
    Sensor2_temp[i] = 0;
    Sensor3_temp[i] = 0;
    last_Sensor1_temp[i] = 0;
    last_Sensor2_temp[i] = 0;
    last_Sensor3_temp[i] = 0;
    highest_temp[i] = 0;
    lowest_temp[i] = 0;
    gGlobalHighestTemp[i] = 0;
    temp_change[i] = 0;
    gHigherThanAlarmTemp[i] = 0;
    gHigherThanMaxTempGap[i] = 0;
    gMaxTempGap_value[i] = 0;
    gIsReadTemp[i] = 1;
    gReadingTemp[i] = 0;
    gNotReadOutTemp[i] = 0;
    pthread_mutex_init(&HW_check_mutex[i], 0);
    *((_BYTE *)&cgpu + i + 1049784) = 0;
    gRepeated_Nonce_Id[i] = 0;
    gValid_Nonce_Num[i] = 0;
    gSend_Work_Num[i] = 0;
    for ( j = 0; dword_336848 > j; ++j )
    {
      v1 = *((_DWORD *)&cgpu + j + 131112);
      for ( k = 0; dword_33684C > k; ++k )
      {
        *((_DWORD *)&gAsic_Core_Nonce_Num + 512 * ((i << 8) + j) + k) = 0;
        for ( m = 0; dword_33681C > m; ++m )
          *(_DWORD *)(v1 + 204 * (k * dword_33681C + m) + 4 * (i + 46) + 4) = 0;
      }
    }
  }
  return clear_register_value_buf();
}
// 35540: using guessed type _BYTE Sensor1_OK[4];
// 35544: using guessed type _BYTE Sensor2_OK[4];
// 35548: using guessed type _BYTE Sensor3_OK[4];
// 35AC5: using guessed type char pattern_test_time;
// 35AC8: using guessed type _DWORD time_counter[4];
// 35AD8: using guessed type _BYTE gStartTest[4];
// 35ADC: using guessed type _BYTE gIsOpenCoreEnd[4];
// 35AF4: using guessed type _DWORD gReceive_Nonce_Num[4];
// 35B04: using guessed type _DWORD gValid_Nonce_Num[4];
// 35B14: using guessed type _DWORD gHw_Nonce_Num[4];
// 35B24: using guessed type _DWORD gSend_Work_Num[4];
// 235B34: using guessed type _DWORD gRepeated_Nonce_Id[4];
// 235B50: using guessed type _BYTE gWork_Num_For_Hw_Check[4];
// 235B54: using guessed type _BYTE gNotReadOutTemp[4];
// 235B58: using guessed type _BYTE gT1_offset_value[4];
// 235B5C: using guessed type _BYTE gT2_offset_value[4];
// 235B60: using guessed type _BYTE gT3_offset_value[4];
// 235B64: using guessed type _DWORD Sensor1_temp[4];
// 235B74: using guessed type _DWORD Sensor2_temp[4];
// 235B84: using guessed type _DWORD Sensor3_temp[4];
// 235B94: using guessed type _DWORD last_Sensor1_temp[4];
// 235BA4: using guessed type _DWORD last_Sensor2_temp[4];
// 235BB4: using guessed type _DWORD last_Sensor3_temp[4];
// 235BC4: using guessed type _DWORD highest_temp[4];
// 235BD4: using guessed type _DWORD lowest_temp[4];
// 235BE4: using guessed type _DWORD gGlobalHighestTemp[4];
// 235BF4: using guessed type _DWORD temp_change[4];
// 235C04: using guessed type _BYTE gHigherThanAlarmTemp[4];
// 235C08: using guessed type _BYTE gHigherThanMaxTempGap[4];
// 235C0C: using guessed type _DWORD gMaxTempGap_value[4];
// 235C1C: using guessed type _BYTE gIsReadTemp[4];
// 235C20: using guessed type _BYTE gReadingTemp[4];
// 3367D8: using guessed type int reg_value_buf;
// 33681C: using guessed type int dword_33681C;
// 336848: using guessed type int dword_336848;
// 33684C: using guessed type int dword_33684C;
// 3368E8: using guessed type pthread_mutex_t HW_check_mutex[4];
// 338928: using guessed type pthread_mutex_t reg_mutex;

//----- (0000DDD8) --------------------------------------------------------
int __fastcall rev(int result, char a2)
{
  char v2; // [sp+Dh] [bp+Dh]
  unsigned __int8 i; // [sp+Eh] [bp+Eh]
  unsigned __int8 v4; // [sp+Fh] [bp+Fh]

  v4 = 0;
  for ( i = a2 - 1; v4 < (unsigned int)i; --i )
  {
    v2 = *(_BYTE *)(result + v4);
    *(_BYTE *)(result + v4) = *(_BYTE *)(result + i);
    *(_BYTE *)(result + i) = v2;
    ++v4;
  }
  return result;
}

//----- (0000DE34) --------------------------------------------------------
int __fastcall target_to_dcrdiff(int a1)
{
  int j; // [sp+Ch] [bp+Ch]
  int i; // [sp+10h] [bp+10h]
  unsigned __int8 v5; // [sp+17h] [bp+17h]

  v5 = 0;
  for ( i = 7; i >= 0; --i )
  {
    for ( j = 31; j >= 0; --j )
    {
      if ( ((*(_DWORD *)(a1 + 4 * i) >> j) & 1) != 0 )
        return v5;
      ++v5;
    }
  }
  return v5;
}

//----- (0000DE98) --------------------------------------------------------
void *__fastcall decred_hash_simple(int a1, char *a2)
{
  _DWORD v5[31]; // [sp+Ch] [bp+Ch] BYREF

  sph_blake256_init(v5);
  sph_blake256((unsigned int)v5, a2, 0xB4u);
  return sph_blake256_close(v5, a1);
}

//----- (0000DED0) --------------------------------------------------------
int __fastcall check_hw(int a1, int a2, char a3, char a4)
{
  _BYTE v10[32]; // [sp+14h] [bp+14h] BYREF
  _DWORD s[45]; // [sp+34h] [bp+34h] BYREF
  unsigned __int8 v12; // [sp+EBh] [bp+EBh]
  unsigned int i; // [sp+ECh] [bp+ECh]

  i = 0;
  memset(s, 0, sizeof(s));
  memcpy(s, (const void *)(a1 + 8), sizeof(s));
  s[35] = a2;
  if ( dword_336850 == 1725 )
    LOBYTE(s[36]) = a3;
  decred_hash_simple((int)v10, (char *)s);
  v12 = target_to_dcrdiff((int)v10);
  if ( v12 > 0x25u )
    return 0;
  if ( a4 )
  {
    printf("\n%s: Got a HW!\n", "check_hw");
    printf("\tdata=");
    for ( i = 0; i <= 0xB3; ++i )
      printf("%02x", *(unsigned __int8 *)(a1 + i + 8));
    printf("\treturn nonce=0x%08x, but it should be nonce=0x%08x\n", a2, *(_DWORD *)(a1 + 4));
  }
  return 1;
}
// 336850: using guessed type int dword_336850;

//----- (0000DFFC) --------------------------------------------------------
int calculate_timeout_and_baud()
{
  int result; // r0
  int v1; // [sp+Ch] [bp+Ch]

  v1 = 0;
  printf("\n%s\n", "calculate_timeout_and_baud");
  result = calculate_core_number(dword_33684C);
  switch ( pattern_test_time )
  {
    case 0:
      v1 = dword_336824;
      break;
    case 1:
      v1 = dword_336828;
      break;
    case 2:
      v1 = dword_33682C;
      break;
    case 3:
      v1 = dword_336830;
      break;
    case 4:
      v1 = dword_336834;
      break;
    case 5:
      v1 = dword_336838;
      break;
    case 6:
      v1 = dword_33683C;
      break;
    case 7:
      v1 = dword_336840;
      break;
    case 8:
      v1 = dword_336844;
      break;
    default:
      result = printf(
                 "%s: pattern_test_time = %d, error!!! \n",
                 "calculate_timeout_and_baud",
                 (unsigned __int8)pattern_test_time);
      break;
  }
  LODWORD(flt_336820) = v1;
  dword_3368E0 = 0;
  return result;
}
// 35AC5: using guessed type char pattern_test_time;
// 336820: using guessed type float flt_336820;
// 336824: using guessed type int dword_336824;
// 336828: using guessed type int dword_336828;
// 33682C: using guessed type int dword_33682C;
// 336830: using guessed type int dword_336830;
// 336834: using guessed type int dword_336834;
// 336838: using guessed type int dword_336838;
// 33683C: using guessed type int dword_33683C;
// 336840: using guessed type int dword_336840;
// 336844: using guessed type int dword_336844;
// 33684C: using guessed type int dword_33684C;
// 3368E0: using guessed type int dword_3368E0;

//----- (0000E134) --------------------------------------------------------
void __fastcall __noreturn show_status_func(unsigned __int8 *a1)
{
  unsigned __int8 v1; // [sp+Bh] [bp+Bh]

  v1 = *a1;
  time_counter[*a1] = 0;
  while ( 1 )
  {
    memset(lcd_output_0, 32, 0x40u);
    sprintf(lcd_output_0, "   time %ds", time_counter[v1]);
    sprintf(s, "   nonce=%d", gValid_Nonce_Num[v1]);
    sprintf(byte_338960, "   HW=%d", gHw_Nonce_Num[v1]);
    if ( gIsReadTemp[v1] )
    {
      if ( gIsOpenCoreEnd[v1] )
        sprintf(byte_338970, "   temp %d `C", highest_temp[v1]);
    }
    write_lcd(0, (int)lcd_output_0, 0x40u);
    usleep((__useconds_t)&unk_F4240);
    ++time_counter[v1];
  }
}
// 35AC8: using guessed type _DWORD time_counter[4];
// 35ADC: using guessed type _BYTE gIsOpenCoreEnd[4];
// 35B04: using guessed type _DWORD gValid_Nonce_Num[4];
// 35B14: using guessed type _DWORD gHw_Nonce_Num[4];
// 235BC4: using guessed type _DWORD highest_temp[4];
// 235C1C: using guessed type _BYTE gIsReadTemp[4];

//----- (0000E24C) --------------------------------------------------------
int __fastcall set_voltage(char a1, char a2, char a3)
{
  unsigned __int8 v7; // [sp+1Bh] [bp+Bh]
  unsigned int v8; // [sp+1Ch] [bp+Ch]
  double v9; // [sp+20h] [bp+10h]

  v9 = 0.0;
  switch ( pattern_test_time )
  {
    case 0:
      v8 = dword_33687C;
      break;
    case 1:
      v8 = dword_336880;
      break;
    case 2:
      v8 = dword_336884;
      break;
    case 3:
      v8 = dword_336888;
      break;
    case 4:
      v8 = dword_33688C;
      break;
    case 5:
      v8 = dword_336890;
      break;
    case 6:
      v8 = dword_336894;
      break;
    case 7:
      v8 = dword_336898;
      break;
    case 8:
      v8 = dword_33689C;
      break;
    default:
      v8 = dword_33687C;
      printf("\n--- %s: Can't find voltage%d\n", (const char *)(unsigned __int8)pattern_test_time, 0);
      break;
  }
  dword_336878 = v8;
  if ( a3 )
    v8 += unk_3368C0;
  if ( dword_336850 == 1722 )
  {
    v9 = 1438.749 - (double)v8 * 129.4922 / 100.0;
  }
  else if ( dword_336850 == 1725 )
  {
    v9 = 1582.35294 - (double)v8 * 166.666667 / 100.0;
  }
  if ( v9 > 255.0 )
    v9 = 255.0;
  if ( v9 < 0.0 )
    v9 = 0.0;
  v7 = (unsigned int)v9;
  printf("\n--- %s: real voltage = %d, temp_voltage = %.6f, Pic_Voltage = %d\n", "set_voltage", v8, v9, v7);
  if ( dword_336850 == 1722 )
  {
    set_PIC16F1704_voltage(a1, a2, v7);
  }
  else if ( dword_336850 == 1725 )
  {
    power_set_voltage(v7);
  }
  return usleep(0x186A0u);
}
// 35AC5: using guessed type char pattern_test_time;
// 336850: using guessed type int dword_336850;
// 336878: using guessed type int dword_336878;
// 33687C: using guessed type int dword_33687C;
// 336880: using guessed type int dword_336880;
// 336884: using guessed type int dword_336884;
// 336888: using guessed type int dword_336888;
// 33688C: using guessed type int dword_33688C;
// 336890: using guessed type int dword_336890;
// 336894: using guessed type int dword_336894;
// 336898: using guessed type int dword_336898;
// 33689C: using guessed type int dword_33689C;

//----- (0000E4E0) --------------------------------------------------------
int __fastcall set_baud(unsigned __int8 a1, unsigned __int8 a2)
{
  printf("\n--- %s: Chain : %d, baud = %d\n", "set_baud", a1, a2);
  if ( dword_336850 == 1722 )
  {
    set_BM1722_asic_register(a1, 0, 0x1Cu, 1, (a2 << 8) | 0x7002001);
  }
  else if ( dword_336850 == 1725 )
  {
    set_BM1725_asic_register(a1, 0, 0x1Cu, 1, (a2 << 8) | 0x7002001);
  }
  usleep(0xC350u);
  return uart_set_baud(a1, a2);
}
// 336850: using guessed type int dword_336850;

//----- (0000E590) --------------------------------------------------------
bool __fastcall is_nonce_or_reg_value(char a1)
{
  return a1 < 0;
}

//----- (0000E5B4) --------------------------------------------------------
int __fastcall check_nonce(unsigned __int8 a1, unsigned __int8 *a2)
{
  int v6; // [sp+18h] [bp+8h]
  int v7; // [sp+20h] [bp+10h]
  int i; // [sp+28h] [bp+18h]
  int v9; // [sp+2Ch] [bp+1Ch]
  int v10; // [sp+30h] [bp+20h]
  unsigned int v11; // [sp+34h] [bp+24h]
  unsigned int v12; // [sp+38h] [bp+28h]
  unsigned int v13; // [sp+3Ch] [bp+2Ch]

  v13 = 0;
  v12 = 0;
  v11 = 0;
  v10 = 0;
  v9 = 0;
  if ( dword_336850 == 1722 )
  {
    v10 = (a2[3] << 24) | *a2 | (a2[1] << 8) | (a2[2] << 16);
    v13 = a2[3] / (unsigned int)gChain_Asic_Interval;
    v12 = *a2 & 0x7F;
    v11 = a2[5] & 0x7F;
  }
  else if ( dword_336850 == 1725 )
  {
    v10 = (a2[3] << 24) | *a2 | (a2[1] << 8) | (a2[2] << 16);
    v13 = a2[4] / (unsigned int)gChain_Asic_Interval;
    v12 = a2[3] | ((a2[2] & 1) << 8);
    v11 = a2[6] & 0x7F;
  }
  if ( dword_336848 > v13 )
  {
    if ( dword_33684C > v12 )
    {
      if ( dword_33681C > v11 )
      {
        v6 = *((_DWORD *)&cgpu + v13 + 131112) + 204 * (v12 * dword_33681C + v11);
        v7 = *(_DWORD *)(v6 + 4);
        ++gReceive_Nonce_Num[a1];
        if ( v10 == v7 )
        {
          if ( *(_DWORD *)(v6 + 4 * (a1 + 46) + 4) )
          {
            ++gRepeated_Nonce_Id[a1];
            ++*(_DWORD *)(v6 + 4 * (a1 + 46) + 4);
          }
          else
          {
            ++*(_DWORD *)(v6 + 4 * (a1 + 46) + 4);
            ++gValid_Nonce_Num[a1];
            ++*((_DWORD *)&gAsic_Core_Nonce_Num + 512 * ((a1 << 8) + v13) + v12);
          }
        }
        else
        {
          pthread_mutex_lock(&HW_check_mutex[a1]);
          for ( i = 0; (unsigned __int8)gWork_Num_For_Hw_Check[a1] > i; ++i )
          {
            v9 = check_hw((int)&gWorks_For_Hw_Check + 2040 * a1 + 204 * i, v10, a2[4], 0);
            if ( !v9 )
              break;
          }
          pthread_mutex_unlock(&HW_check_mutex[a1]);
          if ( v9 == 1 )
          {
            ++gHw_Nonce_Num[a1];
            printf("%s: Find a HW. Chain%d ASIC%d Core%d : nonce = 0x%08x.\n", "check_nonce", a1, v13, v12, v10);
          }
        }
        return 0;
      }
      else
      {
        printf("%s: received work_id = %02d nonce. error!!!\t", "check_nonce", v11);
        printf(",received data is : 0x%02x%02x%02x%02x%02x%02x\n", *a2, a2[1], a2[2], a2[3], a2[4], a2[5]);
        return -1;
      }
    }
    else
    {
      printf("%s: received core%02d nonce. error!!!\t", "check_nonce", v12);
      printf(",received data is : 0x%02x%02x%02x%02x%02x%02x\n", *a2, a2[1], a2[2], a2[3], a2[4], a2[5]);
      return -1;
    }
  }
  else
  {
    printf("%s: received ASIC%02d nonce. error!!!\t", "check_nonce", v13);
    printf(",received data is : 0x%02x%02x%02x%02x%02x\n", *a2, a2[1], a2[2], a2[3], a2[4]);
    return -1;
  }
}
// 35AE8: using guessed type int gChain_Asic_Interval;
// 35AF4: using guessed type _DWORD gReceive_Nonce_Num[4];
// 35B04: using guessed type _DWORD gValid_Nonce_Num[4];
// 35B14: using guessed type _DWORD gHw_Nonce_Num[4];
// 235B34: using guessed type _DWORD gRepeated_Nonce_Id[4];
// 235B50: using guessed type _BYTE gWork_Num_For_Hw_Check[4];
// 33681C: using guessed type int dword_33681C;
// 336848: using guessed type int dword_336848;
// 33684C: using guessed type int dword_33684C;
// 336850: using guessed type int dword_336850;
// 3368E8: using guessed type pthread_mutex_t HW_check_mutex[4];

//----- (0000EA04) --------------------------------------------------------
int __fastcall check_register_value(char a1, const void *a2)
{
  size_t n; // [sp+Ch] [bp+Ch]

  n = 0;
  if ( dword_336850 == 1722 )
  {
    n = 7;
  }
  else if ( dword_336850 == 1725 )
  {
    n = 8;
  }
  if ( *(_DWORD *)(reg_value_buf + 8) > 0x1FFu )
  {
    printf("%s: reg_value_buf buffer is full!\n", "check_register_value");
    return -1;
  }
  else
  {
    memcpy((void *)(reg_value_buf + 10 * *(_DWORD *)reg_value_buf + 16), a2, n);
    *(_BYTE *)(reg_value_buf + 10 * *(_DWORD *)reg_value_buf + 24) = *((_BYTE *)a2 + n - 1) & 0x1F;
    *(_BYTE *)(reg_value_buf + 10 * (*(_DWORD *)reg_value_buf)++ + 25) = a1;
    ++*(_DWORD *)(reg_value_buf + 8);
    if ( *(_DWORD *)reg_value_buf > 0x200u )
      *(_DWORD *)reg_value_buf = 0;
    return 0;
  }
}
// 3367D8: using guessed type int reg_value_buf;
// 336850: using guessed type int dword_336850;

//----- (0000EB44) --------------------------------------------------------
_DWORD *__fastcall add_point(_DWORD *result, unsigned int a2)
{
  if ( ++*result >= a2 )
    *result = 0;
  return result;
}

//----- (0000EB74) --------------------------------------------------------
int __fastcall use_point_sub_1(int a1, int a2)
{
  if ( a1 )
    return a1 - 1;
  else
    return a2 - 1;
}

//----- (0000EB9C) --------------------------------------------------------
unsigned int __fastcall use_point_add_1(unsigned int a1, int a2)
{
  if ( a2 - 1 <= a1 )
    return 0;
  else
    return a1 + 1;
}

//----- (0000EBC4) --------------------------------------------------------
void *__fastcall receive_func(unsigned __int8 *a1)
{
  void *v1; // r3
  size_t v2; // r3
  unsigned int v3; // r0
  unsigned int v4; // r0
  int v5; // r0
  int v6; // r5
  int v7; // r4
  unsigned int v8; // r0
  unsigned int v11; // [sp+10h] [bp+8h] BYREF
  unsigned int v12; // [sp+14h] [bp+Ch] BYREF
  void *v13; // [sp+18h] [bp+10h]
  void *v14; // [sp+1Ch] [bp+14h]
  void *ptr; // [sp+20h] [bp+18h]
  size_t v16; // [sp+24h] [bp+1Ch]
  int v17; // [sp+28h] [bp+20h]
  int v18; // [sp+2Ch] [bp+24h]
  unsigned __int8 v19; // [sp+32h] [bp+2Ah]
  unsigned __int8 v20; // [sp+33h] [bp+2Bh]
  unsigned __int8 *v21; // [sp+34h] [bp+2Ch]
  size_t size; // [sp+38h] [bp+30h]
  size_t i; // [sp+3Ch] [bp+34h]
  int v24; // [sp+40h] [bp+38h]
  size_t v25; // [sp+44h] [bp+3Ch]

  v21 = a1;
  v20 = *a1;
  v19 = a1[1];
  v25 = 0;
  v24 = 0;
  v12 = 0;
  v11 = 0;
  v18 = 0;
  i = 0;
  v17 = 0;
  v16 = 0;
  size = 0;
  if ( dword_336850 == 1722 )
  {
    size = 9;
  }
  else if ( dword_336850 == 1725 )
  {
    size = 10;
  }
  ptr = malloc(200 * size);
  if ( ptr )
  {
    v14 = malloc(100 * size);
    if ( v14 )
    {
      v13 = malloc(size);
      if ( v13 )
      {
        v16 = 100 * size;
        printf("%s: which_chain = %d, which_i2c = %d\n", "receive_func", v20, v19);
        uart_flush_rx(v20);
        while ( start_receive[v20] )
        {
          while ( gIsOpeningCore[v20] )
            usleep(0x7D0u);
          usleep(0x12Cu);
          v25 = uart_receive(v20, (int)ptr, size);
          for ( i = 0; i < v25; ++i )
          {
            *((_BYTE *)v14 + v12) = *((_BYTE *)ptr + i);
            add_point(&v12, v16);
          }
          if ( v11 != v12 )
          {
            if ( v12 <= v11 )
              v2 = 100 * size - v11 + v12;
            else
              v2 = v12 - v11;
            v25 = v2;
            while ( v25 >= size )
            {
              if ( *((unsigned __int8 *)v14 + v11) == 170
                && (v3 = use_point_add_1(v11, v16), *((_BYTE *)v14 + v3) == 85) )
              {
                for ( i = 0; i < size; ++i )
                {
                  *((_BYTE *)v13 + i) = *((_BYTE *)v14 + v11);
                  add_point(&v11, v16);
                }
                v25 -= size;
                if ( is_nonce_or_reg_value(*((_BYTE *)v13 + size - 1)) )
                {
                  if ( gStartTest[v20] )
                  {
                    if ( gIsOpenCoreEnd[v20] )
                    {
                      v17 = check_nonce(v20, (unsigned __int8 *)v13 + 2);
                      if ( v17 == -1 )
                        ++v24;
                    }
                  }
                }
                else
                {
                  v17 = check_register_value(v20, (char *)v13 + 2);
                  if ( v17 == -1 )
                    ++v24;
                }
              }
              else
              {
                for ( i = 0; size - 1 > i; ++i )
                {
                  if ( *((unsigned __int8 *)v14 + v11) == 170 )
                  {
                    v4 = use_point_add_1(v11, v16);
                    if ( *((_BYTE *)v14 + v4) == 85 )
                      break;
                  }
                  add_point(&v11, v16);
                  v5 = use_point_sub_1(v11, v16);
                  v6 = *((unsigned __int8 *)v14 + v5);
                  v7 = *((unsigned __int8 *)v14 + v11);
                  v8 = use_point_add_1(v11, v16);
                  printf(
                    "%s: Headers are not corret! Header0 = 0x%02x, Header1 = 0x%02x, Header2 = 0x%02x rp = %d\n",
                    "receive_func",
                    v6,
                    v7,
                    *((unsigned __int8 *)v14 + v8),
                    v11);
                }
                v25 -= i;
              }
            }
          }
        }
        if ( v13 )
          free(v13);
        if ( v14 )
          free(v14);
        v1 = ptr;
        if ( ptr )
          free(ptr);
      }
      else
      {
        printf("%s, malloc buffer error!\n", "receive_func");
        free(v14);
        free(ptr);
      }
    }
    else
    {
      printf("%s, malloc buffer error!\n", "receive_func");
      free(ptr);
    }
  }
  else
  {
    printf("%s, malloc buffer error!\n", "receive_func");
  }
  return v1;
}
// EF4E: variable 'v1' is possibly undefined
// 35AD8: using guessed type _BYTE gStartTest[4];
// 35ADC: using guessed type _BYTE gIsOpenCoreEnd[4];
// 35AE0: using guessed type _BYTE gIsOpeningCore[4];
// 35AE4: using guessed type _BYTE start_receive[4];
// 336850: using guessed type int dword_336850;

//----- (0000EF58) --------------------------------------------------------
int __fastcall send_func(unsigned __int8 *a1)
{
  int v1; // r3
  char s[186]; // [sp+14h] [bp+Ch] BYREF
  __int16 v4; // [sp+CEh] [bp+C6h]
  void *src; // [sp+D0h] [bp+C8h]
  int v6; // [sp+D4h] [bp+CCh]
  int v7; // [sp+D8h] [bp+D0h]
  int v8; // [sp+DCh] [bp+D4h]
  unsigned __int8 v9; // [sp+E3h] [bp+DBh]
  unsigned __int8 *v10; // [sp+E4h] [bp+DCh]
  int m; // [sp+E8h] [bp+E0h]
  unsigned int k; // [sp+ECh] [bp+E4h]
  unsigned int j; // [sp+F0h] [bp+E8h]
  unsigned int i; // [sp+F4h] [bp+ECh]

  v10 = a1;
  v9 = *a1;
  j = 0;
  k = 0;
  v8 = 0;
  v7 = 0;
  m = 0;
  memset(s, 0, 0xB8u);
  for ( i = 0; dword_336848 > i; ++i )
  {
    v6 = *((_DWORD *)&cgpu + i + 131112);
    for ( j = 0; dword_33684C > j; ++j )
    {
      for ( k = 0; dword_33681C > k; ++k )
      {
        src = (void *)(v6 + 204 * (j * dword_33681C + k));
        s[0] = 48;
        if ( dword_336850 == 1722 )
        {
          s[1] = k;
        }
        else if ( dword_336850 == 1725 )
        {
          s[1] = k | 0x80;
        }
        for ( m = 0; m <= 179; ++m )
          s[m + 2] = *((_BYTE *)src + m + 8);
        if ( s[0] == 48 )
          s[146] = 0;
        v4 = CRC16(s, 182);
        s[182] = HIBYTE(v4);
        s[183] = v4;
        dcr_uart_send(v9, s, 0xB8u);
        pthread_mutex_lock(&HW_check_mutex[v9]);
        for ( m = 8; m >= 0; --m )
          memcpy(
            (char *)&gWorks_For_Hw_Check + 2040 * v9 + 204 * m + 204,
            (char *)&gWorks_For_Hw_Check + 2040 * v9 + 204 * m,
            0xCCu);
        if ( (unsigned __int8)++gWork_Num_For_Hw_Check[v9] > 8u )
          gWork_Num_For_Hw_Check[v9] = 9;
        memcpy((char *)&gWorks_For_Hw_Check + 2040 * v9, src, 0xCCu);
        pthread_mutex_unlock(&HW_check_mutex[v9]);
        ++gSend_Work_Num[v9];
        usleep(dword_3368A4);
      }
    }
  }
  while ( gSend_Work_Num[v9] < (unsigned int)(dword_336848 * dword_33684C * dword_33681C) )
    printf(
      "\n\n---%s: Chain%d send work num : %d, less than %d\n",
      "send_func",
      v9,
      gSend_Work_Num[v9],
      276 * dword_336848 * dword_33681C);
  printf("\n\n---%s: Chain%d send work num : %d\n", "send_func", v9, gSend_Work_Num[v9]);
  puts("\nsend test pattern done");
  system("date");
  putchar(10);
  start_receive[v9] = 0;
  puts("to stop receive");
  return v1;
}
// F33E: variable 'v1' is possibly undefined
// 35AE4: using guessed type _BYTE start_receive[4];
// 35B24: using guessed type _DWORD gSend_Work_Num[4];
// 235B50: using guessed type _BYTE gWork_Num_For_Hw_Check[4];
// 33681C: using guessed type int dword_33681C;
// 336848: using guessed type int dword_336848;
// 33684C: using guessed type int dword_33684C;
// 336850: using guessed type int dword_336850;
// 3368A4: using guessed type int dword_3368A4;
// 3368E8: using guessed type pthread_mutex_t HW_check_mutex[4];

//----- (0000F348) --------------------------------------------------------
void __fastcall __noreturn read_temp_func(unsigned __int8 *a1)
{
  unsigned __int8 v1; // [sp+Bh] [bp+Bh]

  v1 = *a1;
  while ( 1 )
  {
    if ( gIsReadTemp[v1] && gIsOpenCoreEnd[v1] )
    {
      gReadingTemp[v1] = 1;
      usleep(15 * dword_3368A4);
      if ( byte_3368D8 == 1 )
        read_asic_temperature(v1);
      else
        printf("\n%s: please config sensor_model in Config.ini\n", "read_temp_func");
      if ( gNotReadOutTemp[v1] != 1 )
        set_PWM_according_to_temperature();
      gReadingTemp[v1] = 0;
    }
    usleep((__useconds_t)&unk_F4240);
  }
}
// 35ADC: using guessed type _BYTE gIsOpenCoreEnd[4];
// 235B54: using guessed type _BYTE gNotReadOutTemp[4];
// 235C1C: using guessed type _BYTE gIsReadTemp[4];
// 235C20: using guessed type _BYTE gReadingTemp[4];
// 3368A4: using guessed type int dword_3368A4;
// 3368D8: using guessed type char byte_3368D8;

//----- (0000F408) --------------------------------------------------------
int __fastcall single_asic_print_lcd(int a1, char a2)
{
  char v4[20]; // [sp+8h] [bp+8h] BYREF

  qmemcpy(v4, "      HW:       ", 16);
  display_level_result_on_lcd();
  if ( (a2 & 1) != 0 )
    write_lcd_no_memset(2u, (int)"   Pattern OK   ", 0x10u);
  else
    write_lcd_no_memset(2u, (int)"   Pattern NG   ", 0x10u);
  sprintf(&v4[10], "%d", gHw_Nonce_Num[(unsigned __int8)gChain]);
  return write_lcd_no_memset(1u, (int)v4, 0x10u);
}
// 35530: using guessed type char gChain;
// 35B14: using guessed type _DWORD gHw_Nonce_Num[4];

//----- (0000F4A0) --------------------------------------------------------
int __fastcall single_board_print_lcd(char a1)
{
  display_level_result_on_lcd();
  if ( (a1 & 1) != 0 )
  {
    write_lcd_no_memset(1u, (int)"   Pattern OK   ", 0x10u);
    pattern_test_time = 0;
  }
  else
  {
    write_lcd_no_memset(1u, (int)"   Pattern NG   ", 0x10u);
    ++pattern_test_time;
  }
  if ( g_test_epprom )
  {
    puts("eeprom OK");
    write_lcd_no_memset(2u, (int)"   epprom OK\t", 0x10u);
  }
  else
  {
    puts("eeprom NG");
    write_lcd_no_memset(2u, (int)"   epprom NG\t", 0x10u);
  }
  if ( (a1 & 4) != 0 )
    return write_lcd_no_memset(3u, (int)" Temperature OK ", 0x10u);
  else
    return write_lcd_no_memset(3u, (int)" Temperature NG ", 0x10u);
}
// 35AC5: using guessed type char pattern_test_time;
// 235C3C: using guessed type char g_test_epprom;

//----- (0000F578) --------------------------------------------------------
int __fastcall single_asic_get_result(unsigned __int8 a1)
{
  int v1; // r3
  unsigned int v4; // [sp+8h] [bp+8h]
  int v5; // [sp+Ch] [bp+Ch]
  int v6; // [sp+14h] [bp+14h]
  int v7; // [sp+18h] [bp+18h]
  int v8; // [sp+1Ch] [bp+1Ch]
  unsigned int k; // [sp+20h] [bp+20h]
  unsigned int n; // [sp+20h] [bp+20h]
  unsigned int jj; // [sp+20h] [bp+20h]
  unsigned int i; // [sp+24h] [bp+24h]
  unsigned int j; // [sp+24h] [bp+24h]
  unsigned int m; // [sp+24h] [bp+24h]
  unsigned int ii; // [sp+24h] [bp+24h]

  v8 = 1;
  puts("\n\n------------------------------------------------------------------------------------------------------\n");
  printf("every CORE require nonce number: %lu\n\n", dword_33681C);
  puts("\n\nevery core returned valid nonce count:");
  v5 = dword_2B63AC;
  for ( i = 0; dword_33684C > i; ++i )
  {
    if ( !(i % 0xA) )
      putchar(10);
    printf("core[%02d]=%02d\t", i, *((_DWORD *)&gAsic_Core_Nonce_Num + 0x20000 * a1 + i));
  }
  puts("\n\n");
  for ( j = 0; dword_33684C > j; ++j )
  {
    if ( *((_DWORD *)&gAsic_Core_Nonce_Num + 0x20000 * a1 + j) < (unsigned int)dword_33681C )
    {
      v8 &= ~1u;
      printf(
        "core[%02d] = %d,      lost these pattern's nonce : ",
        j,
        *((_DWORD *)&gAsic_Core_Nonce_Num + 0x20000 * a1 + j));
      for ( k = 0; dword_33681C > k; ++k )
      {
        if ( !*(_DWORD *)(v5 + 204 * (j * dword_33681C + k) + 4 * (a1 + 46) + 4) )
          printf("%d  ", k);
      }
      putchar(10);
    }
  }
  puts("\n\nevery core returned all nonce count:");
  for ( m = 0; dword_33684C > m; ++m )
  {
    v7 = 0;
    if ( !(m % 0xA) )
      putchar(10);
    for ( n = 0; dword_33681C > n; ++n )
      v7 += *(_DWORD *)(v5 + 204 * (m * dword_33681C + n) + 4 * (a1 + 46) + 4);
    printf("core[%02d]=%02d\t", m, v7);
  }
  puts("\n\nevery core returned repeated nonce count:");
  for ( ii = 0; dword_33684C > ii; ++ii )
  {
    v6 = 0;
    if ( !(ii % 0xA) )
      putchar(10);
    for ( jj = 0; dword_33681C > jj; ++jj )
    {
      v4 = v5 + 204 * (ii * dword_33681C + jj);
      if ( *(_DWORD *)(v4 + 4 * (a1 + 46) + 4) )
        v1 = *(_DWORD *)(v4 + 4 * (a1 + 46) + 4) - 1;
      else
        v1 = 0;
      v6 += v1;
    }
    printf("core[%02d]=%02d\t", ii, v6);
  }
  puts("\n------------------------------------------------------------------------------------------------------\n");
  printf("Chain%d total valid nonce number: %d\n\n", a1, gValid_Nonce_Num[a1]);
  printf("Chain%d total receive nonce number: %d\n\n", a1, gReceive_Nonce_Num[a1]);
  printf("Chain%d total repeate nonce number: %d\n\n", a1, gRepeated_Nonce_Id[a1]);
  printf("Chain%d HW number = %d\n\n", a1, gHw_Nonce_Num[a1]);
  if ( (v8 & 1) != 0 )
    puts("Pattern OK\n");
  else
    puts("Pattern NG\n");
  return v8;
}
// 35AF4: using guessed type _DWORD gReceive_Nonce_Num[4];
// 35B04: using guessed type _DWORD gValid_Nonce_Num[4];
// 35B14: using guessed type _DWORD gHw_Nonce_Num[4];
// 235B34: using guessed type _DWORD gRepeated_Nonce_Id[4];
// 2B63AC: using guessed type int dword_2B63AC;
// 33681C: using guessed type int dword_33681C;
// 33684C: using guessed type int dword_33684C;

//----- (0000F950) --------------------------------------------------------
int __fastcall single_board_get_result(unsigned __int8 a1)
{
  int v1; // r3
  int v4; // [sp+8h] [bp+8h]
  int v5; // [sp+Ch] [bp+Ch]
  int v6; // [sp+10h] [bp+10h]
  unsigned int v7; // [sp+14h] [bp+14h]
  unsigned int v8; // [sp+14h] [bp+14h]
  int v9; // [sp+18h] [bp+18h]
  int v10; // [sp+1Ch] [bp+1Ch]
  int v11; // [sp+20h] [bp+20h]
  int v12; // [sp+24h] [bp+24h]
  int v13; // [sp+28h] [bp+28h]
  unsigned int v14; // [sp+2Ch] [bp+2Ch]
  int v15; // [sp+30h] [bp+30h]
  unsigned int m; // [sp+34h] [bp+34h]
  unsigned int jj; // [sp+34h] [bp+34h]
  unsigned int nn; // [sp+34h] [bp+34h]
  unsigned int k; // [sp+38h] [bp+38h]
  unsigned int ii; // [sp+38h] [bp+38h]
  unsigned int mm; // [sp+38h] [bp+38h]
  unsigned int i; // [sp+3Ch] [bp+3Ch]
  unsigned int j; // [sp+3Ch] [bp+3Ch]
  unsigned int n; // [sp+3Ch] [bp+3Ch]
  unsigned int kk; // [sp+3Ch] [bp+3Ch]

  v15 = 0;
  v13 = 7;
  v9 = 0;
  puts("\n\n------------------------------------------------------------------------------------------------------\n");
  printf("every ASIC require nonce number: %lu\n", dword_33684C * dword_33681C);
  v6 = dword_33684C * dword_33681C * dword_336848;
  puts("\n\nevery asic returned valid nonce count:");
  for ( i = 0; dword_336848 > i; ++i )
  {
    if ( !(i % 9) )
      putchar(10);
    v7 = calculate_how_many_nonce_per_asic_get(a1, i, dword_33684C);
    printf("asic[%02d]=%d\t", i, v7);
    if ( dword_33684C * dword_33681C > v7 && dword_3368C4 < (unsigned int)++v15 )
      v13 &= ~1u;
  }
  puts("\n\nevery asic returned all nonce count:");
  v10 = 0;
  for ( j = 0; dword_336848 > j; ++j )
  {
    if ( !(j % 9) )
      putchar(10);
    v12 = 0;
    for ( k = 0; dword_33684C > k; ++k )
    {
      for ( m = 0; dword_33681C > m; ++m )
        v12 += *(_DWORD *)(*((_DWORD *)&cgpu + j + 131112) + 204 * (k * dword_33681C + m) + 4 * (a1 + 46) + 4);
    }
    printf("asic[%02d]=%d\t", j, v12);
    v10 += v12;
  }
  puts("\n\nevery asic returned repeated nonce count:");
  for ( n = 0; dword_336848 > n; ++n )
  {
    if ( !(n % 9) )
      putchar(10);
    v11 = 0;
    for ( ii = 0; dword_33684C > ii; ++ii )
    {
      for ( jj = 0; dword_33681C > jj; ++jj )
      {
        v4 = *((_DWORD *)&cgpu + n + 131112) + 204 * (ii * dword_33681C + jj);
        if ( *(_DWORD *)(v4 + 4 * (a1 + 46) + 4) )
          v1 = *(_DWORD *)(v4 + 4 * (a1 + 46) + 4) - 1;
        else
          v1 = 0;
        v11 += v1;
      }
    }
    printf("asic[%02d]=%d\t", n, v11);
  }
  puts("\n");
  for ( kk = 0; dword_336848 > kk; ++kk )
  {
    v8 = calculate_how_many_nonce_per_asic_get(a1, kk, dword_33684C);
    if ( dword_33684C * dword_33681C > v8 )
    {
      printf("asic[%02d] = %d\n", kk, v8);
      v5 = *((_DWORD *)&cgpu + kk + 131112);
      v14 = 0;
      for ( mm = 0; dword_33684C > mm; ++mm )
      {
        if ( *((_DWORD *)&gAsic_Core_Nonce_Num + 512 * ((a1 << 8) + kk) + mm) < (unsigned int)dword_33681C )
        {
          v9 += ++v14;
          if ( dword_3368C8 < v14 )
            v13 &= ~1u;
          if ( *((_DWORD *)&gAsic_Core_Nonce_Num + 512 * ((a1 << 8) + kk) + mm) < (unsigned int)dword_3368CC )
            v13 &= ~1u;
          printf(
            "core[%02d] = %d,      lost these nonce : ",
            mm,
            *((_DWORD *)&gAsic_Core_Nonce_Num + 512 * ((a1 << 8) + kk) + mm));
          for ( nn = 0; dword_33681C > nn; ++nn )
          {
            if ( !*(_DWORD *)(v5 + 204 * (mm * dword_33681C + nn) + 4 * (a1 + 46) + 4) )
              printf("%d  ", nn);
          }
          putchar(10);
        }
      }
      puts("\n");
    }
  }
  if ( gHw_Nonce_Num[a1] > (unsigned int)dword_3368D4 )
  {
    v13 &= ~1u;
    printf("ret = %d\n", v13);
  }
  if ( v6 - gValid_Nonce_Num[a1] > (unsigned int)dword_3368D0 )
  {
    v13 &= ~1u;
    printf("ret = %d\n", v13);
  }
  puts("\n------------------------------------------------------------------------------------------------------\n");
  if ( gHigherThanAlarmTemp[a1] )
    v13 &= ~4u;
  printf("Chain%d total valid nonce number: %d\n\n", a1, gValid_Nonce_Num[a1]);
  printf("Chain%d total returned nonce number: %d\n\n", a1, v10);
  printf("Chain%d total repeated nonce number: %d\n\n", a1, gRepeated_Nonce_Id[a1]);
  printf("Chain%d HW number = %d\n\n", a1, gHw_Nonce_Num[a1]);
  printf("total invalid asic number %d\n", v15);
  printf("total invalid core number %d\n", v9);
  printf("total nonce expected %d lost %d allow most %d\n", v6, v6 - gValid_Nonce_Num[a1], dword_3368D0);
  if ( (v13 & 1) != 0 )
    puts("Pattern OK\n");
  else
    puts("Pattern NG\n");
  if ( (v13 & 2) != 0 )
    puts("Sensor OK\n");
  else
    puts("Sensor NG\n");
  if ( (v13 & 4) != 0 )
    puts("Temperature OK\n");
  else
    puts("Temperature NG\n");
  return v13;
}
// 35B04: using guessed type _DWORD gValid_Nonce_Num[4];
// 35B14: using guessed type _DWORD gHw_Nonce_Num[4];
// 235B34: using guessed type _DWORD gRepeated_Nonce_Id[4];
// 235C04: using guessed type _BYTE gHigherThanAlarmTemp[4];
// 33681C: using guessed type int dword_33681C;
// 336848: using guessed type int dword_336848;
// 33684C: using guessed type int dword_33684C;
// 3368C4: using guessed type int dword_3368C4;
// 3368C8: using guessed type int dword_3368C8;
// 3368CC: using guessed type int dword_3368CC;
// 3368D0: using guessed type int dword_3368D0;
// 3368D4: using guessed type int dword_3368D4;

//----- (0000FFF0) --------------------------------------------------------
int __fastcall get_pllparam_divider(int *a1, unsigned __int8 *a2, float *a3)
{
  float v3; // s0
  float v11; // [sp+34h] [bp+1Ch]
  float v12; // [sp+3Ch] [bp+24h]
  float v13; // [sp+44h] [bp+2Ch]
  unsigned int v14; // [sp+48h] [bp+30h]
  char v15; // [sp+5Fh] [bp+47h]
  float v16; // [sp+60h] [bp+48h]
  unsigned __int8 v17; // [sp+66h] [bp+4Eh]
  unsigned __int8 v18; // [sp+67h] [bp+4Fh]
  unsigned __int8 v19; // [sp+68h] [bp+50h]
  unsigned __int8 v20; // [sp+69h] [bp+51h]
  unsigned __int8 v21; // [sp+6Ah] [bp+52h]
  unsigned __int8 v22; // [sp+6Bh] [bp+53h]
  float v23; // [sp+6Ch] [bp+54h]
  float v24; // [sp+70h] [bp+58h]
  float v25; // [sp+74h] [bp+5Ch]

  v16 = 25.0;
  v15 = 0;
  v25 = 2500.0;
  while ( 1 )
  {
    while ( 1 )
    {
      do
      {
        if ( v25 >= 3125.0 )
          v23 = 25.0;
        else
          v23 = 12.5;
        if ( v15 )
        {
          v25 = v24 - v23;
          v15 = 0;
          v16 = 25.0;
        }
        v14 = (unsigned int)(float)(v25 / v3);
        if ( (float)((float)(v25 / v3) - (float)v14) < v16 )
        {
          v17 = (unsigned int)(float)(v25 / v3);
          v24 = v25;
          v22 = (unsigned int)(float)((float)((float)(unsigned __int8)(unsigned int)(float)(25.0 / v23) * v25) / 25.0);
          v21 = (unsigned int)(float)(25.0 / v23);
          v16 = (float)(v25 / v3) - (float)v14;
          if ( v16 < 0.000001 )
            break;
        }
        v25 = v25 - v23;
      }
      while ( v25 >= 1400.0 );
      if ( v17 <= 0x10u )
      {
        v18 = v17;
        v19 = 1;
        v20 = 1;
        goto LABEL_33;
      }
      v18 = 16;
      while ( v18-- > 2u )
      {
        v12 = (float)v17 / (float)v18;
        v13 = v12 - (float)(unsigned int)v12;
        printf("--- %s: pll_div decimals %f postdiv_f %f", "get_pllparam_divider", v13, v12);
        if ( v13 < 0.0001 )
        {
          v17 /= v18;
          break;
        }
      }
      if ( v18 != 2 || (v17 & 1) == 0 )
        break;
      printf("--- %s: need recal 1", "get_pllparam_divider");
      if ( v24 <= 1400.0 )
      {
        printf("--- %s: !!!!!!!!!!!!!!!Set freq don't ok!!!!!!!!!! using 200M pll", "get_pllparam_divider");
        *a1 = 7864593;
        *a2 = 15;
        return -1;
      }
      v25 = v24;
      v15 = 1;
    }
    if ( v17 <= 7u )
    {
      v20 = v17;
      v19 = 1;
      goto LABEL_33;
    }
    v20 = 7;
    v19 = 1;
    while ( v20-- != 0 )
    {
      v11 = (float)v17 / (float)v20;
      if ( (float)(v11 - (float)(unsigned int)v11) < 0.0001 )
      {
        v19 = (unsigned int)v11;
        break;
      }
    }
    if ( v20 >= (unsigned int)v19 && v19 <= 7u )
      break;
    printf("--- %s: need recal 2", "get_pllparam_divider");
    if ( v24 <= 1400.0 )
      break;
    v25 = v24;
    v15 = 1;
  }
  if ( v17 != v19 * v20 )
  {
    printf("--- %s: Don't find postdiv1 %d * postdiv2 %d = postdiv %d", "get_pllparam_divider", v20, v19, v17);
    *a1 = 7864593;
    *a2 = 15;
    printf("--- %s: !!!!!!!!!!!!!!!Set freq don't ok!!!!!!!!!! using 200M pll", "get_pllparam_divider");
    return -1;
  }
LABEL_33:
  if ( a3 )
    *a3 = (float)((float)(25.0 / (float)v21) * (float)v22) / (float)(v19 * v20);
  *a1 = v19 | (v22 << 16) | (v21 << 8) | (16 * v20);
  *a2 = v18;
  printf(
    "--- %s: Want freq %f  real freq %f",
    "get_pllparam_divider",
    v3,
    (float)((float)((float)(25.0 / (float)v21) * (float)v22) / (float)(v18 * v19 * v20)));
  printf(
    "--- %s: pll_vco %f, fbdiv %#x refdiv %#x postdiv1 %#x postdiv2 %#x, pll_divider %d ,{pll_value %#x}",
    "get_pllparam_divider",
    v24,
    v22,
    v21,
    v20,
    v19,
    *a2,
    *a1);
  return 0;
}
// 10076: variable 'v24' is possibly undefined
// 100D6: variable 'v3' is possibly undefined
// 10170: variable 'v17' is possibly undefined
// 10480: variable 'v21' is possibly undefined
// 10494: variable 'v22' is possibly undefined

//----- (00010568) --------------------------------------------------------
size_t __fastcall enable_read_temperature_from_asic_chain(size_t result, unsigned __int8 a2)
{
  if ( dword_336850 == 1722 )
    return set_BM1722_asic_register(result, a2, 0x1Cu, 0, (dword_3368E0 << 8) | 0x7006061);
  if ( dword_336850 == 1725 )
    return set_BM1725_asic_register(result, a2, 0x1Cu, 0, (dword_3368E0 << 8) | 0x7006061);
  return result;
}
// 336850: using guessed type int dword_336850;
// 3368E0: using guessed type int dword_3368E0;

//----- (00010604) --------------------------------------------------------
size_t __fastcall enable_extended_mode_of_temperature_sensor_chain(unsigned __int8 a1)
{
  size_t result; // r0
  unsigned int v3; // [sp+20h] [bp+18h]
  int v4; // [sp+24h] [bp+1Ch]
  size_t v5; // [sp+28h] [bp+20h]
  unsigned int i; // [sp+2Ch] [bp+24h]

  v3 = 0;
  result = printf("\n--- %s\n", "enable_extended_mode_of_temperature_sensor_chain");
  for ( i = 0; i <= 2; ++i )
  {
    if ( !i )
      v4 = (unsigned __int8)byte_3368AC;
    if ( i == 1 )
      v4 = (unsigned __int8)byte_3368AD;
    if ( i == 2 )
      v4 = (unsigned __int8)byte_3368AE;
    if ( v4 )
    {
      result = enable_read_temperature_from_asic_chain(a1, gChain_Asic_Interval * (v4 - 1));
      do
      {
        if ( dword_336850 == 1722 )
        {
          result = check_BM1722_asic_reg(a1, gChain_Asic_Interval * (v4 - 1), 0x20u, 0);
          v5 = result;
        }
        else if ( dword_336850 == 1725 )
        {
          result = check_BM1725_asic_reg(a1, gChain_Asic_Interval * (v4 - 1), 0x20u, 0);
          v5 = result;
        }
        ++v3;
      }
      while ( (v5 & 0xC0000000) != 0 && v3 < 2 );
      v3 = 0;
      if ( (v5 & 0xC0000000) != 0 )
      {
        gNotReadOutTemp[a1] = 1;
        result = printf(
                   "%s: Can't read out GENERAL_I2C_COMMAND. ret = 0x%08x\n",
                   "enable_extended_mode_of_temperature_sensor_chain",
                   v5);
      }
      else
      {
        if ( dword_336850 == 1722 )
        {
          result = set_BM1722_asic_register(a1, gChain_Asic_Interval * (v4 - 1), 0x20u, 0, 26806532);
        }
        else if ( dword_336850 == 1725 )
        {
          result = set_BM1725_asic_register(a1, gChain_Asic_Interval * (v4 - 1), 0x20u, 0, 26806532);
        }
        do
        {
          if ( dword_336850 == 1722 )
          {
            result = check_BM1722_asic_reg(a1, gChain_Asic_Interval * (v4 - 1), 0x20u, 0);
            v5 = result;
          }
          else if ( dword_336850 == 1725 )
          {
            result = check_BM1725_asic_reg(a1, gChain_Asic_Interval * (v4 - 1), 0x20u, 0);
            v5 = result;
          }
          ++v3;
        }
        while ( (v5 & 0xC0000000) != 0 && v3 < 2 );
        v3 = 0;
        if ( (v5 & 0xC0000000) != 0 )
        {
          gNotReadOutTemp[a1] = 1;
          result = printf(
                     "%s: Can't set extended mode. ret = 0x%08x\n",
                     "enable_extended_mode_of_temperature_sensor_chain",
                     v5);
        }
      }
    }
  }
  return result;
}
// 10698: variable 'v4' is possibly undefined
// 10734: variable 'v5' is possibly undefined
// 35AE8: using guessed type int gChain_Asic_Interval;
// 235B54: using guessed type _BYTE gNotReadOutTemp[4];
// 336850: using guessed type int dword_336850;
// 3368AC: using guessed type char byte_3368AC;
// 3368AD: using guessed type char byte_3368AD;
// 3368AE: using guessed type char byte_3368AE;

//----- (000108D4) --------------------------------------------------------
int __fastcall get_temperature_offset_value_from_asic_chain(unsigned __int8 a1)
{
  int result; // r0
  char v3; // [sp+14h] [bp+Ch]
  char v4; // [sp+15h] [bp+Dh]
  char v5; // [sp+16h] [bp+Eh]
  char v6; // [sp+17h] [bp+Fh]
  char v7; // [sp+18h] [bp+10h]
  char v8; // [sp+19h] [bp+11h]
  char v9; // [sp+1Ah] [bp+12h]
  char v10; // [sp+1Bh] [bp+13h]
  int v11; // [sp+1Ch] [bp+14h]
  int v12; // [sp+20h] [bp+18h]
  char v13; // [sp+27h] [bp+1Fh]
  unsigned int v14; // [sp+28h] [bp+20h]
  int v15; // [sp+2Ch] [bp+24h]
  unsigned int v16; // [sp+30h] [bp+28h]
  unsigned int i; // [sp+34h] [bp+2Ch]

  v16 = -1;
  v14 = 0;
  v3 = 0;
  v4 = 0;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v13 = 0;
  v12 = 0;
  v11 = 0;
  result = printf("\n--- %s\n", "get_temperature_offset_value_from_asic_chain");
  for ( i = 0; i <= 2; ++i )
  {
    if ( !i )
      v15 = (unsigned __int8)byte_3368AC;
    if ( i == 1 )
      v15 = (unsigned __int8)byte_3368AD;
    if ( i == 2 )
      v15 = (unsigned __int8)byte_3368AE;
    if ( v15 )
    {
      enable_read_temperature_from_asic_chain(a1, gChain_Asic_Interval * (v15 - 1));
      do
      {
        if ( dword_336850 == 1722 )
        {
          v16 = check_BM1722_asic_reg(a1, gChain_Asic_Interval * (v15 - 1), 0x20u, 0);
        }
        else if ( dword_336850 == 1725 )
        {
          v16 = check_BM1725_asic_reg(a1, gChain_Asic_Interval * (v15 - 1), 0x20u, 0);
        }
        ++v14;
      }
      while ( (v16 & 0xC0000000) != 0 && v14 < 2 );
      v14 = 0;
      if ( dword_336850 == 1722 )
      {
        set_BM1722_asic_register(a1, gChain_Asic_Interval * (v15 - 1), 0x20u, 0, 26738944);
      }
      else if ( dword_336850 == 1725 )
      {
        set_BM1725_asic_register(a1, gChain_Asic_Interval * (v15 - 1), 0x20u, 0, 26738944);
      }
      do
      {
        if ( dword_336850 == 1722 )
        {
          v16 = check_BM1722_asic_reg(a1, gChain_Asic_Interval * (v15 - 1), 0x20u, 0);
        }
        else if ( dword_336850 == 1725 )
        {
          v16 = check_BM1725_asic_reg(a1, gChain_Asic_Interval * (v15 - 1), 0x20u, 0);
        }
        ++v14;
      }
      while ( (v16 & 0xC0000000) != 0 && v14 < 2 );
      v14 = 0;
      if ( (v16 & 0xC0000000) != 0 )
      {
        gNotReadOutTemp[a1] = 1;
        printf("%s: Can't read out ASIC TEMP. ret = 0x%08x\n", "get_temperature_offset_value_from_asic_chain", v16);
      }
      else
      {
        v11 = (unsigned __int8)v16;
        printf("ASIC temperature is %d\n", (unsigned __int8)v16);
      }
      v16 = -1;
      if ( dword_336850 == 1722 )
      {
        set_BM1722_asic_register(a1, gChain_Asic_Interval * (v15 - 1), 0x20u, 0, 26738688);
      }
      else if ( dword_336850 == 1725 )
      {
        set_BM1725_asic_register(a1, gChain_Asic_Interval * (v15 - 1), 0x20u, 0, 26738688);
      }
      do
      {
        if ( dword_336850 == 1722 )
        {
          v16 = check_BM1722_asic_reg(a1, gChain_Asic_Interval * (v15 - 1), 0x20u, 0);
        }
        else if ( dword_336850 == 1725 )
        {
          v16 = check_BM1725_asic_reg(a1, gChain_Asic_Interval * (v15 - 1), 0x20u, 0);
        }
        ++v14;
      }
      while ( (v16 & 0xC0000000) != 0 && v14 < 2 );
      v14 = 0;
      if ( (v16 & 0xC0000000) != 0 )
      {
        gNotReadOutTemp[a1] = 1;
        printf(
          "%s: Can't read out HASH BOARD TEMP. ret = 0x%08x\n",
          "get_temperature_offset_value_from_asic_chain",
          v16);
      }
      else
      {
        v12 = (unsigned __int8)v16;
        printf("local_temp is %d\n", (unsigned __int8)v16);
      }
      if ( gNotReadOutTemp[a1] )
        v13 = 0;
      else
        v13 = v12 - v11;
      if ( !i )
      {
        byte_3367CC = v13;
        v3 = v15;
        v4 = v13;
        gT1_offset_value[a1] = v13;
      }
      if ( i == 1 )
      {
        byte_3367CD = v13;
        v5 = v15;
        v6 = v13;
        gT2_offset_value[a1] = v13;
      }
      if ( i == 2 )
      {
        byte_3367CE = v13;
        v7 = v15;
        v8 = v13;
        gT3_offset_value[a1] = v13;
      }
      result = printf("temp_offset_value = %d\n", v13);
    }
  }
  v9 = byte_3368D8 | 0x20;
  v10 = dword_3368DC;
  if ( (unsigned int)dword_336848 > 1 )
  {
    result = putchar(10);
    for ( i = 0; i <= 7; ++i )
      result = printf("offset_value[%d] = %d\n", i, *(&v3 + i));
  }
  return result;
}
// 35AE8: using guessed type int gChain_Asic_Interval;
// 235B54: using guessed type _BYTE gNotReadOutTemp[4];
// 235B58: using guessed type _BYTE gT1_offset_value[4];
// 235B5C: using guessed type _BYTE gT2_offset_value[4];
// 235B60: using guessed type _BYTE gT3_offset_value[4];
// 3367CC: using guessed type char byte_3367CC;
// 3367CD: using guessed type char byte_3367CD;
// 3367CE: using guessed type char byte_3367CE;
// 336848: using guessed type int dword_336848;
// 336850: using guessed type int dword_336850;
// 3368AC: using guessed type char byte_3368AC;
// 3368AD: using guessed type char byte_3368AD;
// 3368AE: using guessed type char byte_3368AE;
// 3368D8: using guessed type char byte_3368D8;
// 3368DC: using guessed type int dword_3368DC;

//----- (00010E94) --------------------------------------------------------
size_t __fastcall set_default_temperature_offset_value_chain(unsigned __int8 a1)
{
  size_t result; // r0
  unsigned __int8 v3; // [sp+13h] [bp+Bh]
  size_t v4; // [sp+14h] [bp+Ch]
  int v5; // [sp+18h] [bp+10h]
  unsigned int v6; // [sp+1Ch] [bp+14h]
  unsigned int v7; // [sp+1Ch] [bp+14h]
  unsigned int v8; // [sp+1Ch] [bp+14h]
  int v9; // [sp+20h] [bp+18h]
  unsigned int i; // [sp+24h] [bp+1Ch]

  v9 = 0;
  v6 = 0;
  v4 = 0;
  v3 = 0;
  result = printf("\n--- %s\n", "set_default_temperature_offset_value_chain");
  for ( i = 0; i <= 2; ++i )
  {
    v5 = 0;
    if ( !i )
    {
      v9 = (unsigned __int8)byte_3368AC;
      v3 = gT1_offset_value[a1];
      v5 = v3 | 0x1991100;
    }
    if ( i == 1 )
    {
      v9 = (unsigned __int8)byte_3368AD;
      v3 = gT2_offset_value[a1];
      v5 = v3 | 0x1991100;
    }
    if ( i == 2 )
    {
      v9 = (unsigned __int8)byte_3368AE;
      v3 = gT3_offset_value[a1];
      v5 = v3 | 0x1991100;
    }
    if ( v9 )
    {
      result = enable_read_temperature_from_asic_chain(a1, gChain_Asic_Interval * (v9 - 1));
      do
      {
        if ( dword_336850 == 1722 )
        {
          result = check_BM1722_asic_reg(a1, gChain_Asic_Interval * (v9 - 1), 0x20u, 0);
          v4 = result;
        }
        else if ( dword_336850 == 1725 )
        {
          result = check_BM1725_asic_reg(a1, gChain_Asic_Interval * (v9 - 1), 0x20u, 0);
          v4 = result;
        }
        ++v6;
      }
      while ( (v4 & 0xC0000000) != 0 && v6 < 2 );
      v7 = 0;
      if ( dword_336850 == 1722 )
      {
        result = set_BM1722_asic_register(a1, gChain_Asic_Interval * (v9 - 1), 0x20u, 0, v5);
      }
      else if ( dword_336850 == 1725 )
      {
        result = set_BM1725_asic_register(a1, gChain_Asic_Interval * (v9 - 1), 0x20u, 0, v5);
      }
      do
      {
        if ( dword_336850 == 1722 )
        {
          result = check_BM1722_asic_reg(a1, gChain_Asic_Interval * (v9 - 1), 0x20u, 0);
          v4 = result;
        }
        else if ( dword_336850 == 1725 )
        {
          result = check_BM1725_asic_reg(a1, gChain_Asic_Interval * (v9 - 1), 0x20u, 0);
          v4 = result;
        }
        ++v7;
      }
      while ( (v4 & 0xC0000000) != 0 && v7 < 2 );
      v8 = 0;
      if ( dword_336850 == 1722 )
      {
        result = set_BM1722_asic_register(a1, gChain_Asic_Interval * (v9 - 1), 0x20u, 0, 26743040);
      }
      else if ( dword_336850 == 1725 )
      {
        result = set_BM1725_asic_register(a1, gChain_Asic_Interval * (v9 - 1), 0x20u, 0, 26743040);
      }
      do
      {
        if ( dword_336850 == 1722 )
        {
          result = check_BM1722_asic_reg(a1, gChain_Asic_Interval * (v9 - 1), 0x20u, 0);
          v4 = result;
        }
        else if ( dword_336850 == 1725 )
        {
          result = check_BM1725_asic_reg(a1, gChain_Asic_Interval * (v9 - 1), 0x20u, 0);
          v4 = result;
        }
        ++v8;
      }
      while ( (v4 & 0xC0000000) != 0 && v8 < 2 );
      v6 = 0;
      if ( (char)v4 != (char)v3 )
      {
        if ( !i )
        {
          Sensor1_OK[a1] = 0;
          result = puts("!!! sensor1 is error!\n");
        }
        if ( i == 1 )
        {
          Sensor2_OK[a1] = 0;
          result = puts("!!! sensor2 is error!\n");
        }
        if ( i == 2 )
        {
          Sensor3_OK[a1] = 0;
          result = puts("!!! sensor3 is error!\n");
        }
      }
    }
  }
  return result;
}
// 35540: using guessed type _BYTE Sensor1_OK[4];
// 35544: using guessed type _BYTE Sensor2_OK[4];
// 35548: using guessed type _BYTE Sensor3_OK[4];
// 35AE8: using guessed type int gChain_Asic_Interval;
// 235B58: using guessed type _BYTE gT1_offset_value[4];
// 235B5C: using guessed type _BYTE gT2_offset_value[4];
// 235B60: using guessed type _BYTE gT3_offset_value[4];
// 336850: using guessed type int dword_336850;
// 3368AC: using guessed type char byte_3368AC;
// 3368AD: using guessed type char byte_3368AD;
// 3368AE: using guessed type char byte_3368AE;

//----- (000112EC) --------------------------------------------------------
int __fastcall read_asic_temperature(unsigned __int8 a1)
{
  int result; // r0
  int v3; // [sp+14h] [bp+Ch]
  unsigned int v4; // [sp+28h] [bp+20h]
  unsigned int v5; // [sp+28h] [bp+20h]
  unsigned int v6; // [sp+28h] [bp+20h]
  int v7; // [sp+2Ch] [bp+24h]
  unsigned int v8; // [sp+30h] [bp+28h]
  unsigned int i; // [sp+34h] [bp+2Ch]

  v8 = -1;
  v4 = 0;
  gNotReadOutTemp[a1] = 0;
  for ( i = 0; i <= 2; ++i )
  {
    if ( !i )
      v7 = (unsigned __int8)byte_3368AC;
    if ( i == 1 )
      v7 = (unsigned __int8)byte_3368AD;
    if ( i == 2 )
      v7 = (unsigned __int8)byte_3368AE;
    if ( v7 )
    {
      enable_read_temperature_from_asic_chain(a1, gChain_Asic_Interval * (v7 - 1));
      do
      {
        if ( dword_336850 == 1722 )
        {
          v8 = check_BM1722_asic_reg(a1, gChain_Asic_Interval * (v7 - 1), 0x20u, 0);
        }
        else if ( dword_336850 == 1725 )
        {
          v8 = check_BM1725_asic_reg(a1, gChain_Asic_Interval * (v7 - 1), 0x20u, 0);
        }
        ++v4;
      }
      while ( (v8 & 0xC0000000) != 0 && v4 < 2 );
      v5 = 0;
      if ( dword_336850 == 1722 )
      {
        set_BM1722_asic_register(a1, gChain_Asic_Interval * (v7 - 1), 0x20u, 0, 26738944);
      }
      else if ( dword_336850 == 1725 )
      {
        set_BM1725_asic_register(a1, gChain_Asic_Interval * (v7 - 1), 0x20u, 0, 26738944);
      }
      do
      {
        if ( dword_336850 == 1722 )
        {
          v8 = check_BM1722_asic_reg(a1, gChain_Asic_Interval * (v7 - 1), 0x20u, 0);
        }
        else if ( dword_336850 == 1725 )
        {
          v8 = check_BM1725_asic_reg(a1, gChain_Asic_Interval * (v7 - 1), 0x20u, 0);
        }
        ++v5;
      }
      while ( (v8 & 0xC0000000) != 0 && v5 < 2 );
      v6 = 0;
      if ( (v8 & 0xC0000000) != 0 )
      {
        printf("%s: do not read out ASIC %d temperature\n\n", "read_asic_temperature", v7);
        gNotReadOutTemp[a1] = 1;
      }
      else
      {
        printf("\n\nASIC %d TEMP is : %d\n", v7, (unsigned __int8)v8);
        if ( !i )
          Sensor1_temp[a1] = (unsigned __int8)v8;
        if ( i == 1 )
          Sensor2_temp[a1] = (unsigned __int8)v8;
        if ( i == 2 )
          Sensor3_temp[a1] = (unsigned __int8)v8;
        if ( (unsigned __int8)byte_3368AF == v7 )
        {
          if ( (unsigned __int8)byte_3368B0 > (int)(unsigned __int8)v8 )
          {
            if ( gStartTest[a1] != 1 )
              printf(
                "\nASIC %d temperature is %d, waiting it raise to start temperature %d\n\n",
                v7,
                (unsigned __int8)v8,
                (unsigned __int8)byte_3368B0);
          }
          else
          {
            if ( gStartTest[a1] != 1 )
              printf("\nBegin test!!! Start sensor is %d, ASIC temperature is %d\n\n", v7, (unsigned __int8)v8);
            gStartTest[a1] = 1;
          }
        }
      }
      if ( dword_336850 == 1722 )
      {
        set_BM1722_asic_register(a1, gChain_Asic_Interval * (v7 - 1), 0x20u, 0, 26738688);
      }
      else if ( dword_336850 == 1725 )
      {
        set_BM1725_asic_register(a1, gChain_Asic_Interval * (v7 - 1), 0x20u, 0, 26738688);
      }
      do
      {
        if ( dword_336850 == 1722 )
        {
          v8 = check_BM1722_asic_reg(a1, gChain_Asic_Interval * (v7 - 1), 0x20u, 0);
        }
        else if ( dword_336850 == 1725 )
        {
          v8 = check_BM1725_asic_reg(a1, gChain_Asic_Interval * (v7 - 1), 0x20u, 0);
        }
        ++v6;
      }
      while ( (v8 & 0xC0000000) != 0 && v6 < 2 );
      v4 = 0;
      if ( (v8 & 0xC0000000) != 0 )
      {
        printf("%s: do not read out ASIC %d Hash Board temperature\n\n", "read_asic_temperature", v7);
        gNotReadOutTemp[a1] = 1;
      }
      else
      {
        printf("ASIC %d Hash Board temperature is %d\n\n", v7, (unsigned __int8)v8);
      }
    }
  }
  temp_change[a1] = (Sensor1_temp[a1]
                   + Sensor2_temp[a1]
                   + Sensor3_temp[a1]
                   - last_Sensor1_temp[a1]
                   - last_Sensor2_temp[a1]
                   - last_Sensor3_temp[a1])
                  / (unsigned int)gSensor_number;
  if ( temp_change[a1] )
  {
    last_Sensor1_temp[a1] = Sensor1_temp[a1];
    last_Sensor2_temp[a1] = Sensor2_temp[a1];
    last_Sensor3_temp[a1] = Sensor3_temp[a1];
  }
  highest_temp[a1] = Sensor1_temp[a1];
  if ( Sensor2_temp[a1] > highest_temp[a1] )
    highest_temp[a1] = Sensor2_temp[a1];
  if ( Sensor3_temp[a1] > highest_temp[a1] )
    highest_temp[a1] = Sensor3_temp[a1];
  lowest_temp[a1] = Sensor1_temp[a1];
  if ( Sensor2_temp[a1] < lowest_temp[a1] && Sensor2_temp[a1] )
    lowest_temp[a1] = Sensor2_temp[a1];
  if ( Sensor3_temp[a1] < lowest_temp[a1] && Sensor3_temp[a1] )
    lowest_temp[a1] = Sensor3_temp[a1];
  if ( highest_temp[a1] > gGlobalHighestTemp[a1] )
    gGlobalHighestTemp[a1] = highest_temp[a1];
  result = printf("\ngGlobalHighestTemp is %d\n\n", gGlobalHighestTemp[a1]);
  if ( highest_temp[a1] > (int)(unsigned __int8)byte_3368B2 )
    gHigherThanAlarmTemp[a1] = 1;
  v3 = highest_temp[a1] - lowest_temp[a1];
  if ( v3 > (unsigned int)dword_3368B8 )
  {
    gHigherThanMaxTempGap[a1] = 1;
    if ( gMaxTempGap_value[a1] < v3 )
    {
      gMaxTempGap_value[a1] = v3;
      return printf("gMaxTempGap_value is %d\n\n", gMaxTempGap_value[a1]);
    }
  }
  return result;
}
// 11368: variable 'v7' is possibly undefined
// 35AD8: using guessed type _BYTE gStartTest[4];
// 35AE8: using guessed type int gChain_Asic_Interval;
// 35AF0: using guessed type int gSensor_number;
// 235B54: using guessed type _BYTE gNotReadOutTemp[4];
// 235B64: using guessed type _DWORD Sensor1_temp[4];
// 235B74: using guessed type _DWORD Sensor2_temp[4];
// 235B84: using guessed type _DWORD Sensor3_temp[4];
// 235B94: using guessed type _DWORD last_Sensor1_temp[4];
// 235BA4: using guessed type _DWORD last_Sensor2_temp[4];
// 235BB4: using guessed type _DWORD last_Sensor3_temp[4];
// 235BC4: using guessed type _DWORD highest_temp[4];
// 235BD4: using guessed type _DWORD lowest_temp[4];
// 235BE4: using guessed type _DWORD gGlobalHighestTemp[4];
// 235BF4: using guessed type _DWORD temp_change[4];
// 235C04: using guessed type _BYTE gHigherThanAlarmTemp[4];
// 235C08: using guessed type _BYTE gHigherThanMaxTempGap[4];
// 235C0C: using guessed type _DWORD gMaxTempGap_value[4];
// 336850: using guessed type int dword_336850;
// 3368AC: using guessed type char byte_3368AC;
// 3368AD: using guessed type char byte_3368AD;
// 3368AE: using guessed type char byte_3368AE;
// 3368AF: using guessed type char byte_3368AF;
// 3368B0: using guessed type char byte_3368B0;
// 3368B2: using guessed type char byte_3368B2;
// 3368B8: using guessed type int dword_3368B8;

//----- (00011B00) --------------------------------------------------------
bool test_eeprom()
{
  unsigned __int8 v2; // [sp+9h] [bp+1h] BYREF
  char v3; // [sp+Ah] [bp+2h] BYREF
  unsigned __int8 v4; // [sp+Bh] [bp+3h] BYREF
  int v5; // [sp+Ch] [bp+4h]

  v4 = -112;
  v3 = 90;
  v2 = -91;
  v5 = 0;
  printf("test_set_eeprom_val = %x\n", 90);
  iic_write_reg(e2prom_fd, &v4, 1, (int)&v3, 1u);
  usleep(0x186A0u);
  v5 = iic_read_reg(e2prom_fd, &v4, 1, (int)&v2, 1u);
  if ( v5 != 1 )
    return 0;
  printf("test_get_eeprom_val = %x\n", v2);
  return v2 == (unsigned __int8)v3;
}
// 235C48: using guessed type int e2prom_fd;

//----- (00011BA0) --------------------------------------------------------
int __fastcall save_eeprom_N(unsigned __int8 a1, char a2)
{
  unsigned __int8 v3[8]; // [sp+Fh] [bp+7h] BYREF
  char v4; // [sp+17h] [bp+Fh] BYREF

  v3[0] = a1;
  v4 = a2;
  return iic_write_reg(e2prom_fd, v3, 1, (int)&v4, 1u);
}
// 235C48: using guessed type int e2prom_fd;

//----- (00011BD8) --------------------------------------------------------
bool __fastcall get_eeprom_N(unsigned __int8 a1, int a2)
{
  unsigned __int8 v3[5]; // [sp+Fh] [bp+7h] BYREF
  int v4; // [sp+14h] [bp+Ch]

  v3[0] = a1;
  v4 = 0;
  return iic_read_reg(e2prom_fd, v3, 1, a2, 1u) == 1;
}
// 235C48: using guessed type int e2prom_fd;

//----- (00011C1C) --------------------------------------------------------
int __fastcall save_byte_to_eeprom(unsigned __int8 a1, char a2)
{
  unsigned __int8 v5; // [sp+Eh] [bp+Eh] BYREF
  unsigned __int8 v6; // [sp+Fh] [bp+Fh]

  v6 = 1;
  save_eeprom_N(a1, a2);
  usleep((__useconds_t)&unk_7A120);
  if ( get_eeprom_N(a1, (int)&v5) )
  {
    printf("The value write to eeprom : 0x%02X\n", (unsigned __int8)a2);
    printf("The value get from eeprom : 0x%02X\n", v5);
    if ( (unsigned __int8)a2 != v5 )
    {
      puts("Save eeprom Error");
      return 0;
    }
  }
  else
  {
    puts("Get value from eeprom Error");
    return 0;
  }
  return v6;
}

//----- (00011CB0) --------------------------------------------------------
int __fastcall save_voltage_info_to_eeprom(unsigned int a1, unsigned int a2)
{
  int v3; // [sp+8h] [bp+8h] BYREF
  __int16 v4; // [sp+Ch] [bp+Ch]
  char v5; // [sp+Eh] [bp+Eh]
  char v6; // [sp+Fh] [bp+Fh]
  int i; // [sp+10h] [bp+10h]
  unsigned __int8 v8; // [sp+17h] [bp+17h]

  v8 = 0;
  v6 = 0;
  v5 = 0;
  v3 = 43605;
  HIBYTE(v3) = a1 / 0xA;
  v4 = (unsigned __int8)(a2 / 0xA);
  HIBYTE(v4) = CRC5((unsigned __int8 *)&v3, 0x28u);
  if ( test_eeprom() )
  {
    for ( i = 0; i <= 5; ++i )
    {
      v8 = save_byte_to_eeprom(i - 102, *((_BYTE *)&v3 + i));
      if ( v8 != 1 )
      {
        puts("save_voltage_info_to_eeprom failed!");
        return v8;
      }
    }
  }
  return v8;
}

//----- (00011D78) --------------------------------------------------------
int open_i2c()
{
  int v1; // [sp+0h] [bp+0h] BYREF
  __int16 v2; // [sp+4h] [bp+4h]
  char v3; // [sp+6h] [bp+6h]
  char v4; // [sp+7h] [bp+7h]
  int v5; // [sp+8h] [bp+8h] BYREF
  __int16 v6; // [sp+Ch] [bp+Ch]
  char v7; // [sp+Eh] [bp+Eh]
  char v8; // [sp+Fh] [bp+Fh]
  int v9; // [sp+10h] [bp+10h] BYREF
  __int16 v10; // [sp+14h] [bp+14h]
  char v11; // [sp+16h] [bp+16h]
  char v12; // [sp+17h] [bp+17h]

  v9 = (unsigned __int8)gChain;
  v10 = 0;
  v11 = 4;
  v12 = gChain;
  printf("--- %s on 7007, slave high = 0x%x, low = 0x%x\n", "open_i2c", 4, (unsigned __int8)gChain);
  i2c_fd = iic_init((int)&v9);
  v5 = (unsigned __int8)gChain;
  v6 = 1;
  v7 = 2;
  v8 = 0;
  printf("--- %s on 7007, slave high = 0x%x, low = 0x%x\n", "open_i2c", 2, 0);
  power_fd = iic_init((int)&v5);
  v1 = (unsigned __int8)gChain;
  v2 = 0;
  v3 = 10;
  v4 = gChain;
  printf("--- %s on 7007, slave high = 0x%x, low = 0x%x\n", "open_i2c", 10, (unsigned __int8)gChain);
  e2prom_fd = iic_init((int)&v1);
  return i2c_fd;
}
// 35530: using guessed type char gChain;
// 235C40: using guessed type int i2c_fd;
// 235C44: using guessed type int power_fd;
// 235C48: using guessed type int e2prom_fd;

//----- (00011E78) --------------------------------------------------------
int close_i2c()
{
  printf("--- %s\n", "close_i2c");
  iic_uninit(e2prom_fd);
  iic_uninit(power_fd);
  iic_uninit(i2c_fd);
  return 0;
}
// 235C40: using guessed type int i2c_fd;
// 235C44: using guessed type int power_fd;
// 235C48: using guessed type int e2prom_fd;

//----- (00011EC8) --------------------------------------------------------
int __fastcall iic_i2c_write(int a1, unsigned int a2)
{
  return iic_write(i2c_fd, a1, a2);
}
// 235C40: using guessed type int i2c_fd;

//----- (00011EF4) --------------------------------------------------------
int __fastcall iic_i2c_read(int a1, unsigned int a2)
{
  return iic_read(i2c_fd, a1, a2);
}
// 235C40: using guessed type int i2c_fd;

//----- (00011F20) --------------------------------------------------------
int __fastcall iic_i2c_write_reg(unsigned __int8 a1, int a2, unsigned int a3)
{
  unsigned __int8 v4; // [sp+17h] [bp+Fh] BYREF

  v4 = a1;
  return iic_write_reg(power_fd, &v4, 1, a2, a3);
}
// 235C44: using guessed type int power_fd;

//----- (00011F58) --------------------------------------------------------
int __fastcall iic_i2c_read_reg(unsigned __int8 a1, int a2, unsigned int a3)
{
  unsigned __int8 v4; // [sp+17h] [bp+Fh] BYREF

  v4 = a1;
  return iic_read_reg(power_fd, &v4, 1, a2, a3);
}
// 235C44: using guessed type int power_fd;

//----- (00011F90) --------------------------------------------------------
size_t __fastcall dcr_uart_send(unsigned __int8 a1, const void *a2, size_t a3)
{
  _BYTE s[512]; // [sp+14h] [bp+14h] BYREF
  int v9; // [sp+214h] [bp+214h]

  v9 = 0;
  if ( a1 == 255 )
  {
    printf("%s: invalid chain id\n", "dcr_uart_send");
    return -1;
  }
  else
  {
    memset(s, 0, sizeof(s));
    s[0] = 85;
    s[1] = -86;
    memcpy(&s[2], a2, a3);
    return uart_send(a1, s, a3 + 2);
  }
}

//----- (00012034) --------------------------------------------------------
int __fastcall uart_set_baud(unsigned __int8 a1, int a2)
{
  int v3; // [sp+0h] [bp+0h] BYREF
  unsigned __int8 v4; // [sp+7h] [bp+7h]

  v3 = a2;
  v4 = a1;
  printf("uart_set_config %d \n", a2);
  return uart_set_config(v4, 0, &v3);
}

//----- (00012068) --------------------------------------------------------
const char *__fastcall key_callback(int a1, int a2)
{
  const char *result; // r0
  _DWORD v4[2]; // [sp+8h] [bp+8h]

  result = "reset";
  v4[0] = "reset";
  v4[1] = "ipreport";
  if ( a2 )
  {
    if ( a2 == 1 )
    {
      result = (const char *)printf("%s key up\n", (const char *)v4[a1 - 256]);
      key_pressed = 0;
    }
  }
  else
  {
    result = (const char *)printf("%s key pressed\n", (const char *)v4[a1 - 256]);
    key_pressed = 1;
  }
  if ( a1 == 256 )
  {
    red_led_off();
    return (const char *)green_led_off();
  }
  return result;
}
// 235C4C: using guessed type int key_pressed;

//----- (00012108) --------------------------------------------------------
int open_key()
{
  reg_key_callback((int)key_callback);
  return 1;
}

//----- (00012120) --------------------------------------------------------
int close_key()
{
  return unreg_key_callback((int)key_callback);
}

//----- (00012134) --------------------------------------------------------
int __fastcall read_key(_BYTE *a1)
{
  *a1 = key_pressed;
  return 1;
}
// 235C4C: using guessed type int key_pressed;

//----- (0001215C) --------------------------------------------------------
int __fastcall write_lcd(unsigned __int8 a1, int a2, unsigned int a3)
{
  lcd_clear_result();
  return lcd_show_result(a1, a2, a3);
}

//----- (00012180) --------------------------------------------------------
int __fastcall write_lcd_no_memset(unsigned __int8 a1, int a2, unsigned int a3)
{
  return lcd_show_result(a1, a2, a3);
}

//----- (000121A0) --------------------------------------------------------
int __fastcall c2hex(unsigned __int8 a1)
{
  unsigned __int8 v2; // [sp+Fh] [bp+Fh]

  v2 = -1;
  if ( a1 <= 0x2Fu || a1 > 0x39u )
  {
    switch ( a1 )
    {
      case 'a':
      case 'A':
        return 10;
      case 'b':
      case 'B':
        return 11;
      case 'c':
      case 'C':
        return 12;
      case 'd':
      case 'D':
        return 13;
      case 'e':
      case 'E':
        return 14;
      case 'f':
      case 'F':
        return 15;
      default:
        printf("input value error: %c\n", a1);
        break;
    }
  }
  else
  {
    return a1 & 0xF;
  }
  return v2;
}

//----- (0001224C) --------------------------------------------------------
unsigned __int8 __cdecl twoc2hex(unsigned __int8 high, unsigned __int8 low)
{
  char v4; // [sp+7h] [bp+7h]

  v4 = c2hex(high);
  return c2hex(low) ^ (16 * v4);
}

//----- (00012290) --------------------------------------------------------
int __fastcall s2hex(_BYTE *a1, _BYTE *a2, int a3)
{
  int v7; // [sp+14h] [bp+14h]
  int v8; // [sp+18h] [bp+18h]
  int i; // [sp+1Ch] [bp+1Ch]

  if ( a2 && a3 > 0 && a1 )
  {
    v8 = a3 / 2;
    v7 = a3 % 2;
    for ( i = 0; i < v8; ++i )
      a1[i] = twoc2hex(a2[2 * i], a2[2 * i + 1]);
    if ( v7 )
      a1[i] = twoc2hex(a2[2 * i], 0);
    return v8 + v7;
  }
  else
  {
    printf("s2hex para error dst(%p), src(%p), inlen(%d)\n", a1, a2, a3);
    return -1;
  }
}

//----- (00012368) --------------------------------------------------------
int print_works()
{
  int v0; // r3
  int v2; // [sp+0h] [bp+0h]
  int v3; // [sp+0h] [bp+0h]
  int v4; // [sp+4h] [bp+4h]
  int v5; // [sp+4h] [bp+4h]
  unsigned int j; // [sp+8h] [bp+8h]
  unsigned int ii; // [sp+8h] [bp+8h]
  unsigned int i; // [sp+Ch] [bp+Ch]
  unsigned int n; // [sp+Ch] [bp+Ch]
  unsigned int m; // [sp+10h] [bp+10h]
  int k; // [sp+14h] [bp+14h]
  int jj; // [sp+14h] [bp+14h]

  printf("\n%s begin\n\n", "print_works");
  if ( dword_336848 == 1 )
  {
    for ( i = 0; dword_33684C > i; ++i )
    {
      v4 = *((_DWORD *)&cgpu + i + 131112);
      for ( j = 0; dword_33681C > j; ++j )
      {
        v2 = v4 + 204 * j;
        printf("core[%02d][%02d].work=0x", i, j);
        for ( k = 0; k <= 179; ++k )
          printf("%02x", *(unsigned __int8 *)(v2 + k + 8));
        printf(" nonce=0x%08x\n", *(_DWORD *)(v2 + 4));
      }
      putchar(10);
    }
  }
  else
  {
    for ( m = 0; dword_336848 > m; ++m )
    {
      v5 = *((_DWORD *)&cgpu + m + 131112);
      for ( n = 0; dword_33684C > n; ++n )
      {
        for ( ii = 0; dword_33681C > ii; ++ii )
        {
          v3 = v5 + 204 * (n * dword_33681C + ii);
          printf("asic[%02d][%02d][%02d].work=0x", m, n, ii);
          for ( jj = 0; jj <= 179; ++jj )
            printf("%02x", *(unsigned __int8 *)(v3 + jj + 8));
          printf(" nonce=0x%08x\n", *(_DWORD *)(v3 + 4));
        }
        putchar(10);
      }
      putchar(10);
    }
  }
  printf("\n%s end\n\n", "print_works");
  return v0;
}
// 12558: variable 'v0' is possibly undefined
// 33681C: using guessed type int dword_33681C;
// 336848: using guessed type int dword_336848;
// 33684C: using guessed type int dword_33684C;

//----- (00012564) --------------------------------------------------------
unsigned int __fastcall get_work(int a1, int a2, FILE *a3, unsigned int a4)
{
  char s[1024]; // [sp+10h] [bp+10h] BYREF
  void *ptr; // [sp+410h] [bp+410h]
  int i; // [sp+414h] [bp+414h]
  unsigned int v13; // [sp+418h] [bp+418h]
  char *v14; // [sp+41Ch] [bp+41Ch]

  memset(s, 0, sizeof(s));
  v13 = 0;
  i = 0;
  while ( 1 )
  {
    if ( !fgets(s, 1023, a3) || a4 <= v13 )
      return v13;
    ptr = (void *)(*((_DWORD *)&cgpu + a1 + 131112) + 204 * (a4 * a2 + v13));
    v14 = strstr(s, "nonce");
    if ( !v14 )
      break;
    for ( v14 += 5; *v14 == 32; ++v14 )
      ;
    s2hex((_BYTE *)ptr + 4, v14, 8);
    v14 = strstr(s, "work");
    if ( !v14 )
      break;
    for ( v14 += 4; *v14 == 32; ++v14 )
      ;
    s2hex((_BYTE *)ptr + 8, v14, 360);
    for ( i = 0; i <= 3; ++i )
      *((_DWORD *)ptr + i + 47) = 0;
    *(_DWORD *)ptr = v13++;
  }
  free(ptr);
  puts("get work err");
  return v13;
}

//----- (0001271C) --------------------------------------------------------
int get_works()
{
  unsigned int v1; // r4
  unsigned int v2; // r4
  char s[64]; // [sp+Ch] [bp+4h] BYREF
  int v5; // [sp+4Ch] [bp+44h]
  unsigned int i; // [sp+50h] [bp+48h]
  unsigned int j; // [sp+54h] [bp+4Ch]
  unsigned int v8; // [sp+58h] [bp+50h]
  unsigned int k; // [sp+5Ch] [bp+54h]

  memset(s, 0, sizeof(s));
  j = 0;
  i = 0;
  v5 = 0;
  printf("%s, Conf.AsicNum %d, Conf.CoreNum %d\n", "get_works", dword_336848, dword_33684C);
  for ( i = 0; dword_336848 > i; ++i )
  {
    *((_DWORD *)&cgpu + i + 131112) = malloc(204 * dword_33684C * dword_33681C);
    if ( !*((_DWORD *)&cgpu + i + 131112) )
    {
      printf("%s: malloc struct work err!\n", "get_works");
      return -1;
    }
    for ( j = 0; dword_33684C > j; ++j )
    {
      sprintf(s, "%s%02d%s%03d.txt", dest, i, byte_2B636C, j);
      v1 = i * dword_33684C + j;
      *((_DWORD *)&cgpu + v1) = fopen(s, "r");
      if ( !*((_DWORD *)&cgpu + i * dword_33684C + j) )
      {
        printf("%s: Open test file %s error\n", "get_works", s);
        return -1;
      }
      v2 = i * dword_33684C + j;
      *((_DWORD *)&cgpu + v2 + 131368) = get_work(i, j, *((FILE **)&cgpu + v2), dword_33681C);
      fclose(*((FILE **)&cgpu + i * dword_33684C + j));
    }
  }
  dword_3367AC = dword_2B67AC;
  v8 = 0;
  for ( k = 0; k < dword_33684C * dword_336848; ++k )
  {
    if ( dword_3367AC > *((_DWORD *)&cgpu + k + 131368) )
    {
      dword_3367AC = *((_DWORD *)&cgpu + k + 131368);
      v8 = k;
    }
  }
  if ( dword_33681C <= (unsigned int)dword_3367AC )
    return 0;
  write_lcd(1u, (int)"Get Less Work", 0xDu);
  printf("%s: cgpu.subid[%d] = %d, is the least pattern number\n", "get_works", v8, dword_3367AC);
  return -1;
}
// 2B67AC: using guessed type int dword_2B67AC;
// 3367AC: using guessed type int dword_3367AC;
// 33681C: using guessed type int dword_33681C;
// 336848: using guessed type int dword_336848;
// 33684C: using guessed type int dword_33684C;

//----- (00012A3C) --------------------------------------------------------
int __fastcall write_pic(char a1, char a2, char a3)
{
  _BYTE v4[3]; // [sp+5h] [bp+5h] BYREF

  v4[2] = a1;
  v4[1] = a2;
  v4[0] = a3;
  return iic_i2c_write((int)v4, 1u);
}

//----- (00012A60) --------------------------------------------------------
int read_pic()
{
  unsigned __int8 v1; // [sp+Fh] [bp+Fh] BYREF

  v1 = 0;
  iic_i2c_read((int)&v1, 1u);
  return v1;
}

//----- (00012A8C) --------------------------------------------------------
int __fastcall set_PIC16F1704_flash_point32_ter(char a1, char a2, unsigned __int8 a3, unsigned __int8 a4)
{
  __int16 v4; // r3
  int v5; // r4
  int v11; // [sp+Ch] [bp+Ch]
  unsigned __int8 v12; // [sp+10h] [bp+10h]
  unsigned __int8 v13; // [sp+11h] [bp+11h]
  char v14; // [sp+12h] [bp+12h]
  char v15; // [sp+13h] [bp+13h]
  unsigned __int8 v16[4]; // [sp+14h] [bp+14h]
  char v17; // [sp+18h] [bp+18h]
  char v18; // [sp+19h] [bp+19h]
  __int16 v19; // [sp+1Ch] [bp+1Ch]
  char v20; // [sp+1Eh] [bp+1Eh]
  unsigned __int8 i; // [sp+1Fh] [bp+1Fh]

  v20 = 6;
  *(_WORD *)v16 = 255;
  v11 = 17214037;
  v4 = a3 + 6 + a4;
  v19 = v4 + 1;
  v17 = (unsigned __int16)(v4 + 1) >> 8;
  v18 = v4 + 1;
  v12 = a3;
  v13 = a4;
  v14 = v17;
  v15 = v4 + 1;
  pthread_mutex_lock(&i2c_mutex_0);
  for ( i = 0; i <= 7u; ++i )
    write_pic(a1, a2, *((_BYTE *)&v11 + i));
  usleep(0x186A0u);
  for ( i = 0; i <= 1u; ++i )
  {
    v5 = i;
    v16[v5] = read_pic();
  }
  pthread_mutex_unlock(&i2c_mutex_0);
  if ( v16[0] == 1 && v16[1] == 1 )
  {
    printf("\n--- %s ok\n\n", "set_PIC16F1704_flash_point32_ter");
    return 1;
  }
  else
  {
    printf(
      "\n--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
      "set_PIC16F1704_flash_point32_ter",
      v16[0],
      v16[1]);
    return 0;
  }
}
// 35AAC: using guessed type pthread_mutex_t i2c_mutex_0;

//----- (00012BD0) --------------------------------------------------------
int __fastcall send_data_to_PIC16F1704(char a1, char a2, int a3)
{
  int v3; // r4
  _DWORD v8[5]; // [sp+14h] [bp+14h] BYREF
  __int16 v9; // [sp+28h] [bp+28h]
  unsigned __int8 v10[4]; // [sp+2Ch] [bp+2Ch]
  __int16 v11; // [sp+30h] [bp+30h]
  char v12; // [sp+34h] [bp+34h]
  unsigned __int8 i; // [sp+35h] [bp+35h]
  __int16 v14; // [sp+36h] [bp+36h]

  v12 = 20;
  v11 = 255;
  *(_WORD *)v10 = 255;
  memset(v8, 0, sizeof(v8));
  v9 = 0;
  v14 = 22;
  for ( i = 0; i <= 0xFu; ++i )
    v14 += *(unsigned __int8 *)(a3 + i);
  LOBYTE(v11) = HIBYTE(v14);
  HIBYTE(v11) = v14;
  LOWORD(v8[0]) = -21931;
  BYTE2(v8[0]) = v12;
  HIBYTE(v8[0]) = 2;
  for ( i = 0; i <= 0xFu; ++i )
    *((_BYTE *)&v8[1] + i) = *(_BYTE *)(a3 + i);
  v9 = v11;
  pthread_mutex_lock(&i2c_mutex_0);
  for ( i = 0; i <= 0x15u; ++i )
    write_pic(a1, a2, *((_BYTE *)v8 + i));
  usleep(0x186A0u);
  for ( i = 0; i <= 1u; ++i )
  {
    v3 = i;
    v10[v3] = read_pic();
  }
  pthread_mutex_unlock(&i2c_mutex_0);
  if ( v10[0] == 2 && v10[1] == 1 )
  {
    printf("\n--- %s ok\n\n", "send_data_to_PIC16F1704");
    return 1;
  }
  else
  {
    printf(
      "\n--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
      "send_data_to_PIC16F1704",
      v10[0],
      v10[1]);
    return 0;
  }
}
// 35AAC: using guessed type pthread_mutex_t i2c_mutex_0;

//----- (00012DAC) --------------------------------------------------------
int __fastcall read_PIC16F1704_flash_point32_ter(char a1, char a2, unsigned __int8 *a3, unsigned __int8 *a4)
{
  int v4; // r4
  int v11; // [sp+20h] [bp+10h]
  char v12; // [sp+24h] [bp+14h]
  char v13; // [sp+25h] [bp+15h]
  int v14; // [sp+28h] [bp+18h]
  __int16 v15; // [sp+2Ch] [bp+1Ch]
  __int16 v16; // [sp+30h] [bp+20h]
  __int16 v17; // [sp+34h] [bp+24h]
  char v18; // [sp+36h] [bp+26h]
  unsigned __int8 i; // [sp+37h] [bp+27h]

  v18 = 4;
  v16 = 3072;
  v14 = 255;
  v15 = 0;
  v11 = 134523477;
  v17 = 12;
  v12 = 0;
  v13 = 12;
  pthread_mutex_lock(&i2c_mutex_0);
  for ( i = 0; i <= 5u; ++i )
    write_pic(a1, a2, *((_BYTE *)&v11 + i));
  usleep(0x186A0u);
  for ( i = 0; i <= 5u; ++i )
  {
    v4 = i;
    *((_BYTE *)&v14 + v4) = read_pic();
  }
  pthread_mutex_unlock(&i2c_mutex_0);
  if ( BYTE1(v14) == 8
    && (unsigned __int8)v14 == 6
    && (v17 = (unsigned __int8)v14 + BYTE1(v14) + BYTE2(v14) + HIBYTE(v14), HIBYTE(v17) == (unsigned __int8)v15)
    && (unsigned __int8)v17 == HIBYTE(v15) )
  {
    *a3 = BYTE2(v14);
    *a4 = HIBYTE(v14);
    printf(
      "\n--- %s ok! flash_addr_h = 0x%02x, flash_addr_l = 0x%02x\n\n",
      "read_PIC16F1704_flash_point32_ter",
      *a3,
      *a4);
    return 1;
  }
  else
  {
    printf(
      "\n"
      "--- %s failed! read_back_data[0] = 0x%x, read_back_data[1] = 0x%x, read_back_data[2] = 0x%x, read_back_data[3] = 0"
      "x%x, read_back_data[4] = 0x%x, read_back_data[5] = 0x%x\n"
      "\n",
      "read_PIC16F1704_flash_point32_ter",
      (unsigned __int8)v14,
      BYTE1(v14),
      BYTE2(v14),
      HIBYTE(v14),
      (unsigned __int8)v15,
      HIBYTE(v15));
    return 0;
  }
}
// 35AAC: using guessed type pthread_mutex_t i2c_mutex_0;

//----- (00012F90) --------------------------------------------------------
int __fastcall read_PIC16F1704_flash_data(char a1, char a2, int a3)
{
  int v3; // r4
  int v9; // [sp+74h] [bp+2Ch]
  char v10; // [sp+78h] [bp+30h]
  char v11; // [sp+79h] [bp+31h]
  int v12; // [sp+7Ch] [bp+34h]
  int v13; // [sp+80h] [bp+38h]
  int v14; // [sp+84h] [bp+3Ch]
  int v15; // [sp+88h] [bp+40h]
  int v16; // [sp+8Ch] [bp+44h]
  __int16 v17; // [sp+90h] [bp+48h]
  unsigned __int16 v18; // [sp+94h] [bp+4Ch]
  char v19; // [sp+96h] [bp+4Eh]
  unsigned __int8 i; // [sp+97h] [bp+4Fh]

  v19 = 4;
  v17 = 1792;
  v12 = 255;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  v9 = 50637397;
  v18 = 7;
  v10 = 0;
  v11 = 7;
  pthread_mutex_lock(&i2c_mutex_0);
  for ( i = 0; i <= 5u; ++i )
    write_pic(a1, a2, *((_BYTE *)&v9 + i));
  usleep((__useconds_t)&unk_493E0);
  for ( i = 0; i <= 0x13u; ++i )
  {
    v3 = i;
    *((_BYTE *)&v12 + v3) = read_pic();
  }
  pthread_mutex_unlock(&i2c_mutex_0);
  printf(
    "--- %s: read_back_data[0] = 0x%x, read_back_data[1] = 0x%x, read_back_data[2] = 0x%x, read_back_data[3] = 0x%x,     "
    "    read_back_data[4] = 0x%x, read_back_data[5] = 0x%x, read_back_data[6] = 0x%x, read_back_data[7] = 0x%x,         "
    "read_back_data[8] = 0x%x, read_back_data[9] = 0x%x, read_back_data[10] = 0x%x, read_back_data[11] = 0x%x,         re"
    "ad_back_data[12] = 0x%x, read_back_data[13] = 0x%x, read_back_data[14] = 0x%x, read_back_data[15] = 0x%x,         re"
    "ad_back_data[16] = 0x%x, read_back_data[17] = 0x%x, read_back_data[18] = 0x%x, read_back_data[19] = 0x%x\n",
    "read_PIC16F1704_flash_data",
    (unsigned __int8)v12,
    BYTE1(v12),
    BYTE2(v12),
    HIBYTE(v12),
    (unsigned __int8)v13,
    BYTE1(v13),
    BYTE2(v13),
    HIBYTE(v13),
    (unsigned __int8)v14,
    BYTE1(v14),
    BYTE2(v14),
    HIBYTE(v14),
    (unsigned __int8)v15,
    BYTE1(v15),
    BYTE2(v15),
    HIBYTE(v15),
    (unsigned __int8)v16,
    BYTE1(v16),
    BYTE2(v16),
    HIBYTE(v16));
  usleep(0x186A0u);
  if ( BYTE1(v12) == 3 && (unsigned __int8)v12 == 20 )
  {
    v18 = (unsigned __int8)v12
        + BYTE1(v12)
        + BYTE2(v12)
        + HIBYTE(v12)
        + (unsigned __int8)v13
        + BYTE1(v13)
        + BYTE2(v13)
        + HIBYTE(v13)
        + (unsigned __int8)v14
        + BYTE1(v14)
        + BYTE2(v14)
        + HIBYTE(v14)
        + (unsigned __int8)v15
        + BYTE1(v15)
        + BYTE2(v15)
        + HIBYTE(v15)
        + (unsigned __int8)v16
        + BYTE1(v16);
    if ( HIBYTE(v18) == BYTE2(v16) && (unsigned __int8)v18 == HIBYTE(v16) )
    {
      for ( i = 0; i <= 0xFu; ++i )
        *(_BYTE *)(a3 + i) = *((_BYTE *)&v12 + i + 2);
      printf("\n--- %s ok\n\n", "read_PIC16F1704_flash_data");
      return 1;
    }
    else
    {
      printf("\n--- %s failed! crc = 0x%04x\n\n", "read_PIC16F1704_flash_data", v18);
      return 0;
    }
  }
  else
  {
    printf("\n--- %s failed!\n\n", "read_PIC16F1704_flash_data");
    return 0;
  }
}
// 35AAC: using guessed type pthread_mutex_t i2c_mutex_0;

//----- (000132F4) --------------------------------------------------------
int __fastcall erase_PIC16F1704_flash(char a1, char a2)
{
  int v2; // r4
  int v7; // [sp+Ch] [bp+Ch]
  char v8; // [sp+10h] [bp+10h]
  char v9; // [sp+11h] [bp+11h]
  _WORD v10[5]; // [sp+14h] [bp+14h]
  char v11; // [sp+1Eh] [bp+1Eh]
  unsigned __int8 i; // [sp+1Fh] [bp+1Fh]

  v11 = 4;
  v10[2] = 2048;
  v10[0] = 255;
  v7 = 67414613;
  v10[4] = 8;
  v8 = 0;
  v9 = 8;
  pthread_mutex_lock(&i2c_mutex_0);
  for ( i = 0; i <= 5u; ++i )
    write_pic(a1, a2, *((_BYTE *)&v7 + i));
  usleep(0x186A0u);
  for ( i = 0; i <= 1u; ++i )
  {
    v2 = i;
    *((_BYTE *)v10 + v2) = read_pic();
  }
  pthread_mutex_unlock(&i2c_mutex_0);
  usleep(0x30D40u);
  if ( LOBYTE(v10[0]) == 4 && HIBYTE(v10[0]) == 1 )
  {
    printf("\n--- %s ok\n\n", "erase_PIC16F1704_flash");
    return 1;
  }
  else
  {
    printf(
      "\n--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
      "erase_PIC16F1704_flash",
      LOBYTE(v10[0]),
      HIBYTE(v10[0]));
    return 0;
  }
}
// 35AAC: using guessed type pthread_mutex_t i2c_mutex_0;

//----- (00013428) --------------------------------------------------------
int __fastcall write_data_int32_to_PIC16F1704_flash(char a1, char a2)
{
  int v2; // r4
  int v7; // [sp+Ch] [bp+Ch]
  char v8; // [sp+10h] [bp+10h]
  char v9; // [sp+11h] [bp+11h]
  _WORD v10[5]; // [sp+14h] [bp+14h]
  char v11; // [sp+1Eh] [bp+1Eh]
  unsigned __int8 i; // [sp+1Fh] [bp+1Fh]

  v11 = 4;
  v10[2] = 2304;
  v10[0] = 255;
  v7 = 84191829;
  v10[4] = 9;
  v8 = 0;
  v9 = 9;
  pthread_mutex_lock(&i2c_mutex_0);
  for ( i = 0; i <= 5u; ++i )
    write_pic(a1, a2, *((_BYTE *)&v7 + i));
  usleep(0x30D40u);
  for ( i = 0; i <= 1u; ++i )
  {
    v2 = i;
    *((_BYTE *)v10 + v2) = read_pic();
  }
  pthread_mutex_unlock(&i2c_mutex_0);
  usleep(0x30D40u);
  if ( LOBYTE(v10[0]) == 5 && HIBYTE(v10[0]) == 1 )
  {
    printf("\n--- %s ok\n\n", "write_data_int32_to_PIC16F1704_flash");
    return 1;
  }
  else
  {
    printf(
      "\n--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
      "write_data_int32_to_PIC16F1704_flash",
      LOBYTE(v10[0]),
      HIBYTE(v10[0]));
    return 0;
  }
}
// 35AAC: using guessed type pthread_mutex_t i2c_mutex_0;

//----- (0001355C) --------------------------------------------------------
int __fastcall jump_from_loader_to_app_PIC16F1704(char a1, char a2)
{
  int v2; // r4
  int v7; // [sp+Ch] [bp+Ch]
  char v8; // [sp+10h] [bp+10h]
  char v9; // [sp+11h] [bp+11h]
  _WORD v10[5]; // [sp+14h] [bp+14h]
  char v11; // [sp+1Eh] [bp+1Eh]
  unsigned __int8 i; // [sp+1Fh] [bp+1Fh]

  v11 = 4;
  v10[2] = 2560;
  v10[0] = 255;
  v7 = 100969045;
  v10[4] = 10;
  v8 = 0;
  v9 = 10;
  pthread_mutex_lock(&i2c_mutex_0);
  for ( i = 0; i <= 5u; ++i )
    write_pic(a2, a1, *((_BYTE *)&v7 + i));
  usleep(0x186A0u);
  for ( i = 0; i <= 1u; ++i )
  {
    v2 = i;
    *((_BYTE *)v10 + v2) = read_pic();
  }
  pthread_mutex_unlock(&i2c_mutex_0);
  usleep((__useconds_t)&unk_493E0);
  if ( LOBYTE(v10[0]) == 6 && HIBYTE(v10[0]) == 1 )
  {
    printf("\n--- %s ok\n\n", "jump_from_loader_to_app_PIC16F1704");
    return 1;
  }
  else
  {
    printf(
      "\n--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
      "jump_from_loader_to_app_PIC16F1704",
      LOBYTE(v10[0]),
      HIBYTE(v10[0]));
    return 0;
  }
}
// 35AAC: using guessed type pthread_mutex_t i2c_mutex_0;

//----- (00013690) --------------------------------------------------------
int __fastcall reset_PIC16F1704_pic(char a1, char a2)
{
  int v2; // r4
  int v7; // [sp+Ch] [bp+Ch]
  char v8; // [sp+10h] [bp+10h]
  char v9; // [sp+11h] [bp+11h]
  _WORD v10[5]; // [sp+14h] [bp+14h]
  char v11; // [sp+1Eh] [bp+1Eh]
  unsigned __int8 i; // [sp+1Fh] [bp+1Fh]

  v11 = 4;
  v10[2] = 2816;
  v10[0] = 255;
  v7 = 117746261;
  v10[4] = 11;
  v8 = 0;
  v9 = 11;
  pthread_mutex_lock(&i2c_mutex_0);
  for ( i = 0; i <= 5u; ++i )
    write_pic(a2, a1, *((_BYTE *)&v7 + i));
  usleep(0x186A0u);
  for ( i = 0; i <= 1u; ++i )
  {
    v2 = i;
    *((_BYTE *)v10 + v2) = read_pic();
  }
  pthread_mutex_unlock(&i2c_mutex_0);
  usleep((__useconds_t)&unk_F4240);
  if ( LOBYTE(v10[0]) == 7 && HIBYTE(v10[0]) == 1 )
  {
    printf("\n--- %s ok\n\n", "reset_PIC16F1704_pic");
    return 1;
  }
  else
  {
    printf(
      "\n--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
      "reset_PIC16F1704_pic",
      LOBYTE(v10[0]),
      HIBYTE(v10[0]));
    return 0;
  }
}
// 35AAC: using guessed type pthread_mutex_t i2c_mutex_0;

//----- (000137C4) --------------------------------------------------------
int __fastcall set_PIC16F1704_voltage(char a1, char a2, unsigned __int8 a3)
{
  int v3; // r4
  _BYTE v9[8]; // [sp+Ch] [bp+Ch]
  unsigned __int8 v10[4]; // [sp+14h] [bp+14h]
  char v11; // [sp+18h] [bp+18h]
  char v12; // [sp+19h] [bp+19h]
  __int16 v13; // [sp+1Ch] [bp+1Ch]
  char v14; // [sp+1Eh] [bp+1Eh]
  unsigned __int8 i; // [sp+1Fh] [bp+1Fh]

  v14 = 5;
  *(_WORD *)v10 = 255;
  printf("\n--- %s\n", "set_PIC16F1704_voltage");
  v13 = a3 + 21;
  v11 = HIBYTE(v13);
  v12 = a3 + 21;
  v9[0] = 85;
  v9[1] = -86;
  v9[2] = 5;
  v9[3] = 16;
  v9[4] = a3;
  v9[5] = HIBYTE(v13);
  v9[6] = a3 + 21;
  pthread_mutex_lock(&i2c_mutex_0);
  for ( i = 0; i <= 6u; ++i )
    write_pic(a2, a1, v9[i]);
  usleep(0x30D40u);
  for ( i = 0; i <= 1u; ++i )
  {
    v3 = i;
    v10[v3] = read_pic();
  }
  pthread_mutex_unlock(&i2c_mutex_0);
  usleep(0x30D40u);
  if ( v10[0] == 16 && v10[1] == 1 )
  {
    printf("\n--- %s ok\n\n", "set_PIC16F1704_voltage");
    return 1;
  }
  else
  {
    printf(
      "\n--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
      "set_PIC16F1704_voltage",
      v10[0],
      v10[1]);
    return 0;
  }
}
// 35AAC: using guessed type pthread_mutex_t i2c_mutex_0;

//----- (0001392C) --------------------------------------------------------
int __fastcall write_hash_ID_PIC16F1704(char a1, char a2, int a3)
{
  int v3; // r4
  _DWORD v8[4]; // [sp+10h] [bp+10h] BYREF
  __int16 v9; // [sp+20h] [bp+20h]
  unsigned __int8 v10[4]; // [sp+24h] [bp+24h]
  __int16 v11; // [sp+28h] [bp+28h]
  char v12; // [sp+2Ch] [bp+2Ch]
  unsigned __int8 i; // [sp+2Dh] [bp+2Dh]
  __int16 v14; // [sp+2Eh] [bp+2Eh]

  v12 = 16;
  v11 = 255;
  *(_WORD *)v10 = 255;
  memset(v8, 0, sizeof(v8));
  v9 = 0;
  v14 = 34;
  for ( i = 0; i <= 0xBu; ++i )
    v14 += *(unsigned __int8 *)(a3 + i);
  LOBYTE(v11) = HIBYTE(v14);
  HIBYTE(v11) = v14;
  LOWORD(v8[0]) = -21931;
  BYTE2(v8[0]) = v12;
  HIBYTE(v8[0]) = 18;
  for ( i = 0; i <= 0xBu; ++i )
    *((_BYTE *)&v8[1] + i) = *(_BYTE *)(a3 + i);
  v9 = v11;
  pthread_mutex_lock(&i2c_mutex_0);
  for ( i = 0; i <= 0x11u; ++i )
    write_pic(a2, a1, *((_BYTE *)v8 + i));
  usleep((__useconds_t)&unk_61A80);
  for ( i = 0; i <= 1u; ++i )
  {
    v3 = i;
    v10[v3] = read_pic();
  }
  pthread_mutex_unlock(&i2c_mutex_0);
  usleep(0x30D40u);
  if ( v10[0] == 18 && v10[1] == 1 )
  {
    printf("\n--- %s ok\n\n", "write_hash_ID_PIC16F1704");
    return 1;
  }
  else
  {
    printf(
      "\n--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
      "write_hash_ID_PIC16F1704",
      v10[0],
      v10[1]);
    return 0;
  }
}
// 35AAC: using guessed type pthread_mutex_t i2c_mutex_0;

//----- (00013B10) --------------------------------------------------------
int __fastcall read_hash_id_PIC16F1704(char a1, char a2, int a3)
{
  int v3; // r4
  int v9; // [sp+50h] [bp+18h]
  char v10; // [sp+54h] [bp+1Ch]
  char v11; // [sp+55h] [bp+1Dh]
  int v12; // [sp+58h] [bp+20h]
  int v13; // [sp+5Ch] [bp+24h]
  int v14; // [sp+60h] [bp+28h]
  int v15; // [sp+64h] [bp+2Ch]
  __int16 v16; // [sp+68h] [bp+30h]
  unsigned __int16 v17; // [sp+6Ch] [bp+34h]
  char v18; // [sp+6Eh] [bp+36h]
  unsigned __int8 i; // [sp+6Fh] [bp+37h]

  v18 = 4;
  v16 = 5888;
  v12 = 255;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v9 = 319072853;
  v17 = 23;
  v10 = 0;
  v11 = 23;
  pthread_mutex_lock(&i2c_mutex_0);
  for ( i = 0; i <= 5u; ++i )
    write_pic(a1, a2, *((_BYTE *)&v9 + i));
  usleep(0x30D40u);
  for ( i = 0; i <= 0xFu; ++i )
  {
    v3 = i;
    *((_BYTE *)&v12 + v3) = read_pic();
  }
  pthread_mutex_unlock(&i2c_mutex_0);
  printf(
    "--- %s: read_back_data[0] = 0x%x, read_back_data[1] = 0x%x, read_back_data[2] = 0x%x, read_back_data[3] = 0x%x,     "
    "   read_back_data[4] = 0x%x, read_back_data[5] = 0x%x, read_back_data[6] = 0x%x, read_back_data[7] = 0x%x,        re"
    "ad_back_data[8] = 0x%x, read_back_data[9] = 0x%x, read_back_data[10] = 0x%x, read_back_data[11] = 0x%x,        read_"
    "back_data[12] = 0x%x, read_back_data[13] = 0x%x, read_back_data[14] = 0x%x, read_back_data[15] = 0x%x\n",
    "read_hash_id_PIC16F1704",
    (unsigned __int8)v12,
    BYTE1(v12),
    BYTE2(v12),
    HIBYTE(v12),
    (unsigned __int8)v13,
    BYTE1(v13),
    BYTE2(v13),
    HIBYTE(v13),
    (unsigned __int8)v14,
    BYTE1(v14),
    BYTE2(v14),
    HIBYTE(v14),
    (unsigned __int8)v15,
    BYTE1(v15),
    BYTE2(v15),
    HIBYTE(v15));
  if ( BYTE1(v12) == 19 && (unsigned __int8)v12 == 16 )
  {
    v17 = (unsigned __int8)v12
        + BYTE1(v12)
        + BYTE2(v12)
        + HIBYTE(v12)
        + (unsigned __int8)v13
        + BYTE1(v13)
        + BYTE2(v13)
        + HIBYTE(v13)
        + (unsigned __int8)v14
        + BYTE1(v14)
        + BYTE2(v14)
        + HIBYTE(v14)
        + (unsigned __int8)v15
        + BYTE1(v15);
    if ( HIBYTE(v17) == BYTE2(v15) && (unsigned __int8)v17 == HIBYTE(v15) )
    {
      for ( i = 0; i <= 0xBu; ++i )
        *(_BYTE *)(a3 + i) = *((_BYTE *)&v12 + i + 2);
      printf("\n--- %s ok\n\n", "read_hash_id_PIC16F1704");
      return 1;
    }
    else
    {
      printf("\n--- %s failed! crc = 0x%04x\n\n", "read_hash_id_PIC16F1704", v17);
      return 0;
    }
  }
  else
  {
    printf("\n--- %s failed!\n\n", "read_hash_id_PIC16F1704");
    return 0;
  }
}
// 35AAC: using guessed type pthread_mutex_t i2c_mutex_0;

//----- (00013DF8) --------------------------------------------------------
int __fastcall enable_PIC16F1704_dc_dc(char a1, char a2, unsigned __int8 a3)
{
  int v3; // r4
  _BYTE v9[8]; // [sp+Ch] [bp+Ch]
  unsigned __int8 v10[4]; // [sp+14h] [bp+14h]
  char v11; // [sp+18h] [bp+18h]
  char v12; // [sp+19h] [bp+19h]
  __int16 v13; // [sp+1Ch] [bp+1Ch]
  char v14; // [sp+1Eh] [bp+1Eh]
  unsigned __int8 i; // [sp+1Fh] [bp+1Fh]

  v14 = 5;
  *(_WORD *)v10 = 255;
  printf("\n--- %s\n", "enable_PIC16F1704_dc_dc");
  v13 = a3 + 26;
  v11 = HIBYTE(v13);
  v12 = a3 + 26;
  v9[0] = 85;
  v9[1] = -86;
  v9[2] = 5;
  v9[3] = 21;
  v9[4] = a3;
  v9[5] = HIBYTE(v13);
  v9[6] = a3 + 26;
  pthread_mutex_lock(&i2c_mutex_0);
  for ( i = 0; i <= 6u; ++i )
    write_pic(a2, a1, v9[i]);
  usleep(0x186A0u);
  for ( i = 0; i <= 1u; ++i )
  {
    v3 = i;
    v10[v3] = read_pic();
  }
  pthread_mutex_unlock(&i2c_mutex_0);
  if ( v10[0] == 21 && v10[1] == 1 )
  {
    printf("\n--- %s ok\n\n", "enable_PIC16F1704_dc_dc");
    usleep((__useconds_t)&unk_7A120);
    return 1;
  }
  else
  {
    printf(
      "\n--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
      "enable_PIC16F1704_dc_dc",
      v10[0],
      v10[1]);
    return 0;
  }
}
// 35AAC: using guessed type pthread_mutex_t i2c_mutex_0;

//----- (00013F60) --------------------------------------------------------
int __fastcall heart_beat_PIC16F1704(char a1, char a2)
{
  int v2; // r4
  int v7; // [sp+8h] [bp+8h]
  char v8; // [sp+Ch] [bp+Ch]
  char v9; // [sp+Dh] [bp+Dh]
  int v10; // [sp+10h] [bp+10h]
  __int16 v11; // [sp+14h] [bp+14h]
  __int16 v12; // [sp+18h] [bp+18h]
  __int16 v13; // [sp+1Ch] [bp+1Ch]
  char v14; // [sp+1Eh] [bp+1Eh]
  unsigned __int8 i; // [sp+1Fh] [bp+1Fh]

  v14 = 4;
  v12 = 6656;
  v10 = 255;
  v11 = 0;
  v7 = 369404501;
  v13 = 26;
  v8 = 0;
  v9 = 26;
  pthread_mutex_lock(&i2c_mutex_0);
  for ( i = 0; i <= 5u; ++i )
    write_pic(a2, a1, *((_BYTE *)&v7 + i));
  usleep(0x186A0u);
  for ( i = 0; i <= 5u; ++i )
  {
    v2 = i;
    *((_BYTE *)&v10 + v2) = read_pic();
  }
  pthread_mutex_unlock(&i2c_mutex_0);
  if ( BYTE1(v10) == 22 && BYTE2(v10) == 1 )
  {
    printf("\n--- %s ok\n\n", "heart_beat_PIC16F1704");
    return 1;
  }
  else
  {
    printf("\n--- %s failed!\n\n", "heart_beat_PIC16F1704");
    return 0;
  }
}
// 35AAC: using guessed type pthread_mutex_t i2c_mutex_0;

//----- (00014088) --------------------------------------------------------
void __fastcall __noreturn pic_heart_beat_func(char *a1)
{
  char v1; // [sp+Ah] [bp+Ah]
  char v2; // [sp+Bh] [bp+Bh]

  v2 = *a1;
  v1 = a1[1];
  while ( 1 )
  {
    heart_beat_PIC16F1704(v2, v1);
    sleep(0xAu);
  }
}

//----- (000140B4) --------------------------------------------------------
int __fastcall get_PIC16F1704_software_version(char a1, char a2, unsigned __int8 *a3)
{
  int v3; // r4
  int v9; // [sp+20h] [bp+10h]
  char v10; // [sp+24h] [bp+14h]
  char v11; // [sp+25h] [bp+15h]
  int v12; // [sp+28h] [bp+18h]
  unsigned __int8 v13; // [sp+2Ch] [bp+1Ch]
  __int16 v14; // [sp+30h] [bp+20h]
  unsigned __int16 v15; // [sp+34h] [bp+24h]
  char v16; // [sp+36h] [bp+26h]
  unsigned __int8 i; // [sp+37h] [bp+27h]

  v16 = 4;
  v14 = 6912;
  v12 = 255;
  v13 = 0;
  v9 = 386181717;
  v15 = 27;
  v10 = 0;
  v11 = 27;
  pthread_mutex_lock(&i2c_mutex_0);
  for ( i = 0; i <= 5u; ++i )
    write_pic(a1, a2, *((_BYTE *)&v9 + i));
  usleep(0x30D40u);
  for ( i = 0; i <= 4u; ++i )
  {
    v3 = i;
    *((_BYTE *)&v12 + v3) = read_pic();
  }
  pthread_mutex_unlock(&i2c_mutex_0);
  usleep(0x30D40u);
  printf(
    "--- %s: read_back_data[0] = 0x%x, read_back_data[1] = 0x%x, read_back_data[2] = 0x%x, read_back_data[3] = 0x%x, read"
    "_back_data[4] = 0x%x\n",
    "get_PIC16F1704_software_version",
    (unsigned __int8)v12,
    BYTE1(v12),
    BYTE2(v12),
    HIBYTE(v12),
    v13);
  if ( BYTE1(v12) == 23 && (unsigned __int8)v12 == 5 )
  {
    v15 = (unsigned __int8)v12 + BYTE1(v12) + BYTE2(v12);
    if ( HIBYTE(v15) == HIBYTE(v12) && (unsigned __int8)v15 == v13 )
    {
      *a3 = BYTE2(v12);
      printf("\n--- %s ok, version = 0x%02x\n\n", "get_PIC16F1704_software_version", *a3);
      return 1;
    }
    else
    {
      printf("\n--- %s failed! crc = 0x%04x\n\n", "get_PIC16F1704_software_version", v15);
      return 0;
    }
  }
  else
  {
    printf("\n--- %s failed!\n\n", "get_PIC16F1704_software_version");
    return 0;
  }
}
// 35AAC: using guessed type pthread_mutex_t i2c_mutex_0;

//----- (00014288) --------------------------------------------------------
int __fastcall get_PIC16F1704_voltage(char a1, char a2, unsigned __int8 *a3)
{
  int v3; // r4
  int v9; // [sp+20h] [bp+10h]
  char v10; // [sp+24h] [bp+14h]
  char v11; // [sp+25h] [bp+15h]
  int v12; // [sp+28h] [bp+18h]
  unsigned __int8 v13; // [sp+2Ch] [bp+1Ch]
  __int16 v14; // [sp+30h] [bp+20h]
  unsigned __int16 v15; // [sp+34h] [bp+24h]
  char v16; // [sp+36h] [bp+26h]
  unsigned __int8 i; // [sp+37h] [bp+27h]

  v16 = 4;
  v14 = 7168;
  v12 = 255;
  v13 = 0;
  v9 = 402958933;
  v15 = 28;
  v10 = 0;
  v11 = 28;
  pthread_mutex_lock(&i2c_mutex_0);
  for ( i = 0; i <= 5u; ++i )
    write_pic(a1, a2, *((_BYTE *)&v9 + i));
  usleep(0x30D40u);
  for ( i = 0; i <= 4u; ++i )
  {
    v3 = i;
    *((_BYTE *)&v12 + v3) = read_pic();
  }
  pthread_mutex_unlock(&i2c_mutex_0);
  printf(
    "--- %s: read_back_data[0] = 0x%x, read_back_data[1] = 0x%x, read_back_data[2] = 0x%x, read_back_data[3] = 0x%x, read"
    "_back_data[4] = 0x%x\n",
    "get_PIC16F1704_voltage",
    (unsigned __int8)v12,
    BYTE1(v12),
    BYTE2(v12),
    HIBYTE(v12),
    v13);
  if ( BYTE1(v12) == 24 && (unsigned __int8)v12 == 5 )
  {
    v15 = (unsigned __int8)v12 + BYTE1(v12) + BYTE2(v12);
    if ( HIBYTE(v15) == HIBYTE(v12) && (unsigned __int8)v15 == v13 )
    {
      *a3 = BYTE2(v12);
      printf("\n--- %s ok, voltage = 0x%02x\n\n", "get_PIC16F1704_voltage", *a3);
      return 1;
    }
    else
    {
      printf("\n--- %s failed! crc = 0x%04x\n\n", "get_PIC16F1704_voltage", v15);
      return 0;
    }
  }
  else
  {
    printf("\n--- %s failed!\n\n", "get_PIC16F1704_voltage");
    return 0;
  }
}
// 35AAC: using guessed type pthread_mutex_t i2c_mutex_0;

//----- (00014450) --------------------------------------------------------
int __fastcall write_temperature_offset_PIC16F1704(char a1, char a2, int a3)
{
  int v3; // r4
  _DWORD v8[3]; // [sp+14h] [bp+14h] BYREF
  __int16 v9; // [sp+20h] [bp+20h]
  unsigned __int8 v10[4]; // [sp+24h] [bp+24h]
  __int16 v11; // [sp+28h] [bp+28h]
  char v12; // [sp+2Ch] [bp+2Ch]
  unsigned __int8 i; // [sp+2Dh] [bp+2Dh]
  __int16 v14; // [sp+2Eh] [bp+2Eh]

  v12 = 12;
  v11 = 255;
  *(_WORD *)v10 = 255;
  memset(v8, 0, sizeof(v8));
  v9 = 0;
  v14 = 46;
  for ( i = 0; i <= 7u; ++i )
    v14 += *(unsigned __int8 *)(a3 + i);
  LOBYTE(v11) = HIBYTE(v14);
  HIBYTE(v11) = v14;
  LOWORD(v8[0]) = -21931;
  BYTE2(v8[0]) = v12;
  HIBYTE(v8[0]) = 34;
  for ( i = 0; i <= 7u; ++i )
    *((_BYTE *)&v8[1] + i) = *(_BYTE *)(a3 + i);
  v9 = v11;
  pthread_mutex_lock(&i2c_mutex_0);
  for ( i = 0; i <= 0xDu; ++i )
    write_pic(a1, a2, *((_BYTE *)v8 + i));
  usleep(0x30D40u);
  for ( i = 0; i <= 1u; ++i )
  {
    v3 = i;
    v10[v3] = read_pic();
  }
  pthread_mutex_unlock(&i2c_mutex_0);
  usleep(0x30D40u);
  if ( v10[0] == 34 && v10[1] == 1 )
  {
    printf("\n--- %s ok\n\n", "write_temperature_offset_PIC16F1704");
    return 1;
  }
  else
  {
    printf(
      "\n--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
      "write_temperature_offset_PIC16F1704",
      v10[0],
      v10[1]);
    return 0;
  }
}
// 35AAC: using guessed type pthread_mutex_t i2c_mutex_0;

//----- (0001462C) --------------------------------------------------------
int __fastcall read_temperature_offset_PIC16F1704(char a1, char a2, int a3)
{
  int v3; // r4
  int v9; // [sp+3Ch] [bp+14h]
  char v10; // [sp+40h] [bp+18h]
  char v11; // [sp+41h] [bp+19h]
  int v12; // [sp+44h] [bp+1Ch]
  int v13; // [sp+48h] [bp+20h]
  int v14; // [sp+4Ch] [bp+24h]
  __int16 v15; // [sp+50h] [bp+28h]
  unsigned __int16 v16; // [sp+54h] [bp+2Ch]
  char v17; // [sp+56h] [bp+2Eh]
  unsigned __int8 i; // [sp+57h] [bp+2Fh]

  v17 = 4;
  v15 = 9984;
  v12 = 255;
  v13 = 0;
  v14 = 0;
  v9 = 587508309;
  v16 = 39;
  v10 = 0;
  v11 = 39;
  pthread_mutex_lock(&i2c_mutex_0);
  for ( i = 0; i <= 5u; ++i )
    write_pic(a1, a2, *((_BYTE *)&v9 + i));
  usleep(0x30D40u);
  for ( i = 0; i <= 0xBu; ++i )
  {
    v3 = i;
    *((_BYTE *)&v12 + v3) = read_pic();
  }
  pthread_mutex_unlock(&i2c_mutex_0);
  printf(
    "--- %s: read_back_data[0] = 0x%x, read_back_data[1] = 0x%x, read_back_data[2] = 0x%x, read_back_data[3] = 0x%x,     "
    "    read_back_data[4] = 0x%x, read_back_data[5] = 0x%x, read_back_data[6] = 0x%x, read_back_data[7] = 0x%x,         "
    "read_back_data[8] = 0x%x, read_back_data[9] = 0x%x, read_back_data[10] = 0x%x, read_back_data[11] = 0x%x\n",
    "read_temperature_offset_PIC16F1704",
    (unsigned __int8)v12,
    BYTE1(v12),
    BYTE2(v12),
    HIBYTE(v12),
    (unsigned __int8)v13,
    BYTE1(v13),
    BYTE2(v13),
    HIBYTE(v13),
    (unsigned __int8)v14,
    BYTE1(v14),
    BYTE2(v14),
    HIBYTE(v14));
  if ( BYTE1(v12) == 35 && (unsigned __int8)v12 == 12 )
  {
    v16 = (unsigned __int8)v12
        + BYTE1(v12)
        + BYTE2(v12)
        + HIBYTE(v12)
        + (unsigned __int8)v13
        + BYTE1(v13)
        + BYTE2(v13)
        + HIBYTE(v13)
        + (unsigned __int8)v14
        + BYTE1(v14);
    if ( HIBYTE(v16) == BYTE2(v14) && (unsigned __int8)v16 == HIBYTE(v14) )
    {
      for ( i = 0; i <= 7u; ++i )
        *(_BYTE *)(a3 + i) = *((_BYTE *)&v12 + i + 2);
      printf("\n--- %s ok\n\n", "read_temperature_offset_PIC16F1704");
      return 1;
    }
    else
    {
      printf("\n--- %s failed! crc = 0x%04x\n\n", "read_temperature_offset_PIC16F1704", v16);
      return 0;
    }
  }
  else
  {
    printf("\n--- %s failed!\n\n", "read_temperature_offset_PIC16F1704");
    return 0;
  }
}
// 35AAC: using guessed type pthread_mutex_t i2c_mutex_0;

//----- (000148B0) --------------------------------------------------------
int __fastcall erase_PIC16F1704_app_flash(char a1, char a2)
{
  unsigned int i; // [sp+1Ch] [bp+1Ch]

  set_PIC16F1704_flash_point32_ter(a1, a2, 6u, 0);
  printf("%s: erase_loop = %d\n", "erase_PIC16F1704_app_flash", 76);
  for ( i = 0; i < 0x4C; ++i )
    erase_PIC16F1704_flash(a1, a2);
  return 76;
}

//----- (00014944) --------------------------------------------------------
int __fastcall PIC1704_update_pic_app_program(char a1, char a2)
{
  int v2; // r3
  int *v3; // r3
  int v4; // r0
  int v5; // r1
  int v6; // r2
  int v7; // r3
  int v11; // [sp+60h] [bp+60h] BYREF
  int v12; // [sp+64h] [bp+64h]
  int v13; // [sp+68h] [bp+68h]
  int v14; // [sp+6Ch] [bp+6Ch]
  char v15[8]; // [sp+70h] [bp+70h] BYREF
  _BYTE v16[5000]; // [sp+78h] [bp+78h] BYREF
  FILE *v17; // [sp+1400h] [bp+1400h]
  int v18; // [sp+1404h] [bp+1404h]
  unsigned int v19; // [sp+1408h] [bp+1408h]
  unsigned __int8 v20; // [sp+140Ch] [bp+140Ch]
  unsigned __int8 v21; // [sp+140Dh] [bp+140Dh]
  unsigned __int8 v22; // [sp+140Eh] [bp+140Eh]
  unsigned __int8 v23; // [sp+140Fh] [bp+140Fh]
  unsigned int v24; // [sp+1410h] [bp+1410h]
  int v25; // [sp+1414h] [bp+1414h]
  unsigned int j; // [sp+1418h] [bp+1418h]
  unsigned int i; // [sp+141Ch] [bp+141Ch]

  memset(v16, 0, sizeof(v16));
  v25 = 0;
  i = 0;
  v15[0] = 0;
  v15[1] = 0;
  v15[2] = 0;
  v15[3] = 0;
  v15[4] = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v24 = 0;
  v23 = 6;
  v22 = 0;
  v21 = 15;
  v20 = 127;
  v19 = 0;
  v18 = 0;
  puts("\n--- update pic program");
  v17 = fopen("/mnt/card/pic16f1704_app.txt", "r");
  if ( v17 )
  {
    fseek(v17, 0, 0);
    memset(v16, 0, sizeof(v16));
    v19 = (v21 << 8) + v20 - ((v23 << 8) + v22) + 1;
    printf("pic_flash_length = %d\n", v19);
    for ( i = 0; i < v19; ++i )
    {
      fgets(v15, 1023, v17);
      v24 = strtoul(v15, 0, 16);
      v16[2 * i] = BYTE1(v24);
      v16[2 * i + 1] = v24;
    }
    fclose(v17);
    v18 = reset_PIC16F1704_pic(a1, a2);
    if ( v18 )
    {
      v18 = erase_PIC16F1704_app_flash(a1, a2);
      if ( v18 )
      {
        v18 = set_PIC16F1704_flash_point32_ter(a1, a2, 6u, 0);
        if ( v18 )
        {
          for ( i = 0; 4 * (v19 >> 5) > i; ++i )
          {
            v3 = (int *)&v16[16 * i];
            v4 = *v3;
            v5 = v3[1];
            v6 = v3[2];
            v7 = v3[3];
            v11 = v4;
            v12 = v5;
            v13 = v6;
            v14 = v7;
            printf("send pic program time: %d\n", i);
            for ( j = 0; j <= 0xF; ++j )
              printf("buf[%d] = 0x%02x\n", j, *((unsigned __int8 *)&v11 + j));
            putchar(10);
            send_data_to_PIC16F1704(a1, a2, (int)&v11);
            write_data_int32_to_PIC16F1704_flash(a1, a2);
          }
          v18 = reset_PIC16F1704_pic(a1, a2);
          if ( v18 )
          {
            return 1;
          }
          else
          {
            printf("!!! %s: reset pic error!\n\n", "PIC1704_update_pic_app_program");
            return 0;
          }
        }
        else
        {
          printf("!!! %s: set flash point32_ter error!\n\n", "PIC1704_update_pic_app_program");
          return 0;
        }
      }
      else
      {
        printf("!!! %s: erase flash error!\n\n", "PIC1704_update_pic_app_program");
        return 0;
      }
    }
    else
    {
      printf("!!! %s: reset pic error!\n\n", "PIC1704_update_pic_app_program");
      return 0;
    }
  }
  else
  {
    printf("\n%s: open pic16f1704_app.txt failed\n", "PIC1704_update_pic_app_program");
  }
  return v2;
}
// 14DCE: variable 'v2' is possibly undefined

//----- (00014DDC) --------------------------------------------------------
int __fastcall save_freq_PIC16F1704(char a1, char a2, unsigned __int16 a3)
{
  __int16 v3; // r2
  int v4; // r4
  int v10; // [sp+Ch] [bp+Ch]
  char v11; // [sp+10h] [bp+10h]
  char v12; // [sp+11h] [bp+11h]
  char v13; // [sp+12h] [bp+12h]
  char v14; // [sp+13h] [bp+13h]
  unsigned __int8 v15[4]; // [sp+14h] [bp+14h]
  char v16; // [sp+18h] [bp+18h]
  char v17; // [sp+19h] [bp+19h]
  __int16 v18; // [sp+1Ch] [bp+1Ch]
  char v19; // [sp+1Eh] [bp+1Eh]
  unsigned __int8 i; // [sp+1Fh] [bp+1Fh]

  v19 = 6;
  *(_WORD *)v15 = 255;
  v10 = 604416597;
  v3 = HIBYTE(a3) + 6;
  v18 = v3 + (unsigned __int8)a3 + 36;
  v16 = HIBYTE(v18);
  v17 = v3 + a3 + 36;
  v11 = HIBYTE(a3);
  v12 = a3;
  v13 = HIBYTE(v18);
  v14 = v17;
  pthread_mutex_lock(&i2c_mutex_0);
  for ( i = 0; i <= 7u; ++i )
    write_pic(a2, a1, *((_BYTE *)&v10 + i));
  usleep((__useconds_t)&unk_493E0);
  for ( i = 0; i <= 1u; ++i )
  {
    v4 = i;
    v15[v4] = read_pic();
  }
  pthread_mutex_unlock(&i2c_mutex_0);
  usleep(0x30D40u);
  if ( v15[0] == 36 && v15[1] == 1 )
  {
    printf("\n--- %s ok\n\n", "save_freq_PIC16F1704");
    return 1;
  }
  else
  {
    printf(
      "\n--- %s failed! read_back_data[0] = 0x%02x, read_back_data[1] = 0x%02x\n\n",
      "save_freq_PIC16F1704",
      v15[0],
      v15[1]);
    return 0;
  }
}
// 35AAC: using guessed type pthread_mutex_t i2c_mutex_0;

//----- (00014F38) --------------------------------------------------------
int __fastcall get_PIC16F1704_freq(char a1, char a2, unsigned __int16 *a3)
{
  int v3; // r4
  int v9; // [sp+20h] [bp+10h]
  char v10; // [sp+24h] [bp+14h]
  char v11; // [sp+25h] [bp+15h]
  int v12; // [sp+28h] [bp+18h]
  __int16 v13; // [sp+2Ch] [bp+1Ch]
  __int16 v14; // [sp+30h] [bp+20h]
  unsigned __int16 v15; // [sp+34h] [bp+24h]
  char v16; // [sp+36h] [bp+26h]
  unsigned __int8 i; // [sp+37h] [bp+27h]

  v16 = 4;
  v14 = 10496;
  v12 = 255;
  v13 = 0;
  v9 = 621062741;
  v15 = 41;
  v10 = 0;
  v11 = 41;
  pthread_mutex_lock(&i2c_mutex_0);
  for ( i = 0; i <= 5u; ++i )
    write_pic(a2, a1, *((_BYTE *)&v9 + i));
  usleep((__useconds_t)&unk_493E0);
  for ( i = 0; i <= 5u; ++i )
  {
    v3 = i;
    *((_BYTE *)&v12 + v3) = read_pic();
  }
  pthread_mutex_unlock(&i2c_mutex_0);
  usleep(0x30D40u);
  printf(
    "--- %s: read_back_data[0] = 0x%x, read_back_data[1] = 0x%x, read_back_data[2] = 0x%x, read_back_data[3] = 0x%x, read"
    "_back_data[4] = 0x%x, read_back_data[5] = 0x%x\n",
    "get_PIC16F1704_freq",
    (unsigned __int8)v12,
    BYTE1(v12),
    BYTE2(v12),
    HIBYTE(v12),
    (unsigned __int8)v13,
    HIBYTE(v13));
  if ( BYTE1(v12) == 37 && (unsigned __int8)v12 == 6 )
  {
    v15 = (unsigned __int8)v12 + BYTE1(v12) + BYTE2(v12) + HIBYTE(v12);
    if ( HIBYTE(v15) == (unsigned __int8)v13 && (unsigned __int8)v15 == HIBYTE(v13) )
    {
      *a3 = _byteswap_ushort(HIWORD(v12));
      printf("\n--- %s ok, freq = %d\n\n", "get_PIC16F1704_freq", *a3);
      return 1;
    }
    else
    {
      printf("\n--- %s failed! crc = 0x%04x\n\n", "get_PIC16F1704_freq", v15);
      return 0;
    }
  }
  else
  {
    printf("\n--- %s failed!\n\n", "get_PIC16F1704_freq");
    return 0;
  }
}
// 35AAC: using guessed type pthread_mutex_t i2c_mutex_0;

//----- (00015124) --------------------------------------------------------
int __fastcall set_temperature_offset_value(char a1, char a2, int a3)
{
  printf("\n--- %s\n", "set_temperature_offset_value");
  write_temperature_offset_PIC16F1704(a1, a2, a3);
  return usleep(0x186A0u);
}

//----- (00015168) --------------------------------------------------------
int __fastcall write_sensor_info_int32_to_pic(char a1, char a2)
{
  _BYTE v5[8]; // [sp+8h] [bp+8h] BYREF

  printf("\n--- %s\n", "write_sensor_info_int32_to_pic");
  v5[0] = byte_3368AC;
  v5[1] = 0;
  v5[2] = byte_3368AD;
  v5[3] = 0;
  v5[4] = byte_3368AE;
  v5[5] = 0;
  v5[6] = byte_3368D8 | 0x20;
  v5[7] = dword_3368DC;
  return set_temperature_offset_value(a1, a2, (int)v5);
}
// 3368AC: using guessed type char byte_3368AC;
// 3368AD: using guessed type char byte_3368AD;
// 3368AE: using guessed type char byte_3368AE;
// 3368D8: using guessed type char byte_3368D8;
// 3368DC: using guessed type int dword_3368DC;

//----- (0001521C) --------------------------------------------------------
int check_chain()
{
  unsigned int v2; // [sp+4h] [bp+4h] BYREF
  unsigned __int8 v3; // [sp+8h] [bp+8h]

  printf("--- %s\n", "check_chain");
  if ( platform_init() )
  {
    puts("platform init failed!");
    return -1;
  }
  else
  {
    get_system_capability(&v2);
    if ( v2 == 1 )
    {
      gChain = v3;
      chain_info[2 * v3] = v3;
      chain_info[2 * (unsigned __int8)gChain + 1] = 0;
      printf("gChain = %d\n", (unsigned __int8)gChain);
      return 0;
    }
    else
    {
      if ( v2 <= 1 )
        puts("no hash board inserted");
      else
        puts("test zhiju only support 1 plug");
      return -1;
    }
  }
}
// 35530: using guessed type char gChain;
// 3367D0: using guessed type _BYTE chain_info[8];

//----- (00015300) --------------------------------------------------------
int __fastcall fan_control(unsigned __int8 a1)
{
  if ( !fan_pwm_handle )
    fan_pwm_handle = pwm_init(0, 100);
  printf("--- %s\n", "fan_control");
  return pwm_set(fan_pwm_handle, a1);
}
// 235C50: using guessed type int fan_pwm_handle;

//----- (0001535C) --------------------------------------------------------
int set_PWM_according_to_temperature()
{
  if ( highest_temp[(unsigned __int8)gChain] < (int)(unsigned __int8)byte_3368B0 )
    return fan_control(0);
  if ( (int)highest_temp[(unsigned __int8)gChain] <= 49 )
    return fan_control(0x28u);
  if ( highest_temp[(unsigned __int8)gChain] < (int)(unsigned __int8)byte_3368B1 )
    return fan_control((60 * highest_temp[(unsigned __int8)gChain] - 3000) / ((unsigned __int8)byte_3368B1 - 50) + 40);
  return fan_control(0x64u);
}
// 35530: using guessed type char gChain;
// 235BC4: using guessed type _DWORD highest_temp[4];
// 3368B0: using guessed type char byte_3368B0;
// 3368B1: using guessed type char byte_3368B1;

//----- (00015430) --------------------------------------------------------
int znyq_set_iic(int a1, int a2, char a3, int a4, unsigned __int8 a5, ...)
{
  unsigned __int8 v7; // [sp+Fh] [bp+Fh] BYREF
  va_list va; // [sp+1Ch] [bp+1Ch] BYREF

  va_start(va, a5);
  if ( !a3 )
    return (unsigned __int8)iic_i2c_write_reg(a5, (int)va, 1u);
  iic_i2c_read_reg(a5, (int)&v7, 1u);
  return v7;
}

//----- (00015478) --------------------------------------------------------
unsigned int power_on()
{
  if ( access("/sys/class/gpio/gpio907", 0) == -1 )
  {
    system("echo 907 > /sys/class/gpio/export");
    system("echo out > /sys/class/gpio/gpio907/direction");
    puts("init gpio907");
  }
  system("echo 0 > /sys/class/gpio/gpio907/value");
  return sleep(1u);
}

//----- (000154CC) --------------------------------------------------------
unsigned int power_off()
{
  if ( access("/sys/class/gpio/gpio907", 0) == -1 )
  {
    system("echo 907 > /sys/class/gpio/export");
    system("echo out > /sys/class/gpio/gpio907/direction");
    puts("init gpio907");
  }
  system("echo 1 > /sys/class/gpio/gpio907/value");
  return sleep(1u);
}

//----- (00015520) --------------------------------------------------------
int power_check_protocal_type()
{
  unsigned __int8 v1; // [sp+Fh] [bp+7h]

  pthread_mutex_lock(&i2c_mutex_0);
  v1 = znyq_set_iic((unsigned __int8)power_iic_addr, (unsigned __int8)power_iic_no, 1, 1, 0, 0);
  if ( v1 == 245 )
  {
    printf("power protocal %02x, using package cmd\n", v1);
    power_protocal_type = 2;
  }
  else
  {
    printf("power protocal %02x, using simple cmd\n", v1);
    power_protocal_type = 1;
  }
  return pthread_mutex_unlock(&i2c_mutex_0);
}
// 3554C: using guessed type __int16 power_protocal_type;
// 3554E: using guessed type char power_iic_addr;
// 3554F: using guessed type char power_iic_no;
// 35AAC: using guessed type pthread_mutex_t i2c_mutex_0;

//----- (000155B8) --------------------------------------------------------
unsigned int power_init()
{
  puts("power init ... ");
  power_check_protocal_type();
  return power_on();
}

//----- (000155D4) --------------------------------------------------------
int __fastcall power_check_reply(unsigned __int8 *a1, unsigned __int8 *a2, unsigned __int8 a3)
{
  unsigned __int16 v7; // [sp+12h] [bp+12h]
  unsigned __int16 k; // [sp+14h] [bp+14h]
  unsigned __int16 i; // [sp+14h] [bp+14h]
  unsigned __int16 j; // [sp+14h] [bp+14h]
  unsigned __int16 v11; // [sp+16h] [bp+16h]

  v11 = 0;
  if ( *a1 == *a2 && a1[1] == a2[1] && a1[3] == a2[3] && a2[2] + 2 == a3 )
  {
    for ( i = 2; i < a3 - 2; ++i )
      v11 += a2[i];
    v7 = (a2[a3 - 1] << 8) + a2[a3 - 2];
    if ( v11 == v7 )
      return 1;
    printf("power reply crc error, crc %04x != crc_reply %04x:\n", v11, v7);
    for ( j = 0; j < (unsigned int)a3; ++j )
      printf("%02x ", a2[j]);
  }
  else
  {
    puts("power reply data error:");
    for ( k = 0; k < (unsigned int)a3; ++k )
      printf("%02x ", a2[k]);
  }
  putchar(10);
  return 0;
}

//----- (00015710) --------------------------------------------------------
bool __fastcall power_send_cmd(unsigned __int8 *a1, unsigned __int8 a2, unsigned __int8 *a3, unsigned __int8 a4)
{
  unsigned __int8 v9; // [sp+1Eh] [bp+16h]
  unsigned __int8 i; // [sp+1Fh] [bp+17h]
  unsigned __int8 j; // [sp+1Fh] [bp+17h]

  v9 = 0;
  pthread_mutex_lock(&i2c_mutex_0);
  while ( v9 <= 2u )
  {
    for ( i = 0; i < (unsigned int)a2; znyq_set_iic(16, 1, 0, 1, 0x11u, a1[i++]) )
      ;
    usleep((__useconds_t)&unk_7A120);
    for ( j = 0; j < (unsigned int)a4; ++j )
    {
      a3[j] = znyq_set_iic(16, 1, 1, 0, 0x11u, 0);
      printf("%s, reply_buf[%d]=%02x\n", "power_send_cmd", j, a3[j]);
    }
    if ( power_check_reply(a1, a3, a4) )
      break;
    printf("power send cmd 0x%02x failed, retry for %d times\n", a1[3], ++v9);
  }
  pthread_mutex_unlock(&i2c_mutex_0);
  return v9 <= 2u;
}
// 35AAC: using guessed type pthread_mutex_t i2c_mutex_0;

//----- (00015834) --------------------------------------------------------
int power_get_firmware_version()
{
  int result; // r0
  int v1; // [sp+0h] [bp+0h] BYREF
  int v2; // [sp+4h] [bp+4h]
  int v3; // [sp+8h] [bp+8h]
  int v4; // [sp+Ch] [bp+Ch]
  int v5; // [sp+10h] [bp+10h]
  int v6; // [sp+14h] [bp+14h]
  int v7; // [sp+18h] [bp+18h]
  int v8; // [sp+1Ch] [bp+1Ch]
  int v9; // [sp+20h] [bp+20h] BYREF
  __int16 v10; // [sp+24h] [bp+24h]

  v9 = 17082965;
  v10 = 5;
  v1 = 0;
  v2 = 0;
  v3 = 0;
  v4 = 0;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  result = power_send_cmd((unsigned __int8 *)&v9, 6u, (unsigned __int8 *)&v1, 8u);
  if ( result )
    return printf("power firmware version is %02x %02x\n", BYTE1(v2), (unsigned __int8)v2);
  return result;
}

//----- (000158B8) --------------------------------------------------------
int power_get_device_no()
{
  int result; // r0
  int v1; // [sp+0h] [bp+0h] BYREF
  int v2; // [sp+4h] [bp+4h]
  int v3; // [sp+8h] [bp+8h]
  int v4; // [sp+Ch] [bp+Ch]
  int v5; // [sp+10h] [bp+10h]
  int v6; // [sp+14h] [bp+14h]
  int v7; // [sp+18h] [bp+18h]
  int v8; // [sp+1Ch] [bp+1Ch]
  int v9; // [sp+20h] [bp+20h] BYREF
  __int16 v10; // [sp+24h] [bp+24h]

  v9 = 33860181;
  v10 = 6;
  v1 = 0;
  v2 = 0;
  v3 = 0;
  v4 = 0;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  result = power_send_cmd((unsigned __int8 *)&v9, 6u, (unsigned __int8 *)&v1, 8u);
  if ( result )
    return printf("power device no is %02x %02x\n", BYTE1(v2), (unsigned __int8)v2);
  return result;
}

//----- (0001593C) --------------------------------------------------------
int power_get_da_value()
{
  _BOOL4 v0; // r3
  int v2; // [sp+0h] [bp+0h] BYREF
  int v3; // [sp+4h] [bp+4h]
  int v4; // [sp+8h] [bp+8h]
  int v5; // [sp+Ch] [bp+Ch]
  int v6; // [sp+10h] [bp+10h]
  int v7; // [sp+14h] [bp+14h]
  int v8; // [sp+18h] [bp+18h]
  int v9; // [sp+1Ch] [bp+1Ch]
  int v10; // [sp+20h] [bp+20h] BYREF
  __int16 v11; // [sp+24h] [bp+24h]

  v10 = 50637397;
  v11 = 7;
  v2 = 0;
  v3 = 0;
  v4 = 0;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v0 = power_send_cmd((unsigned __int8 *)&v10, 6u, (unsigned __int8 *)&v2, 8u);
  if ( v0 )
  {
    printf("power get da value is %02x\n", (unsigned __int8)v3);
    return (unsigned __int8)v3;
  }
  return v0;
}

//----- (000159C0) --------------------------------------------------------
int power_get_da_value_simple()
{
  unsigned __int8 v1; // [sp+Fh] [bp+7h]

  pthread_mutex_lock(&i2c_mutex_0);
  v1 = znyq_set_iic((unsigned __int8)power_iic_addr, (unsigned __int8)power_iic_no, 1, 1, 2u, 0);
  printf("power da value is %d\n", v1);
  pthread_mutex_unlock(&i2c_mutex_0);
  return v1;
}
// 3554E: using guessed type char power_iic_addr;
// 3554F: using guessed type char power_iic_no;
// 35AAC: using guessed type pthread_mutex_t i2c_mutex_0;

//----- (00015A2C) --------------------------------------------------------
int power_get_adc_value()
{
  int result; // r0
  int v1; // [sp+0h] [bp+0h] BYREF
  int v2; // [sp+4h] [bp+4h]
  int v3; // [sp+8h] [bp+8h]
  int v4; // [sp+Ch] [bp+Ch]
  int v5; // [sp+10h] [bp+10h]
  int v6; // [sp+14h] [bp+14h]
  int v7; // [sp+18h] [bp+18h]
  int v8; // [sp+1Ch] [bp+1Ch]
  int v9; // [sp+20h] [bp+20h] BYREF
  __int16 v10; // [sp+24h] [bp+24h]

  v9 = 67414613;
  v10 = 8;
  v1 = 0;
  v2 = 0;
  v3 = 0;
  v4 = 0;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  result = power_send_cmd((unsigned __int8 *)&v9, 6u, (unsigned __int8 *)&v1, 8u);
  if ( result )
    return printf("power get adc value is %02x\n", (unsigned __int8)v2);
  return result;
}

//----- (00015AA8) --------------------------------------------------------
bool __fastcall power_set_da_value(unsigned __int8 a1)
{
  unsigned __int8 v2[32]; // [sp+24h] [bp+Ch] BYREF
  int v3; // [sp+44h] [bp+2Ch] BYREF
  int v4; // [sp+48h] [bp+30h]
  unsigned __int16 i; // [sp+4Ch] [bp+34h]
  __int16 v6; // [sp+4Eh] [bp+36h]

  v3 = -2096715179;
  memset(v2, 0, sizeof(v2));
  v6 = 0;
  v4 = a1;
  for ( i = 2; i <= 5u; ++i )
    v6 += *((unsigned __int8 *)&v3 + i);
  HIWORD(v4) = v6;
  printf(
    "%s, %02x, %02x, %02x, %02x, %02x, %02x, %02x, %02x\n",
    "power_set_da_value",
    (unsigned __int8)v3,
    BYTE1(v3),
    BYTE2(v3),
    HIBYTE(v3),
    (unsigned __int8)v4,
    BYTE1(v4),
    (unsigned __int8)v6,
    HIBYTE(v6));
  return power_send_cmd((unsigned __int8 *)&v3, 8u, v2, 8u);
}

//----- (00015BA8) --------------------------------------------------------
int __fastcall power_set_da_value_simple(unsigned __int8 a1)
{
  unsigned __int8 v3; // [sp+15h] [bp+Dh]

  pthread_mutex_lock(&i2c_mutex_0);
  usleep(0x186A0u);
  v3 = znyq_set_iic((unsigned __int8)power_iic_addr, (unsigned __int8)power_iic_no, 0, 1, 2u, a1);
  pthread_mutex_unlock(&i2c_mutex_0);
  return v3;
}
// 3554E: using guessed type char power_iic_addr;
// 3554F: using guessed type char power_iic_no;
// 35AAC: using guessed type pthread_mutex_t i2c_mutex_0;

//----- (00015C1C) --------------------------------------------------------
int __fastcall power_save_eeprom_data(char a1, int a2, unsigned __int8 a3)
{
  int v8; // [sp+Ch] [bp+Ch] BYREF
  int v9; // [sp+10h] [bp+10h]
  int v10; // [sp+14h] [bp+14h]
  int v11; // [sp+18h] [bp+18h]
  int v12; // [sp+1Ch] [bp+1Ch]
  int v13; // [sp+20h] [bp+20h]
  int v14; // [sp+24h] [bp+24h]
  int v15; // [sp+28h] [bp+28h]
  unsigned __int8 s[259]; // [sp+2Ch] [bp+2Ch] BYREF
  int v18; // [sp+130h] [bp+130h]
  unsigned __int16 i; // [sp+134h] [bp+134h]
  __int16 v20; // [sp+136h] [bp+136h]

  memset(s, 0, 0x100u);
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v20 = 0;
  v18 = a3 + 7;
  if ( a1 >= 0 && a3 <= 0x20u )
  {
    s[0] = 85;
    s[1] = -86;
    s[2] = a3 + 5;
    s[3] = -122;
    s[4] = a1;
    for ( i = 0; i < (unsigned int)a3; ++i )
      s[i + 5] = *(_BYTE *)(a2 + i);
    for ( i = 2; i < a3 + 5; ++i )
      v20 += s[i];
    s[v18 - 2] = v20;
    s[v18 - 1] = HIBYTE(v20);
    if ( !power_send_cmd(s, v18, (unsigned __int8 *)&v8, 8u) )
    {
      return 0;
    }
    else if ( BYTE1(v9) == 1 )
    {
      puts("save eeprom data success ");
      return 1;
    }
    else
    {
      puts("save eeprom data failed ");
      return 0;
    }
  }
  else
  {
    printf("invalid param addr 0x%02x, len %d\n", (unsigned __int8)a1, a3);
    return 0;
  }
}

//----- (00015DE0) --------------------------------------------------------
int __fastcall power_read_eeprom_data(char a1, int a2, unsigned __int8 a3)
{
  unsigned __int8 s[256]; // [sp+8h] [bp+8h] BYREF
  int v9; // [sp+108h] [bp+108h] BYREF
  int v10; // [sp+10Ch] [bp+10Ch]
  unsigned __int16 i; // [sp+114h] [bp+114h]
  __int16 v13; // [sp+116h] [bp+116h]

  v9 = 101100117;
  v10 = 0;
  memset(s, 0, sizeof(s));
  v13 = 0;
  if ( a1 >= 0 && a3 <= 0x20u )
  {
    LOBYTE(v10) = a1;
    BYTE1(v10) = a3;
    for ( i = 2; i <= 5u; ++i )
      v13 += *((unsigned __int8 *)&v9 + i);
    HIWORD(v10) = v13;
    if ( !power_send_cmd((unsigned __int8 *)&v9, 8u, s, a3 + 7) )
    {
      return 0;
    }
    else
    {
      printf("read eeprom data:");
      for ( i = 0; i < (unsigned int)a3; ++i )
      {
        *(_BYTE *)(a2 + i) = s[i + 5];
        printf("%02x ", *(unsigned __int8 *)(a2 + i));
      }
      putchar(10);
      return 1;
    }
  }
  else
  {
    printf("invalid param addr 0x%02x, len %d\n", (unsigned __int8)a1, a3);
    return 0;
  }
}

//----- (00015F4C) --------------------------------------------------------
bool power_is_support_cmd_package()
{
  return power_protocal_type == 2;
}
// 3554C: using guessed type __int16 power_protocal_type;

//----- (00015F6C) --------------------------------------------------------
_BYTE *__fastcall power_get_voltage(_BYTE *a1)
{
  char da_value; // r0

  if ( power_is_support_cmd_package() )
    da_value = power_get_da_value();
  else
    da_value = power_get_da_value_simple();
  *a1 = da_value;
  return a1;
}

//----- (00015FA4) --------------------------------------------------------
int __fastcall power_set_voltage(unsigned __int8 a1)
{
  int v1; // r3

  if ( power_is_support_cmd_package() )
    power_set_da_value(a1);
  else
    power_set_da_value_simple(a1);
  return v1;
}
// 15FCA: variable 'v1' is possibly undefined

//----- (00015FD8) --------------------------------------------------------
unsigned int __fastcall sph_bswap32(int a1)
{
  int v1; // t2

  v1 = __ROR4__(a1, 16);
  return ((v1 & 0xFF00FF) << 8) | ((v1 & 0xFF00FF00) >> 8);
}

//----- (0001600C) --------------------------------------------------------
__int64 __fastcall sph_bswap64(unsigned int a1, unsigned int a2)
{
  int v2; // r0
  int v3; // r1
  __int64 v4; // r2
  unsigned __int64 v6; // [sp+18h] [bp+18h]

  v6 = __PAIR64__(a1, a2);
  v2 = ((__int64)(v6 & 0xFFFF0000FFFF0000LL) >> 16) | ((_DWORD)v6 << 16);
  v3 = ((unsigned int)((v6 & 0xFFFF0000FFFF0000LL) >> 32) >> 16) | ((__int64)(v6 & 0xFFFF0000FFFFLL) >> 16);
  LODWORD(v4) = ((v2 & 0xFF00FF) << 8) | ((v2 & 0xFF00FF00) >> 8) | ((v3 & 0xFF00FF00) << 24);
  HIDWORD(v4) = ((v3 & 0xFF00FF) << 8) | ((v2 & 0xFF00FFu) >> 24) | ((v3 & 0xFF00FF00) >> 8);
  return v4;
}

//----- (000160E8) --------------------------------------------------------
_BYTE *__fastcall sph_enc32be(_BYTE *result, int a2)
{
  *result = HIBYTE(a2);
  result[1] = BYTE2(a2);
  result[2] = BYTE1(a2);
  result[3] = a2;
  return result;
}

//----- (00016128) --------------------------------------------------------
unsigned int __fastcall sph_enc32be_aligned(unsigned int *a1, int a2)
{
  unsigned int result; // r0

  result = sph_bswap32(a2);
  *a1 = result;
  return result;
}

//----- (00016148) --------------------------------------------------------
unsigned int __fastcall sph_dec32be_aligned(int *a1)
{
  return sph_bswap32(*a1);
}

//----- (00016168) --------------------------------------------------------
int __fastcall sph_enc64be(_BYTE *a1, int a2, int a3, int a4)
{
  *a1 = HIBYTE(a4);
  a1[1] = BYTE2(a4);
  a1[2] = BYTE1(a4);
  a1[3] = a4;
  a1[4] = HIBYTE(a3);
  a1[5] = BYTE2(a3);
  a1[6] = BYTE1(a3);
  a1[7] = a3;
  return a4;
}

//----- (00016224) --------------------------------------------------------
int __fastcall sph_enc64be_aligned(__int64 *a1, int a2, unsigned int a3, unsigned int a4)
{
  __int64 v4; // r0

  v4 = sph_bswap64(a3, a4);
  *a1 = v4;
  return v4;
}

//----- (0001624C) --------------------------------------------------------
__int64 __fastcall sph_dec64be_aligned(unsigned int *a1)
{
  return sph_bswap64(*a1, a1[1]);
}

//----- (00016274) --------------------------------------------------------
void *__fastcall blake32_init(_DWORD *a1, const void *a2, const void *a3)
{
  void *result; // r0

  memcpy(a1 + 17, a2, 0x20u);
  result = memcpy(a1 + 25, a3, 0x10u);
  a1[30] = 0;
  a1[29] = a1[30];
  a1[16] = 0;
  return result;
}

//----- (000162B8) --------------------------------------------------------
unsigned int __fastcall blake32(unsigned int result, char *a2, size_t a3)
{
  size_t n; // [sp+4h] [bp+4h]
  char *src; // [sp+8h] [bp+8h]
  _DWORD *v5; // [sp+Ch] [bp+Ch]
  unsigned int v6; // [sp+18h] [bp+18h]
  unsigned int v7; // [sp+1Ch] [bp+1Ch]
  unsigned int v8; // [sp+20h] [bp+20h]
  unsigned int v9; // [sp+24h] [bp+24h]
  unsigned int v10; // [sp+28h] [bp+28h]
  unsigned int v11; // [sp+2Ch] [bp+2Ch]
  unsigned int v12; // [sp+30h] [bp+30h]
  unsigned int v13; // [sp+34h] [bp+34h]
  unsigned int v14; // [sp+38h] [bp+38h]
  unsigned int v15; // [sp+3Ch] [bp+3Ch]
  unsigned int v16; // [sp+40h] [bp+40h]
  unsigned int v17; // [sp+44h] [bp+44h]
  unsigned int v18; // [sp+48h] [bp+48h]
  unsigned int v19; // [sp+4Ch] [bp+4Ch]
  unsigned int v20; // [sp+50h] [bp+50h]
  int v21; // [sp+54h] [bp+54h]
  int v22; // [sp+54h] [bp+54h]
  int v23; // [sp+54h] [bp+54h]
  int v24; // [sp+54h] [bp+54h]
  int v25; // [sp+54h] [bp+54h]
  int v26; // [sp+54h] [bp+54h]
  int v27; // [sp+54h] [bp+54h]
  int v28; // [sp+54h] [bp+54h]
  int v29; // [sp+54h] [bp+54h]
  int v30; // [sp+54h] [bp+54h]
  int v31; // [sp+54h] [bp+54h]
  int v32; // [sp+54h] [bp+54h]
  int v33; // [sp+54h] [bp+54h]
  int v34; // [sp+54h] [bp+54h]
  int v35; // [sp+54h] [bp+54h]
  int v36; // [sp+54h] [bp+54h]
  int v37; // [sp+54h] [bp+54h]
  int v38; // [sp+54h] [bp+54h]
  int v39; // [sp+54h] [bp+54h]
  int v40; // [sp+54h] [bp+54h]
  int v41; // [sp+54h] [bp+54h]
  int v42; // [sp+54h] [bp+54h]
  int v43; // [sp+54h] [bp+54h]
  int v44; // [sp+54h] [bp+54h]
  int v45; // [sp+54h] [bp+54h]
  int v46; // [sp+54h] [bp+54h]
  int v47; // [sp+54h] [bp+54h]
  int v48; // [sp+54h] [bp+54h]
  int v49; // [sp+54h] [bp+54h]
  int v50; // [sp+54h] [bp+54h]
  int v51; // [sp+54h] [bp+54h]
  int v52; // [sp+54h] [bp+54h]
  int v53; // [sp+54h] [bp+54h]
  int v54; // [sp+54h] [bp+54h]
  int v55; // [sp+54h] [bp+54h]
  int v56; // [sp+54h] [bp+54h]
  int v57; // [sp+54h] [bp+54h]
  int v58; // [sp+54h] [bp+54h]
  int v59; // [sp+54h] [bp+54h]
  int v60; // [sp+54h] [bp+54h]
  int v61; // [sp+54h] [bp+54h]
  int v62; // [sp+54h] [bp+54h]
  int v63; // [sp+54h] [bp+54h]
  int v64; // [sp+54h] [bp+54h]
  int v65; // [sp+54h] [bp+54h]
  int v66; // [sp+54h] [bp+54h]
  int v67; // [sp+54h] [bp+54h]
  int v68; // [sp+54h] [bp+54h]
  int v69; // [sp+54h] [bp+54h]
  int v70; // [sp+54h] [bp+54h]
  int v71; // [sp+54h] [bp+54h]
  int v72; // [sp+54h] [bp+54h]
  int v73; // [sp+54h] [bp+54h]
  int v74; // [sp+54h] [bp+54h]
  int v75; // [sp+54h] [bp+54h]
  int v76; // [sp+54h] [bp+54h]
  int v77; // [sp+58h] [bp+58h]
  int v78; // [sp+58h] [bp+58h]
  int v79; // [sp+58h] [bp+58h]
  int v80; // [sp+58h] [bp+58h]
  int v81; // [sp+58h] [bp+58h]
  int v82; // [sp+58h] [bp+58h]
  int v83; // [sp+58h] [bp+58h]
  int v84; // [sp+58h] [bp+58h]
  int v85; // [sp+58h] [bp+58h]
  int v86; // [sp+58h] [bp+58h]
  int v87; // [sp+58h] [bp+58h]
  int v88; // [sp+58h] [bp+58h]
  int v89; // [sp+58h] [bp+58h]
  int v90; // [sp+58h] [bp+58h]
  int v91; // [sp+58h] [bp+58h]
  int v92; // [sp+58h] [bp+58h]
  int v93; // [sp+58h] [bp+58h]
  int v94; // [sp+58h] [bp+58h]
  int v95; // [sp+58h] [bp+58h]
  int v96; // [sp+58h] [bp+58h]
  int v97; // [sp+58h] [bp+58h]
  int v98; // [sp+58h] [bp+58h]
  int v99; // [sp+58h] [bp+58h]
  int v100; // [sp+58h] [bp+58h]
  int v101; // [sp+58h] [bp+58h]
  int v102; // [sp+58h] [bp+58h]
  int v103; // [sp+58h] [bp+58h]
  int v104; // [sp+58h] [bp+58h]
  int v105; // [sp+58h] [bp+58h]
  int v106; // [sp+58h] [bp+58h]
  int v107; // [sp+58h] [bp+58h]
  int v108; // [sp+58h] [bp+58h]
  int v109; // [sp+58h] [bp+58h]
  int v110; // [sp+58h] [bp+58h]
  int v111; // [sp+58h] [bp+58h]
  int v112; // [sp+58h] [bp+58h]
  int v113; // [sp+58h] [bp+58h]
  int v114; // [sp+58h] [bp+58h]
  int v115; // [sp+58h] [bp+58h]
  int v116; // [sp+58h] [bp+58h]
  int v117; // [sp+58h] [bp+58h]
  int v118; // [sp+58h] [bp+58h]
  int v119; // [sp+58h] [bp+58h]
  int v120; // [sp+58h] [bp+58h]
  int v121; // [sp+58h] [bp+58h]
  int v122; // [sp+58h] [bp+58h]
  int v123; // [sp+58h] [bp+58h]
  int v124; // [sp+58h] [bp+58h]
  int v125; // [sp+58h] [bp+58h]
  int v126; // [sp+58h] [bp+58h]
  int v127; // [sp+58h] [bp+58h]
  int v128; // [sp+58h] [bp+58h]
  int v129; // [sp+58h] [bp+58h]
  int v130; // [sp+58h] [bp+58h]
  int v131; // [sp+58h] [bp+58h]
  int v132; // [sp+58h] [bp+58h]
  int v133; // [sp+5Ch] [bp+5Ch]
  int v134; // [sp+5Ch] [bp+5Ch]
  int v135; // [sp+5Ch] [bp+5Ch]
  int v136; // [sp+5Ch] [bp+5Ch]
  int v137; // [sp+5Ch] [bp+5Ch]
  int v138; // [sp+5Ch] [bp+5Ch]
  int v139; // [sp+5Ch] [bp+5Ch]
  int v140; // [sp+5Ch] [bp+5Ch]
  int v141; // [sp+5Ch] [bp+5Ch]
  int v142; // [sp+5Ch] [bp+5Ch]
  int v143; // [sp+5Ch] [bp+5Ch]
  int v144; // [sp+5Ch] [bp+5Ch]
  int v145; // [sp+5Ch] [bp+5Ch]
  int v146; // [sp+5Ch] [bp+5Ch]
  int v147; // [sp+5Ch] [bp+5Ch]
  int v148; // [sp+5Ch] [bp+5Ch]
  int v149; // [sp+5Ch] [bp+5Ch]
  int v150; // [sp+5Ch] [bp+5Ch]
  int v151; // [sp+5Ch] [bp+5Ch]
  int v152; // [sp+5Ch] [bp+5Ch]
  int v153; // [sp+5Ch] [bp+5Ch]
  int v154; // [sp+5Ch] [bp+5Ch]
  int v155; // [sp+5Ch] [bp+5Ch]
  int v156; // [sp+5Ch] [bp+5Ch]
  int v157; // [sp+5Ch] [bp+5Ch]
  int v158; // [sp+5Ch] [bp+5Ch]
  int v159; // [sp+5Ch] [bp+5Ch]
  int v160; // [sp+5Ch] [bp+5Ch]
  int v161; // [sp+5Ch] [bp+5Ch]
  int v162; // [sp+5Ch] [bp+5Ch]
  int v163; // [sp+5Ch] [bp+5Ch]
  int v164; // [sp+5Ch] [bp+5Ch]
  int v165; // [sp+5Ch] [bp+5Ch]
  int v166; // [sp+5Ch] [bp+5Ch]
  int v167; // [sp+5Ch] [bp+5Ch]
  int v168; // [sp+5Ch] [bp+5Ch]
  int v169; // [sp+5Ch] [bp+5Ch]
  int v170; // [sp+5Ch] [bp+5Ch]
  int v171; // [sp+5Ch] [bp+5Ch]
  int v172; // [sp+5Ch] [bp+5Ch]
  int v173; // [sp+5Ch] [bp+5Ch]
  int v174; // [sp+5Ch] [bp+5Ch]
  int v175; // [sp+5Ch] [bp+5Ch]
  int v176; // [sp+5Ch] [bp+5Ch]
  int v177; // [sp+5Ch] [bp+5Ch]
  int v178; // [sp+5Ch] [bp+5Ch]
  int v179; // [sp+5Ch] [bp+5Ch]
  int v180; // [sp+5Ch] [bp+5Ch]
  int v181; // [sp+5Ch] [bp+5Ch]
  int v182; // [sp+5Ch] [bp+5Ch]
  int v183; // [sp+5Ch] [bp+5Ch]
  int v184; // [sp+5Ch] [bp+5Ch]
  int v185; // [sp+5Ch] [bp+5Ch]
  int v186; // [sp+5Ch] [bp+5Ch]
  int v187; // [sp+5Ch] [bp+5Ch]
  int v188; // [sp+5Ch] [bp+5Ch]
  int v189; // [sp+60h] [bp+60h]
  int v190; // [sp+60h] [bp+60h]
  int v191; // [sp+60h] [bp+60h]
  int v192; // [sp+60h] [bp+60h]
  int v193; // [sp+60h] [bp+60h]
  int v194; // [sp+60h] [bp+60h]
  int v195; // [sp+60h] [bp+60h]
  int v196; // [sp+60h] [bp+60h]
  int v197; // [sp+60h] [bp+60h]
  int v198; // [sp+60h] [bp+60h]
  int v199; // [sp+60h] [bp+60h]
  int v200; // [sp+60h] [bp+60h]
  int v201; // [sp+60h] [bp+60h]
  int v202; // [sp+60h] [bp+60h]
  int v203; // [sp+60h] [bp+60h]
  int v204; // [sp+60h] [bp+60h]
  int v205; // [sp+60h] [bp+60h]
  int v206; // [sp+60h] [bp+60h]
  int v207; // [sp+60h] [bp+60h]
  int v208; // [sp+60h] [bp+60h]
  int v209; // [sp+60h] [bp+60h]
  int v210; // [sp+60h] [bp+60h]
  int v211; // [sp+60h] [bp+60h]
  int v212; // [sp+60h] [bp+60h]
  int v213; // [sp+60h] [bp+60h]
  int v214; // [sp+60h] [bp+60h]
  int v215; // [sp+60h] [bp+60h]
  int v216; // [sp+60h] [bp+60h]
  int v217; // [sp+60h] [bp+60h]
  int v218; // [sp+60h] [bp+60h]
  int v219; // [sp+60h] [bp+60h]
  int v220; // [sp+60h] [bp+60h]
  int v221; // [sp+60h] [bp+60h]
  int v222; // [sp+60h] [bp+60h]
  int v223; // [sp+60h] [bp+60h]
  int v224; // [sp+60h] [bp+60h]
  int v225; // [sp+60h] [bp+60h]
  int v226; // [sp+60h] [bp+60h]
  int v227; // [sp+60h] [bp+60h]
  int v228; // [sp+60h] [bp+60h]
  int v229; // [sp+60h] [bp+60h]
  int v230; // [sp+60h] [bp+60h]
  int v231; // [sp+60h] [bp+60h]
  int v232; // [sp+60h] [bp+60h]
  int v233; // [sp+60h] [bp+60h]
  int v234; // [sp+60h] [bp+60h]
  int v235; // [sp+60h] [bp+60h]
  int v236; // [sp+60h] [bp+60h]
  int v237; // [sp+60h] [bp+60h]
  int v238; // [sp+60h] [bp+60h]
  int v239; // [sp+60h] [bp+60h]
  int v240; // [sp+60h] [bp+60h]
  int v241; // [sp+60h] [bp+60h]
  int v242; // [sp+60h] [bp+60h]
  int v243; // [sp+60h] [bp+60h]
  int v244; // [sp+60h] [bp+60h]
  int v245; // [sp+64h] [bp+64h]
  int v246; // [sp+64h] [bp+64h]
  int v247; // [sp+64h] [bp+64h]
  int v248; // [sp+64h] [bp+64h]
  int v249; // [sp+64h] [bp+64h]
  int v250; // [sp+64h] [bp+64h]
  int v251; // [sp+64h] [bp+64h]
  int v252; // [sp+64h] [bp+64h]
  int v253; // [sp+64h] [bp+64h]
  int v254; // [sp+64h] [bp+64h]
  int v255; // [sp+64h] [bp+64h]
  int v256; // [sp+64h] [bp+64h]
  int v257; // [sp+64h] [bp+64h]
  int v258; // [sp+64h] [bp+64h]
  int v259; // [sp+64h] [bp+64h]
  int v260; // [sp+64h] [bp+64h]
  int v261; // [sp+64h] [bp+64h]
  int v262; // [sp+64h] [bp+64h]
  int v263; // [sp+64h] [bp+64h]
  int v264; // [sp+64h] [bp+64h]
  int v265; // [sp+64h] [bp+64h]
  int v266; // [sp+64h] [bp+64h]
  int v267; // [sp+64h] [bp+64h]
  int v268; // [sp+64h] [bp+64h]
  int v269; // [sp+64h] [bp+64h]
  int v270; // [sp+64h] [bp+64h]
  int v271; // [sp+64h] [bp+64h]
  int v272; // [sp+64h] [bp+64h]
  int v273; // [sp+64h] [bp+64h]
  int v274; // [sp+64h] [bp+64h]
  int v275; // [sp+64h] [bp+64h]
  int v276; // [sp+64h] [bp+64h]
  int v277; // [sp+64h] [bp+64h]
  int v278; // [sp+64h] [bp+64h]
  int v279; // [sp+64h] [bp+64h]
  int v280; // [sp+64h] [bp+64h]
  int v281; // [sp+64h] [bp+64h]
  int v282; // [sp+64h] [bp+64h]
  int v283; // [sp+64h] [bp+64h]
  int v284; // [sp+64h] [bp+64h]
  int v285; // [sp+64h] [bp+64h]
  int v286; // [sp+64h] [bp+64h]
  int v287; // [sp+64h] [bp+64h]
  int v288; // [sp+64h] [bp+64h]
  int v289; // [sp+64h] [bp+64h]
  int v290; // [sp+64h] [bp+64h]
  int v291; // [sp+64h] [bp+64h]
  int v292; // [sp+64h] [bp+64h]
  int v293; // [sp+64h] [bp+64h]
  int v294; // [sp+64h] [bp+64h]
  int v295; // [sp+64h] [bp+64h]
  int v296; // [sp+64h] [bp+64h]
  int v297; // [sp+64h] [bp+64h]
  int v298; // [sp+64h] [bp+64h]
  int v299; // [sp+64h] [bp+64h]
  int v300; // [sp+64h] [bp+64h]
  int v301; // [sp+68h] [bp+68h]
  int v302; // [sp+68h] [bp+68h]
  int v303; // [sp+68h] [bp+68h]
  int v304; // [sp+68h] [bp+68h]
  int v305; // [sp+68h] [bp+68h]
  int v306; // [sp+68h] [bp+68h]
  int v307; // [sp+68h] [bp+68h]
  int v308; // [sp+68h] [bp+68h]
  int v309; // [sp+68h] [bp+68h]
  int v310; // [sp+68h] [bp+68h]
  int v311; // [sp+68h] [bp+68h]
  int v312; // [sp+68h] [bp+68h]
  int v313; // [sp+68h] [bp+68h]
  int v314; // [sp+68h] [bp+68h]
  int v315; // [sp+68h] [bp+68h]
  int v316; // [sp+68h] [bp+68h]
  int v317; // [sp+68h] [bp+68h]
  int v318; // [sp+68h] [bp+68h]
  int v319; // [sp+68h] [bp+68h]
  int v320; // [sp+68h] [bp+68h]
  int v321; // [sp+68h] [bp+68h]
  int v322; // [sp+68h] [bp+68h]
  int v323; // [sp+68h] [bp+68h]
  int v324; // [sp+68h] [bp+68h]
  int v325; // [sp+68h] [bp+68h]
  int v326; // [sp+68h] [bp+68h]
  int v327; // [sp+68h] [bp+68h]
  int v328; // [sp+68h] [bp+68h]
  int v329; // [sp+68h] [bp+68h]
  int v330; // [sp+68h] [bp+68h]
  int v331; // [sp+68h] [bp+68h]
  int v332; // [sp+68h] [bp+68h]
  int v333; // [sp+68h] [bp+68h]
  int v334; // [sp+68h] [bp+68h]
  int v335; // [sp+68h] [bp+68h]
  int v336; // [sp+68h] [bp+68h]
  int v337; // [sp+68h] [bp+68h]
  int v338; // [sp+68h] [bp+68h]
  int v339; // [sp+68h] [bp+68h]
  int v340; // [sp+68h] [bp+68h]
  int v341; // [sp+68h] [bp+68h]
  int v342; // [sp+68h] [bp+68h]
  int v343; // [sp+68h] [bp+68h]
  int v344; // [sp+68h] [bp+68h]
  int v345; // [sp+68h] [bp+68h]
  int v346; // [sp+68h] [bp+68h]
  int v347; // [sp+68h] [bp+68h]
  int v348; // [sp+68h] [bp+68h]
  int v349; // [sp+68h] [bp+68h]
  int v350; // [sp+68h] [bp+68h]
  int v351; // [sp+68h] [bp+68h]
  int v352; // [sp+68h] [bp+68h]
  int v353; // [sp+68h] [bp+68h]
  int v354; // [sp+68h] [bp+68h]
  int v355; // [sp+68h] [bp+68h]
  int v356; // [sp+68h] [bp+68h]
  int v357; // [sp+6Ch] [bp+6Ch]
  int v358; // [sp+6Ch] [bp+6Ch]
  int v359; // [sp+6Ch] [bp+6Ch]
  int v360; // [sp+6Ch] [bp+6Ch]
  int v361; // [sp+6Ch] [bp+6Ch]
  int v362; // [sp+6Ch] [bp+6Ch]
  int v363; // [sp+6Ch] [bp+6Ch]
  int v364; // [sp+6Ch] [bp+6Ch]
  int v365; // [sp+6Ch] [bp+6Ch]
  int v366; // [sp+6Ch] [bp+6Ch]
  int v367; // [sp+6Ch] [bp+6Ch]
  int v368; // [sp+6Ch] [bp+6Ch]
  int v369; // [sp+6Ch] [bp+6Ch]
  int v370; // [sp+6Ch] [bp+6Ch]
  int v371; // [sp+6Ch] [bp+6Ch]
  int v372; // [sp+6Ch] [bp+6Ch]
  int v373; // [sp+6Ch] [bp+6Ch]
  int v374; // [sp+6Ch] [bp+6Ch]
  int v375; // [sp+6Ch] [bp+6Ch]
  int v376; // [sp+6Ch] [bp+6Ch]
  int v377; // [sp+6Ch] [bp+6Ch]
  int v378; // [sp+6Ch] [bp+6Ch]
  int v379; // [sp+6Ch] [bp+6Ch]
  int v380; // [sp+6Ch] [bp+6Ch]
  int v381; // [sp+6Ch] [bp+6Ch]
  int v382; // [sp+6Ch] [bp+6Ch]
  int v383; // [sp+6Ch] [bp+6Ch]
  int v384; // [sp+6Ch] [bp+6Ch]
  int v385; // [sp+6Ch] [bp+6Ch]
  int v386; // [sp+6Ch] [bp+6Ch]
  int v387; // [sp+6Ch] [bp+6Ch]
  int v388; // [sp+6Ch] [bp+6Ch]
  int v389; // [sp+6Ch] [bp+6Ch]
  int v390; // [sp+6Ch] [bp+6Ch]
  int v391; // [sp+6Ch] [bp+6Ch]
  int v392; // [sp+6Ch] [bp+6Ch]
  int v393; // [sp+6Ch] [bp+6Ch]
  int v394; // [sp+6Ch] [bp+6Ch]
  int v395; // [sp+6Ch] [bp+6Ch]
  int v396; // [sp+6Ch] [bp+6Ch]
  int v397; // [sp+6Ch] [bp+6Ch]
  int v398; // [sp+6Ch] [bp+6Ch]
  int v399; // [sp+6Ch] [bp+6Ch]
  int v400; // [sp+6Ch] [bp+6Ch]
  int v401; // [sp+6Ch] [bp+6Ch]
  int v402; // [sp+6Ch] [bp+6Ch]
  int v403; // [sp+6Ch] [bp+6Ch]
  int v404; // [sp+6Ch] [bp+6Ch]
  int v405; // [sp+6Ch] [bp+6Ch]
  int v406; // [sp+6Ch] [bp+6Ch]
  int v407; // [sp+6Ch] [bp+6Ch]
  int v408; // [sp+6Ch] [bp+6Ch]
  int v409; // [sp+6Ch] [bp+6Ch]
  int v410; // [sp+6Ch] [bp+6Ch]
  int v411; // [sp+6Ch] [bp+6Ch]
  int v412; // [sp+6Ch] [bp+6Ch]
  int v413; // [sp+70h] [bp+70h]
  int v414; // [sp+70h] [bp+70h]
  int v415; // [sp+70h] [bp+70h]
  int v416; // [sp+70h] [bp+70h]
  int v417; // [sp+70h] [bp+70h]
  int v418; // [sp+70h] [bp+70h]
  int v419; // [sp+70h] [bp+70h]
  int v420; // [sp+70h] [bp+70h]
  int v421; // [sp+70h] [bp+70h]
  int v422; // [sp+70h] [bp+70h]
  int v423; // [sp+70h] [bp+70h]
  int v424; // [sp+70h] [bp+70h]
  int v425; // [sp+70h] [bp+70h]
  int v426; // [sp+70h] [bp+70h]
  int v427; // [sp+70h] [bp+70h]
  int v428; // [sp+70h] [bp+70h]
  int v429; // [sp+70h] [bp+70h]
  int v430; // [sp+70h] [bp+70h]
  int v431; // [sp+70h] [bp+70h]
  int v432; // [sp+70h] [bp+70h]
  int v433; // [sp+70h] [bp+70h]
  int v434; // [sp+70h] [bp+70h]
  int v435; // [sp+70h] [bp+70h]
  int v436; // [sp+70h] [bp+70h]
  int v437; // [sp+70h] [bp+70h]
  int v438; // [sp+70h] [bp+70h]
  int v439; // [sp+70h] [bp+70h]
  int v440; // [sp+70h] [bp+70h]
  int v441; // [sp+70h] [bp+70h]
  int v442; // [sp+70h] [bp+70h]
  int v443; // [sp+70h] [bp+70h]
  int v444; // [sp+70h] [bp+70h]
  int v445; // [sp+70h] [bp+70h]
  int v446; // [sp+70h] [bp+70h]
  int v447; // [sp+70h] [bp+70h]
  int v448; // [sp+70h] [bp+70h]
  int v449; // [sp+70h] [bp+70h]
  int v450; // [sp+70h] [bp+70h]
  int v451; // [sp+70h] [bp+70h]
  int v452; // [sp+70h] [bp+70h]
  int v453; // [sp+70h] [bp+70h]
  int v454; // [sp+70h] [bp+70h]
  int v455; // [sp+70h] [bp+70h]
  int v456; // [sp+70h] [bp+70h]
  int v457; // [sp+70h] [bp+70h]
  int v458; // [sp+70h] [bp+70h]
  int v459; // [sp+70h] [bp+70h]
  int v460; // [sp+70h] [bp+70h]
  int v461; // [sp+70h] [bp+70h]
  int v462; // [sp+70h] [bp+70h]
  int v463; // [sp+70h] [bp+70h]
  int v464; // [sp+70h] [bp+70h]
  int v465; // [sp+70h] [bp+70h]
  int v466; // [sp+70h] [bp+70h]
  int v467; // [sp+70h] [bp+70h]
  int v468; // [sp+70h] [bp+70h]
  int v469; // [sp+74h] [bp+74h]
  int v470; // [sp+74h] [bp+74h]
  int v471; // [sp+74h] [bp+74h]
  int v472; // [sp+74h] [bp+74h]
  int v473; // [sp+74h] [bp+74h]
  int v474; // [sp+74h] [bp+74h]
  int v475; // [sp+74h] [bp+74h]
  int v476; // [sp+74h] [bp+74h]
  int v477; // [sp+74h] [bp+74h]
  int v478; // [sp+74h] [bp+74h]
  int v479; // [sp+74h] [bp+74h]
  int v480; // [sp+74h] [bp+74h]
  int v481; // [sp+74h] [bp+74h]
  int v482; // [sp+74h] [bp+74h]
  int v483; // [sp+74h] [bp+74h]
  int v484; // [sp+74h] [bp+74h]
  int v485; // [sp+74h] [bp+74h]
  int v486; // [sp+74h] [bp+74h]
  int v487; // [sp+74h] [bp+74h]
  int v488; // [sp+74h] [bp+74h]
  int v489; // [sp+74h] [bp+74h]
  int v490; // [sp+74h] [bp+74h]
  int v491; // [sp+74h] [bp+74h]
  int v492; // [sp+74h] [bp+74h]
  int v493; // [sp+74h] [bp+74h]
  int v494; // [sp+74h] [bp+74h]
  int v495; // [sp+74h] [bp+74h]
  int v496; // [sp+74h] [bp+74h]
  int v497; // [sp+74h] [bp+74h]
  int v498; // [sp+74h] [bp+74h]
  int v499; // [sp+74h] [bp+74h]
  int v500; // [sp+74h] [bp+74h]
  int v501; // [sp+74h] [bp+74h]
  int v502; // [sp+74h] [bp+74h]
  int v503; // [sp+74h] [bp+74h]
  int v504; // [sp+74h] [bp+74h]
  int v505; // [sp+74h] [bp+74h]
  int v506; // [sp+74h] [bp+74h]
  int v507; // [sp+74h] [bp+74h]
  int v508; // [sp+74h] [bp+74h]
  int v509; // [sp+74h] [bp+74h]
  int v510; // [sp+74h] [bp+74h]
  int v511; // [sp+74h] [bp+74h]
  int v512; // [sp+74h] [bp+74h]
  int v513; // [sp+74h] [bp+74h]
  int v514; // [sp+74h] [bp+74h]
  int v515; // [sp+74h] [bp+74h]
  int v516; // [sp+74h] [bp+74h]
  int v517; // [sp+74h] [bp+74h]
  int v518; // [sp+74h] [bp+74h]
  int v519; // [sp+74h] [bp+74h]
  int v520; // [sp+74h] [bp+74h]
  int v521; // [sp+74h] [bp+74h]
  int v522; // [sp+74h] [bp+74h]
  int v523; // [sp+74h] [bp+74h]
  int v524; // [sp+78h] [bp+78h]
  int v525; // [sp+78h] [bp+78h]
  int v526; // [sp+78h] [bp+78h]
  int v527; // [sp+78h] [bp+78h]
  int v528; // [sp+78h] [bp+78h]
  int v529; // [sp+78h] [bp+78h]
  int v530; // [sp+78h] [bp+78h]
  int v531; // [sp+78h] [bp+78h]
  int v532; // [sp+78h] [bp+78h]
  int v533; // [sp+78h] [bp+78h]
  int v534; // [sp+78h] [bp+78h]
  int v535; // [sp+78h] [bp+78h]
  int v536; // [sp+78h] [bp+78h]
  int v537; // [sp+78h] [bp+78h]
  int v538; // [sp+78h] [bp+78h]
  int v539; // [sp+78h] [bp+78h]
  int v540; // [sp+78h] [bp+78h]
  int v541; // [sp+78h] [bp+78h]
  int v542; // [sp+78h] [bp+78h]
  int v543; // [sp+78h] [bp+78h]
  int v544; // [sp+78h] [bp+78h]
  int v545; // [sp+78h] [bp+78h]
  int v546; // [sp+78h] [bp+78h]
  int v547; // [sp+78h] [bp+78h]
  int v548; // [sp+78h] [bp+78h]
  int v549; // [sp+78h] [bp+78h]
  int v550; // [sp+78h] [bp+78h]
  int v551; // [sp+78h] [bp+78h]
  int v552; // [sp+78h] [bp+78h]
  int v553; // [sp+78h] [bp+78h]
  int v554; // [sp+78h] [bp+78h]
  int v555; // [sp+78h] [bp+78h]
  int v556; // [sp+78h] [bp+78h]
  int v557; // [sp+78h] [bp+78h]
  int v558; // [sp+78h] [bp+78h]
  int v559; // [sp+78h] [bp+78h]
  int v560; // [sp+78h] [bp+78h]
  int v561; // [sp+78h] [bp+78h]
  int v562; // [sp+78h] [bp+78h]
  int v563; // [sp+78h] [bp+78h]
  int v564; // [sp+78h] [bp+78h]
  int v565; // [sp+78h] [bp+78h]
  int v566; // [sp+78h] [bp+78h]
  int v567; // [sp+78h] [bp+78h]
  int v568; // [sp+78h] [bp+78h]
  int v569; // [sp+78h] [bp+78h]
  int v570; // [sp+78h] [bp+78h]
  int v571; // [sp+78h] [bp+78h]
  int v572; // [sp+78h] [bp+78h]
  int v573; // [sp+78h] [bp+78h]
  int v574; // [sp+78h] [bp+78h]
  int v575; // [sp+78h] [bp+78h]
  int v576; // [sp+78h] [bp+78h]
  int v577; // [sp+78h] [bp+78h]
  int v578; // [sp+78h] [bp+78h]
  int v579; // [sp+7Ch] [bp+7Ch]
  int v580; // [sp+7Ch] [bp+7Ch]
  int v581; // [sp+7Ch] [bp+7Ch]
  int v582; // [sp+7Ch] [bp+7Ch]
  int v583; // [sp+7Ch] [bp+7Ch]
  int v584; // [sp+7Ch] [bp+7Ch]
  int v585; // [sp+7Ch] [bp+7Ch]
  int v586; // [sp+7Ch] [bp+7Ch]
  int v587; // [sp+7Ch] [bp+7Ch]
  int v588; // [sp+7Ch] [bp+7Ch]
  int v589; // [sp+7Ch] [bp+7Ch]
  int v590; // [sp+7Ch] [bp+7Ch]
  int v591; // [sp+7Ch] [bp+7Ch]
  int v592; // [sp+7Ch] [bp+7Ch]
  int v593; // [sp+7Ch] [bp+7Ch]
  int v594; // [sp+7Ch] [bp+7Ch]
  int v595; // [sp+7Ch] [bp+7Ch]
  int v596; // [sp+7Ch] [bp+7Ch]
  int v597; // [sp+7Ch] [bp+7Ch]
  int v598; // [sp+7Ch] [bp+7Ch]
  int v599; // [sp+7Ch] [bp+7Ch]
  int v600; // [sp+7Ch] [bp+7Ch]
  int v601; // [sp+7Ch] [bp+7Ch]
  int v602; // [sp+7Ch] [bp+7Ch]
  int v603; // [sp+7Ch] [bp+7Ch]
  int v604; // [sp+7Ch] [bp+7Ch]
  int v605; // [sp+7Ch] [bp+7Ch]
  int v606; // [sp+7Ch] [bp+7Ch]
  int v607; // [sp+7Ch] [bp+7Ch]
  int v608; // [sp+7Ch] [bp+7Ch]
  int v609; // [sp+7Ch] [bp+7Ch]
  int v610; // [sp+7Ch] [bp+7Ch]
  int v611; // [sp+7Ch] [bp+7Ch]
  int v612; // [sp+7Ch] [bp+7Ch]
  int v613; // [sp+7Ch] [bp+7Ch]
  int v614; // [sp+7Ch] [bp+7Ch]
  int v615; // [sp+7Ch] [bp+7Ch]
  int v616; // [sp+7Ch] [bp+7Ch]
  int v617; // [sp+7Ch] [bp+7Ch]
  int v618; // [sp+7Ch] [bp+7Ch]
  int v619; // [sp+7Ch] [bp+7Ch]
  int v620; // [sp+7Ch] [bp+7Ch]
  int v621; // [sp+7Ch] [bp+7Ch]
  int v622; // [sp+7Ch] [bp+7Ch]
  int v623; // [sp+7Ch] [bp+7Ch]
  int v624; // [sp+7Ch] [bp+7Ch]
  int v625; // [sp+7Ch] [bp+7Ch]
  int v626; // [sp+7Ch] [bp+7Ch]
  int v627; // [sp+7Ch] [bp+7Ch]
  int v628; // [sp+7Ch] [bp+7Ch]
  int v629; // [sp+7Ch] [bp+7Ch]
  int v630; // [sp+7Ch] [bp+7Ch]
  int v631; // [sp+7Ch] [bp+7Ch]
  int v632; // [sp+7Ch] [bp+7Ch]
  int v633; // [sp+7Ch] [bp+7Ch]
  int v634; // [sp+80h] [bp+80h]
  int v635; // [sp+80h] [bp+80h]
  int v636; // [sp+80h] [bp+80h]
  int v637; // [sp+80h] [bp+80h]
  int v638; // [sp+80h] [bp+80h]
  int v639; // [sp+80h] [bp+80h]
  int v640; // [sp+80h] [bp+80h]
  int v641; // [sp+80h] [bp+80h]
  int v642; // [sp+80h] [bp+80h]
  int v643; // [sp+80h] [bp+80h]
  int v644; // [sp+80h] [bp+80h]
  int v645; // [sp+80h] [bp+80h]
  int v646; // [sp+80h] [bp+80h]
  int v647; // [sp+80h] [bp+80h]
  int v648; // [sp+80h] [bp+80h]
  int v649; // [sp+80h] [bp+80h]
  int v650; // [sp+80h] [bp+80h]
  int v651; // [sp+80h] [bp+80h]
  int v652; // [sp+80h] [bp+80h]
  int v653; // [sp+80h] [bp+80h]
  int v654; // [sp+80h] [bp+80h]
  int v655; // [sp+80h] [bp+80h]
  int v656; // [sp+80h] [bp+80h]
  int v657; // [sp+80h] [bp+80h]
  int v658; // [sp+80h] [bp+80h]
  int v659; // [sp+80h] [bp+80h]
  int v660; // [sp+80h] [bp+80h]
  int v661; // [sp+80h] [bp+80h]
  int v662; // [sp+80h] [bp+80h]
  int v663; // [sp+80h] [bp+80h]
  int v664; // [sp+80h] [bp+80h]
  int v665; // [sp+80h] [bp+80h]
  int v666; // [sp+80h] [bp+80h]
  int v667; // [sp+80h] [bp+80h]
  int v668; // [sp+80h] [bp+80h]
  int v669; // [sp+80h] [bp+80h]
  int v670; // [sp+80h] [bp+80h]
  int v671; // [sp+80h] [bp+80h]
  int v672; // [sp+80h] [bp+80h]
  int v673; // [sp+80h] [bp+80h]
  int v674; // [sp+80h] [bp+80h]
  int v675; // [sp+80h] [bp+80h]
  int v676; // [sp+80h] [bp+80h]
  int v677; // [sp+80h] [bp+80h]
  int v678; // [sp+80h] [bp+80h]
  int v679; // [sp+80h] [bp+80h]
  int v680; // [sp+80h] [bp+80h]
  int v681; // [sp+80h] [bp+80h]
  int v682; // [sp+80h] [bp+80h]
  int v683; // [sp+80h] [bp+80h]
  int v684; // [sp+80h] [bp+80h]
  int v685; // [sp+80h] [bp+80h]
  int v686; // [sp+80h] [bp+80h]
  int v687; // [sp+80h] [bp+80h]
  int v688; // [sp+80h] [bp+80h]
  unsigned int v689; // [sp+84h] [bp+84h]
  int v690; // [sp+84h] [bp+84h]
  unsigned int v691; // [sp+84h] [bp+84h]
  unsigned int v692; // [sp+84h] [bp+84h]
  int v693; // [sp+84h] [bp+84h]
  unsigned int v694; // [sp+84h] [bp+84h]
  int v695; // [sp+84h] [bp+84h]
  int v696; // [sp+84h] [bp+84h]
  unsigned int v697; // [sp+84h] [bp+84h]
  unsigned int v698; // [sp+84h] [bp+84h]
  unsigned int v699; // [sp+84h] [bp+84h]
  int v700; // [sp+84h] [bp+84h]
  int v701; // [sp+84h] [bp+84h]
  int v702; // [sp+84h] [bp+84h]
  unsigned int v703; // [sp+84h] [bp+84h]
  unsigned int v704; // [sp+84h] [bp+84h]
  unsigned int v705; // [sp+84h] [bp+84h]
  unsigned int v706; // [sp+84h] [bp+84h]
  unsigned int v707; // [sp+84h] [bp+84h]
  int v708; // [sp+84h] [bp+84h]
  int v709; // [sp+84h] [bp+84h]
  int v710; // [sp+84h] [bp+84h]
  int v711; // [sp+84h] [bp+84h]
  unsigned int v712; // [sp+84h] [bp+84h]
  unsigned int v713; // [sp+84h] [bp+84h]
  unsigned int v714; // [sp+84h] [bp+84h]
  int v715; // [sp+84h] [bp+84h]
  int v716; // [sp+84h] [bp+84h]
  int v717; // [sp+84h] [bp+84h]
  int v718; // [sp+84h] [bp+84h]
  unsigned int v719; // [sp+84h] [bp+84h]
  int v720; // [sp+84h] [bp+84h]
  int v721; // [sp+84h] [bp+84h]
  int v722; // [sp+84h] [bp+84h]
  int v723; // [sp+84h] [bp+84h]
  unsigned int v724; // [sp+84h] [bp+84h]
  int v725; // [sp+84h] [bp+84h]
  unsigned int v726; // [sp+84h] [bp+84h]
  int v727; // [sp+84h] [bp+84h]
  unsigned int v728; // [sp+84h] [bp+84h]
  unsigned int v729; // [sp+84h] [bp+84h]
  int v730; // [sp+84h] [bp+84h]
  unsigned int v731; // [sp+84h] [bp+84h]
  unsigned int v732; // [sp+84h] [bp+84h]
  int v733; // [sp+84h] [bp+84h]
  unsigned int v734; // [sp+84h] [bp+84h]
  int v735; // [sp+84h] [bp+84h]
  int v736; // [sp+84h] [bp+84h]
  unsigned int v737; // [sp+84h] [bp+84h]
  unsigned int v738; // [sp+84h] [bp+84h]
  unsigned int v739; // [sp+84h] [bp+84h]
  int v740; // [sp+84h] [bp+84h]
  int v741; // [sp+84h] [bp+84h]
  int v742; // [sp+84h] [bp+84h]
  unsigned int v743; // [sp+84h] [bp+84h]
  unsigned int v744; // [sp+84h] [bp+84h]
  int v745; // [sp+88h] [bp+88h]
  unsigned int v746; // [sp+88h] [bp+88h]
  unsigned int v747; // [sp+88h] [bp+88h]
  unsigned int v748; // [sp+88h] [bp+88h]
  unsigned int v749; // [sp+88h] [bp+88h]
  unsigned int v750; // [sp+88h] [bp+88h]
  unsigned int v751; // [sp+88h] [bp+88h]
  int v752; // [sp+88h] [bp+88h]
  int v753; // [sp+88h] [bp+88h]
  int v754; // [sp+88h] [bp+88h]
  unsigned int v755; // [sp+88h] [bp+88h]
  unsigned int v756; // [sp+88h] [bp+88h]
  unsigned int v757; // [sp+88h] [bp+88h]
  unsigned int v758; // [sp+88h] [bp+88h]
  int v759; // [sp+88h] [bp+88h]
  unsigned int v760; // [sp+88h] [bp+88h]
  unsigned int v761; // [sp+88h] [bp+88h]
  int v762; // [sp+88h] [bp+88h]
  int v763; // [sp+88h] [bp+88h]
  int v764; // [sp+88h] [bp+88h]
  int v765; // [sp+88h] [bp+88h]
  int v766; // [sp+88h] [bp+88h]
  unsigned int v767; // [sp+88h] [bp+88h]
  unsigned int v768; // [sp+88h] [bp+88h]
  unsigned int v769; // [sp+88h] [bp+88h]
  int v770; // [sp+88h] [bp+88h]
  int v771; // [sp+88h] [bp+88h]
  int v772; // [sp+88h] [bp+88h]
  unsigned int v773; // [sp+88h] [bp+88h]
  unsigned int v774; // [sp+88h] [bp+88h]
  int v775; // [sp+88h] [bp+88h]
  int v776; // [sp+88h] [bp+88h]
  int v777; // [sp+88h] [bp+88h]
  int v778; // [sp+88h] [bp+88h]
  unsigned int v779; // [sp+88h] [bp+88h]
  unsigned int v780; // [sp+88h] [bp+88h]
  int v781; // [sp+88h] [bp+88h]
  unsigned int v782; // [sp+88h] [bp+88h]
  unsigned int v783; // [sp+88h] [bp+88h]
  int v784; // [sp+88h] [bp+88h]
  int v785; // [sp+88h] [bp+88h]
  unsigned int v786; // [sp+88h] [bp+88h]
  unsigned int v787; // [sp+88h] [bp+88h]
  unsigned int v788; // [sp+88h] [bp+88h]
  unsigned int v789; // [sp+88h] [bp+88h]
  unsigned int v790; // [sp+88h] [bp+88h]
  unsigned int v791; // [sp+88h] [bp+88h]
  int v792; // [sp+88h] [bp+88h]
  int v793; // [sp+88h] [bp+88h]
  int v794; // [sp+88h] [bp+88h]
  unsigned int v795; // [sp+88h] [bp+88h]
  unsigned int v796; // [sp+88h] [bp+88h]
  unsigned int v797; // [sp+88h] [bp+88h]
  unsigned int v798; // [sp+88h] [bp+88h]
  int v799; // [sp+88h] [bp+88h]
  unsigned int v800; // [sp+88h] [bp+88h]
  int v801; // [sp+8Ch] [bp+8Ch]
  int v802; // [sp+8Ch] [bp+8Ch]
  int v803; // [sp+8Ch] [bp+8Ch]
  unsigned int v804; // [sp+8Ch] [bp+8Ch]
  int v805; // [sp+8Ch] [bp+8Ch]
  unsigned int v806; // [sp+8Ch] [bp+8Ch]
  int v807; // [sp+8Ch] [bp+8Ch]
  int v808; // [sp+8Ch] [bp+8Ch]
  int v809; // [sp+8Ch] [bp+8Ch]
  unsigned int v810; // [sp+8Ch] [bp+8Ch]
  int v811; // [sp+8Ch] [bp+8Ch]
  int v812; // [sp+8Ch] [bp+8Ch]
  unsigned int v813; // [sp+8Ch] [bp+8Ch]
  int v814; // [sp+8Ch] [bp+8Ch]
  unsigned int v815; // [sp+8Ch] [bp+8Ch]
  int v816; // [sp+8Ch] [bp+8Ch]
  unsigned int v817; // [sp+8Ch] [bp+8Ch]
  int v818; // [sp+8Ch] [bp+8Ch]
  unsigned int v819; // [sp+8Ch] [bp+8Ch]
  int v820; // [sp+8Ch] [bp+8Ch]
  unsigned int v821; // [sp+8Ch] [bp+8Ch]
  int v822; // [sp+8Ch] [bp+8Ch]
  int v823; // [sp+8Ch] [bp+8Ch]
  unsigned int v824; // [sp+8Ch] [bp+8Ch]
  unsigned int v825; // [sp+8Ch] [bp+8Ch]
  unsigned int v826; // [sp+8Ch] [bp+8Ch]
  int v827; // [sp+8Ch] [bp+8Ch]
  int v828; // [sp+8Ch] [bp+8Ch]
  int v829; // [sp+8Ch] [bp+8Ch]
  unsigned int v830; // [sp+8Ch] [bp+8Ch]
  unsigned int v831; // [sp+8Ch] [bp+8Ch]
  unsigned int v832; // [sp+8Ch] [bp+8Ch]
  int v833; // [sp+8Ch] [bp+8Ch]
  int v834; // [sp+8Ch] [bp+8Ch]
  unsigned int v835; // [sp+8Ch] [bp+8Ch]
  unsigned int v836; // [sp+8Ch] [bp+8Ch]
  unsigned int v837; // [sp+8Ch] [bp+8Ch]
  int v838; // [sp+8Ch] [bp+8Ch]
  int v839; // [sp+8Ch] [bp+8Ch]
  int v840; // [sp+8Ch] [bp+8Ch]
  int v841; // [sp+8Ch] [bp+8Ch]
  int v842; // [sp+8Ch] [bp+8Ch]
  int v843; // [sp+8Ch] [bp+8Ch]
  unsigned int v844; // [sp+8Ch] [bp+8Ch]
  int v845; // [sp+8Ch] [bp+8Ch]
  unsigned int v846; // [sp+8Ch] [bp+8Ch]
  int v847; // [sp+8Ch] [bp+8Ch]
  int v848; // [sp+8Ch] [bp+8Ch]
  int v849; // [sp+8Ch] [bp+8Ch]
  unsigned int v850; // [sp+8Ch] [bp+8Ch]
  int v851; // [sp+8Ch] [bp+8Ch]
  int v852; // [sp+8Ch] [bp+8Ch]
  unsigned int v853; // [sp+8Ch] [bp+8Ch]
  int v854; // [sp+8Ch] [bp+8Ch]
  unsigned int v855; // [sp+8Ch] [bp+8Ch]
  int v856; // [sp+8Ch] [bp+8Ch]
  unsigned int v857; // [sp+90h] [bp+90h]
  int v858; // [sp+90h] [bp+90h]
  int v859; // [sp+90h] [bp+90h]
  int v860; // [sp+90h] [bp+90h]
  unsigned int v861; // [sp+90h] [bp+90h]
  int v862; // [sp+90h] [bp+90h]
  unsigned int v863; // [sp+90h] [bp+90h]
  unsigned int v864; // [sp+90h] [bp+90h]
  int v865; // [sp+90h] [bp+90h]
  int v866; // [sp+90h] [bp+90h]
  int v867; // [sp+90h] [bp+90h]
  unsigned int v868; // [sp+90h] [bp+90h]
  int v869; // [sp+90h] [bp+90h]
  unsigned int v870; // [sp+90h] [bp+90h]
  int v871; // [sp+90h] [bp+90h]
  int v872; // [sp+90h] [bp+90h]
  int v873; // [sp+90h] [bp+90h]
  int v874; // [sp+90h] [bp+90h]
  unsigned int v875; // [sp+90h] [bp+90h]
  int v876; // [sp+90h] [bp+90h]
  unsigned int v877; // [sp+90h] [bp+90h]
  int v878; // [sp+90h] [bp+90h]
  unsigned int v879; // [sp+90h] [bp+90h]
  unsigned int v880; // [sp+90h] [bp+90h]
  int v881; // [sp+90h] [bp+90h]
  unsigned int v882; // [sp+90h] [bp+90h]
  unsigned int v883; // [sp+90h] [bp+90h]
  int v884; // [sp+90h] [bp+90h]
  int v885; // [sp+90h] [bp+90h]
  unsigned int v886; // [sp+90h] [bp+90h]
  int v887; // [sp+90h] [bp+90h]
  int v888; // [sp+90h] [bp+90h]
  unsigned int v889; // [sp+90h] [bp+90h]
  unsigned int v890; // [sp+90h] [bp+90h]
  int v891; // [sp+90h] [bp+90h]
  unsigned int v892; // [sp+90h] [bp+90h]
  int v893; // [sp+90h] [bp+90h]
  unsigned int v894; // [sp+90h] [bp+90h]
  unsigned int v895; // [sp+90h] [bp+90h]
  unsigned int v896; // [sp+90h] [bp+90h]
  unsigned int v897; // [sp+90h] [bp+90h]
  int v898; // [sp+90h] [bp+90h]
  int v899; // [sp+90h] [bp+90h]
  int v900; // [sp+90h] [bp+90h]
  unsigned int v901; // [sp+90h] [bp+90h]
  int v902; // [sp+90h] [bp+90h]
  unsigned int v903; // [sp+90h] [bp+90h]
  unsigned int v904; // [sp+90h] [bp+90h]
  int v905; // [sp+90h] [bp+90h]
  int v906; // [sp+90h] [bp+90h]
  int v907; // [sp+90h] [bp+90h]
  unsigned int v908; // [sp+90h] [bp+90h]
  int v909; // [sp+90h] [bp+90h]
  unsigned int v910; // [sp+90h] [bp+90h]
  int v911; // [sp+90h] [bp+90h]
  int v912; // [sp+90h] [bp+90h]
  int v913; // [sp+94h] [bp+94h]
  int v914; // [sp+98h] [bp+98h]
  int v915; // [sp+9Ch] [bp+9Ch]
  int v916; // [sp+A0h] [bp+A0h]
  int *v917; // [sp+A4h] [bp+A4h]
  size_t v918; // [sp+A8h] [bp+A8h]
  int v919; // [sp+ACh] [bp+ACh]
  unsigned int v920; // [sp+B0h] [bp+B0h]
  int v921; // [sp+B4h] [bp+B4h]
  int v922; // [sp+B8h] [bp+B8h]
  int v923; // [sp+BCh] [bp+BCh]
  int v924; // [sp+C0h] [bp+C0h]
  int v925; // [sp+C4h] [bp+C4h]
  int v926; // [sp+C8h] [bp+C8h]
  int v927; // [sp+CCh] [bp+CCh]
  int v928; // [sp+D0h] [bp+D0h]
  int v929; // [sp+D4h] [bp+D4h]

  v5 = (_DWORD *)result;
  src = a2;
  n = a3;
  v917 = (int *)result;
  v929 = *(_DWORD *)(result + 64);
  if ( 64 - v929 <= a3 )
  {
    v928 = *(_DWORD *)(result + 68);
    v927 = *(_DWORD *)(result + 72);
    v926 = *(_DWORD *)(result + 76);
    v925 = *(_DWORD *)(result + 80);
    v924 = *(_DWORD *)(result + 84);
    v923 = *(_DWORD *)(result + 88);
    v922 = *(_DWORD *)(result + 92);
    v921 = *(_DWORD *)(result + 96);
    v916 = *(_DWORD *)(result + 100);
    v915 = *(_DWORD *)(result + 104);
    v914 = *(_DWORD *)(result + 108);
    v913 = *(_DWORD *)(result + 112);
    v920 = *(_DWORD *)(result + 116);
    v919 = *(_DWORD *)(result + 120);
    while ( n )
    {
      v918 = 64 - v929;
      if ( 64 - v929 > n )
        v918 = n;
      result = (unsigned int)memcpy((char *)v917 + v929, src, v918);
      v929 += v918;
      src += v918;
      n -= v918;
      if ( v929 == 64 )
      {
        v920 += 512;
        if ( v920 <= 0x1FF )
          ++v919;
        v20 = sph_dec32be_aligned(v917);
        v19 = sph_dec32be_aligned(v917 + 1);
        v18 = sph_dec32be_aligned(v917 + 2);
        v17 = sph_dec32be_aligned(v917 + 3);
        v16 = sph_dec32be_aligned(v917 + 4);
        v15 = sph_dec32be_aligned(v917 + 5);
        v14 = sph_dec32be_aligned(v917 + 6);
        v13 = sph_dec32be_aligned(v917 + 7);
        v12 = sph_dec32be_aligned(v917 + 8);
        v11 = sph_dec32be_aligned(v917 + 9);
        v10 = sph_dec32be_aligned(v917 + 10);
        v9 = sph_dec32be_aligned(v917 + 11);
        v8 = sph_dec32be_aligned(v917 + 12);
        v7 = sph_dec32be_aligned(v917 + 13);
        v6 = sph_dec32be_aligned(v917 + 14);
        result = sph_dec32be_aligned(v917 + 15);
        v857 = v928 + v924 + (v20 ^ 0x85A308D3);
        v189 = __ROR4__(v857 ^ v920 ^ 0xA4093822, 16);
        v413 = (v916 ^ 0x243F6A88) + v189;
        v634 = __ROR4__(v413 ^ v924, 12);
        v858 = v857 + v634 + (v19 ^ 0x243F6A88);
        v190 = __ROR4__(v858 ^ v189, 8);
        v414 = v413 + v190;
        v635 = __ROR4__(v414 ^ v634, 7);
        v801 = v927 + v923 + (v18 ^ 0x3707344);
        v133 = __ROR4__(v801 ^ v920 ^ 0x299F31D0, 16);
        v357 = (v915 ^ 0x85A308D3) + v133;
        v579 = __ROR4__(v357 ^ v923, 12);
        v802 = v801 + v579 + (v17 ^ 0x13198A2E);
        v134 = __ROR4__(v802 ^ v133, 8);
        v358 = v357 + v134;
        v580 = __ROR4__(v358 ^ v579, 7);
        v745 = v926 + v922 + (v16 ^ 0x299F31D0);
        v77 = __ROR4__(v745 ^ v919 ^ 0x82EFA98, 16);
        v301 = (v914 ^ 0x13198A2E) + v77;
        v524 = __ROR4__(v301 ^ v922, 12);
        v746 = v745 + v524 + (v15 ^ 0xA4093822);
        v78 = __ROR4__(v746 ^ v77, 8);
        v302 = v301 + v78;
        v525 = __ROR4__(v302 ^ v524, 7);
        v689 = v925 + v921 + (v14 ^ 0xEC4E6C89);
        v21 = __ROR4__(v689 ^ v919 ^ 0xEC4E6C89, 16);
        v245 = (v913 ^ 0x3707344) + v21;
        v469 = __ROR4__(v245 ^ v921, 12);
        v690 = v689 + v469 + (v13 ^ 0x82EFA98);
        v22 = __ROR4__(v690 ^ v21, 8);
        v246 = v245 + v22;
        v470 = __ROR4__(v246 ^ v469, 7);
        v859 = v858 + v580 + (v12 ^ 0x38D01377);
        v23 = __ROR4__(v859 ^ v22, 16);
        v303 = v302 + v23;
        v581 = __ROR4__(v303 ^ v580, 12);
        v860 = v859 + v581 + (v11 ^ 0x452821E6);
        v24 = __ROR4__(v860 ^ v23, 8);
        v304 = v303 + v24;
        v582 = __ROR4__(v304 ^ v581, 7);
        v803 = v802 + v525 + (v10 ^ 0x34E90C6C);
        v191 = __ROR4__(v803 ^ v190, 16);
        v247 = v246 + v191;
        v526 = __ROR4__(v247 ^ v525, 12);
        v804 = v803 + v526 + (v9 ^ 0xBE5466CF);
        v192 = __ROR4__(v804 ^ v191, 8);
        v248 = v247 + v192;
        v527 = __ROR4__(v248 ^ v526, 7);
        v747 = v746 + v470 + (v8 ^ 0xC97C50DD);
        v135 = __ROR4__(v747 ^ v134, 16);
        v415 = v414 + v135;
        v471 = __ROR4__(v415 ^ v470, 12);
        v748 = v747 + v471 + (v7 ^ 0xC0AC29B7);
        v136 = __ROR4__(v748 ^ v135, 8);
        v416 = v415 + v136;
        v472 = __ROR4__(v416 ^ v471, 7);
        v691 = v690 + v635 + (v6 ^ 0xB5470917);
        v79 = __ROR4__(v691 ^ v78, 16);
        v359 = v358 + v79;
        v636 = __ROR4__(v359 ^ v635, 12);
        v692 = v691 + v636 + (result ^ 0x3F84D5B5);
        v80 = __ROR4__(v692 ^ v79, 8);
        v360 = v359 + v80;
        v637 = __ROR4__(v360 ^ v636, 7);
        v861 = v860 + v637 + (v6 ^ 0xBE5466CF);
        v193 = __ROR4__(v861 ^ v192, 16);
        v417 = v416 + v193;
        v638 = __ROR4__(v417 ^ v637, 12);
        v862 = v861 + v638 + (v10 ^ 0x3F84D5B5);
        v194 = __ROR4__(v862 ^ v193, 8);
        v418 = v417 + v194;
        v639 = __ROR4__(v418 ^ v638, 7);
        v805 = v804 + v582 + (v16 ^ 0x452821E6);
        v137 = __ROR4__(v805 ^ v136, 16);
        v361 = v360 + v137;
        v583 = __ROR4__(v361 ^ v582, 12);
        v806 = v805 + v583 + (v12 ^ 0xA4093822);
        v138 = __ROR4__(v806 ^ v137, 8);
        v362 = v361 + v138;
        v584 = __ROR4__(v362 ^ v583, 7);
        v749 = v748 + v527 + (v11 ^ 0xB5470917);
        v81 = __ROR4__(v749 ^ v80, 16);
        v305 = v304 + v81;
        v528 = __ROR4__(v305 ^ v527, 12);
        v750 = v749 + v528 + (result ^ 0x38D01377);
        v82 = __ROR4__(v750 ^ v81, 8);
        v306 = v305 + v82;
        v529 = __ROR4__(v306 ^ v528, 7);
        v693 = v692 + v472 + (v7 ^ 0x82EFA98);
        v25 = __ROR4__(v693 ^ v24, 16);
        v249 = v248 + v25;
        v473 = __ROR4__(v249 ^ v472, 12);
        v694 = v693 + v473 + (v14 ^ 0xC97C50DD);
        v26 = __ROR4__(v694 ^ v25, 8);
        v250 = v249 + v26;
        v474 = __ROR4__(v250 ^ v473, 7);
        v863 = v862 + v584 + (v19 ^ 0xC0AC29B7);
        v27 = __ROR4__(v863 ^ v26, 16);
        v307 = v306 + v27;
        v585 = __ROR4__(v307 ^ v584, 12);
        v864 = v863 + v585 + (v8 ^ 0x85A308D3);
        v28 = __ROR4__(v864 ^ v27, 8);
        v308 = v307 + v28;
        v586 = __ROR4__(v308 ^ v585, 7);
        v807 = v806 + v529 + (v20 ^ 0x13198A2E);
        v195 = __ROR4__(v807 ^ v194, 16);
        v251 = v250 + v195;
        v530 = __ROR4__(v251 ^ v529, 12);
        v808 = v807 + v530 + (v18 ^ 0x243F6A88);
        v196 = __ROR4__(v808 ^ v195, 8);
        v252 = v251 + v196;
        v531 = __ROR4__(v252 ^ v530, 7);
        v751 = v750 + v474 + (v9 ^ 0xEC4E6C89);
        v139 = __ROR4__(v751 ^ v138, 16);
        v419 = v418 + v139;
        v475 = __ROR4__(v419 ^ v474, 12);
        v752 = v751 + v475 + (v13 ^ 0x34E90C6C);
        v140 = __ROR4__(v752 ^ v139, 8);
        v420 = v419 + v140;
        v476 = __ROR4__(v420 ^ v475, 7);
        v695 = v694 + v639 + (v15 ^ 0x3707344);
        v83 = __ROR4__(v695 ^ v82, 16);
        v363 = v362 + v83;
        v640 = __ROR4__(v363 ^ v639, 12);
        v696 = v695 + v640 + (v17 ^ 0x299F31D0);
        v84 = __ROR4__(v696 ^ v83, 8);
        v364 = v363 + v84;
        v641 = __ROR4__(v364 ^ v640, 7);
        v865 = v864 + v641 + (v9 ^ 0x452821E6);
        v197 = __ROR4__(v865 ^ v196, 16);
        v421 = v420 + v197;
        v642 = __ROR4__(v421 ^ v641, 12);
        v866 = v865 + v642 + (v12 ^ 0x34E90C6C);
        v198 = __ROR4__(v866 ^ v197, 8);
        v422 = v421 + v198;
        v643 = __ROR4__(v422 ^ v642, 7);
        v809 = v808 + v586 + (v8 ^ 0x243F6A88);
        v141 = __ROR4__(v809 ^ v140, 16);
        v365 = v364 + v141;
        v587 = __ROR4__(v365 ^ v586, 12);
        v810 = v809 + v587 + (v20 ^ 0xC0AC29B7);
        v142 = __ROR4__(v810 ^ v141, 8);
        v366 = v365 + v142;
        v588 = __ROR4__(v366 ^ v587, 7);
        v753 = v752 + v531 + (v15 ^ 0x13198A2E);
        v85 = __ROR4__(v753 ^ v84, 16);
        v309 = v308 + v85;
        v532 = __ROR4__(v309 ^ v531, 12);
        v754 = v753 + v532 + (v18 ^ 0x299F31D0);
        v86 = __ROR4__(v754 ^ v85, 8);
        v310 = v309 + v86;
        v533 = __ROR4__(v310 ^ v532, 7);
        v697 = v696 + v476 + (result ^ 0xC97C50DD);
        v29 = __ROR4__(v697 ^ v28, 16);
        v253 = v252 + v29;
        v477 = __ROR4__(v253 ^ v476, 12);
        v698 = v697 + v477 + (v7 ^ 0xB5470917);
        v30 = __ROR4__(v698 ^ v29, 8);
        v254 = v253 + v30;
        v478 = __ROR4__(v254 ^ v477, 7);
        v867 = v866 + v588 + (v10 ^ 0x3F84D5B5);
        v31 = __ROR4__(v867 ^ v30, 16);
        v311 = v310 + v31;
        v589 = __ROR4__(v311 ^ v588, 12);
        v868 = v867 + v589 + (v6 ^ 0xBE5466CF);
        v32 = __ROR4__(v868 ^ v31, 8);
        v312 = v311 + v32;
        v590 = __ROR4__(v312 ^ v589, 7);
        v811 = v810 + v533 + (v17 ^ 0x82EFA98);
        v199 = __ROR4__(v811 ^ v198, 16);
        v255 = v254 + v199;
        v534 = __ROR4__(v255 ^ v533, 12);
        v812 = v811 + v534 + (v14 ^ 0x3707344);
        v200 = __ROR4__(v812 ^ v199, 8);
        v256 = v255 + v200;
        v535 = __ROR4__(v256 ^ v534, 7);
        v755 = v754 + v478 + (v13 ^ 0x85A308D3);
        v143 = __ROR4__(v755 ^ v142, 16);
        v423 = v422 + v143;
        v479 = __ROR4__(v423 ^ v478, 12);
        v756 = v755 + v479 + (v19 ^ 0xEC4E6C89);
        v144 = __ROR4__(v756 ^ v143, 8);
        v424 = v423 + v144;
        v480 = __ROR4__(v424 ^ v479, 7);
        v699 = v698 + v643 + (v11 ^ 0xA4093822);
        v87 = __ROR4__(v699 ^ v86, 16);
        v367 = v366 + v87;
        v644 = __ROR4__(v367 ^ v643, 12);
        v700 = v699 + v644 + (v16 ^ 0x38D01377);
        v88 = __ROR4__(v700 ^ v87, 8);
        v368 = v367 + v88;
        v645 = __ROR4__(v368 ^ v644, 7);
        v869 = v868 + v645 + (v13 ^ 0x38D01377);
        v201 = __ROR4__(v869 ^ v200, 16);
        v425 = v424 + v201;
        v646 = __ROR4__(v425 ^ v645, 12);
        v870 = v869 + v646 + (v11 ^ 0xEC4E6C89);
        v202 = __ROR4__(v870 ^ v201, 8);
        v426 = v425 + v202;
        v647 = __ROR4__(v426 ^ v646, 7);
        v813 = v812 + v590 + (v17 ^ 0x85A308D3);
        v145 = __ROR4__(v813 ^ v144, 16);
        v369 = v368 + v145;
        v591 = __ROR4__(v369 ^ v590, 12);
        v814 = v813 + v591 + (v19 ^ 0x3707344);
        v146 = __ROR4__(v814 ^ v145, 8);
        v370 = v369 + v146;
        v592 = __ROR4__(v370 ^ v591, 7);
        v757 = v756 + v535 + (v7 ^ 0xC0AC29B7);
        v89 = __ROR4__(v757 ^ v88, 16);
        v313 = v312 + v89;
        v536 = __ROR4__(v313 ^ v535, 12);
        v758 = v757 + v536 + (v8 ^ 0xC97C50DD);
        v90 = __ROR4__(v758 ^ v89, 8);
        v314 = v313 + v90;
        v537 = __ROR4__(v314 ^ v536, 7);
        v701 = v700 + v480 + (v9 ^ 0x3F84D5B5);
        v33 = __ROR4__(v701 ^ v32, 16);
        v257 = v256 + v33;
        v481 = __ROR4__(v257 ^ v480, 12);
        v702 = v701 + v481 + (v6 ^ 0x34E90C6C);
        v34 = __ROR4__(v702 ^ v33, 8);
        v258 = v257 + v34;
        v482 = __ROR4__(v258 ^ v481, 7);
        v871 = v870 + v592 + (v18 ^ 0x82EFA98);
        v35 = __ROR4__(v871 ^ v34, 16);
        v315 = v314 + v35;
        v593 = __ROR4__(v315 ^ v592, 12);
        v872 = v871 + v593 + (v14 ^ 0x13198A2E);
        v36 = __ROR4__(v872 ^ v35, 8);
        v316 = v315 + v36;
        v594 = __ROR4__(v316 ^ v593, 7);
        v815 = v814 + v537 + (v15 ^ 0xBE5466CF);
        v203 = __ROR4__(v815 ^ v202, 16);
        v259 = v258 + v203;
        v538 = __ROR4__(v259 ^ v537, 12);
        v816 = v815 + v538 + (v10 ^ 0x299F31D0);
        v204 = __ROR4__(v816 ^ v203, 8);
        v260 = v259 + v204;
        v539 = __ROR4__(v260 ^ v538, 7);
        v759 = v758 + v482 + (v16 ^ 0x243F6A88);
        v147 = __ROR4__(v759 ^ v146, 16);
        v427 = v426 + v147;
        v483 = __ROR4__(v427 ^ v482, 12);
        v760 = v759 + v483 + (v20 ^ 0xA4093822);
        v148 = __ROR4__(v760 ^ v147, 8);
        v428 = v427 + v148;
        v484 = __ROR4__(v428 ^ v483, 7);
        v703 = v702 + v647 + (result ^ 0x452821E6);
        v91 = __ROR4__(v703 ^ v90, 16);
        v371 = v370 + v91;
        v648 = __ROR4__(v371 ^ v647, 12);
        v704 = v703 + v648 + (v12 ^ 0xB5470917);
        v92 = __ROR4__(v704 ^ v91, 8);
        v372 = v371 + v92;
        v649 = __ROR4__(v372 ^ v648, 7);
        v873 = v872 + v649 + (v11 ^ 0x243F6A88);
        v205 = __ROR4__(v873 ^ v204, 16);
        v429 = v428 + v205;
        v650 = __ROR4__(v429 ^ v649, 12);
        v874 = v873 + v650 + (v20 ^ 0x38D01377);
        v206 = __ROR4__(v874 ^ v205, 8);
        v430 = v429 + v206;
        v651 = __ROR4__(v430 ^ v650, 7);
        v817 = v816 + v594 + (v15 ^ 0xEC4E6C89);
        v149 = __ROR4__(v817 ^ v148, 16);
        v373 = v372 + v149;
        v595 = __ROR4__(v373 ^ v594, 12);
        v818 = v817 + v595 + (v13 ^ 0x299F31D0);
        v150 = __ROR4__(v818 ^ v149, 8);
        v374 = v373 + v150;
        v596 = __ROR4__(v374 ^ v595, 7);
        v761 = v760 + v539 + (v18 ^ 0xA4093822);
        v93 = __ROR4__(v761 ^ v92, 16);
        v317 = v316 + v93;
        v540 = __ROR4__(v317 ^ v539, 12);
        v762 = v761 + v540 + (v16 ^ 0x13198A2E);
        v94 = __ROR4__(v762 ^ v93, 8);
        v318 = v317 + v94;
        v541 = __ROR4__(v318 ^ v540, 7);
        v705 = v704 + v484 + (v10 ^ 0xB5470917);
        v37 = __ROR4__(v705 ^ v36, 16);
        v261 = v260 + v37;
        v485 = __ROR4__(v261 ^ v484, 12);
        v706 = v705 + v485 + (result ^ 0xBE5466CF);
        v38 = __ROR4__(v706 ^ v37, 8);
        v262 = v261 + v38;
        v486 = __ROR4__(v262 ^ v485, 7);
        v875 = v874 + v596 + (v6 ^ 0x85A308D3);
        v39 = __ROR4__(v875 ^ v38, 16);
        v319 = v318 + v39;
        v597 = __ROR4__(v319 ^ v596, 12);
        v876 = v875 + v597 + (v19 ^ 0x3F84D5B5);
        v40 = __ROR4__(v876 ^ v39, 8);
        v320 = v319 + v40;
        v598 = __ROR4__(v320 ^ v597, 7);
        v819 = v818 + v541 + (v9 ^ 0xC0AC29B7);
        v207 = __ROR4__(v819 ^ v206, 16);
        v263 = v262 + v207;
        v542 = __ROR4__(v263 ^ v541, 12);
        v820 = v819 + v542 + (v8 ^ 0x34E90C6C);
        v208 = __ROR4__(v820 ^ v207, 8);
        v264 = v263 + v208;
        v543 = __ROR4__(v264 ^ v542, 7);
        v763 = v762 + v486 + (v14 ^ 0x452821E6);
        v151 = __ROR4__(v763 ^ v150, 16);
        v431 = v430 + v151;
        v487 = __ROR4__(v431 ^ v486, 12);
        v764 = v763 + v487 + (v12 ^ 0x82EFA98);
        v152 = __ROR4__(v764 ^ v151, 8);
        v432 = v431 + v152;
        v488 = __ROR4__(v432 ^ v487, 7);
        v707 = v706 + v651 + (v17 ^ 0xC97C50DD);
        v95 = __ROR4__(v707 ^ v94, 16);
        v375 = v374 + v95;
        v652 = __ROR4__(v375 ^ v651, 12);
        v708 = v707 + v652 + (v7 ^ 0x3707344);
        v96 = __ROR4__(v708 ^ v95, 8);
        v376 = v375 + v96;
        v653 = __ROR4__(v376 ^ v652, 7);
        v877 = v876 + v653 + (v18 ^ 0xC0AC29B7);
        v209 = __ROR4__(v877 ^ v208, 16);
        v433 = v432 + v209;
        v654 = __ROR4__(v433 ^ v653, 12);
        v878 = v877 + v654 + (v8 ^ 0x13198A2E);
        v210 = __ROR4__(v878 ^ v209, 8);
        v434 = v433 + v210;
        v655 = __ROR4__(v434 ^ v654, 7);
        v821 = v820 + v598 + (v14 ^ 0xBE5466CF);
        v153 = __ROR4__(v821 ^ v152, 16);
        v377 = v376 + v153;
        v599 = __ROR4__(v377 ^ v598, 12);
        v822 = v821 + v599 + (v10 ^ 0x82EFA98);
        v154 = __ROR4__(v822 ^ v153, 8);
        v378 = v377 + v154;
        v600 = __ROR4__(v378 ^ v599, 7);
        v765 = v764 + v543 + (v20 ^ 0x34E90C6C);
        v97 = __ROR4__(v765 ^ v96, 16);
        v321 = v320 + v97;
        v544 = __ROR4__(v321 ^ v543, 12);
        v766 = v765 + v544 + (v9 ^ 0x243F6A88);
        v98 = __ROR4__(v766 ^ v97, 8);
        v322 = v321 + v98;
        v545 = __ROR4__(v322 ^ v544, 7);
        v709 = v708 + v488 + (v12 ^ 0x3707344);
        v41 = __ROR4__(v709 ^ v40, 16);
        v265 = v264 + v41;
        v489 = __ROR4__(v265 ^ v488, 12);
        v710 = v709 + v489 + (v17 ^ 0x452821E6);
        v42 = __ROR4__(v710 ^ v41, 8);
        v266 = v265 + v42;
        v490 = __ROR4__(v266 ^ v489, 7);
        v879 = v878 + v600 + (v16 ^ 0xC97C50DD);
        v43 = __ROR4__(v879 ^ v42, 16);
        v323 = v322 + v43;
        v601 = __ROR4__(v323 ^ v600, 12);
        v880 = v879 + v601 + (v7 ^ 0xA4093822);
        v44 = __ROR4__(v880 ^ v43, 8);
        v324 = v323 + v44;
        v602 = __ROR4__(v324 ^ v601, 7);
        v823 = v822 + v545 + (v13 ^ 0x299F31D0);
        v211 = __ROR4__(v823 ^ v210, 16);
        v267 = v266 + v211;
        v546 = __ROR4__(v267 ^ v545, 12);
        v824 = v823 + v546 + (v15 ^ 0xEC4E6C89);
        v212 = __ROR4__(v824 ^ v211, 8);
        v268 = v267 + v212;
        v547 = __ROR4__(v268 ^ v546, 7);
        v767 = v766 + v490 + (result ^ 0x3F84D5B5);
        v155 = __ROR4__(v767 ^ v154, 16);
        v435 = v434 + v155;
        v491 = __ROR4__(v435 ^ v490, 12);
        v768 = v767 + v491 + (v6 ^ 0xB5470917);
        v156 = __ROR4__(v768 ^ v155, 8);
        v436 = v435 + v156;
        v492 = __ROR4__(v436 ^ v491, 7);
        v711 = v710 + v655 + (v19 ^ 0x38D01377);
        v99 = __ROR4__(v711 ^ v98, 16);
        v379 = v378 + v99;
        v656 = __ROR4__(v379 ^ v655, 12);
        v712 = v711 + v656 + (v11 ^ 0x85A308D3);
        v100 = __ROR4__(v712 ^ v99, 8);
        v380 = v379 + v100;
        v657 = __ROR4__(v380 ^ v656, 7);
        v881 = v880 + v657 + (v8 ^ 0x299F31D0);
        v213 = __ROR4__(v881 ^ v212, 16);
        v437 = v436 + v213;
        v658 = __ROR4__(v437 ^ v657, 12);
        v882 = v881 + v658 + (v15 ^ 0xC0AC29B7);
        v214 = __ROR4__(v882 ^ v213, 8);
        v438 = v437 + v214;
        v659 = __ROR4__(v438 ^ v658, 7);
        v825 = v824 + v602 + (v19 ^ 0xB5470917);
        v157 = __ROR4__(v825 ^ v156, 16);
        v381 = v380 + v157;
        v603 = __ROR4__(v381 ^ v602, 12);
        v826 = v825 + v603 + (result ^ 0x85A308D3);
        v158 = __ROR4__(v826 ^ v157, 8);
        v382 = v381 + v158;
        v604 = __ROR4__(v382 ^ v603, 7);
        v769 = v768 + v547 + (v6 ^ 0xC97C50DD);
        v101 = __ROR4__(v769 ^ v100, 16);
        v325 = v324 + v101;
        v548 = __ROR4__(v325 ^ v547, 12);
        v770 = v769 + v548 + (v7 ^ 0x3F84D5B5);
        v102 = __ROR4__(v770 ^ v101, 8);
        v326 = v325 + v102;
        v549 = __ROR4__(v326 ^ v548, 7);
        v713 = v712 + v492 + (v16 ^ 0xBE5466CF);
        v45 = __ROR4__(v713 ^ v44, 16);
        v269 = v268 + v45;
        v493 = __ROR4__(v269 ^ v492, 12);
        v714 = v713 + v493 + (v10 ^ 0xA4093822);
        v46 = __ROR4__(v714 ^ v45, 8);
        v270 = v269 + v46;
        v494 = __ROR4__(v270 ^ v493, 7);
        v883 = v882 + v604 + (v20 ^ 0xEC4E6C89);
        v47 = __ROR4__(v883 ^ v46, 16);
        v327 = v326 + v47;
        v605 = __ROR4__(v327 ^ v604, 12);
        v884 = v883 + v605 + (v13 ^ 0x243F6A88);
        v48 = __ROR4__(v884 ^ v47, 8);
        v328 = v327 + v48;
        v606 = __ROR4__(v328 ^ v605, 7);
        v827 = v826 + v549 + (v14 ^ 0x3707344);
        v215 = __ROR4__(v827 ^ v214, 16);
        v271 = v270 + v215;
        v550 = __ROR4__(v271 ^ v549, 12);
        v828 = v827 + v550 + (v17 ^ 0x82EFA98);
        v216 = __ROR4__(v828 ^ v215, 8);
        v272 = v271 + v216;
        v551 = __ROR4__(v272 ^ v550, 7);
        v771 = v770 + v494 + (v11 ^ 0x13198A2E);
        v159 = __ROR4__(v771 ^ v158, 16);
        v439 = v438 + v159;
        v495 = __ROR4__(v439 ^ v494, 12);
        v772 = v771 + v495 + (v18 ^ 0x38D01377);
        v160 = __ROR4__(v772 ^ v159, 8);
        v440 = v439 + v160;
        v496 = __ROR4__(v440 ^ v495, 7);
        v715 = v714 + v659 + (v12 ^ 0x34E90C6C);
        v103 = __ROR4__(v715 ^ v102, 16);
        v383 = v382 + v103;
        v660 = __ROR4__(v383 ^ v659, 12);
        v716 = v715 + v660 + (v9 ^ 0x452821E6);
        v104 = __ROR4__(v716 ^ v103, 8);
        v384 = v383 + v104;
        v661 = __ROR4__(v384 ^ v660, 7);
        v885 = v884 + v661 + (v7 ^ 0x34E90C6C);
        v217 = __ROR4__(v885 ^ v216, 16);
        v441 = v440 + v217;
        v662 = __ROR4__(v441 ^ v661, 12);
        v886 = v885 + v662 + (v9 ^ 0xC97C50DD);
        v218 = __ROR4__(v886 ^ v217, 8);
        v442 = v441 + v218;
        v663 = __ROR4__(v442 ^ v662, 7);
        v829 = v828 + v606 + (v13 ^ 0x3F84D5B5);
        v161 = __ROR4__(v829 ^ v160, 16);
        v385 = v384 + v161;
        v607 = __ROR4__(v385 ^ v606, 12);
        v830 = v829 + v607 + (v6 ^ 0xEC4E6C89);
        v162 = __ROR4__(v830 ^ v161, 8);
        v386 = v385 + v162;
        v608 = __ROR4__(v386 ^ v607, 7);
        v773 = v772 + v551 + (v8 ^ 0x85A308D3);
        v105 = __ROR4__(v773 ^ v104, 16);
        v329 = v328 + v105;
        v552 = __ROR4__(v329 ^ v551, 12);
        v774 = v773 + v552 + (v19 ^ 0xC0AC29B7);
        v106 = __ROR4__(v774 ^ v105, 8);
        v330 = v329 + v106;
        v553 = __ROR4__(v330 ^ v552, 7);
        v717 = v716 + v496 + (v17 ^ 0x38D01377);
        v49 = __ROR4__(v717 ^ v48, 16);
        v273 = v272 + v49;
        v497 = __ROR4__(v273 ^ v496, 12);
        v718 = v717 + v497 + (v11 ^ 0x3707344);
        v50 = __ROR4__(v718 ^ v49, 8);
        v274 = v273 + v50;
        v498 = __ROR4__(v274 ^ v497, 7);
        v887 = v886 + v608 + (v15 ^ 0x243F6A88);
        v51 = __ROR4__(v887 ^ v50, 16);
        v331 = v330 + v51;
        v609 = __ROR4__(v331 ^ v608, 12);
        v888 = v887 + v609 + (v20 ^ 0x299F31D0);
        v52 = __ROR4__(v888 ^ v51, 8);
        v332 = v331 + v52;
        v610 = __ROR4__(v332 ^ v609, 7);
        v831 = v830 + v553 + (result ^ 0xA4093822);
        v219 = __ROR4__(v831 ^ v218, 16);
        v275 = v274 + v219;
        v554 = __ROR4__(v275 ^ v553, 12);
        v832 = v831 + v554 + (v16 ^ 0xB5470917);
        v220 = __ROR4__(v832 ^ v219, 8);
        v276 = v275 + v220;
        v555 = __ROR4__(v276 ^ v554, 7);
        v775 = v774 + v498 + (v12 ^ 0x82EFA98);
        v163 = __ROR4__(v775 ^ v162, 16);
        v443 = v442 + v163;
        v499 = __ROR4__(v443 ^ v498, 12);
        v776 = v775 + v499 + (v14 ^ 0x452821E6);
        v164 = __ROR4__(v776 ^ v163, 8);
        v444 = v443 + v164;
        v500 = __ROR4__(v444 ^ v499, 7);
        v719 = v718 + v663 + (v18 ^ 0xBE5466CF);
        v107 = __ROR4__(v719 ^ v106, 16);
        v387 = v386 + v107;
        v664 = __ROR4__(v387 ^ v663, 12);
        v720 = v719 + v664 + (v10 ^ 0x13198A2E);
        v108 = __ROR4__(v720 ^ v107, 8);
        v388 = v387 + v108;
        v665 = __ROR4__(v388 ^ v664, 7);
        v889 = v888 + v665 + (v14 ^ 0xB5470917);
        v221 = __ROR4__(v889 ^ v220, 16);
        v445 = v444 + v221;
        v666 = __ROR4__(v445 ^ v665, 12);
        v890 = v889 + v666 + (result ^ 0x82EFA98);
        v222 = __ROR4__(v890 ^ v221, 8);
        v446 = v445 + v222;
        v667 = __ROR4__(v446 ^ v666, 7);
        v833 = v832 + v610 + (v6 ^ 0x38D01377);
        v165 = __ROR4__(v833 ^ v164, 16);
        v389 = v388 + v165;
        v611 = __ROR4__(v389 ^ v610, 12);
        v834 = v833 + v611 + (v11 ^ 0x3F84D5B5);
        v166 = __ROR4__(v834 ^ v165, 8);
        v390 = v389 + v166;
        v612 = __ROR4__(v390 ^ v611, 7);
        v777 = v776 + v555 + (v9 ^ 0x3707344);
        v109 = __ROR4__(v777 ^ v108, 16);
        v333 = v332 + v109;
        v556 = __ROR4__(v333 ^ v555, 12);
        v778 = v777 + v556 + (v17 ^ 0x34E90C6C);
        v110 = __ROR4__(v778 ^ v109, 8);
        v334 = v333 + v110;
        v557 = __ROR4__(v334 ^ v556, 7);
        v721 = v720 + v500 + (v20 ^ 0x452821E6);
        v53 = __ROR4__(v721 ^ v52, 16);
        v277 = v276 + v53;
        v501 = __ROR4__(v277 ^ v500, 12);
        v722 = v721 + v501 + (v12 ^ 0x243F6A88);
        v54 = __ROR4__(v722 ^ v53, 8);
        v278 = v277 + v54;
        v502 = __ROR4__(v278 ^ v501, 7);
        v891 = v890 + v612 + (v8 ^ 0x13198A2E);
        v55 = __ROR4__(v891 ^ v54, 16);
        v335 = v334 + v55;
        v613 = __ROR4__(v335 ^ v612, 12);
        v892 = v891 + v613 + (v18 ^ 0xC0AC29B7);
        v56 = __ROR4__(v892 ^ v55, 8);
        v336 = v335 + v56;
        v614 = __ROR4__(v336 ^ v613, 7);
        v835 = v834 + v557 + (v7 ^ 0xEC4E6C89);
        v223 = __ROR4__(v835 ^ v222, 16);
        v279 = v278 + v223;
        v558 = __ROR4__(v279 ^ v557, 12);
        v836 = v835 + v558 + (v13 ^ 0xC97C50DD);
        v224 = __ROR4__(v836 ^ v223, 8);
        v280 = v279 + v224;
        v559 = __ROR4__(v280 ^ v558, 7);
        v779 = v778 + v502 + (v19 ^ 0xA4093822);
        v167 = __ROR4__(v779 ^ v166, 16);
        v447 = v446 + v167;
        v503 = __ROR4__(v447 ^ v502, 12);
        v780 = v779 + v503 + (v16 ^ 0x85A308D3);
        v168 = __ROR4__(v780 ^ v167, 8);
        v448 = v447 + v168;
        v504 = __ROR4__(v448 ^ v503, 7);
        v723 = v722 + v667 + (v10 ^ 0x299F31D0);
        v111 = __ROR4__(v723 ^ v110, 16);
        v391 = v390 + v111;
        v668 = __ROR4__(v391 ^ v667, 12);
        v724 = v723 + v668 + (v15 ^ 0xBE5466CF);
        v112 = __ROR4__(v724 ^ v111, 8);
        v392 = v391 + v112;
        v669 = __ROR4__(v392 ^ v668, 7);
        v893 = v892 + v669 + (v10 ^ 0x13198A2E);
        v225 = __ROR4__(v893 ^ v224, 16);
        v449 = v448 + v225;
        v670 = __ROR4__(v449 ^ v669, 12);
        v894 = v893 + v670 + (v18 ^ 0xBE5466CF);
        v226 = __ROR4__(v894 ^ v225, 8);
        v450 = v449 + v226;
        v671 = __ROR4__(v450 ^ v670, 7);
        v837 = v836 + v614 + (v12 ^ 0xA4093822);
        v169 = __ROR4__(v837 ^ v168, 16);
        v393 = v392 + v169;
        v615 = __ROR4__(v393 ^ v614, 12);
        v838 = v837 + v615 + (v16 ^ 0x452821E6);
        v170 = __ROR4__(v838 ^ v169, 8);
        v394 = v393 + v170;
        v616 = __ROR4__(v394 ^ v615, 7);
        v781 = v780 + v559 + (v13 ^ 0x82EFA98);
        v113 = __ROR4__(v781 ^ v112, 16);
        v337 = v336 + v113;
        v560 = __ROR4__(v337 ^ v559, 12);
        v782 = v781 + v560 + (v14 ^ 0xEC4E6C89);
        v114 = __ROR4__(v782 ^ v113, 8);
        v338 = v337 + v114;
        v561 = __ROR4__(v338 ^ v560, 7);
        v725 = v724 + v504 + (v19 ^ 0x299F31D0);
        v57 = __ROR4__(v725 ^ v56, 16);
        v281 = v280 + v57;
        v505 = __ROR4__(v281 ^ v504, 12);
        v726 = v725 + v505 + (v15 ^ 0x85A308D3);
        v58 = __ROR4__(v726 ^ v57, 8);
        v282 = v281 + v58;
        v506 = __ROR4__(v282 ^ v505, 7);
        v895 = v894 + v616 + (result ^ 0x34E90C6C);
        v59 = __ROR4__(v895 ^ v58, 16);
        v339 = v338 + v59;
        v617 = __ROR4__(v339 ^ v616, 12);
        v896 = v895 + v617 + (v9 ^ 0xB5470917);
        v60 = __ROR4__(v896 ^ v59, 8);
        v340 = v339 + v60;
        v618 = __ROR4__(v340 ^ v617, 7);
        v839 = v838 + v561 + (v11 ^ 0x3F84D5B5);
        v227 = __ROR4__(v839 ^ v226, 16);
        v283 = v282 + v227;
        v562 = __ROR4__(v283 ^ v561, 12);
        v840 = v839 + v562 + (v6 ^ 0x38D01377);
        v228 = __ROR4__(v840 ^ v227, 8);
        v284 = v283 + v228;
        v563 = __ROR4__(v284 ^ v562, 7);
        v783 = v782 + v506 + (v17 ^ 0xC0AC29B7);
        v171 = __ROR4__(v783 ^ v170, 16);
        v451 = v450 + v171;
        v507 = __ROR4__(v451 ^ v506, 12);
        v784 = v783 + v507 + (v8 ^ 0x3707344);
        v172 = __ROR4__(v784 ^ v171, 8);
        v452 = v451 + v172;
        v508 = __ROR4__(v452 ^ v507, 7);
        v727 = v726 + v671 + (v7 ^ 0x243F6A88);
        v115 = __ROR4__(v727 ^ v114, 16);
        v395 = v394 + v115;
        v672 = __ROR4__(v395 ^ v671, 12);
        v728 = v727 + v672 + (v20 ^ 0xC97C50DD);
        v116 = __ROR4__(v728 ^ v115, 8);
        v396 = v395 + v116;
        v673 = __ROR4__(v396 ^ v672, 7);
        v897 = v896 + v673 + (v20 ^ 0x85A308D3);
        v229 = __ROR4__(v897 ^ v228, 16);
        v453 = v452 + v229;
        v674 = __ROR4__(v453 ^ v673, 12);
        v898 = v897 + v674 + (v19 ^ 0x243F6A88);
        v230 = __ROR4__(v898 ^ v229, 8);
        v454 = v453 + v230;
        v675 = __ROR4__(v454 ^ v674, 7);
        v841 = v840 + v618 + (v18 ^ 0x3707344);
        v173 = __ROR4__(v841 ^ v172, 16);
        v397 = v396 + v173;
        v619 = __ROR4__(v397 ^ v618, 12);
        v842 = v841 + v619 + (v17 ^ 0x13198A2E);
        v174 = __ROR4__(v842 ^ v173, 8);
        v398 = v397 + v174;
        v620 = __ROR4__(v398 ^ v619, 7);
        v785 = v784 + v563 + (v16 ^ 0x299F31D0);
        v117 = __ROR4__(v785 ^ v116, 16);
        v341 = v340 + v117;
        v564 = __ROR4__(v341 ^ v563, 12);
        v786 = v785 + v564 + (v15 ^ 0xA4093822);
        v118 = __ROR4__(v786 ^ v117, 8);
        v342 = v341 + v118;
        v565 = __ROR4__(v342 ^ v564, 7);
        v729 = v728 + v508 + (v14 ^ 0xEC4E6C89);
        v61 = __ROR4__(v729 ^ v60, 16);
        v285 = v284 + v61;
        v509 = __ROR4__(v285 ^ v508, 12);
        v730 = v729 + v509 + (v13 ^ 0x82EFA98);
        v62 = __ROR4__(v730 ^ v61, 8);
        v286 = v285 + v62;
        v510 = __ROR4__(v286 ^ v509, 7);
        v899 = v898 + v620 + (v12 ^ 0x38D01377);
        v63 = __ROR4__(v899 ^ v62, 16);
        v343 = v342 + v63;
        v621 = __ROR4__(v343 ^ v620, 12);
        v900 = v899 + v621 + (v11 ^ 0x452821E6);
        v64 = __ROR4__(v900 ^ v63, 8);
        v344 = v343 + v64;
        v622 = __ROR4__(v344 ^ v621, 7);
        v843 = v842 + v565 + (v10 ^ 0x34E90C6C);
        v231 = __ROR4__(v843 ^ v230, 16);
        v287 = v286 + v231;
        v566 = __ROR4__(v287 ^ v565, 12);
        v844 = v843 + v566 + (v9 ^ 0xBE5466CF);
        v232 = __ROR4__(v844 ^ v231, 8);
        v288 = v287 + v232;
        v567 = __ROR4__(v288 ^ v566, 7);
        v787 = v786 + v510 + (v8 ^ 0xC97C50DD);
        v175 = __ROR4__(v787 ^ v174, 16);
        v455 = v454 + v175;
        v511 = __ROR4__(v455 ^ v510, 12);
        v788 = v787 + v511 + (v7 ^ 0xC0AC29B7);
        v176 = __ROR4__(v788 ^ v175, 8);
        v456 = v455 + v176;
        v512 = __ROR4__(v456 ^ v511, 7);
        v731 = v730 + v675 + (v6 ^ 0xB5470917);
        v119 = __ROR4__(v731 ^ v118, 16);
        v399 = v398 + v119;
        v676 = __ROR4__(v399 ^ v675, 12);
        v732 = v731 + v676 + (result ^ 0x3F84D5B5);
        v120 = __ROR4__(v732 ^ v119, 8);
        v400 = v399 + v120;
        v677 = __ROR4__(v400 ^ v676, 7);
        v901 = v900 + v677 + (v6 ^ 0xBE5466CF);
        v233 = __ROR4__(v901 ^ v232, 16);
        v457 = v456 + v233;
        v678 = __ROR4__(v457 ^ v677, 12);
        v902 = v901 + v678 + (v10 ^ 0x3F84D5B5);
        v234 = __ROR4__(v902 ^ v233, 8);
        v458 = v457 + v234;
        v679 = __ROR4__(v458 ^ v678, 7);
        v845 = v844 + v622 + (v16 ^ 0x452821E6);
        v177 = __ROR4__(v845 ^ v176, 16);
        v401 = v400 + v177;
        v623 = __ROR4__(v401 ^ v622, 12);
        v846 = v845 + v623 + (v12 ^ 0xA4093822);
        v178 = __ROR4__(v846 ^ v177, 8);
        v402 = v401 + v178;
        v624 = __ROR4__(v402 ^ v623, 7);
        v789 = v788 + v567 + (v11 ^ 0xB5470917);
        v121 = __ROR4__(v789 ^ v120, 16);
        v345 = v344 + v121;
        v568 = __ROR4__(v345 ^ v567, 12);
        v790 = v789 + v568 + (result ^ 0x38D01377);
        v122 = __ROR4__(v790 ^ v121, 8);
        v346 = v345 + v122;
        v569 = __ROR4__(v346 ^ v568, 7);
        v733 = v732 + v512 + (v7 ^ 0x82EFA98);
        v65 = __ROR4__(v733 ^ v64, 16);
        v289 = v288 + v65;
        v513 = __ROR4__(v289 ^ v512, 12);
        v734 = v733 + v513 + (v14 ^ 0xC97C50DD);
        v66 = __ROR4__(v734 ^ v65, 8);
        v290 = v289 + v66;
        v514 = __ROR4__(v290 ^ v513, 7);
        v903 = v902 + v624 + (v19 ^ 0xC0AC29B7);
        v67 = __ROR4__(v903 ^ v66, 16);
        v347 = v346 + v67;
        v625 = __ROR4__(v347 ^ v624, 12);
        v904 = v903 + v625 + (v8 ^ 0x85A308D3);
        v68 = __ROR4__(v904 ^ v67, 8);
        v348 = v347 + v68;
        v626 = __ROR4__(v348 ^ v625, 7);
        v847 = v846 + v569 + (v20 ^ 0x13198A2E);
        v235 = __ROR4__(v847 ^ v234, 16);
        v291 = v290 + v235;
        v570 = __ROR4__(v291 ^ v569, 12);
        v848 = v847 + v570 + (v18 ^ 0x243F6A88);
        v236 = __ROR4__(v848 ^ v235, 8);
        v292 = v291 + v236;
        v571 = __ROR4__(v292 ^ v570, 7);
        v791 = v790 + v514 + (v9 ^ 0xEC4E6C89);
        v179 = __ROR4__(v791 ^ v178, 16);
        v459 = v458 + v179;
        v515 = __ROR4__(v459 ^ v514, 12);
        v792 = v791 + v515 + (v13 ^ 0x34E90C6C);
        v180 = __ROR4__(v792 ^ v179, 8);
        v460 = v459 + v180;
        v516 = __ROR4__(v460 ^ v515, 7);
        v735 = v734 + v679 + (v15 ^ 0x3707344);
        v123 = __ROR4__(v735 ^ v122, 16);
        v403 = v402 + v123;
        v680 = __ROR4__(v403 ^ v679, 12);
        v736 = v735 + v680 + (v17 ^ 0x299F31D0);
        v124 = __ROR4__(v736 ^ v123, 8);
        v404 = v403 + v124;
        v681 = __ROR4__(v404 ^ v680, 7);
        v905 = v904 + v681 + (v9 ^ 0x452821E6);
        v237 = __ROR4__(v905 ^ v236, 16);
        v461 = v460 + v237;
        v682 = __ROR4__(v461 ^ v681, 12);
        v906 = v905 + v682 + (v12 ^ 0x34E90C6C);
        v238 = __ROR4__(v906 ^ v237, 8);
        v462 = v461 + v238;
        v683 = __ROR4__(v462 ^ v682, 7);
        v849 = v848 + v626 + (v8 ^ 0x243F6A88);
        v181 = __ROR4__(v849 ^ v180, 16);
        v405 = v404 + v181;
        v627 = __ROR4__(v405 ^ v626, 12);
        v850 = v849 + v627 + (v20 ^ 0xC0AC29B7);
        v182 = __ROR4__(v850 ^ v181, 8);
        v406 = v405 + v182;
        v628 = __ROR4__(v406 ^ v627, 7);
        v793 = v792 + v571 + (v15 ^ 0x13198A2E);
        v125 = __ROR4__(v793 ^ v124, 16);
        v349 = v348 + v125;
        v572 = __ROR4__(v349 ^ v571, 12);
        v794 = v793 + v572 + (v18 ^ 0x299F31D0);
        v126 = __ROR4__(v794 ^ v125, 8);
        v350 = v349 + v126;
        v573 = __ROR4__(v350 ^ v572, 7);
        v737 = v736 + v516 + (result ^ 0xC97C50DD);
        v69 = __ROR4__(v737 ^ v68, 16);
        v293 = v292 + v69;
        v517 = __ROR4__(v293 ^ v516, 12);
        v738 = v737 + v517 + (v7 ^ 0xB5470917);
        v70 = __ROR4__(v738 ^ v69, 8);
        v294 = v293 + v70;
        v518 = __ROR4__(v294 ^ v517, 7);
        v907 = v906 + v628 + (v10 ^ 0x3F84D5B5);
        v71 = __ROR4__(v907 ^ v70, 16);
        v351 = v350 + v71;
        v629 = __ROR4__(v351 ^ v628, 12);
        v908 = v907 + v629 + (v6 ^ 0xBE5466CF);
        v72 = __ROR4__(v908 ^ v71, 8);
        v352 = v351 + v72;
        v630 = __ROR4__(v352 ^ v629, 7);
        v851 = v850 + v573 + (v17 ^ 0x82EFA98);
        v239 = __ROR4__(v851 ^ v238, 16);
        v295 = v294 + v239;
        v574 = __ROR4__(v295 ^ v573, 12);
        v852 = v851 + v574 + (v14 ^ 0x3707344);
        v240 = __ROR4__(v852 ^ v239, 8);
        v296 = v295 + v240;
        v575 = __ROR4__(v296 ^ v574, 7);
        v795 = v794 + v518 + (v13 ^ 0x85A308D3);
        v183 = __ROR4__(v795 ^ v182, 16);
        v463 = v462 + v183;
        v519 = __ROR4__(v463 ^ v518, 12);
        v796 = v795 + v519 + (v19 ^ 0xEC4E6C89);
        v184 = __ROR4__(v796 ^ v183, 8);
        v464 = v463 + v184;
        v520 = __ROR4__(v464 ^ v519, 7);
        v739 = v738 + v683 + (v11 ^ 0xA4093822);
        v127 = __ROR4__(v739 ^ v126, 16);
        v407 = v406 + v127;
        v684 = __ROR4__(v407 ^ v683, 12);
        v740 = v739 + v684 + (v16 ^ 0x38D01377);
        v128 = __ROR4__(v740 ^ v127, 8);
        v408 = v407 + v128;
        v685 = __ROR4__(v408 ^ v684, 7);
        v909 = v908 + v685 + (v13 ^ 0x38D01377);
        v241 = __ROR4__(v909 ^ v240, 16);
        v465 = v464 + v241;
        v686 = __ROR4__(v465 ^ v685, 12);
        v910 = v909 + v686 + (v11 ^ 0xEC4E6C89);
        v242 = __ROR4__(v910 ^ v241, 8);
        v466 = v465 + v242;
        v687 = __ROR4__(v466 ^ v686, 7);
        v853 = v852 + v630 + (v17 ^ 0x85A308D3);
        v185 = __ROR4__(v853 ^ v184, 16);
        v409 = v408 + v185;
        v631 = __ROR4__(v409 ^ v630, 12);
        v854 = v853 + v631 + (v19 ^ 0x3707344);
        v186 = __ROR4__(v854 ^ v185, 8);
        v410 = v409 + v186;
        v632 = __ROR4__(v410 ^ v631, 7);
        v797 = v796 + v575 + (v7 ^ 0xC0AC29B7);
        v129 = __ROR4__(v797 ^ v128, 16);
        v353 = v352 + v129;
        v576 = __ROR4__(v353 ^ v575, 12);
        v798 = v797 + v576 + (v8 ^ 0xC97C50DD);
        v130 = __ROR4__(v798 ^ v129, 8);
        v354 = v353 + v130;
        v577 = __ROR4__(v354 ^ v576, 7);
        v741 = v740 + v520 + (v9 ^ 0x3F84D5B5);
        v73 = __ROR4__(v741 ^ v72, 16);
        v297 = v296 + v73;
        v521 = __ROR4__(v297 ^ v520, 12);
        v742 = v741 + v521 + (v6 ^ 0x34E90C6C);
        v74 = __ROR4__(v742 ^ v73, 8);
        v298 = v297 + v74;
        v522 = __ROR4__(v298 ^ v521, 7);
        v911 = v910 + v632 + (v18 ^ 0x82EFA98);
        v75 = __ROR4__(v911 ^ v74, 16);
        v355 = v354 + v75;
        v633 = __ROR4__(v355 ^ v632, 12);
        v912 = v911 + v633 + (v14 ^ 0x13198A2E);
        v76 = __ROR4__(v912 ^ v75, 8);
        v356 = v355 + v76;
        v855 = v854 + v577 + (v15 ^ 0xBE5466CF);
        v243 = __ROR4__(v855 ^ v242, 16);
        v299 = v298 + v243;
        v578 = __ROR4__(v299 ^ v577, 12);
        v856 = v855 + v578 + (v10 ^ 0x299F31D0);
        v244 = __ROR4__(v856 ^ v243, 8);
        v300 = v299 + v244;
        v799 = v798 + v522 + (v16 ^ 0x243F6A88);
        v187 = __ROR4__(v799 ^ v186, 16);
        v467 = v466 + v187;
        v523 = __ROR4__(v467 ^ v522, 12);
        v800 = v799 + v523 + (v20 ^ 0xA4093822);
        v188 = __ROR4__(v800 ^ v187, 8);
        v468 = v467 + v188;
        v743 = v742 + v687 + (result ^ 0x452821E6);
        v131 = __ROR4__(v743 ^ v130, 16);
        v411 = v410 + v131;
        v688 = __ROR4__(v411 ^ v687, 12);
        v744 = v743 + v688 + (v12 ^ 0xB5470917);
        v132 = __ROR4__(v744 ^ v131, 8);
        v412 = v411 + v132;
        v928 ^= v468 ^ v916 ^ v912;
        v927 ^= v412 ^ v915 ^ v856;
        v926 ^= v356 ^ v914 ^ v800;
        v925 ^= v300 ^ v913 ^ v744;
        v924 ^= v244 ^ v916 ^ __ROR4__(v412 ^ v688, 7);
        v923 ^= v188 ^ v915 ^ __ROR4__(v356 ^ v633, 7);
        v922 ^= v132 ^ v914 ^ __ROR4__(v300 ^ v578, 7);
        v921 ^= v76 ^ v913 ^ __ROR4__(v468 ^ v523, 7);
        v929 = 0;
      }
    }
    v5[17] = v928;
    v5[18] = v927;
    v5[19] = v926;
    v5[20] = v925;
    v5[21] = v924;
    v5[22] = v923;
    v5[23] = v922;
    v5[24] = v921;
    v5[25] = v916;
    v5[26] = v915;
    v5[27] = v914;
    v5[28] = v913;
    v5[29] = v920;
    v5[30] = v919;
    v5[16] = v929;
  }
  else
  {
    result = (unsigned int)memcpy((void *)(result + v929), a2, a3);
    v5[16] = v929 + n;
  }
  return result;
}

//----- (00019CB0) --------------------------------------------------------
_BYTE *__fastcall blake32_close(_DWORD *a1, char a2, int a3, int a4, unsigned int a5)
{
  _BYTE *result; // r0
  char s[56]; // [sp+14h] [bp+14h] BYREF
  unsigned int v9; // [sp+4Ch] [bp+4Ch] BYREF
  unsigned int v10; // [sp+50h] [bp+50h] BYREF
  int v11; // [sp+54h] [bp+54h]
  int v12; // [sp+58h] [bp+58h]
  int v13; // [sp+5Ch] [bp+5Ch]
  int v14; // [sp+60h] [bp+60h]
  unsigned int v15; // [sp+64h] [bp+64h]
  int v16; // [sp+68h] [bp+68h]
  unsigned int i; // [sp+6Ch] [bp+6Ch]

  v16 = a1[16];
  v15 = 8 * v16 + a3;
  v14 = 128 >> a3;
  s[v16] = (128 >> a3) | a2 & -(128 >> a3);
  v13 = a1[29] + v15;
  v12 = a1[30];
  if ( v16 || a3 )
  {
    if ( a1[29] )
    {
      a1[29] = a1[29] + v15 - 512;
    }
    else
    {
      a1[29] = v15 - 512;
      --a1[30];
    }
  }
  else
  {
    a1[29] = -512;
    a1[30] = -1;
  }
  if ( v15 > 0x1BE )
  {
    memset(&s[v16 + 1], 0, 63 - v16);
    blake32((unsigned int)a1, &s[v16], 64 - v16);
    a1[29] = -512;
    a1[30] = -1;
    memset(s, 0, sizeof(s));
    if ( a5 == 8 )
      s[55] = 1;
    sph_enc32be_aligned(&v9, v12);
    sph_enc32be_aligned(&v10, v13);
    result = (_BYTE *)blake32((unsigned int)a1, s, 0x40u);
  }
  else
  {
    memset(&s[v16 + 1], 0, 55 - v16);
    if ( a5 == 8 )
      s[55] |= 1u;
    sph_enc32be_aligned(&v9, v12);
    sph_enc32be_aligned(&v10, v13);
    result = (_BYTE *)blake32((unsigned int)a1, &s[v16], 64 - v16);
  }
  v11 = a4;
  for ( i = 0; i < a5; ++i )
    result = sph_enc32be((_BYTE *)(v11 + 4 * i), a1[i + 17]);
  return result;
}

//----- (00019E8C) --------------------------------------------------------
void *__fastcall blake64_init(int a1, const void *a2, const void *a3)
{
  void *result; // r0

  memcpy((void *)(a1 + 136), a2, 0x40u);
  result = memcpy((void *)(a1 + 200), a3, 0x20u);
  *(_QWORD *)(a1 + 240) = 0;
  *(_QWORD *)(a1 + 232) = *(_QWORD *)(a1 + 240);
  *(_DWORD *)(a1 + 128) = 0;
  return result;
}

//----- (00019EE0) --------------------------------------------------------
__int64 *__fastcall blake64(int a1, char *a2, size_t a3)
{
  __int64 *result; // r0
  unsigned __int64 v4; // r10
  unsigned __int64 v5; // r8
  unsigned __int64 v6; // [sp+0h] [bp+0h]
  unsigned __int64 v7; // [sp+8h] [bp+8h]
  unsigned __int64 v8; // [sp+10h] [bp+10h]
  unsigned __int64 v9; // [sp+18h] [bp+18h]
  unsigned __int64 v10; // [sp+20h] [bp+20h]
  unsigned __int64 v11; // [sp+28h] [bp+28h]
  unsigned __int64 v12; // [sp+30h] [bp+30h]
  unsigned __int64 v13; // [sp+38h] [bp+38h]
  unsigned __int64 v14; // [sp+40h] [bp+40h]
  unsigned __int64 v15; // [sp+48h] [bp+48h]
  unsigned __int64 v16; // [sp+50h] [bp+50h]
  unsigned __int64 v17; // [sp+58h] [bp+58h]
  unsigned __int64 v18; // [sp+60h] [bp+60h]
  unsigned __int64 v19; // [sp+68h] [bp+68h]
  unsigned __int64 v20; // [sp+70h] [bp+70h]
  unsigned __int64 v21; // [sp+78h] [bp+78h]
  unsigned __int64 v22; // [sp+80h] [bp+80h]
  unsigned __int64 v23; // [sp+88h] [bp+88h]
  unsigned __int64 v24; // [sp+90h] [bp+90h]
  unsigned __int64 v25; // [sp+98h] [bp+98h]
  unsigned __int64 v26; // [sp+A0h] [bp+A0h]
  unsigned __int64 v27; // [sp+A8h] [bp+A8h]
  unsigned __int64 v28; // [sp+B0h] [bp+B0h]
  unsigned __int64 v29; // [sp+B8h] [bp+B8h]
  unsigned __int64 v30; // [sp+C0h] [bp+C0h]
  unsigned __int64 v31; // [sp+C8h] [bp+C8h]
  unsigned __int64 v32; // [sp+D0h] [bp+D0h]
  unsigned __int64 v33; // [sp+D8h] [bp+D8h]
  unsigned __int64 v34; // [sp+E0h] [bp+E0h]
  unsigned __int64 v35; // [sp+E8h] [bp+E8h]
  size_t v36; // [sp+F4h] [bp+F4h]
  char *v37; // [sp+F8h] [bp+F8h]
  _QWORD v39[16]; // [sp+100h] [bp+100h]
  __int64 v40; // [sp+180h] [bp+180h]
  __int64 v41; // [sp+188h] [bp+188h]
  __int64 v42; // [sp+190h] [bp+190h]
  __int64 v43; // [sp+198h] [bp+198h]
  unsigned int *v44; // [sp+1A0h] [bp+1A0h]
  unsigned int i; // [sp+1A4h] [bp+1A4h]
  unsigned __int64 v46; // [sp+1A8h] [bp+1A8h]
  unsigned __int64 v47; // [sp+1B0h] [bp+1B0h]
  unsigned __int64 v48; // [sp+1B8h] [bp+1B8h]
  unsigned __int64 v49; // [sp+1C0h] [bp+1C0h]
  __int64 v50; // [sp+1C8h] [bp+1C8h]
  __int64 v51; // [sp+1D0h] [bp+1D0h]
  __int64 v52; // [sp+1D8h] [bp+1D8h]
  __int64 v53; // [sp+1E0h] [bp+1E0h]
  unsigned __int64 v54; // [sp+1E8h] [bp+1E8h]
  unsigned __int64 v55; // [sp+1F0h] [bp+1F0h]
  unsigned __int64 v56; // [sp+1F8h] [bp+1F8h]
  unsigned __int64 v57; // [sp+200h] [bp+200h]
  __int64 v58; // [sp+208h] [bp+208h]
  __int64 v59; // [sp+210h] [bp+210h]
  __int64 v60; // [sp+218h] [bp+218h]
  __int64 v61; // [sp+220h] [bp+220h]
  size_t n; // [sp+22Ch] [bp+22Ch]
  __int64 v63; // [sp+230h] [bp+230h] BYREF
  unsigned __int64 v64; // [sp+238h] [bp+238h]
  unsigned __int64 v65; // [sp+240h] [bp+240h]
  unsigned __int64 v66; // [sp+248h] [bp+248h]
  unsigned __int64 v67; // [sp+250h] [bp+250h]
  unsigned __int64 v68; // [sp+258h] [bp+258h]
  __int64 v69; // [sp+260h] [bp+260h]
  __int64 v70; // [sp+268h] [bp+268h]
  __int64 v71; // [sp+270h] [bp+270h]
  __int64 v72; // [sp+278h] [bp+278h]
  int v73; // [sp+284h] [bp+284h]

  v37 = a2;
  v36 = a3;
  v44 = (unsigned int *)a1;
  v73 = *(_DWORD *)(a1 + 128);
  if ( 128 - v73 <= a3 )
  {
    v72 = *(_QWORD *)(a1 + 136);
    v71 = *(_QWORD *)(a1 + 144);
    v70 = *(_QWORD *)(a1 + 152);
    v69 = *(_QWORD *)(a1 + 160);
    v68 = *(_QWORD *)(a1 + 168);
    v67 = *(_QWORD *)(a1 + 176);
    v66 = *(_QWORD *)(a1 + 184);
    v65 = *(_QWORD *)(a1 + 192);
    v43 = *(_QWORD *)(a1 + 200);
    v42 = *(_QWORD *)(a1 + 208);
    v41 = *(_QWORD *)(a1 + 216);
    v40 = *(_QWORD *)(a1 + 224);
    v64 = *(_QWORD *)(a1 + 232);
    v63 = *(_QWORD *)(a1 + 240);
    while ( v36 )
    {
      n = 128 - v73;
      if ( 128 - v73 > v36 )
        n = v36;
      memcpy((char *)v44 + v73, v37, n);
      v73 += n;
      v37 += n;
      v36 -= n;
      if ( v73 == 128 )
      {
        v64 += 1024LL;
        if ( v64 <= 0x3FF )
          ++v63;
        v61 = v72;
        v60 = v71;
        v59 = v70;
        v58 = v69;
        v57 = v68;
        v56 = v67;
        v55 = v66;
        v54 = v65;
        v53 = loc_1A3E0 ^ v43;
        v52 = loc_1A3E8 ^ v42;
        v51 = loc_1A3F0 ^ v41;
        v50 = loc_1A3F8 ^ v40;
        v49 = loc_1A400 ^ v64;
        v48 = loc_1A408 ^ v64;
        v47 = loc_1A410 ^ v63;
        v46 = loc_1A418 ^ v63;
        v39[0] = sph_dec64be_aligned(v44);
        v39[1] = sph_dec64be_aligned(v44 + 2);
        v39[2] = sph_dec64be_aligned(v44 + 4);
        v39[3] = sph_dec64be_aligned(v44 + 6);
        v39[4] = sph_dec64be_aligned(v44 + 8);
        v39[5] = sph_dec64be_aligned(v44 + 10);
        v39[6] = sph_dec64be_aligned(v44 + 12);
        v39[7] = sph_dec64be_aligned(v44 + 14);
        v39[8] = sph_dec64be_aligned(v44 + 16);
        v39[9] = sph_dec64be_aligned(v44 + 18);
        v39[10] = sph_dec64be_aligned(v44 + 20);
        v39[11] = sph_dec64be_aligned(v44 + 22);
        v39[12] = sph_dec64be_aligned(v44 + 24);
        v39[13] = sph_dec64be_aligned(v44 + 26);
        v39[14] = sph_dec64be_aligned(v44 + 28);
        v39[15] = sph_dec64be_aligned(v44 + 30);
        for ( i = 0; i <= 0xF; ++i )
        {
          v61 += (CB[sigma[16 * i + 1]] ^ v39[sigma[16 * i]]) + v57;
          LODWORD(v35) = (v61 ^ v49) >> 32;
          HIDWORD(v35) = v61 ^ v49;
          v49 = v35;
          v53 += v35;
          HIDWORD(v34) = ((unsigned int)((v53 ^ v57) >> 32) >> 25) | (((unsigned int)v53 ^ (unsigned int)v57) << 7);
          LODWORD(v34) = (__int64)(v53 ^ v57) >> 25;
          v57 = v34;
          v61 += (CB[sigma[16 * i]] ^ v39[sigma[16 * i + 1]]) + v34;
          HIDWORD(v33) = ((unsigned int)((v61 ^ v35) >> 32) >> 16) | (((unsigned int)v61 ^ (unsigned int)v35) << 16);
          LODWORD(v33) = (__int64)(v61 ^ v35) >> 16;
          v49 = v33;
          v53 += v33;
          HIDWORD(v32) = ((unsigned int)((v53 ^ v34) >> 32) >> 11) | (((unsigned int)v53 ^ (unsigned int)v34) << 21);
          LODWORD(v32) = (__int64)(v53 ^ v34) >> 11;
          v57 = v32;
          v60 += (CB[sigma[16 * i + 3]] ^ v39[sigma[16 * i + 2]]) + v56;
          LODWORD(v31) = (v60 ^ v48) >> 32;
          HIDWORD(v31) = v60 ^ v48;
          v48 = v31;
          v52 += v31;
          HIDWORD(v30) = ((unsigned int)((v52 ^ v56) >> 32) >> 25) | (((unsigned int)v52 ^ (unsigned int)v56) << 7);
          LODWORD(v30) = (__int64)(v52 ^ v56) >> 25;
          v56 = v30;
          v60 += (CB[sigma[16 * i + 2]] ^ v39[sigma[16 * i + 3]]) + v30;
          HIDWORD(v29) = ((unsigned int)((v60 ^ v31) >> 32) >> 16) | (((unsigned int)v60 ^ (unsigned int)v31) << 16);
          LODWORD(v29) = (__int64)(v60 ^ v31) >> 16;
          v48 = v29;
          v52 += v29;
          HIDWORD(v28) = ((unsigned int)((v52 ^ v30) >> 32) >> 11) | (((unsigned int)v52 ^ (unsigned int)v30) << 21);
          LODWORD(v28) = (__int64)(v52 ^ v30) >> 11;
          v56 = v28;
          v59 += (CB[sigma[16 * i + 5]] ^ v39[sigma[16 * i + 4]]) + v55;
          LODWORD(v27) = (v59 ^ v47) >> 32;
          HIDWORD(v27) = v59 ^ v47;
          v47 = v27;
          v51 += v27;
          HIDWORD(v26) = ((unsigned int)((v51 ^ v55) >> 32) >> 25) | (((unsigned int)v51 ^ (unsigned int)v55) << 7);
          LODWORD(v26) = (__int64)(v51 ^ v55) >> 25;
          v55 = v26;
          v59 += (CB[sigma[16 * i + 4]] ^ v39[sigma[16 * i + 5]]) + v26;
          HIDWORD(v25) = ((unsigned int)((v59 ^ v27) >> 32) >> 16) | (((unsigned int)v59 ^ (unsigned int)v27) << 16);
          LODWORD(v25) = (__int64)(v59 ^ v27) >> 16;
          v47 = v25;
          v51 += v25;
          HIDWORD(v24) = ((unsigned int)((v51 ^ v26) >> 32) >> 11) | (((unsigned int)v51 ^ (unsigned int)v26) << 21);
          LODWORD(v24) = (__int64)(v51 ^ v26) >> 11;
          v55 = v24;
          v58 += (CB[sigma[16 * i + 7]] ^ v39[sigma[16 * i + 6]]) + v54;
          LODWORD(v23) = (v58 ^ v46) >> 32;
          HIDWORD(v23) = v58 ^ v46;
          v46 = v23;
          v50 += v23;
          HIDWORD(v22) = ((unsigned int)((v50 ^ v54) >> 32) >> 25) | (((unsigned int)v50 ^ (unsigned int)v54) << 7);
          LODWORD(v22) = (__int64)(v50 ^ v54) >> 25;
          v54 = v22;
          v58 += (CB[sigma[16 * i + 6]] ^ v39[sigma[16 * i + 7]]) + v22;
          HIDWORD(v21) = ((unsigned int)((v58 ^ v23) >> 32) >> 16) | (((unsigned int)v58 ^ (unsigned int)v23) << 16);
          LODWORD(v21) = (__int64)(v58 ^ v23) >> 16;
          v46 = v21;
          v50 += v21;
          HIDWORD(v20) = ((unsigned int)((v50 ^ v22) >> 32) >> 11) | (((unsigned int)v50 ^ (unsigned int)v22) << 21);
          LODWORD(v20) = (__int64)(v50 ^ v22) >> 11;
          v54 = v20;
          v61 += (CB[sigma[16 * i + 9]] ^ v39[sigma[16 * i + 8]]) + v28;
          LODWORD(v19) = (v61 ^ v21) >> 32;
          HIDWORD(v19) = v61 ^ v21;
          v46 = v19;
          v51 += v19;
          HIDWORD(v18) = ((unsigned int)((v51 ^ v28) >> 32) >> 25) | (((unsigned int)v51 ^ (unsigned int)v28) << 7);
          LODWORD(v18) = (__int64)(v51 ^ v28) >> 25;
          v56 = v18;
          v61 += (CB[sigma[16 * i + 8]] ^ v39[sigma[16 * i + 9]]) + v18;
          HIDWORD(v17) = ((unsigned int)((v61 ^ v19) >> 32) >> 16) | (((unsigned int)v61 ^ (unsigned int)v19) << 16);
          LODWORD(v17) = (__int64)(v61 ^ v19) >> 16;
          v46 = v17;
          v51 += v17;
          HIDWORD(v16) = ((unsigned int)((v51 ^ v18) >> 32) >> 11) | (((unsigned int)v51 ^ (unsigned int)v18) << 21);
          LODWORD(v16) = (__int64)(v51 ^ v18) >> 11;
          v56 = v16;
          v60 += (CB[sigma[16 * i + 11]] ^ v39[sigma[16 * i + 10]]) + v24;
          LODWORD(v15) = (v60 ^ v33) >> 32;
          HIDWORD(v15) = v60 ^ v33;
          v49 = v15;
          v50 += v15;
          HIDWORD(v14) = ((unsigned int)((v50 ^ v24) >> 32) >> 25) | (((unsigned int)v50 ^ (unsigned int)v24) << 7);
          LODWORD(v14) = (__int64)(v50 ^ v24) >> 25;
          v55 = v14;
          v60 += (CB[sigma[16 * i + 10]] ^ v39[sigma[16 * i + 11]]) + v14;
          HIDWORD(v13) = ((unsigned int)((v60 ^ v15) >> 32) >> 16) | (((unsigned int)v60 ^ (unsigned int)v15) << 16);
          LODWORD(v13) = (__int64)(v60 ^ v15) >> 16;
          v49 = v13;
          v50 += v13;
          HIDWORD(v12) = ((unsigned int)((v50 ^ v14) >> 32) >> 11) | (((unsigned int)v50 ^ (unsigned int)v14) << 21);
          LODWORD(v12) = (__int64)(v50 ^ v14) >> 11;
          v55 = v12;
          v59 += (CB[sigma[16 * i + 13]] ^ v39[sigma[16 * i + 12]]) + v20;
          LODWORD(v11) = (v59 ^ v29) >> 32;
          HIDWORD(v11) = v59 ^ v29;
          v48 = v11;
          v53 += v11;
          HIDWORD(v10) = ((unsigned int)((v53 ^ v20) >> 32) >> 25) | (((unsigned int)v53 ^ (unsigned int)v20) << 7);
          LODWORD(v10) = (__int64)(v53 ^ v20) >> 25;
          v54 = v10;
          v59 += (CB[sigma[16 * i + 12]] ^ v39[sigma[16 * i + 13]]) + v10;
          HIDWORD(v9) = ((unsigned int)((v59 ^ v11) >> 32) >> 16) | (((unsigned int)v59 ^ (unsigned int)v11) << 16);
          LODWORD(v9) = (__int64)(v59 ^ v11) >> 16;
          v48 = v9;
          v53 += v9;
          HIDWORD(v8) = ((unsigned int)((v53 ^ v10) >> 32) >> 11) | (((unsigned int)v53 ^ (unsigned int)v10) << 21);
          LODWORD(v8) = (__int64)(v53 ^ v10) >> 11;
          v54 = v8;
          v58 += (CB[sigma[16 * i + 15]] ^ v39[sigma[16 * i + 14]]) + v32;
          LODWORD(v7) = (v58 ^ v25) >> 32;
          HIDWORD(v7) = v58 ^ v25;
          v47 = v7;
          v52 += v7;
          HIDWORD(v6) = ((unsigned int)((v52 ^ v32) >> 32) >> 25) | (((unsigned int)v52 ^ (unsigned int)v32) << 7);
          LODWORD(v6) = (__int64)(v52 ^ v32) >> 25;
          v57 = v6;
          v58 += (CB[sigma[16 * i + 14]] ^ v39[sigma[16 * i + 15]]) + v6;
          HIDWORD(v4) = (((unsigned int)v58 ^ (unsigned int)v7) << 16) | ((unsigned int)((v58 ^ v7) >> 32) >> 16);
          LODWORD(v4) = (__int64)(v58 ^ v7) >> 16;
          v47 = v4;
          v52 += v4;
          HIDWORD(v5) = (((unsigned int)v52 ^ (unsigned int)v6) << 21) | ((unsigned int)((v52 ^ v6) >> 32) >> 11);
          LODWORD(v5) = (__int64)(v52 ^ v6) >> 11;
          v57 = v5;
        }
        v72 ^= v43 ^ v61 ^ v53;
        v71 ^= v42 ^ v60 ^ v52;
        v70 ^= v41 ^ v59 ^ v51;
        v69 ^= v40 ^ v58 ^ v50;
        v68 ^= v43 ^ v57 ^ v49;
        v67 ^= v42 ^ v56 ^ v48;
        v66 ^= v41 ^ v55 ^ v47;
        v65 ^= v40 ^ v54 ^ v46;
        v73 = 0;
      }
    }
    *(_QWORD *)(a1 + 136) = v72;
    *(_QWORD *)(a1 + 144) = v71;
    *(_QWORD *)(a1 + 152) = v70;
    *(_QWORD *)(a1 + 160) = v69;
    *(_QWORD *)(a1 + 168) = v68;
    *(_QWORD *)(a1 + 176) = v67;
    *(_QWORD *)(a1 + 184) = v66;
    *(_QWORD *)(a1 + 192) = v65;
    *(_QWORD *)(a1 + 200) = v43;
    *(_QWORD *)(a1 + 208) = v42;
    *(_QWORD *)(a1 + 216) = v41;
    *(_QWORD *)(a1 + 224) = v40;
    *(_QWORD *)(a1 + 232) = v64;
    *(_QWORD *)(a1 + 240) = v63;
    *(_DWORD *)(a1 + 128) = v73;
    return &v63;
  }
  else
  {
    result = (__int64 *)memcpy((char *)v44 + v73, a2, a3);
    *(_DWORD *)(a1 + 128) = v73 + v36;
  }
  return result;
}
// 1B662: returning address of temporary local variable '%var_58'
// 2B390: using guessed type _DWORD sigma[256];
// 2B790: using guessed type _QWORD CB[16];

//----- (0001B688) --------------------------------------------------------
__int64 *__fastcall blake64_close(int a1, char a2, int a3, int a4, unsigned int a5)
{
  __int64 v5; // r2
  __int64 v6; // r2
  bool v7; // cf
  int v8; // r1
  int v9; // r1
  __int64 *result; // r0
  int v11; // r1
  int v12; // r1
  char s[112]; // [sp+10h] [bp+10h] BYREF
  __int64 v16; // [sp+80h] [bp+80h] BYREF
  __int64 v17; // [sp+88h] [bp+88h] BYREF
  int v18; // [sp+94h] [bp+94h]
  __int64 v19; // [sp+98h] [bp+98h]
  __int64 v20; // [sp+A0h] [bp+A0h]
  int v21; // [sp+A8h] [bp+A8h]
  unsigned int v22; // [sp+ACh] [bp+ACh]
  int v23; // [sp+B0h] [bp+B0h]
  unsigned int i; // [sp+B4h] [bp+B4h]

  v23 = *(_DWORD *)(a1 + 128);
  v22 = 8 * v23 + a3;
  v21 = 128 >> a3;
  s[v23] = (128 >> a3) | a2 & -(128 >> a3);
  v20 = v22 + *(_QWORD *)(a1 + 232);
  v19 = *(_QWORD *)(a1 + 240);
  if ( v23 || a3 )
  {
    if ( *(_QWORD *)(a1 + 232) )
    {
      *(_QWORD *)(a1 + 232) -= 1024 - v22;
    }
    else
    {
      LODWORD(v5) = v22 - 1024;
      HIDWORD(v5) = (v22 >= 0x400) - 1;
      *(_QWORD *)(a1 + 232) = v5;
      v6 = *(_QWORD *)(a1 + 240);
      v7 = (_DWORD)v6 != 0;
      LODWORD(v6) = v6 - 1;
      HIDWORD(v6) = v7 + HIDWORD(v6) - 1;
      *(_QWORD *)(a1 + 240) = v6;
    }
  }
  else
  {
    *(_QWORD *)(a1 + 232) = -1024;
    *(_QWORD *)(a1 + 240) = -1;
  }
  if ( v22 > 0x37E )
  {
    memset(&s[v23 + 1], 0, 127 - v23);
    blake64(a1, &s[v23], 128 - v23);
    *(_QWORD *)(a1 + 232) = -1024;
    *(_QWORD *)(a1 + 240) = -1;
    memset(s, 0, sizeof(s));
    if ( a5 == 8 )
      s[111] = 1;
    sph_enc64be_aligned(&v16, v11, v19, HIDWORD(v19));
    sph_enc64be_aligned(&v17, v12, v20, HIDWORD(v20));
    result = blake64(a1, s, 0x80u);
  }
  else
  {
    memset(&s[v23 + 1], 0, 111 - v23);
    if ( a5 == 8 )
      s[111] |= 1u;
    sph_enc64be_aligned(&v16, v8, v19, HIDWORD(v19));
    sph_enc64be_aligned(&v17, v9, v20, HIDWORD(v20));
    result = blake64(a1, &s[v23], 128 - v23);
  }
  v18 = a4;
  for ( i = 0; i < a5; ++i )
    result = (__int64 *)sph_enc64be(
                          (_BYTE *)(v18 + 8 * i),
                          v18 + 8 * i,
                          *(_DWORD *)(a1 + 8 * (i + 17)),
                          *(_DWORD *)(a1 + 8 * (i + 17) + 4));
  return result;
}
// 1B7D6: variable 'v8' is possibly undefined
// 1B7E6: variable 'v9' is possibly undefined
// 1B88A: variable 'v11' is possibly undefined
// 1B89A: variable 'v12' is possibly undefined

//----- (0001B8FC) --------------------------------------------------------
void *__fastcall sph_blake224_init(_DWORD *a1)
{
  return blake32_init(a1, &IV224, &salt_zero_small);
}

//----- (0001B924) --------------------------------------------------------
unsigned int __fastcall sph_blake224(unsigned int a1, char *a2, size_t a3)
{
  return blake32(a1, a2, a3);
}

//----- (0001B944) --------------------------------------------------------
void *__fastcall sph_blake224_close(_DWORD *a1, int a2)
{
  return sph_blake224_addbits_and_close(a1, 0, 0, a2);
}

//----- (0001B964) --------------------------------------------------------
void *__fastcall sph_blake224_addbits_and_close(_DWORD *a1, char a2, int a3, int a4)
{
  blake32_close(a1, a2, a3, a4, 7u);
  return sph_blake224_init(a1);
}

//----- (0001B990) --------------------------------------------------------
void *__fastcall sph_blake256_init(_DWORD *a1)
{
  return blake32_init(a1, &IV256, &salt_zero_small);
}

//----- (0001B9B8) --------------------------------------------------------
unsigned int __fastcall sph_blake256(unsigned int a1, char *a2, size_t a3)
{
  return blake32(a1, a2, a3);
}

//----- (0001B9D8) --------------------------------------------------------
void *__fastcall sph_blake256_close(_DWORD *a1, int a2)
{
  return sph_blake256_addbits_and_close(a1, 0, 0, a2);
}

//----- (0001B9F8) --------------------------------------------------------
void *__fastcall sph_blake256_addbits_and_close(_DWORD *a1, char a2, int a3, int a4)
{
  blake32_close(a1, a2, a3, a4, 8u);
  return sph_blake256_init(a1);
}

//----- (0001BA24) --------------------------------------------------------
void *__fastcall sph_blake384_init(int a1)
{
  return blake64_init(a1, &IV384, &salt_zero_big);
}

//----- (0001BA4C) --------------------------------------------------------
__int64 *__fastcall sph_blake384(int a1, char *a2, size_t a3)
{
  return blake64(a1, a2, a3);
}

//----- (0001BA6C) --------------------------------------------------------
void *__fastcall sph_blake384_close(int a1, int a2)
{
  return sph_blake384_addbits_and_close(a1, 0, 0, a2);
}

//----- (0001BA8C) --------------------------------------------------------
void *__fastcall sph_blake384_addbits_and_close(int a1, char a2, int a3, int a4)
{
  blake64_close(a1, a2, a3, a4, 6u);
  return sph_blake384_init(a1);
}

//----- (0001BAB8) --------------------------------------------------------
void *__fastcall sph_blake512_init(int a1)
{
  return blake64_init(a1, &IV512, &salt_zero_big);
}

//----- (0001BAE0) --------------------------------------------------------
__int64 *__fastcall sph_blake512(int a1, char *a2, size_t a3)
{
  return blake64(a1, a2, a3);
}

//----- (0001BB00) --------------------------------------------------------
void *__fastcall sph_blake512_close(int a1, int a2)
{
  return sph_blake512_addbits_and_close(a1, 0, 0, a2);
}

//----- (0001BB20) --------------------------------------------------------
void *__fastcall sph_blake512_addbits_and_close(int a1, char a2, int a3, int a4)
{
  blake64_close(a1, a2, a3, a4, 8u);
  return sph_blake512_init(a1);
}

//----- (0001BB50) --------------------------------------------------------
unsigned int *__fastcall platform_dump_capability(unsigned int *result)
{
  unsigned int *v1; // [sp+4h] [bp+4h]
  unsigned int j; // [sp+8h] [bp+8h]
  unsigned int i; // [sp+Ch] [bp+Ch]

  v1 = result;
  if ( result )
  {
    printf("%s:%d", "platform_dump_capability", 32);
    puts("==========================capability start==========================");
    printf("%s:%d", "platform_dump_capability", 33);
    printf("board num = %d\n", *v1);
    for ( i = 0; i < *v1; ++i )
    {
      printf("%s:%d", "platform_dump_capability", 35);
      printf("board id = %d, chain num = %d\n", v1[18 * i + 1], v1[18 * i + 2]);
      for ( j = 0; j < v1[18 * i + 2]; ++j )
      {
        printf("%s:%d", "platform_dump_capability", 37);
        printf("\tchain id = %d\n", v1[18 * i + 3 + j]);
      }
    }
    printf("%s:%d", "platform_dump_capability", 41);
    return (unsigned int *)puts("==========================capability end============================");
  }
  return result;
}

//----- (0001BC94) --------------------------------------------------------
int platform_init()
{
  unsigned int v2; // [sp+Ch] [bp+4h] BYREF
  char s[512]; // [sp+10h] [bp+8h] BYREF
  char *v4; // [sp+210h] [bp+208h]
  int v5; // [sp+214h] [bp+20Ch]

  if ( platform_inited )
    return 0;
  if ( fpga_init() )
  {
    printf("%s:%d", "platform_init", 47);
    puts("fpga init failed");
    return -1;
  }
  else if ( gpio_init() )
  {
    printf("%s:%d", "platform_init", 51);
    puts("gpio init failed");
    return -2;
  }
  else
  {
    memset(capability, 0, sizeof(capability));
    v4 = getenv("HAL_CONFIG_PATH");
    if ( v4 )
      snprintf(s, 0x200u, "%s/%s", v4, "hal_conf.json");
    else
      snprintf(s, 0x200u, "/media/card/%s", "hal_conf.json");
    printf("%s:%d", "platform_init", 65);
    printf("hal config path = %s\n", s);
    if ( hal_load_conf(s) )
    {
      fpga_uninit();
      gpio_uninit();
      printf("%s:%d", "platform_init", 69);
      puts("failed to load hal config");
      return -3;
    }
    else
    {
      v2 = 0;
      v5 = 0;
      fpga_read(2, &v2);
      if ( v2 )
      {
        if ( (v2 & 0xFF000000) != 0 )
        {
          platform_is_t9 = 1;
          v2 >>= 24;
          printf("%s:%d", "platform_init", 81);
          printf("HASH_ON_PLUG T9 = 0x%x\n", v2);
        }
        else
        {
          platform_is_t9 = 0;
          v2 = (unsigned __int16)v2;
          printf("%s:%d", "platform_init", 87);
          printf("HASH_ON_PLUG V9 = 0x%x\n", v2);
          while ( v2 )
          {
            if ( (v2 & 1) != 0 )
            {
              printf("%s:%d", "platform_init", 90);
              printf("slot %d pluged\n", v5);
              capability[18 * capability[0] + 1] = v5;
              capability[18 * capability[0] + 3 + capability[18 * capability[0] + 2]++] = v5;
              ++capability[0];
            }
            v2 >>= 1;
            ++v5;
          }
        }
      }
      else
      {
        printf("%s:%d", "platform_init", 76);
        puts("Cannot Find Any Plug In!\r");
      }
      if ( platform_is_t9 )
        fpga_read(t9_fpga_map, &v2);
      else
        fpga_read(v9_fpga_map, &v2);
      v2 |= 0x20000000u;
      printf("%s:%d", "platform_init", 104);
      printf("HARDWARE_VERSION = 0x%x\n", v2);
      if ( platform_is_t9 )
        fpga_write(t9_fpga_map, v2);
      else
        fpga_write(v9_fpga_map, v2);
      platform_dump_capability(capability);
      platform_inited = 1;
      fan_init();
      ui_init();
      uart_init();
      return 0;
    }
  }
}
// 35550: using guessed type int t9_fpga_map;
// 357E4: using guessed type int v9_fpga_map;
// 235C54: using guessed type int platform_inited;
// 235C58: using guessed type int platform_is_t9;
// 235C5C: using guessed type unsigned int capability[73];

//----- (0001C098) --------------------------------------------------------
int platform_uninit()
{
  int result; // r0

  if ( platform_inited )
  {
    uart_uninit();
    fpga_uninit();
    fan_uninit();
    ui_uninit();
    result = gpio_uninit();
    platform_inited = 0;
  }
  return result;
}
// 235C54: using guessed type int platform_inited;

//----- (0001C0CC) --------------------------------------------------------
void *__fastcall get_system_capability(void *result)
{
  if ( result )
    return memcpy(result, &capability, 0x124u);
  return result;
}
// 235C5C: using guessed type int capability;

//----- (0001C0F4) --------------------------------------------------------
int __fastcall get_eth_mac(const char *a1, int a2)
{
  char dest[32]; // [sp+8h] [bp+8h] BYREF
  int fd; // [sp+28h] [bp+28h]
  int i; // [sp+2Ch] [bp+2Ch]

  fd = socket(2, 1, 0);
  if ( fd >= 0 )
  {
    strcpy(dest, a1);
    if ( ioctl(fd, 0x8927u, dest) >= 0 )
    {
      for ( i = 0; i <= 5; ++i )
        *(_BYTE *)(a2 + i) = dest[i + 18];
      close(fd);
      return 0;
    }
    else
    {
      printf("%s:%d", "get_eth_mac", 149);
      printf("error ioctl");
      close(fd);
      return -2;
    }
  }
  else
  {
    printf("%s:%d", "get_eth_mac", 143);
    printf("error sock");
    return -1;
  }
}

//----- (0001C1C4) --------------------------------------------------------
int __fastcall get_uuid(void *a1)
{
  if ( !a1 )
    return -1;
  memset(a1, 0, 0x10u);
  return get_eth_mac("eth0", (int)a1);
}

//----- (0001C200) --------------------------------------------------------
int __fastcall get_mac(int a1)
{
  if ( a1 )
    return get_eth_mac("eth0", a1);
  else
    return -1;
}

//----- (0001C230) --------------------------------------------------------
int __fastcall chain_reset(char a1)
{
  chain_reset_low(a1);
  usleep(0x186A0u);
  return chain_reset_high(a1);
}

//----- (0001C25C) --------------------------------------------------------
int __fastcall chain_reset_low(char a1)
{
  int v3; // [sp+Ch] [bp+Ch] BYREF

  v3 = 0;
  if ( platform_is_t9 )
    fpga_read(dword_35580, &v3);
  else
    fpga_read(dword_35814, &v3);
  v3 |= 1 << a1;
  if ( platform_is_t9 )
    return fpga_write(dword_35580, v3);
  else
    return fpga_write(dword_35814, v3);
}
// 35580: using guessed type int dword_35580;
// 35814: using guessed type int dword_35814;
// 235C58: using guessed type int platform_is_t9;

//----- (0001C2F4) --------------------------------------------------------
int __fastcall chain_reset_high(char a1)
{
  int v3; // [sp+Ch] [bp+Ch] BYREF

  v3 = 0;
  if ( platform_is_t9 )
    fpga_read(dword_35580, &v3);
  else
    fpga_read(dword_35814, &v3);
  v3 &= ~(1 << a1);
  if ( platform_is_t9 )
    return fpga_write(dword_35580, v3);
  else
    return fpga_write(dword_35814, v3);
}
// 35580: using guessed type int dword_35580;
// 35814: using guessed type int dword_35814;
// 235C58: using guessed type int platform_is_t9;

//----- (0001C390) --------------------------------------------------------
void board_reset()
{
  board_reset_low();
  usleep(0x186A0u);
  board_reset_high();
}

//----- (0001C3B8) --------------------------------------------------------
void board_reset_low()
{
  ;
}

//----- (0001C3CC) --------------------------------------------------------
void board_reset_high()
{
  ;
}

//----- (0001C3E0) --------------------------------------------------------
int get_hardware_type()
{
  int v2; // [sp+4h] [bp+4h] BYREF

  v2 = 0;
  if ( platform_inited )
  {
    if ( platform_is_t9 )
      fpga_read(t9_fpga_map, &v2);
    else
      fpga_read(v9_fpga_map, &v2);
    return v2 < 0;
  }
  else
  {
    printf("%s:%d", "get_hardware_type", 222);
    puts("platform not inited");
    return 2;
  }
}
// 35550: using guessed type int t9_fpga_map;
// 357E4: using guessed type int v9_fpga_map;
// 235C54: using guessed type int platform_inited;
// 235C58: using guessed type int platform_is_t9;

//----- (0001C46C) --------------------------------------------------------
int __fastcall set_hardware_type(int a1)
{
  int v4; // [sp+Ch] [bp+Ch] BYREF

  v4 = 0;
  if ( platform_inited )
  {
    if ( platform_is_t9 )
      fpga_read(t9_fpga_map, &v4);
    else
      fpga_read(v9_fpga_map, &v4);
    if ( a1 )
    {
      if ( a1 == 1 )
        v4 |= 0x80000000;
    }
    else
    {
      v4 &= ~0x80000000;
    }
    if ( platform_is_t9 )
      fpga_write(t9_fpga_map, v4);
    else
      fpga_write(v9_fpga_map, v4);
    return 0;
  }
  else
  {
    printf("%s:%d", "set_hardware_type", 237);
    puts("platform not inited");
    return -2;
  }
}
// 35550: using guessed type int t9_fpga_map;
// 357E4: using guessed type int v9_fpga_map;
// 235C54: using guessed type int platform_inited;
// 235C58: using guessed type int platform_is_t9;

//----- (0001C550) --------------------------------------------------------
int enable_bypass_mode()
{
  int v2; // [sp+4h] [bp+4h] BYREF

  v2 = 0;
  if ( platform_inited )
  {
    if ( platform_is_t9 )
      fpga_read(t9_fpga_map, &v2);
    else
      fpga_read(v9_fpga_map, &v2);
    v2 |= 0x20000000u;
    if ( platform_is_t9 )
      fpga_write(t9_fpga_map, v2);
    else
      fpga_write(v9_fpga_map, v2);
    return 0;
  }
  else
  {
    printf("%s:%d", "enable_bypass_mode", 260);
    puts("platform not inited");
    return -2;
  }
}
// 35550: using guessed type int t9_fpga_map;
// 357E4: using guessed type int v9_fpga_map;
// 235C54: using guessed type int platform_inited;
// 235C58: using guessed type int platform_is_t9;

//----- (0001C618) --------------------------------------------------------
int disable_bypass_mode()
{
  int v2; // [sp+4h] [bp+4h] BYREF

  v2 = 0;
  if ( platform_inited )
  {
    if ( platform_is_t9 )
      fpga_read(t9_fpga_map, &v2);
    else
      fpga_read(v9_fpga_map, &v2);
    v2 &= ~0x20000000u;
    if ( platform_is_t9 )
      fpga_write(t9_fpga_map, v2);
    else
      fpga_write(v9_fpga_map, v2);
    return 0;
  }
  else
  {
    printf("%s:%d", "disable_bypass_mode", 274);
    puts("platform not inited");
    return -2;
  }
}
// 35550: using guessed type int t9_fpga_map;
// 357E4: using guessed type int v9_fpga_map;
// 235C54: using guessed type int platform_inited;
// 235C58: using guessed type int platform_is_t9;

//----- (0001C6E0) --------------------------------------------------------
bool is_bypass_mode_enable()
{
  int v2; // [sp+4h] [bp+4h] BYREF

  v2 = 0;
  if ( platform_inited )
  {
    if ( platform_is_t9 )
      fpga_read(t9_fpga_map, &v2);
    else
      fpga_read(v9_fpga_map, &v2);
    v2 &= 0x20000000u;
    return v2 != 0;
  }
  else
  {
    printf("%s:%d", "is_bypass_mode_enable", 288);
    puts("platform not inited");
    return 0;
  }
}
// 35550: using guessed type int t9_fpga_map;
// 357E4: using guessed type int v9_fpga_map;
// 235C54: using guessed type int platform_inited;
// 235C58: using guessed type int platform_is_t9;

//----- (0001C778) --------------------------------------------------------
int get_hardware_version()
{
  int v2; // [sp+4h] [bp+4h] BYREF

  v2 = 0;
  if ( platform_inited )
  {
    if ( platform_is_t9 )
      fpga_read(t9_fpga_map, &v2);
    else
      fpga_read(v9_fpga_map, &v2);
    return (unsigned __int16)v2;
  }
  else
  {
    printf("%s:%d", "get_hardware_version", 301);
    puts("platform not inited");
    return 0;
  }
}
// 35550: using guessed type int t9_fpga_map;
// 357E4: using guessed type int v9_fpga_map;
// 235C54: using guessed type int platform_inited;
// 235C58: using guessed type int platform_is_t9;

//----- (0001C800) --------------------------------------------------------
int fan_init()
{
  if ( platform_inited )
    return 0;
  printf("%s:%d", "fan_init", 11);
  puts("please init platform first!!");
  return -1;
}
// 235C54: using guessed type int platform_inited;

//----- (0001C840) --------------------------------------------------------
void fan_uninit()
{
  ;
}

//----- (0001C84C) --------------------------------------------------------
int __fastcall fan_get_realtime_speed(int a1)
{
  unsigned int v4; // [sp+8h] [bp+8h] BYREF
  int i; // [sp+Ch] [bp+Ch]

  v4 = 0;
  for ( i = 0; i <= 5; ++i )
  {
    if ( platform_is_t9 )
      fpga_read(dword_35554, &v4);
    else
      fpga_read(dword_357E8, &v4);
    printf("%s:%d", "fan_get_realtime_speed", 32);
    printf("FAN_SPEED fpga value = 0x%x\n", v4);
    if ( ((v4 >> 8) & 7) == a1 )
      return 120 * (unsigned __int8)v4;
    usleep(0x2710u);
  }
  return -1;
}
// 35554: using guessed type int dword_35554;
// 357E8: using guessed type int dword_357E8;
// 235C58: using guessed type int platform_is_t9;

//----- (0001C900) --------------------------------------------------------
int fan_get_max_num()
{
  return hal_fan_number();
}

//----- (0001C910) --------------------------------------------------------
int __fastcall fan_get_max_speed(int a1)
{
  return hal_fan_max_speed(a1);
}

//----- (0001C92C) --------------------------------------------------------
int reset()
{
  int v1; // [sp+4h] [bp+4h] BYREF

  v1 = -2147450880;
  fpga_write(16, -2147450880);
  do
  {
    usleep(0x186A0u);
    fpga_read(16, &v1);
  }
  while ( v1 < 0 );
  printf("%s:%d", "reset", 291);
  return puts("fpga reset success");
}

//----- (0001C98C) --------------------------------------------------------
int fpga_init()
{
  if ( fpga_inited )
    return 0;
  fpga_fd = open("/dev/axi_fpga_dev", 2);
  if ( fpga_fd >= 0 )
  {
    axi_fpga_addr = (int)mmap(0, 0x1200u, 3, 1, fpga_fd, 0);
    if ( axi_fpga_addr )
    {
      printf("%s:%d", "fpga_init", 314);
      printf("fpga_init success. axi_fpga_addr = 0x%x\n", axi_fpga_addr);
      reset();
      fpga_inited = 1;
      return 0;
    }
    else
    {
      printf("%s:%d", "fpga_init", 310);
      printf("mmap axi_fpga_addr failed. axi_fpga_addr = 0x%x\n", axi_fpga_addr);
      close(fpga_fd);
      return -2;
    }
  }
  else
  {
    printf("%s:%d", "fpga_init", 303);
    printf("/dev/axi_fpga_dev open failed. fd = %d\n", fpga_fd);
    return -1;
  }
}
// 235D80: using guessed type int fpga_inited;
// 235D84: using guessed type int fpga_fd;
// 235D88: using guessed type int axi_fpga_addr;

//----- (0001CAC8) --------------------------------------------------------
void fpga_uninit()
{
  if ( fpga_inited )
  {
    if ( munmap((void *)axi_fpga_addr, 0x1200u) < 0 )
    {
      printf("%s:%d", "fpga_uninit", 330);
      puts("munmap failed!");
    }
    fpga_inited = 0;
    close(fpga_fd);
  }
}
// 235D80: using guessed type int fpga_inited;
// 235D84: using guessed type int fpga_fd;
// 235D88: using guessed type int axi_fpga_addr;

//----- (0001CB44) --------------------------------------------------------
int __fastcall fpga_read(int a1, _DWORD *a2)
{
  *a2 = *(_DWORD *)(axi_fpga_addr + 4 * a1);
  return 0;
}
// 235D88: using guessed type int axi_fpga_addr;

//----- (0001CB74) --------------------------------------------------------
int __fastcall fpga_write(int a1, int a2)
{
  *(_DWORD *)(axi_fpga_addr + 4 * a1) = a2;
  return 0;
}
// 235D88: using guessed type int axi_fpga_addr;

//----- (0001CBA0) --------------------------------------------------------
int __fastcall gpio_compare_e(_DWORD *a1, _DWORD *a2)
{
  return *a1 - *a2;
}

//----- (0001CBC0) --------------------------------------------------------
int gpio_thread_function()
{
  _DWORD v1[2]; // [sp+Ch] [bp+Ch] BYREF
  unsigned __int8 v2; // [sp+17h] [bp+17h] BYREF
  int v3; // [sp+18h] [bp+18h]
  void *ptr; // [sp+1Ch] [bp+1Ch]
  int v5; // [sp+20h] [bp+20h]
  _DWORD *v6; // [sp+24h] [bp+24h]
  int v7; // [sp+28h] [bp+28h]
  int i; // [sp+2Ch] [bp+2Ch]

  v7 = 0;
  while ( gpio_thread )
  {
    if ( !pthread_mutex_lock(&gpio_ctrl_map) )
    {
      v6 = new_iterator_c_map(dword_235DC8);
      for ( i = ((int (__fastcall *)(_DWORD *))*v6)(v6); i; i = ((int (__fastcall *)(_DWORD *))*v6)(v6) )
      {
        v5 = v6[5];
        ptr = (void *)((int (__fastcall *)(int))v6[2])(i);
        v3 = ***(_DWORD ***)(v5 + 16);
        v2 = 0;
        v7 = gpio_read(v3, &v2);
        if ( v7 )
        {
          printf("%s:%d", "gpio_thread_function", 50);
          printf("failed to read gpio port %d\n", v3);
          free(ptr);
          break;
        }
        if ( *((_DWORD *)ptr + 1) != v2 )
        {
          printf("%s:%d", "gpio_thread_function", 55);
          printf("gpio port %d, last val = %d, new val = %d\n", ***(_DWORD ***)(v5 + 16), *((_DWORD *)ptr + 1), v2);
          (*(void (__fastcall **)(int, _DWORD))ptr)(v3, v2);
          v1[0] = *(_DWORD *)ptr;
          v1[1] = v2;
          ((void (__fastcall *)(_DWORD *, _DWORD *, int))v6[1])(v6, v1, 8);
        }
        free(ptr);
      }
      delete_iterator_c_map(v6);
      pthread_mutex_unlock(&gpio_ctrl_map);
    }
    usleep(0x30D40u);
  }
  return 0;
}
// 1CBC0: using guessed type int gpio_thread_function();
// 235D90: using guessed type int gpio_thread;
// 235DB0: using guessed type pthread_mutex_t gpio_ctrl_map;
// 235DC8: using guessed type int dword_235DC8;

//----- (0001CD20) --------------------------------------------------------
int gpio_init()
{
  if ( gpio_inited )
  {
    printf("%s:%d", "gpio_init", 78);
    puts("gpio re init");
  }
  else
  {
    pthread_mutex_init(&gpio_ctrl_map, 0);
    dword_235DC8 = (int)new_c_map((int)gpio_compare_e, 0, 0);
    pthread_mutex_init(&api_mutex, 0);
    gpio_thread = 1;
    pthread_create((pthread_t *)&thread, 0, (void *(*)(void *))gpio_thread_function, 0);
    gpio_inited = 1;
  }
  return 0;
}
// 1CBC0: using guessed type int gpio_thread_function();
// 235D8C: using guessed type int gpio_inited;
// 235D90: using guessed type int gpio_thread;
// 235D94: using guessed type int thread;
// 235D98: using guessed type pthread_mutex_t api_mutex;
// 235DB0: using guessed type pthread_mutex_t gpio_ctrl_map;
// 235DC8: using guessed type int dword_235DC8;

//----- (0001CDC8) --------------------------------------------------------
int gpio_uninit()
{
  int result; // r0

  if ( gpio_inited )
  {
    gpio_thread = 0;
    pthread_join(thread, 0);
    pthread_mutex_destroy(&gpio_ctrl_map);
    delete_c_map((void ****)dword_235DC8);
    gpio_inited = 0;
    return pthread_mutex_destroy(&api_mutex);
  }
  return result;
}
// 235D8C: using guessed type int gpio_inited;
// 235D90: using guessed type int gpio_thread;
// 235D94: using guessed type int thread;
// 235D98: using guessed type pthread_mutex_t api_mutex;
// 235DB0: using guessed type pthread_mutex_t gpio_ctrl_map;
// 235DC8: using guessed type int dword_235DC8;

//----- (0001CE30) --------------------------------------------------------
int __fastcall gpio_reg_callback(int a1, int a2)
{
  int v5; // [sp+Ch] [bp+4h] BYREF
  _DWORD v6[2]; // [sp+10h] [bp+8h] BYREF

  v5 = a1;
  if ( a2 )
  {
    if ( pthread_mutex_lock(&gpio_ctrl_map) )
    {
      printf("%s:%d", "gpio_reg_callback", 124);
      puts("fail to lock gpio ctrl mutex");
      return -1;
    }
    else
    {
      if ( exists_c_map((int *)dword_235DC8, (int)&v5) )
      {
        printf("%s:%d", "gpio_reg_callback", 133);
        printf("port %d already exist in callback map \n", v5);
      }
      else
      {
        printf("%s:%d", "gpio_reg_callback", 129);
        printf("add %d to callback map\n", v5);
        v6[0] = a2;
        v6[1] = -1;
        insert_c_map((int *)dword_235DC8, &v5, 4u, v6, 8u);
      }
      pthread_mutex_unlock(&gpio_ctrl_map);
      return 0;
    }
  }
  else
  {
    printf("%s:%d", "gpio_reg_callback", 120);
    puts("bad param");
    return -1;
  }
}
// 235DB0: using guessed type pthread_mutex_t gpio_ctrl_map;
// 235DC8: using guessed type int dword_235DC8;

//----- (0001CF4C) --------------------------------------------------------
int __fastcall gpio_unreg_callback(int a1, int a2)
{
  int v4; // [sp+4h] [bp+4h] BYREF

  v4 = a1;
  if ( a2 )
  {
    if ( pthread_mutex_lock(&gpio_ctrl_map) )
    {
      printf("%s:%d", "gpio_unreg_callback", 152);
      puts("fail to lock gpio ctrl mutex");
      return -1;
    }
    else
    {
      if ( exists_c_map((int *)dword_235DC8, (int)&v4) )
      {
        printf("%s:%d", "gpio_unreg_callback", 157);
        printf("remove %d from callback list\n", v4);
        remove_c_map((int *)dword_235DC8, (int)&v4);
      }
      else
      {
        printf("%s:%d", "gpio_unreg_callback", 160);
        puts("callback function not registered before");
      }
      pthread_mutex_unlock(&gpio_ctrl_map);
      return 0;
    }
  }
  else
  {
    printf("%s:%d", "gpio_unreg_callback", 148);
    puts("bad param");
    return -1;
  }
}
// 235DB0: using guessed type pthread_mutex_t gpio_ctrl_map;
// 235DC8: using guessed type int dword_235DC8;

//----- (0001D050) --------------------------------------------------------
int __fastcall gpio_export(int a1)
{
  char s[64]; // [sp+8h] [bp+8h] BYREF
  size_t n; // [sp+48h] [bp+48h]
  int fd; // [sp+4Ch] [bp+4Ch]

  if ( pthread_mutex_lock(&api_mutex) )
  {
    printf("%s:%d", "gpio_export", 177);
    puts("failed to api lock");
    return -1;
  }
  else
  {
    snprintf(s, 0x40u, "/sys/class/gpio/gpio%d", a1);
    if ( access(s, 0) )
    {
      fd = open("/sys/class/gpio/export", 1);
      if ( fd >= 0 )
      {
        n = snprintf(s, 0x40u, "%d", a1);
        if ( write(fd, s, n) >= 0 )
        {
          printf("%s:%d", "gpio_export", 203);
          printf("export gpio %d success\n", a1);
          close(fd);
          pthread_mutex_unlock(&api_mutex);
          return 0;
        }
        else
        {
          printf("%s:%d", "gpio_export", 198);
          printf("Failed to export gpio %d!", a1);
          close(fd);
          pthread_mutex_unlock(&api_mutex);
          return -3;
        }
      }
      else
      {
        printf("%s:%d", "gpio_export", 191);
        puts("Failed to open export for writing!");
        pthread_mutex_unlock(&api_mutex);
        return -2;
      }
    }
    else
    {
      printf("%s:%d", "gpio_export", 183);
      printf("port %d already exported\n", a1);
      perror("access error");
      pthread_mutex_unlock(&api_mutex);
      return 0;
    }
  }
}
// 235D98: using guessed type pthread_mutex_t api_mutex;

//----- (0001D1F0) --------------------------------------------------------
int __fastcall gpio_unexport(int a1)
{
  char s[64]; // [sp+8h] [bp+8h] BYREF
  size_t n; // [sp+48h] [bp+48h]
  int fd; // [sp+4Ch] [bp+4Ch]

  if ( pthread_mutex_lock(&api_mutex) )
  {
    printf("%s:%d", "gpio_unexport", 220);
    puts("failed to api lock");
    return -1;
  }
  else
  {
    snprintf(s, 0x40u, "/sys/class/gpio/gpio%d", a1);
    fd = access(s, 0);
    if ( fd )
    {
      printf("%s:%d", "gpio_unexport", 226);
      printf("port %d already unexported, ret = %d\n", a1, fd);
      perror("access error");
      pthread_mutex_unlock(&api_mutex);
      return 0;
    }
    else
    {
      fd = open("/sys/class/gpio/unexport", 1);
      if ( fd >= 0 )
      {
        n = snprintf(s, 0x40u, "%d", a1);
        if ( write(fd, s, n) >= 0 )
        {
          printf("%s:%d", "gpio_unexport", 246);
          printf("unexport gpio %d success\n", a1);
          close(fd);
          pthread_mutex_unlock(&api_mutex);
          return 0;
        }
        else
        {
          printf("%s:%d", "gpio_unexport", 241);
          printf("Failed to unexport gpio %d!", a1);
          close(fd);
          pthread_mutex_unlock(&api_mutex);
          return -2;
        }
      }
      else
      {
        printf("%s:%d", "gpio_unexport", 234);
        puts("Failed to open unexport for writing!");
        pthread_mutex_unlock(&api_mutex);
        return -2;
      }
    }
  }
}
// 235D98: using guessed type pthread_mutex_t api_mutex;

//----- (0001D394) --------------------------------------------------------
int __fastcall gpio_direction(int a1, int a2)
{
  int v3; // r2
  char *v4; // r2
  size_t v5; // r3
  int v6; // r2
  int v7; // r2
  char s[64]; // [sp+Ch] [bp+Ch] BYREF
  int fd; // [sp+4Ch] [bp+4Ch]

  if ( pthread_mutex_lock(&api_mutex) )
  {
    printf("%s:%d", "gpio_direction", 266);
    puts("failed to api lock");
    return -1;
  }
  else
  {
    snprintf(s, 0x40u, "/sys/class/gpio/gpio%d/direction", a1);
    fd = open(s, 1);
    if ( fd >= 0 )
    {
      if ( a2 )
        v3 = 3;
      else
        v3 = 0;
      v4 = &dir_str_6737[v3];
      if ( a2 )
        v5 = 3;
      else
        v5 = 2;
      if ( write(fd, v4, v5) >= 0 )
      {
        printf("%s:%d", "gpio_direction", 284);
        if ( a2 )
          v7 = 3;
        else
          v7 = 0;
        printf("set gpio %d direction %s success!\n", a1, &dir_str_6737[v7]);
        close(fd);
        pthread_mutex_unlock(&api_mutex);
        return 0;
      }
      else
      {
        printf("%s:%d", "gpio_direction", 279);
        if ( a2 )
          v6 = 3;
        else
          v6 = 0;
        printf("Failed to set gpio %d direction %s !\n", a1, &dir_str_6737[v6]);
        close(fd);
        pthread_mutex_unlock(&api_mutex);
        return -3;
      }
    }
    else
    {
      printf("%s:%d", "gpio_direction", 273);
      printf("Failed to open gpio %d direction for writing!\n", a1);
      pthread_mutex_unlock(&api_mutex);
      return -2;
    }
  }
}
// 235D98: using guessed type pthread_mutex_t api_mutex;

//----- (0001D520) --------------------------------------------------------
int __fastcall gpio_read(int a1, _BYTE *a2)
{
  int buf; // [sp+8h] [bp+8h] BYREF
  char s[64]; // [sp+Ch] [bp+Ch] BYREF
  int fd; // [sp+4Ch] [bp+4Ch]

  buf = 0;
  if ( pthread_mutex_lock(&api_mutex) )
  {
    printf("%s:%d", "gpio_read", 303);
    puts("failed to api lock");
    return -1;
  }
  else
  {
    snprintf(s, 0x40u, "/sys/class/gpio/gpio%d/value", a1);
    fd = open(s, 0);
    if ( fd >= 0 )
    {
      if ( read(fd, &buf, 4u) >= 0 )
      {
        close(fd);
        pthread_mutex_unlock(&api_mutex);
        *a2 = atoi((const char *)&buf);
        return 0;
      }
      else
      {
        printf("%s:%d", "gpio_read", 316);
        puts("Failed to read value!");
        close(fd);
        pthread_mutex_unlock(&api_mutex);
        return -3;
      }
    }
    else
    {
      printf("%s:%d", "gpio_read", 310);
      printf("Failed to open gpio %d value for reading!\n", a1);
      pthread_mutex_unlock(&api_mutex);
      return -2;
    }
  }
}
// 235D98: using guessed type pthread_mutex_t api_mutex;

//----- (0001D64C) --------------------------------------------------------
int __fastcall gpio_write(int a1, char a2)
{
  char s[64]; // [sp+Ch] [bp+Ch] BYREF
  int fd; // [sp+4Ch] [bp+4Ch]

  if ( pthread_mutex_lock(&api_mutex) )
  {
    printf("%s:%d", "gpio_write", 341);
    puts("failed to api lock");
    return -1;
  }
  else
  {
    snprintf(s, 0x40u, "/sys/class/gpio/gpio%d/value", a1);
    fd = open(s, 1);
    if ( fd >= 0 )
    {
      if ( write(fd, &values_str_6753[a2 != 0], 1u) >= 0 )
      {
        close(fd);
        pthread_mutex_unlock(&api_mutex);
        return 0;
      }
      else
      {
        printf("%s:%d", "gpio_write", 354);
        puts("Failed to write value!");
        close(fd);
        pthread_mutex_unlock(&api_mutex);
        return -3;
      }
    }
    else
    {
      printf("%s:%d", "gpio_write", 348);
      puts("Failed to open gpio value for writing!");
      pthread_mutex_unlock(&api_mutex);
      return -2;
    }
  }
}
// 235D98: using guessed type pthread_mutex_t api_mutex;

//----- (0001D778) --------------------------------------------------------
int __fastcall iic_init(int a1)
{
  int v4; // [sp+10h] [bp+8h]
  int v5; // [sp+14h] [bp+Ch]

  v4 = 0;
  if ( pthread_mutex_lock(&iic_mutex) )
  {
    printf("%s:%d", "iic_init", 19);
    puts("failed to iic lock");
    return -4;
  }
  else
  {
    if ( a1 )
    {
      v4 = i2c_init();
      if ( v4 >= 0 )
      {
        printf("%s:%d", "iic_init", 35);
        printf(
          "i2c chain = %d, master = 0x%x, slave high= 0x%x, slave low = 0x%x\n",
          *(_DWORD *)a1,
          *(unsigned __int16 *)(a1 + 4),
          *(unsigned __int8 *)(a1 + 6),
          *(unsigned __int8 *)(a1 + 7));
        if ( i2c_select(v4, *(unsigned __int16 *)(a1 + 4)) )
        {
          printf("%s:%d", "iic_init", 37);
          puts("failed to i2c_select");
          v5 = -1;
        }
        else
        {
          if ( !i2c_ioctl(v4, 1795, (2 * *(unsigned __int8 *)(a1 + 7)) | (16 * *(unsigned __int8 *)(a1 + 6))) )
          {
            pthread_mutex_unlock(&iic_mutex);
            return v4;
          }
          printf("%s:%d", "iic_init", 42);
          puts("failed to i2c_ioctl");
          v5 = -1;
        }
      }
      else
      {
        printf("%s:%d", "iic_init", 31);
        puts("failed to i2c_init");
        v5 = -1;
      }
    }
    else
    {
      printf("%s:%d", "iic_init", 25);
      puts("bad param");
      v5 = -3;
    }
    if ( v4 > 0 )
      i2c_uninit(v4);
    pthread_mutex_unlock(&iic_mutex);
    return v5;
  }
}
// 235DCC: using guessed type pthread_mutex_t iic_mutex;

//----- (0001D91C) --------------------------------------------------------
int __fastcall iic_uninit(int a1)
{
  if ( pthread_mutex_lock(&iic_mutex) )
  {
    printf("%s:%d", "iic_uninit", 63);
    return puts("failed to i2c lock");
  }
  else
  {
    i2c_uninit(a1);
    return pthread_mutex_unlock(&iic_mutex);
  }
}
// 235DCC: using guessed type pthread_mutex_t iic_mutex;

//----- (0001D97C) --------------------------------------------------------
int __fastcall iic_read(int a1, int a2, unsigned int a3)
{
  int v6; // [sp+4h] [bp+4h]

  if ( pthread_mutex_lock(&iic_mutex) )
  {
    printf("%s:%d", "iic_read", 82);
    puts("failed to i2c lock");
    return -4;
  }
  else
  {
    v6 = i2c_read(a1, a2, a3);
    pthread_mutex_unlock(&iic_mutex);
    return v6;
  }
}
// 235DCC: using guessed type pthread_mutex_t iic_mutex;

//----- (0001D9E8) --------------------------------------------------------
int __fastcall iic_write(int a1, int a2, unsigned int a3)
{
  int v6; // [sp+4h] [bp+4h]

  if ( pthread_mutex_lock(&iic_mutex) )
  {
    printf("%s:%d", "iic_write", 102);
    puts("failed to i2c lock");
    return -4;
  }
  else
  {
    v6 = i2c_write(a1, a2, a3);
    pthread_mutex_unlock(&iic_mutex);
    return v6;
  }
}
// 235DCC: using guessed type pthread_mutex_t iic_mutex;

//----- (0001DA54) --------------------------------------------------------
int __fastcall iic_read_reg(int a1, unsigned __int8 *a2, int a3, int a4, unsigned int a5)
{
  int reg; // [sp+20h] [bp+18h]

  if ( pthread_mutex_lock(&iic_mutex) )
  {
    printf("%s:%d", "iic_read_reg", 123);
    puts("failed to i2c lock");
    return -4;
  }
  else
  {
    reg = i2c_read_reg(a1, a2, a3, a4, a5);
    pthread_mutex_unlock(&iic_mutex);
    return reg;
  }
}
// 235DCC: using guessed type pthread_mutex_t iic_mutex;

//----- (0001DAC8) --------------------------------------------------------
int __fastcall iic_write_reg(int a1, unsigned __int8 *a2, int a3, int a4, unsigned int a5)
{
  int v11; // [sp+20h] [bp+18h]

  if ( pthread_mutex_lock(&iic_mutex) )
  {
    printf("%s:%d", "iic_write_reg", 145);
    puts("failed to i2c lock");
    return -4;
  }
  else
  {
    v11 = i2c_write_reg(a1, a2, a3, a4, a5);
    pthread_mutex_unlock(&iic_mutex);
    return v11;
  }
}
// 235DCC: using guessed type pthread_mutex_t iic_mutex;

//----- (0001DB3C) --------------------------------------------------------
int __fastcall pwm_init(unsigned int a1, int a2)
{
  if ( platform_inited )
  {
    if ( a1 <= 1 )
    {
      *((_DWORD *)&pwm_param + 2 * a1) = a2;
      *((_BYTE *)&pwm_param + 8 * a1 + 4) = 1;
      return a1 + 1;
    }
    else
    {
      printf("%s:%d", "pwm_init", 20);
      puts("bad param");
      return -3;
    }
  }
  else
  {
    printf("%s:%d", "pwm_init", 16);
    puts("please init platform first!!");
    return -2;
  }
}
// 235C54: using guessed type int platform_inited;

//----- (0001DBDC) --------------------------------------------------------
int __fastcall pwm_uninit(int result)
{
  if ( result - 1 <= 1 )
  {
    *((_DWORD *)&pwm_param + 2 * result - 2) = 0;
    *((_BYTE *)&pwm_param + 8 * result - 4) = 0;
  }
  else
  {
    printf("%s:%d", "pwm_uninit", 29);
    return puts("bad param");
  }
  return result;
}

//----- (0001DC40) --------------------------------------------------------
int __fastcall pwm_set(int a1, unsigned int a2)
{
  unsigned int v3; // r3

  if ( a1 - 1 <= 1 )
  {
    if ( a1 == 1 )
    {
      v3 = a2;
      if ( a2 >= 0x64 )
        v3 = 100;
      if ( platform_is_t9 )
        fpga_write(dword_35598, (100 - v3) | (v3 << 16));
      else
        fpga_write(dword_3582C, (100 - v3) | (v3 << 16));
    }
    else
    {
      printf("%s:%d", "pwm_set", 55);
      printf("pwm type %d not supported\n", a1 - 1);
    }
    return 0;
  }
  else
  {
    printf("%s:%d", "pwm_set", 45);
    puts("bad param");
    return -3;
  }
}
// 35598: using guessed type int dword_35598;
// 3582C: using guessed type int dword_3582C;
// 235C58: using guessed type int platform_is_t9;

//----- (0001DD10) --------------------------------------------------------
int __fastcall pwm_get(int a1, _DWORD *a2)
{
  int v5; // [sp+Ch] [bp+Ch]

  v5 = -5;
  if ( a1 - 1 <= 1 )
  {
    if ( a1 == 1 )
    {
      if ( platform_is_t9 )
        fpga_read(dword_35598, a2);
      else
        fpga_read(dword_3582C, a2);
      *a2 >>= 16;
      printf("%s:%d", "pwm_get", 79);
      printf("duty of fpga = 0x%x\n", *a2);
      return 0;
    }
    return v5;
  }
  else
  {
    printf("%s:%d", "pwm_get", 71);
    puts("bad param");
    return -3;
  }
}
// 35598: using guessed type int dword_35598;
// 3582C: using guessed type int dword_3582C;
// 235C58: using guessed type int platform_is_t9;

//----- (0001DDD4) --------------------------------------------------------
int __fastcall get_send_address_info(int a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5)
{
  int v7; // [sp+14h] [bp+14h]

  v7 = 0;
  if ( platform_is_t9 )
  {
    switch ( a1 )
    {
      case 0:
        *a2 = 24;
        *a3 = dword_355FC;
        *a4 = dword_3560C;
        *a5 = dword_35618;
        break;
      case 1:
        *a2 = 16;
        *a3 = dword_355FC;
        *a4 = dword_35614;
        *a5 = dword_35618;
        break;
      case 2:
        *a2 = 8;
        *a3 = dword_355FC;
        *a4 = dword_3561C;
        *a5 = dword_35620;
        break;
      case 3:
        *a2 = 0;
        *a3 = dword_355FC;
        *a4 = dword_35624;
        *a5 = dword_35628;
        break;
      case 4:
        *a2 = 24;
        *a3 = dword_35600;
        *a4 = dword_3562C;
        *a5 = dword_35630;
        break;
      case 5:
        *a2 = 16;
        *a3 = dword_35600;
        *a4 = dword_35634;
        *a5 = dword_35638;
        break;
      case 6:
        *a2 = 8;
        *a3 = dword_35600;
        *a4 = dword_3563C;
        *a5 = dword_35640;
        break;
      case 7:
        *a2 = 0;
        *a3 = dword_35600;
        *a4 = dword_35644;
        *a5 = dword_35648;
        break;
      case 8:
        *a2 = 24;
        *a3 = dword_35604;
        *a4 = dword_3564C;
        *a5 = dword_35650;
        break;
      case 9:
        *a2 = 16;
        *a3 = dword_35604;
        *a4 = dword_35654;
        *a5 = dword_35658;
        break;
      case 10:
        *a2 = 8;
        *a3 = dword_35604;
        *a4 = dword_356C8;
        *a5 = dword_356CC;
        break;
      case 11:
        *a2 = 0;
        *a3 = dword_35604;
        *a4 = dword_356D0;
        *a5 = dword_356D4;
        break;
      case 12:
        *a2 = 24;
        *a3 = dword_35608;
        *a4 = dword_356D8;
        *a5 = dword_356DC;
        break;
      case 13:
        *a2 = 16;
        *a3 = dword_35608;
        *a4 = dword_356E0;
        *a5 = dword_356E4;
        break;
      default:
        printf("%s:%d", "get_send_address_info", 124);
        printf("%s: The uart %d is not supported!!!\n", "get_send_address_info", a1);
        v7 = -1;
        break;
    }
  }
  else
  {
    switch ( a1 )
    {
      case 0:
        *a2 = 24;
        *a3 = dword_35890;
        *a4 = dword_358A0;
        *a5 = dword_358A4;
        break;
      case 1:
        *a2 = 16;
        *a3 = dword_35890;
        *a4 = dword_358A8;
        *a5 = dword_358AC;
        break;
      case 2:
        *a2 = 8;
        *a3 = dword_35890;
        *a4 = dword_358B0;
        *a5 = dword_358B4;
        break;
      case 3:
        *a2 = 0;
        *a3 = dword_35890;
        *a4 = dword_358B8;
        *a5 = dword_358BC;
        break;
      case 4:
        *a2 = 24;
        *a3 = dword_35894;
        *a4 = dword_358C0;
        *a5 = dword_358C4;
        break;
      case 5:
        *a2 = 16;
        *a3 = dword_35894;
        *a4 = dword_358C8;
        *a5 = dword_358CC;
        break;
      case 6:
        *a2 = 8;
        *a3 = dword_35894;
        *a4 = dword_358D0;
        *a5 = dword_358D4;
        break;
      case 7:
        *a2 = 0;
        *a3 = dword_35894;
        *a4 = dword_358D8;
        *a5 = dword_358DC;
        break;
      case 8:
        *a2 = 24;
        *a3 = dword_35898;
        *a4 = dword_358E0;
        *a5 = dword_358E4;
        break;
      case 9:
        *a2 = 16;
        *a3 = dword_35898;
        *a4 = dword_358E8;
        *a5 = dword_358EC;
        break;
      default:
        printf("%s:%d", "get_send_address_info", 201);
        printf("%s: The uart %d is not supported!!!\n", "get_send_address_info", a1);
        v7 = -1;
        break;
    }
  }
  return v7;
}
// 355FC: using guessed type int dword_355FC;
// 35600: using guessed type int dword_35600;
// 35604: using guessed type int dword_35604;
// 35608: using guessed type int dword_35608;
// 3560C: using guessed type int dword_3560C;
// 35614: using guessed type int dword_35614;
// 35618: using guessed type int dword_35618;
// 3561C: using guessed type int dword_3561C;
// 35620: using guessed type int dword_35620;
// 35624: using guessed type int dword_35624;
// 35628: using guessed type int dword_35628;
// 3562C: using guessed type int dword_3562C;
// 35630: using guessed type int dword_35630;
// 35634: using guessed type int dword_35634;
// 35638: using guessed type int dword_35638;
// 3563C: using guessed type int dword_3563C;
// 35640: using guessed type int dword_35640;
// 35644: using guessed type int dword_35644;
// 35648: using guessed type int dword_35648;
// 3564C: using guessed type int dword_3564C;
// 35650: using guessed type int dword_35650;
// 35654: using guessed type int dword_35654;
// 35658: using guessed type int dword_35658;
// 356C8: using guessed type int dword_356C8;
// 356CC: using guessed type int dword_356CC;
// 356D0: using guessed type int dword_356D0;
// 356D4: using guessed type int dword_356D4;
// 356D8: using guessed type int dword_356D8;
// 356DC: using guessed type int dword_356DC;
// 356E0: using guessed type int dword_356E0;
// 356E4: using guessed type int dword_356E4;
// 35890: using guessed type int dword_35890;
// 35894: using guessed type int dword_35894;
// 35898: using guessed type int dword_35898;
// 358A0: using guessed type int dword_358A0;
// 358A4: using guessed type int dword_358A4;
// 358A8: using guessed type int dword_358A8;
// 358AC: using guessed type int dword_358AC;
// 358B0: using guessed type int dword_358B0;
// 358B4: using guessed type int dword_358B4;
// 358B8: using guessed type int dword_358B8;
// 358BC: using guessed type int dword_358BC;
// 358C0: using guessed type int dword_358C0;
// 358C4: using guessed type int dword_358C4;
// 358C8: using guessed type int dword_358C8;
// 358CC: using guessed type int dword_358CC;
// 358D0: using guessed type int dword_358D0;
// 358D4: using guessed type int dword_358D4;
// 358D8: using guessed type int dword_358D8;
// 358DC: using guessed type int dword_358DC;
// 358E0: using guessed type int dword_358E0;
// 358E4: using guessed type int dword_358E4;
// 358E8: using guessed type int dword_358E8;
// 358EC: using guessed type int dword_358EC;
// 235C58: using guessed type int platform_is_t9;

//----- (0001E428) --------------------------------------------------------
int __fastcall get_read_address_info(int a1, _DWORD *a2, _DWORD *a3)
{
  int v5; // [sp+14h] [bp+14h]

  v5 = 0;
  if ( platform_is_t9 )
  {
    switch ( a1 )
    {
      case 0:
        *a2 = dword_35678;
        *a3 = dword_3567C;
        break;
      case 1:
        *a2 = dword_35680;
        *a3 = dword_35684;
        break;
      case 2:
        *a2 = dword_35688;
        *a3 = dword_3568C;
        break;
      case 3:
        *a2 = dword_35690;
        *a3 = dword_35694;
        break;
      case 8:
        *a2 = dword_356B8;
        *a3 = dword_356BC;
        break;
      case 9:
        *a2 = dword_356C0;
        *a3 = dword_356C4;
        break;
      case 10:
        *a2 = dword_356E8;
        *a3 = dword_356EC;
        break;
      case 11:
        *a2 = dword_356F0;
        *a3 = dword_356F4;
        break;
      case 12:
        *a2 = dword_356F8;
        *a3 = dword_356FC;
        break;
      case 13:
        *a2 = dword_35700;
        *a3 = dword_35704;
        break;
      default:
        printf("%s:%d", "get_read_address_info", 268);
        printf("%s: The uart%d is not supported!!!\n", "get_read_address_info", a1);
        v5 = -1;
        break;
    }
  }
  else
  {
    switch ( a1 )
    {
      case 0:
        *a2 = dword_3590C;
        *a3 = dword_35910;
        break;
      case 1:
        *a2 = dword_35914;
        *a3 = dword_35918;
        break;
      case 2:
        *a2 = dword_3591C;
        *a3 = dword_35920;
        break;
      case 3:
        *a2 = dword_35924;
        *a3 = dword_35928;
        break;
      case 4:
        *a2 = dword_3592C;
        *a3 = dword_35930;
        break;
      case 5:
        *a2 = dword_35934;
        *a3 = dword_35938;
        break;
      case 6:
        *a2 = dword_3593C;
        *a3 = dword_35940;
        break;
      case 7:
        *a2 = dword_35944;
        *a3 = dword_35948;
        break;
      case 8:
        *a2 = dword_3594C;
        *a3 = dword_35950;
        break;
      case 9:
        *a2 = dword_35954;
        *a3 = dword_35958;
        break;
      default:
        printf("%s:%d", "get_read_address_info", 326);
        printf("%s: The uart%d is not supported!!!\n", "get_read_address_info", a1);
        v5 = -1;
        break;
    }
  }
  return v5;
}
// 35678: using guessed type int dword_35678;
// 3567C: using guessed type int dword_3567C;
// 35680: using guessed type int dword_35680;
// 35684: using guessed type int dword_35684;
// 35688: using guessed type int dword_35688;
// 3568C: using guessed type int dword_3568C;
// 35690: using guessed type int dword_35690;
// 35694: using guessed type int dword_35694;
// 356B8: using guessed type int dword_356B8;
// 356BC: using guessed type int dword_356BC;
// 356C0: using guessed type int dword_356C0;
// 356C4: using guessed type int dword_356C4;
// 356E8: using guessed type int dword_356E8;
// 356EC: using guessed type int dword_356EC;
// 356F0: using guessed type int dword_356F0;
// 356F4: using guessed type int dword_356F4;
// 356F8: using guessed type int dword_356F8;
// 356FC: using guessed type int dword_356FC;
// 35700: using guessed type int dword_35700;
// 35704: using guessed type int dword_35704;
// 3590C: using guessed type int dword_3590C;
// 35910: using guessed type int dword_35910;
// 35914: using guessed type int dword_35914;
// 35918: using guessed type int dword_35918;
// 3591C: using guessed type int dword_3591C;
// 35920: using guessed type int dword_35920;
// 35924: using guessed type int dword_35924;
// 35928: using guessed type int dword_35928;
// 3592C: using guessed type int dword_3592C;
// 35930: using guessed type int dword_35930;
// 35934: using guessed type int dword_35934;
// 35938: using guessed type int dword_35938;
// 3593C: using guessed type int dword_3593C;
// 35940: using guessed type int dword_35940;
// 35944: using guessed type int dword_35944;
// 35948: using guessed type int dword_35948;
// 3594C: using guessed type int dword_3594C;
// 35950: using guessed type int dword_35950;
// 35954: using guessed type int dword_35954;
// 35958: using guessed type int dword_35958;
// 235C58: using guessed type int platform_is_t9;

//----- (0001E7EC) --------------------------------------------------------
int __fastcall check_how_many_uart_data_in_fpga(unsigned __int8 a1)
{
  int v1; // r3
  unsigned int v4; // [sp+Ch] [bp+Ch] BYREF

  v4 = 0;
  if ( platform_is_t9 )
  {
    switch ( a1 )
    {
      case 0u:
        fpga_read(dword_3565C, &v4);
        v1 = HIWORD(v4) & 0x3FF;
        break;
      case 1u:
        fpga_read(dword_3565C, &v4);
        v1 = v4 & 0x3FF;
        break;
      case 2u:
        fpga_read(dword_35660, &v4);
        v1 = HIWORD(v4) & 0x3FF;
        break;
      case 3u:
        fpga_read(dword_35660, &v4);
        v1 = v4 & 0x3FF;
        break;
      case 4u:
        fpga_read(dword_35664, &v4);
        v1 = HIWORD(v4) & 0x3FF;
        break;
      case 5u:
        fpga_read(dword_35664, &v4);
        v1 = v4 & 0x3FF;
        break;
      case 6u:
        fpga_read(dword_35668, &v4);
        v1 = HIWORD(v4) & 0x3FF;
        break;
      case 7u:
        fpga_read(dword_35668, &v4);
        v1 = v4 & 0x3FF;
        break;
      case 8u:
        fpga_read(dword_3566C, &v4);
        v1 = HIWORD(v4) & 0x3FF;
        break;
      case 9u:
        fpga_read(dword_3566C, &v4);
        v1 = v4 & 0x3FF;
        break;
      case 0xAu:
        fpga_read(dword_35670, &v4);
        v1 = HIWORD(v4) & 0x3FF;
        break;
      case 0xBu:
        fpga_read(dword_35670, &v4);
        v1 = v4 & 0x3FF;
        break;
      case 0xCu:
        fpga_read(dword_35674, &v4);
        v1 = HIWORD(v4) & 0x3FF;
        break;
      case 0xDu:
        fpga_read(dword_35674, &v4);
        v1 = v4 & 0x3FF;
        break;
      default:
        printf("%s:%d", "check_how_many_uart_data_in_fpga", 394);
        printf("%s: The uart%d is not supported!!!\n", "check_how_many_uart_data_in_fpga", a1);
        v1 = 0;
        break;
    }
  }
  else
  {
    switch ( a1 )
    {
      case 0u:
        fpga_read(dword_358F0, &v4);
        v1 = HIWORD(v4) & 0x3FF;
        break;
      case 1u:
        fpga_read(dword_358F0, &v4);
        v1 = v4 & 0x3FF;
        break;
      case 2u:
        fpga_read(dword_358F4, &v4);
        v1 = HIWORD(v4) & 0x3FF;
        break;
      case 3u:
        fpga_read(dword_358F4, &v4);
        v1 = v4 & 0x3FF;
        break;
      case 4u:
        fpga_read(dword_358F8, &v4);
        v1 = HIWORD(v4) & 0x3FF;
        break;
      case 5u:
        fpga_read(dword_358F8, &v4);
        v1 = v4 & 0x3FF;
        break;
      case 6u:
        fpga_read(dword_358FC, &v4);
        v1 = HIWORD(v4) & 0x3FF;
        break;
      case 7u:
        fpga_read(dword_358FC, &v4);
        v1 = v4 & 0x3FF;
        break;
      case 8u:
        fpga_read(dword_35900, &v4);
        v1 = HIWORD(v4) & 0x3FF;
        break;
      case 9u:
        fpga_read(dword_35900, &v4);
        v1 = v4 & 0x3FF;
        break;
      default:
        printf("%s:%d", "check_how_many_uart_data_in_fpga", 449);
        printf("%s: The uart%d is not supported!!!\n", "check_how_many_uart_data_in_fpga", a1);
        v1 = 0;
        break;
    }
  }
  return v1;
}
// 3565C: using guessed type int dword_3565C;
// 35660: using guessed type int dword_35660;
// 35664: using guessed type int dword_35664;
// 35668: using guessed type int dword_35668;
// 3566C: using guessed type int dword_3566C;
// 35670: using guessed type int dword_35670;
// 35674: using guessed type int dword_35674;
// 358F0: using guessed type int dword_358F0;
// 358F4: using guessed type int dword_358F4;
// 358F8: using guessed type int dword_358F8;
// 358FC: using guessed type int dword_358FC;
// 35900: using guessed type int dword_35900;
// 235C58: using guessed type int platform_is_t9;

//----- (0001EC10) --------------------------------------------------------
int __fastcall read_uart_data_in_fpga(int a1, int a2, unsigned int a3)
{
  int v8; // [sp+14h] [bp+14h] BYREF
  int v9; // [sp+18h] [bp+18h] BYREF
  int v10; // [sp+1Ch] [bp+1Ch] BYREF
  unsigned int v11; // [sp+20h] [bp+20h]
  unsigned int v12; // [sp+24h] [bp+24h]
  int v13; // [sp+28h] [bp+28h]
  unsigned int i; // [sp+2Ch] [bp+2Ch]

  v10 = 0;
  v9 = 0;
  v12 = 0;
  v11 = 0;
  i = 0;
  v8 = 0;
  v13 = 0;
  if ( get_read_address_info(a1, &v10, &v9) )
  {
    printf("%s:%d", "read_uart_data_in_fpga", 461);
    printf("get_read_address_info error, chain_id = %d\n", a1);
    return 0;
  }
  else
  {
    v12 = a3 & 0x3FF | 0x80000000;
    fpga_write(v10, v12);
    v11 = a3 >> 2;
    for ( i = 0; i < v11; ++i )
    {
      fpga_read(v9, &v8);
      *(_BYTE *)(a2 + 4 * i) = HIBYTE(v8);
      *(_BYTE *)(a2 + 4 * i + 1) = BYTE2(v8);
      *(_BYTE *)(a2 + 4 * i + 2) = BYTE1(v8);
      *(_BYTE *)(a2 + 4 * i + 3) = v8;
    }
    v13 = 4 * v11;
    v11 = a3 & 3;
    if ( (a3 & 3) != 0 )
    {
      fpga_read(v9, &v8);
      switch ( v11 )
      {
        case 2u:
          *(_BYTE *)(a2 + 4 * i) = HIBYTE(v8);
          *(_BYTE *)(a2 + 4 * i + 1) = BYTE2(v8);
          v13 += 2;
          break;
        case 3u:
          *(_BYTE *)(a2 + 4 * i) = HIBYTE(v8);
          *(_BYTE *)(a2 + 4 * i + 1) = BYTE2(v8);
          *(_BYTE *)(a2 + 4 * i + 2) = BYTE1(v8);
          v13 += 3;
          break;
        case 1u:
          *(_BYTE *)(a2 + 4 * i) = HIBYTE(v8);
          ++v13;
          break;
        default:
          printf("%s:%d", "read_uart_data_in_fpga", 507);
          printf("%s: the uart%d left data is 4*N length, error!!!\n", "read_uart_data_in_fpga", a1);
          break;
      }
    }
    return v13;
  }
}

//----- (0001EDE8) --------------------------------------------------------
int uart_init()
{
  if ( platform_inited )
    return 0;
  printf("%s:%d", "uart_init", 518);
  puts("please init platform first!!");
  return -1;
}
// 235C54: using guessed type int platform_inited;

//----- (0001EE2C) --------------------------------------------------------
void uart_uninit()
{
  ;
}

//----- (0001EE38) --------------------------------------------------------
int __fastcall hexdump(const char *a1, unsigned __int8 *a2, int a3)
{
  int result; // r0
  int v4; // r3
  int v5; // [sp+4h] [bp+4h]
  unsigned int i; // [sp+10h] [bp+10h]
  unsigned int j; // [sp+10h] [bp+10h]
  unsigned __int8 *v8; // [sp+14h] [bp+14h]

  v5 = a3;
  v8 = a2;
  result = printf("Dumping %u %s bytes from %p:\n", a3, a1, a2);
  while ( v5 > 0 )
  {
    for ( i = 0; i <= 0xF; ++i )
    {
      if ( v5 <= i )
        printf("   ");
      else
        printf("%02x ", v8[i]);
    }
    for ( j = 0; j <= 0xF; ++j )
    {
      if ( v5 <= j )
      {
        putchar(32);
      }
      else
      {
        if ( v8[j] <= 0x1Fu || v8[j] > 0x7Eu )
          v4 = 46;
        else
          v4 = v8[j];
        putchar(v4);
      }
    }
    result = putchar(10);
    v8 += 16;
    if ( v5 <= 16 )
      break;
    v5 -= 16;
  }
  return result;
}

//----- (0001EF10) --------------------------------------------------------
size_t __fastcall uart_send(int a1, const void *a2, size_t a3)
{
  int v8; // [sp+18h] [bp+10h] BYREF
  size_t v9; // [sp+1Ch] [bp+14h] BYREF
  int v10; // [sp+20h] [bp+18h] BYREF
  int v11; // [sp+24h] [bp+1Ch] BYREF
  int v12; // [sp+28h] [bp+20h] BYREF
  _BYTE s[256]; // [sp+2Ch] [bp+24h] BYREF
  size_t v14; // [sp+12Ch] [bp+124h]
  signed int v15; // [sp+130h] [bp+128h]
  int v16; // [sp+134h] [bp+12Ch]
  int v17; // [sp+138h] [bp+130h]
  signed int i; // [sp+13Ch] [bp+134h]

  v16 = 0;
  v15 = 0;
  i = 0;
  memset(s, 0, sizeof(s));
  v14 = a3;
  v17 = 0;
  v12 = 0;
  v11 = 0;
  v10 = 0;
  v9 = 0;
  v8 = 0;
  pthread_mutex_lock(&uart_send_mutex[a1]);
  if ( get_send_address_info(a1, &v8, &v12, &v11, &v10) )
  {
    printf("%s:%d", "uart_send", 584);
    printf("get_send_address_info error, chain_id = %d\n", a1);
    pthread_mutex_unlock(&uart_send_mutex[a1]);
    return 0;
  }
  else
  {
    v16 = 0;
    do
    {
      fpga_read(v12, &v9);
      v9 = (unsigned __int8)(v9 >> v8);
    }
    while ( v9 < a3 );
    v16 = 0;
    do
      fpga_read(v11, &v9);
    while ( v9 >> 31 == 1 );
    memcpy(s, a2, a3);
    v15 = v14 >> 2;
    for ( i = 0; i < v15; ++i )
    {
      v17 = (unsigned __int8)s[4 * i + 3]
          | ((unsigned __int8)s[4 * i] << 24)
          | ((unsigned __int8)s[4 * i + 1] << 16)
          | ((unsigned __int8)s[4 * i + 2] << 8);
      fpga_write(v10, v17);
    }
    v15 = v14 & 3;
    if ( (v14 & 3) != 0 )
    {
      switch ( v15 )
      {
        case 2:
          v17 = ((unsigned __int8)s[4 * i + 1] << 16) | ((unsigned __int8)s[4 * i] << 24);
          break;
        case 3:
          v17 = ((unsigned __int8)s[4 * i + 2] << 8)
              | ((unsigned __int8)s[4 * i] << 24)
              | ((unsigned __int8)s[4 * i + 1] << 16);
          break;
        case 1:
          v17 = (unsigned __int8)s[4 * i] << 24;
          break;
        default:
          printf("%s: the uart%d send left data is 4*N length, error!!!\n", "uart_send", a1);
          break;
      }
      fpga_write(v10, v17);
    }
    fpga_write(v11, v14 | 0x80000000);
    pthread_mutex_unlock(&uart_send_mutex[a1]);
    return v14;
  }
}
// 235DF4: using guessed type pthread_mutex_t uart_send_mutex[16];

//----- (0001F214) --------------------------------------------------------
int __fastcall uart_receive(int a1, int a2, unsigned int a3)
{
  int uart_data_in_fpga; // [sp+18h] [bp+18h]
  unsigned int v9; // [sp+1Ch] [bp+1Ch]

  pthread_mutex_lock(&uart_receive_mutex[a1]);
  v9 = check_how_many_uart_data_in_fpga(a1);
  if ( v9 > a3 )
    v9 = a3;
  if ( v9 )
  {
    uart_data_in_fpga = read_uart_data_in_fpga(a1, a2, v9);
    pthread_mutex_unlock(&uart_receive_mutex[a1]);
    return uart_data_in_fpga;
  }
  else
  {
    pthread_mutex_unlock(&uart_receive_mutex[a1]);
    return 0;
  }
}
// 235F74: using guessed type pthread_mutex_t uart_receive_mutex[16];

//----- (0001F2D0) --------------------------------------------------------
int __fastcall uart_set_config(int a1, int a2, int *a3)
{
  int v8; // [sp+14h] [bp+14h]

  v8 = -5;
  if ( !a3 )
    return -3;
  pthread_mutex_lock(&uart_send_mutex[a1]);
  if ( a2 )
  {
    printf("%s:%d", "uart_set_config", 736);
    printf("unknown set config type = %d\n", a2);
  }
  else if ( platform_is_t9 )
  {
    v8 = fpga_write(dword_35588, *a3);
  }
  else
  {
    v8 = fpga_write(dword_3581C, *a3);
  }
  pthread_mutex_unlock(&uart_send_mutex[a1]);
  return v8;
}
// 35588: using guessed type int dword_35588;
// 3581C: using guessed type int dword_3581C;
// 235C58: using guessed type int platform_is_t9;
// 235DF4: using guessed type pthread_mutex_t uart_send_mutex[16];

//----- (0001F3A0) --------------------------------------------------------
int __fastcall uart_get_config(int a1, int a2, _DWORD *a3, int a4)
{
  int v9; // [sp+14h] [bp+14h] BYREF
  int v10; // [sp+18h] [bp+18h] BYREF
  int v11; // [sp+1Ch] [bp+1Ch]

  v11 = -5;
  if ( !a3 || a4 )
    return -3;
  pthread_mutex_lock(&uart_send_mutex[a1]);
  if ( a2 )
  {
    printf("%s:%d", "uart_get_config", 767);
    printf("unknown set config type = %d\n", a2);
  }
  else
  {
    if ( platform_is_t9 )
    {
      v10 = 0;
      v11 = fpga_read(dword_35588, &v10);
      *a3 = v10;
    }
    else
    {
      v9 = 0;
      v11 = fpga_read(dword_3581C, &v9);
      *a3 = v9;
    }
    MEMORY[0] = 4;
    printf("%s:%d", "uart_get_config", 764);
    printf("uart_get_config return %d\n", *a3);
  }
  pthread_mutex_unlock(&uart_send_mutex[a1]);
  return v11;
}
// 35588: using guessed type int dword_35588;
// 3581C: using guessed type int dword_3581C;
// 235C58: using guessed type int platform_is_t9;
// 235DF4: using guessed type pthread_mutex_t uart_send_mutex[16];

//----- (0001F4C0) --------------------------------------------------------
int __fastcall clear_uart_tx_fifo(int a1)
{
  int v3; // [sp+10h] [bp+8h] BYREF
  unsigned int v4; // [sp+14h] [bp+Ch] BYREF
  int v5; // [sp+18h] [bp+10h] BYREF
  int v6; // [sp+1Ch] [bp+14h] BYREF
  int v7; // [sp+20h] [bp+18h] BYREF
  unsigned int i; // [sp+24h] [bp+1Ch]

  v7 = 0;
  v6 = 0;
  v5 = 0;
  v4 = 0;
  v3 = 0;
  i = 0;
  pthread_mutex_lock(&uart_send_mutex[a1]);
  if ( get_send_address_info(a1, &v3, &v7, &v6, &v5) )
  {
    printf("%s:%d", "clear_uart_tx_fifo", 783);
    printf("get_send_address_info error, chain_id = %d\n", a1);
    return pthread_mutex_unlock(&uart_send_mutex[a1]);
  }
  else
  {
    for ( i = 0; i <= 0x14; ++i )
    {
      fpga_read(v7, &v4);
      v4 = (unsigned __int8)(v4 >> v3);
      if ( v4 == 255 )
        return pthread_mutex_unlock(&uart_send_mutex[a1]);
      printf("%s: waiting fpga uart%d clear send fifo space ...\n", "clear_uart_tx_fifo", a1);
      usleep(0xBB8u);
    }
    printf("%s:%d", "clear_uart_tx_fifo", 803);
    printf("%s: uart%d always dose not has enough send fifo space, break\n", "clear_uart_tx_fifo", a1);
    return pthread_mutex_unlock(&uart_send_mutex[a1]);
  }
}
// 235DF4: using guessed type pthread_mutex_t uart_send_mutex[16];

//----- (0001F618) --------------------------------------------------------
int __fastcall clear_uart_rx_fifo(int a1)
{
  void *ptr; // [sp+14h] [bp+Ch]
  int size; // [sp+18h] [bp+10h]
  int uart_data_in_fpga; // [sp+1Ch] [bp+14h]

  pthread_mutex_lock(&uart_receive_mutex[a1]);
  size = check_how_many_uart_data_in_fpga(a1);
  if ( !size )
    return pthread_mutex_unlock(&uart_receive_mutex[a1]);
  ptr = malloc(size);
  if ( ptr )
  {
    uart_data_in_fpga = read_uart_data_in_fpga(a1, (int)ptr, size);
    if ( uart_data_in_fpga != size )
    {
      printf("%s:%d", "clear_uart_rx_fifo", 840);
      printf(
        "%s: uart%d clear rx fifo error. nbytes = %d, len = %d\n",
        "clear_uart_rx_fifo",
        a1,
        size,
        uart_data_in_fpga);
    }
    free(ptr);
    usleep(0x2710u);
    return pthread_mutex_unlock(&uart_receive_mutex[a1]);
  }
  else
  {
    printf("%s:%d", "clear_uart_rx_fifo", 831);
    printf("%s: uart%d malloc buffer error\n", "clear_uart_rx_fifo", a1);
    usleep((__useconds_t)&unk_7A120);
    return pthread_mutex_unlock(&uart_receive_mutex[a1]);
  }
}
// 235F74: using guessed type pthread_mutex_t uart_receive_mutex[16];

//----- (0001F78C) --------------------------------------------------------
int __fastcall uart_flush(int a1)
{
  printf("%s:%d", "uart_flush", 859);
  printf("flush uart %d\n", a1);
  clear_uart_rx_fifo(a1);
  usleep(0x2710u);
  clear_uart_tx_fifo(a1);
  return 0;
}

//----- (0001F7DC) --------------------------------------------------------
int __fastcall uart_flush_tx(int a1)
{
  clear_uart_tx_fifo(a1);
  return 0;
}

//----- (0001F7F8) --------------------------------------------------------
int __fastcall uart_flush_rx(int a1)
{
  clear_uart_rx_fifo(a1);
  return 0;
}

//----- (0001F814) --------------------------------------------------------
int __fastcall uart_get_readable_byte_num(int a1)
{
  int v3; // [sp+Ch] [bp+Ch]

  pthread_mutex_lock(&uart_receive_mutex[a1]);
  v3 = check_how_many_uart_data_in_fpga(a1);
  pthread_mutex_unlock(&uart_receive_mutex[a1]);
  return v3;
}
// 235F74: using guessed type pthread_mutex_t uart_receive_mutex[16];

//----- (0001F86C) --------------------------------------------------------
int ui_pull_function()
{
  _DWORD v1[3]; // [sp+Ch] [bp+Ch] BYREF
  int v2; // [sp+18h] [bp+18h]
  void *ptr; // [sp+1Ch] [bp+1Ch]
  _DWORD *v4; // [sp+20h] [bp+20h]
  int i; // [sp+24h] [bp+24h]

  while ( ui_pull_thread )
  {
    if ( !pthread_mutex_lock(&ui_api_mutex) )
    {
      v4 = new_iterator_c_map(ui_flicker_map);
      for ( i = ((int (__fastcall *)(_DWORD *))*v4)(v4); i; i = ((int (__fastcall *)(_DWORD *))*v4)(v4) )
      {
        ptr = (void *)((int (__fastcall *)(int))v4[2])(i);
        v2 = v4[5];
        if ( !*((_DWORD *)ptr + 1) )
        {
          gpio_write(***(_DWORD ***)(v2 + 16), *((_DWORD *)ptr + 2));
          *((_DWORD *)ptr + 2) = *((_DWORD *)ptr + 2) != 1;
          *((_DWORD *)ptr + 1) = *(_DWORD *)ptr;
        }
        *((_DWORD *)ptr + 1) -= 200;
        *((_DWORD *)ptr + 1) = *((_DWORD *)ptr + 1);
        v1[0] = *(_DWORD *)ptr;
        v1[1] = *((_DWORD *)ptr + 1);
        v1[2] = *((_DWORD *)ptr + 2);
        ((void (__fastcall *)(_DWORD *, _DWORD *, int))v4[1])(v4, v1, 12);
        free(ptr);
      }
      delete_iterator_c_map(v4);
      pthread_mutex_unlock(&ui_api_mutex);
    }
    usleep(0x30D40u);
  }
  return 0;
}
// 1F86C: using guessed type int ui_pull_function();
// 2360F4: using guessed type pthread_mutex_t ui_api_mutex;
// 23610C: using guessed type int ui_flicker_map;
// 236114: using guessed type int ui_pull_thread;

//----- (0001F990) --------------------------------------------------------
int __fastcall gpio_compare_e_0(_DWORD *a1, _DWORD *a2)
{
  return *a1 - *a2;
}

//----- (0001F9B0) --------------------------------------------------------
int __fastcall convert_ui_type_to_port(unsigned int a1)
{
  int v2; // [sp+Ch] [bp+Ch]

  v2 = 0;
  if ( a1 == 2 )
    return 942;
  if ( a1 > 2 )
  {
    if ( a1 == 256 )
    {
      return 921;
    }
    else if ( a1 == 257 )
    {
      return 943;
    }
  }
  else if ( a1 == 1 )
  {
    return 941;
  }
  return v2;
}

//----- (0001FA0C) --------------------------------------------------------
int __fastcall convert_port_to_ui_type(int a1)
{
  int v2; // [sp+Ch] [bp+Ch]

  v2 = 258;
  if ( a1 == 921 )
    return 256;
  if ( a1 == 943 )
    return 257;
  return v2;
}

//----- (0001FA50) --------------------------------------------------------
int __fastcall gpio_key_callback(int a1, char a2)
{
  int result; // r0
  int v5; // [sp+8h] [bp+8h]
  int i; // [sp+Ch] [bp+Ch]

  result = convert_port_to_ui_type(a1);
  v5 = result;
  if ( result == 258 )
  {
    printf("%s:%d", "gpio_key_callback", 110);
    return printf("gpio port %d is not a supported key\n", a1);
  }
  else
  {
    for ( i = 0; i <= 4; ++i )
    {
      if ( ui_callback[i] )
        result = ((int (__fastcall *)(int, bool))ui_callback[i])(v5, a2 != 0);
    }
  }
  return result;
}
// 23611C: using guessed type _DWORD ui_callback[5];

//----- (0001FAE0) --------------------------------------------------------
int ui_init()
{
  int v1; // r0
  int v2; // r0
  int v3; // r0
  int v4; // r0
  int v5; // r0
  int v6; // r0
  int i; // [sp+4h] [bp+4h]

  if ( ui_inited )
    return 0;
  if ( gpio_init() )
  {
    printf("%s:%d", "ui_init", 124);
    puts("gpio init failed");
    return -1;
  }
  else
  {
    v1 = convert_ui_type_to_port(1u);
    gpio_export(v1);
    v2 = convert_ui_type_to_port(2u);
    gpio_export(v2);
    v3 = convert_ui_type_to_port(0x100u);
    gpio_export(v3);
    v4 = convert_ui_type_to_port(0x101u);
    gpio_export(v4);
    v5 = convert_ui_type_to_port(0x100u);
    gpio_reg_callback(v5, (int)gpio_key_callback);
    v6 = convert_ui_type_to_port(0x101u);
    gpio_reg_callback(v6, (int)gpio_key_callback);
    pthread_mutex_init(&ui_api_mutex, 0);
    for ( i = 0; i <= 4; ++i )
      ui_callback[i] = 0;
    ui_flicker_map = (int)new_c_map((int)gpio_compare_e_0, 0, 0);
    ui_pull_thread = 1;
    pthread_create((pthread_t *)&ui_thread, 0, (void *(*)(void *))ui_pull_function, 0);
    ui_inited = 1;
    return 0;
  }
}
// 1F86C: using guessed type int ui_pull_function();
// 2360F4: using guessed type pthread_mutex_t ui_api_mutex;
// 23610C: using guessed type int ui_flicker_map;
// 236110: using guessed type int ui_inited;
// 236114: using guessed type int ui_pull_thread;
// 236118: using guessed type int ui_thread;
// 23611C: using guessed type _DWORD ui_callback[5];

//----- (0001FC24) --------------------------------------------------------
void ui_uninit()
{
  int v0; // r0
  int v1; // r0
  int v2; // r0
  int v3; // r0
  int v4; // r0
  int v5; // r0

  if ( ui_inited )
  {
    ui_pull_thread = 0;
    pthread_join(ui_thread, 0);
    delete_c_map((void ****)ui_flicker_map);
    pthread_mutex_destroy(&ui_api_mutex);
    v0 = convert_ui_type_to_port(0x100u);
    gpio_unreg_callback(v0, (int)gpio_key_callback);
    v1 = convert_ui_type_to_port(0x101u);
    gpio_unreg_callback(v1, (int)gpio_key_callback);
    v2 = convert_ui_type_to_port(1u);
    gpio_unexport(v2);
    v3 = convert_ui_type_to_port(2u);
    gpio_unexport(v3);
    v4 = convert_ui_type_to_port(0x100u);
    gpio_unexport(v4);
    v5 = convert_ui_type_to_port(0x101u);
    gpio_unexport(v5);
    gpio_uninit();
    ui_inited = 0;
  }
}
// 2360F4: using guessed type pthread_mutex_t ui_api_mutex;
// 23610C: using guessed type int ui_flicker_map;
// 236110: using guessed type int ui_inited;
// 236114: using guessed type int ui_pull_thread;
// 236118: using guessed type int ui_thread;

//----- (0001FCF0) --------------------------------------------------------
int __fastcall remove_port_form_gpio_map(int result, int *a2)
{
  int v3; // [sp+4h] [bp+4h] BYREF

  v3 = result;
  if ( a2 )
  {
    result = exists_c_map(a2, (int)&v3);
    if ( result == 1 )
    {
      printf("%s:%d", "remove_port_form_gpio_map", 168);
      printf("remove %d from flicker list\n", v3);
      return remove_c_map(a2, (int)&v3);
    }
  }
  return result;
}

//----- (0001FD50) --------------------------------------------------------
int __fastcall add_port_to_gpio_map(int result, int a2, int *a3)
{
  _DWORD v5[2]; // [sp+14h] [bp+Ch] BYREF
  _DWORD v6[3]; // [sp+1Ch] [bp+14h] BYREF

  v5[0] = result;
  if ( a3 )
  {
    if ( exists_c_map(a3, (int)v5) )
    {
      printf("%s:%d", "add_port_to_gpio_map", 184);
      return printf("port %d already exist in map\n", v5[0]);
    }
    else
    {
      printf("%s:%d", "add_port_to_gpio_map", 180);
      printf("add %d to flicker map with interval %d\n", v5[0], a2);
      v6[0] = a2;
      v6[1] = 0;
      v6[2] = 1;
      return insert_c_map(a3, v5, 4u, v6, 0xCu);
    }
  }
  return result;
}

//----- (0001FDF4) --------------------------------------------------------
void __fastcall update_filcker_freq(int a1, int a2, int a3)
{
  _DWORD v5[3]; // [sp+14h] [bp+14h] BYREF
  void *ptr; // [sp+20h] [bp+20h]
  int v7; // [sp+24h] [bp+24h]
  _DWORD *v8; // [sp+28h] [bp+28h]
  int i; // [sp+2Ch] [bp+2Ch]

  if ( a3 )
  {
    v8 = new_iterator_c_map(a3);
    for ( i = ((int (__fastcall *)(_DWORD *))*v8)(v8); i; i = ((int (__fastcall *)(_DWORD *))*v8)(v8) )
    {
      v7 = v8[5];
      if ( ***(_DWORD ***)(v7 + 16) == a1 )
      {
        ptr = (void *)((int (__fastcall *)(int))v8[2])(i);
        v5[0] = a2;
        v5[1] = 0;
        v5[2] = 1;
        ((void (__fastcall *)(_DWORD *, _DWORD *, int))v8[1])(v8, v5, 12);
        printf("%s:%d", "update_filcker_freq", 201);
        printf("update the freq interval of port[%d] from %d to %d\n", a1, *(_DWORD *)ptr, a2);
        free(ptr);
        break;
      }
    }
    delete_iterator_c_map(v8);
  }
}

//----- (0001FEAC) --------------------------------------------------------
int __fastcall gpio_ctrl_ui(unsigned int a1, int a2)
{
  int v6; // [sp+8h] [bp+8h]
  int v7; // [sp+Ch] [bp+Ch]

  v7 = -1;
  v6 = convert_ui_type_to_port(a1);
  if ( v6 )
  {
    printf("%s:%d", "gpio_ctrl_ui", 225);
    printf("ui type = %d, port = %d, status = %d\n", a1, v6, a2);
    if ( pthread_mutex_lock(&ui_api_mutex) )
    {
      printf("%s:%d", "gpio_ctrl_ui", 227);
      puts("failed to api lock");
      return -1;
    }
    else
    {
      if ( a2 == 1 )
      {
        remove_port_form_gpio_map(v6, (int *)ui_flicker_map);
        v7 = gpio_write(v6, 0);
      }
      else if ( a2 )
      {
        if ( a2 == 2 )
        {
          add_port_to_gpio_map(v6, 200, (int *)ui_flicker_map);
        }
        else
        {
          printf("%s:%d", "gpio_ctrl_ui", 243);
          puts("unsuported led status");
          v7 = -2;
        }
      }
      else
      {
        remove_port_form_gpio_map(v6, (int *)ui_flicker_map);
        v7 = gpio_write(v6, 1);
      }
      pthread_mutex_unlock(&ui_api_mutex);
      return v7;
    }
  }
  else
  {
    printf("%s:%d", "gpio_ctrl_ui", 222);
    puts("unsuported gpio port");
    return -1;
  }
}
// 2360F4: using guessed type pthread_mutex_t ui_api_mutex;
// 23610C: using guessed type int ui_flicker_map;

//----- (00020004) --------------------------------------------------------
int __fastcall gpio_set_led_filker_freq(unsigned int a1, int a2)
{
  int v5; // [sp+Ch] [bp+Ch]

  v5 = convert_ui_type_to_port(a1);
  if ( v5 )
  {
    if ( a2 == 200 )
    {
      printf("%s:%d", "gpio_set_led_filker_freq", 266);
      puts("interval is same with default");
    }
    else
    {
      update_filcker_freq(v5, a2, ui_flicker_map);
    }
    return 0;
  }
  else
  {
    printf("%s:%d", "gpio_set_led_filker_freq", 262);
    puts("unsuported led port");
    return -1;
  }
}
// 23610C: using guessed type int ui_flicker_map;

//----- (000200A0) --------------------------------------------------------
int red_led_on()
{
  return gpio_ctrl_ui(1u, 0);
}

//----- (000200B4) --------------------------------------------------------
int red_led_off()
{
  return gpio_ctrl_ui(1u, 1);
}

//----- (000200C8) --------------------------------------------------------
int red_led_flicker()
{
  return gpio_ctrl_ui(1u, 2);
}

//----- (000200DC) --------------------------------------------------------
int green_led_on()
{
  return gpio_ctrl_ui(2u, 0);
}

//----- (000200F0) --------------------------------------------------------
int green_led_off()
{
  return gpio_ctrl_ui(2u, 1);
}

//----- (00020104) --------------------------------------------------------
int green_led_flicker()
{
  return gpio_ctrl_ui(2u, 2);
}

//----- (00020118) --------------------------------------------------------
int beeper_on()
{
  return gpio_ctrl_ui(0x10u, 0);
}

//----- (0002012C) --------------------------------------------------------
int beeper_off()
{
  return gpio_ctrl_ui(0x10u, 1);
}

//----- (00020140) --------------------------------------------------------
int beeper_flicker()
{
  return gpio_ctrl_ui(0x10u, 2);
}

//----- (00020154) --------------------------------------------------------
int __fastcall reg_key_callback(int a1)
{
  int v4; // [sp+8h] [bp+8h]
  int i; // [sp+Ch] [bp+Ch]

  v4 = 0;
  if ( pthread_mutex_lock(&ui_api_mutex) )
  {
    printf("%s:%d", "reg_key_callback", 320);
    puts("failed to api lock");
    return -1;
  }
  else
  {
    for ( i = 0; i <= 4; ++i )
    {
      if ( !ui_callback[i] )
      {
        ui_callback[i] = a1;
        break;
      }
    }
    if ( i > 4 )
    {
      v4 = -2;
      printf("%s:%d", "reg_key_callback", 331);
      puts("no more listener available");
    }
    pthread_mutex_unlock(&ui_api_mutex);
    return v4;
  }
}
// 2360F4: using guessed type pthread_mutex_t ui_api_mutex;
// 23611C: using guessed type _DWORD ui_callback[5];

//----- (00020220) --------------------------------------------------------
int __fastcall unreg_key_callback(int a1)
{
  int i; // [sp+Ch] [bp+Ch]

  if ( pthread_mutex_lock(&ui_api_mutex) )
  {
    printf("%s:%d", "unreg_key_callback", 347);
    puts("failed to api lock");
    return -1;
  }
  else
  {
    for ( i = 0; i <= 4; ++i )
    {
      if ( ui_callback[i] == a1 )
      {
        ui_callback[i] = 0;
        break;
      }
    }
    if ( i > 4 )
    {
      printf("%s:%d", "unreg_key_callback", 357);
      puts("listener not registered before");
    }
    pthread_mutex_unlock(&ui_api_mutex);
    return 0;
  }
}
// 2360F4: using guessed type pthread_mutex_t ui_api_mutex;
// 23611C: using guessed type _DWORD ui_callback[5];

//----- (000202E4) --------------------------------------------------------
int __fastcall lcd_show_result(unsigned __int8 a1, int a2, unsigned int a3)
{
  int v8; // [sp+14h] [bp+14h]

  if ( pthread_mutex_lock(&ui_api_mutex) )
  {
    printf("%s:%d", "lcd_show_result", 375);
    puts("failed to api lock");
    return -4;
  }
  else
  {
    if ( lcd_ctx < 0 )
    {
      lcd_ctx = lcd_init(lcd_path);
      lcd_clear(lcd_ctx);
    }
    if ( lcd_ctx <= 0 )
    {
      printf("%s:%d", "lcd_show_result", 385);
      printf("failed to init %s\n", lcd_path);
      v8 = -1;
    }
    else
    {
      v8 = lcd_write(lcd_ctx, a1, a2, a3);
    }
    pthread_mutex_unlock(&ui_api_mutex);
    return v8;
  }
}
// 35A78: using guessed type int lcd_ctx;
// 35A7C: using guessed type char *lcd_path;
// 2360F4: using guessed type pthread_mutex_t ui_api_mutex;

//----- (000203E4) --------------------------------------------------------
int lcd_clear_result()
{
  if ( pthread_mutex_lock(&ui_api_mutex) )
  {
    printf("%s:%d", "lcd_clear_result", 396);
    return puts("failed to api lock");
  }
  else
  {
    if ( lcd_ctx > 0 )
      lcd_clear(lcd_ctx);
    return pthread_mutex_unlock(&ui_api_mutex);
  }
}
// 35A78: using guessed type int lcd_ctx;
// 2360F4: using guessed type pthread_mutex_t ui_api_mutex;

//----- (00020450) --------------------------------------------------------
int __fastcall lcd_init(const char *a1)
{
  if ( lcd_inited )
    return 0;
  if ( a1 )
  {
    lcd_fd = open(a1, 2050);
    if ( lcd_fd >= 0 )
    {
      lcd_inited = 1;
      return lcd_fd;
    }
    else
    {
      printf("%s:%d", "lcd_init", 30);
      puts("open lcd failed!!!");
      return -1;
    }
  }
  else
  {
    printf("%s:%d", "lcd_init", 24);
    puts("bad param");
    return -3;
  }
}
// 236130: using guessed type int lcd_fd;
// 236134: using guessed type int lcd_inited;

//----- (00020504) --------------------------------------------------------
int __fastcall lcd_write(int a1, unsigned __int8 a2, int a3, unsigned int a4)
{
  size_t v5; // r3
  char *v6; // r1
  unsigned int v8; // [sp+0h] [bp+0h]
  unsigned __int8 v10; // [sp+Bh] [bp+Bh]
  size_t n; // [sp+10h] [bp+10h]
  int v12; // [sp+14h] [bp+14h]

  v8 = a4;
  v10 = a2;
  v12 = 0;
  if ( !lcd_inited )
    return -2;
  if ( a1 == lcd_fd && a2 <= 3u && a4 <= 0x40 )
  {
    if ( pthread_mutex_lock(&lcd_mutex) )
    {
      printf("%s:%d", "lcd_write", 59);
      puts("failed to lcd lock");
      return -4;
    }
    else
    {
      do
      {
        v5 = v8;
        if ( v8 >= 0x10 )
          v5 = 16;
        n = v5;
        v6 = (char *)&lcd_output + 16 * v10++;
        memcpy(v6, (const void *)(a3 + v12), v5);
        v12 += n;
        v8 -= n;
      }
      while ( v8 && v10 <= 3u );
      write(lcd_fd, &lcd_output, 0x40u);
      pthread_mutex_unlock(&lcd_mutex);
      return 0;
    }
  }
  else
  {
    printf("%s:%d", "lcd_write", 54);
    puts("bad param");
    return -3;
  }
}
// 236130: using guessed type int lcd_fd;
// 236134: using guessed type int lcd_inited;
// 236138: using guessed type pthread_mutex_t lcd_mutex;

//----- (00020628) --------------------------------------------------------
int lcd_flush()
{
  return 0;
}

//----- (00020640) --------------------------------------------------------
int __fastcall lcd_clear(int a1)
{
  if ( !lcd_inited )
    return -2;
  if ( a1 == lcd_fd )
  {
    if ( pthread_mutex_lock(&lcd_mutex) )
    {
      printf("%s:%d", "lcd_clear", 97);
      puts("failed to lcd lock");
      return -4;
    }
    else
    {
      memset(&lcd_output, 32, 0x40u);
      lseek(lcd_fd, 0, 0);
      write(lcd_fd, &lcd_output, 0x40u);
      pthread_mutex_unlock(&lcd_mutex);
      return 0;
    }
  }
  else
  {
    printf("%s:%d", "lcd_clear", 93);
    puts("bad param");
    return -3;
  }
}
// 236130: using guessed type int lcd_fd;
// 236134: using guessed type int lcd_inited;
// 236138: using guessed type pthread_mutex_t lcd_mutex;

//----- (00020724) --------------------------------------------------------
int __fastcall lcd_uninit(int a1)
{
  int v2; // [sp+Ch] [bp+Ch]

  v2 = 0;
  if ( lcd_inited )
  {
    if ( close(a1) )
    {
      printf("%s:%d", "lcd_uninit", 117);
      puts("lcd close failed!!!");
      v2 = -1;
    }
    lcd_inited = 0;
  }
  return v2;
}
// 236134: using guessed type int lcd_inited;

//----- (0002078C) --------------------------------------------------------
int __fastcall i2c_compare_e(_DWORD *a1, _DWORD *a2)
{
  return *a1 - *a2;
}

//----- (000207AC) --------------------------------------------------------
int i2c_init()
{
  _DWORD v2[2]; // [sp+14h] [bp+Ch] BYREF
  int v3; // [sp+1Ch] [bp+14h] BYREF

  v3 = -1;
  if ( platform_inited )
  {
    if ( !i2c_index )
    {
      i2c_ctx_map = (int)new_c_map((int)i2c_compare_e, 0, 0);
      pthread_mutex_init(&i2c_mutex, 0);
    }
    v3 = ++i2c_index;
    v2[0] = 0;
    v2[1] = 0;
    insert_c_map((int *)i2c_ctx_map, &v3, 4u, v2, 8u);
    return v3;
  }
  else
  {
    printf("%s:%d", "i2c_init", 41);
    puts("please init platform first!!");
    return -2;
  }
}
// 235C54: using guessed type int platform_inited;
// 236190: using guessed type pthread_mutex_t i2c_mutex;
// 2361A8: using guessed type int i2c_ctx_map;
// 2361AC: using guessed type int i2c_index;

//----- (00020880) --------------------------------------------------------
int __fastcall i2c_uninit(int a1)
{
  int result; // r0
  _DWORD v2[2]; // [sp+4h] [bp+4h] BYREF
  int (__fastcall **v3)(_DWORD); // [sp+Ch] [bp+Ch]
  int i; // [sp+10h] [bp+10h]
  int v5; // [sp+14h] [bp+14h]

  v2[0] = a1;
  v5 = 0;
  if ( pthread_mutex_lock(&i2c_mutex) )
  {
    printf("%s:%d", "i2c_uninit", 62);
    return puts("failed to i2c lock");
  }
  else
  {
    if ( exists_c_map((int *)i2c_ctx_map, (int)v2) )
    {
      printf("%s:%d", "i2c_uninit", 66);
      printf("remove %d from callback list\n", v2[0]);
      remove_c_map((int *)i2c_ctx_map, (int)v2);
    }
    else
    {
      printf("%s:%d", "i2c_uninit", 69);
      printf("ctx(%d) is not inited\n", v2[0]);
    }
    v3 = (int (__fastcall **)(_DWORD))new_iterator_c_map(i2c_ctx_map);
    for ( i = (*v3)(v3); i; i = (*v3)(v3) )
      ++v5;
    delete_iterator_c_map(v3);
    pthread_mutex_unlock(&i2c_mutex);
    if ( v5 )
    {
      printf("%s:%d", "i2c_uninit", 85);
      return printf("still have %d nodes\n", v5);
    }
    else
    {
      printf("%s:%d", "i2c_uninit", 80);
      puts("all i2c uninited");
      i2c_index = 0;
      result = delete_c_map((void ****)i2c_ctx_map);
      i2c_ctx_map = 0;
    }
  }
  return result;
}
// 236190: using guessed type pthread_mutex_t i2c_mutex;
// 2361A8: using guessed type int i2c_ctx_map;
// 2361AC: using guessed type int i2c_index;

//----- (00020A04) --------------------------------------------------------
int wait4i2c_ready()
{
  unsigned int v3; // [sp+0h] [bp+0h] BYREF
  unsigned int v4; // [sp+4h] [bp+4h]

  v3 = 0;
  v4 = 0;
  do
  {
    if ( platform_is_t9 )
      fpga_read(dword_3557C, &v3);
    else
      fpga_read(dword_35810, &v3);
    if ( v3 >> 31 == 1 )
      return 1;
    usleep(0x1388u);
  }
  while ( v4++ <= 0x13 );
  return 0;
}
// 3557C: using guessed type int dword_3557C;
// 35810: using guessed type int dword_35810;
// 235C58: using guessed type int platform_is_t9;

//----- (00020A80) --------------------------------------------------------
int __fastcall wait4i2c_data(_BYTE *a1)
{
  unsigned int v5; // [sp+8h] [bp+8h] BYREF
  unsigned int v6; // [sp+Ch] [bp+Ch]

  v5 = 0;
  v6 = 0;
  do
  {
    if ( platform_is_t9 )
      fpga_read(dword_3557C, &v5);
    else
      fpga_read(dword_35810, &v5);
    if ( v5 >> 31 == 1 )
    {
      *a1 = v5;
      return 1;
    }
    usleep(0x1388u);
  }
  while ( v6++ <= 0x13 );
  return 0;
}
// 3557C: using guessed type int dword_3557C;
// 35810: using guessed type int dword_35810;
// 235C58: using guessed type int platform_is_t9;

//----- (00020B0C) --------------------------------------------------------
int __fastcall i2c_read(int a1, int a2, unsigned int a3)
{
  int v7; // [sp+Ch] [bp+Ch] BYREF
  void *ptr; // [sp+10h] [bp+10h] BYREF
  _DWORD *v9; // [sp+14h] [bp+14h]
  int v10; // [sp+18h] [bp+18h]
  unsigned int i; // [sp+1Ch] [bp+1Ch]

  v7 = a1;
  i = 0;
  if ( pthread_mutex_lock(&i2c_mutex) )
  {
    printf("%s:%d", "i2c_read", 132);
    puts("failed to i2c lock");
    return -1;
  }
  else
  {
    v10 = 0;
    ptr = 0;
    if ( find_c_map((int *)i2c_ctx_map, (int)&v7, &ptr) == 1 )
    {
      v9 = ptr;
      v10 = (((*((_DWORD *)ptr + 1) >> 1) & 7) << 16) | (*v9 << 26) | (v9[1] >> 4 << 20) | 0x2000000;
      for ( i = 0; i < a3; ++i )
      {
        if ( !wait4i2c_ready() )
        {
          free(ptr);
          printf("%s:%d", "i2c_read", 146);
          puts("iic not ready 4 read1");
          pthread_mutex_unlock(&i2c_mutex);
          return -2;
        }
        if ( platform_is_t9 )
          fpga_write(dword_3557C, v10);
        else
          fpga_write(dword_35810, v10);
        if ( !wait4i2c_data((_BYTE *)(a2 + i)) )
        {
          free(ptr);
          printf("%s:%d", "i2c_read", 158);
          puts("iic not ready 4 read2");
          pthread_mutex_unlock(&i2c_mutex);
          return -3;
        }
      }
      free(ptr);
      pthread_mutex_unlock(&i2c_mutex);
      return a3;
    }
    else
    {
      printf("%s:%d", "i2c_read", 165);
      printf("ctx %d not inited\n", v7);
      pthread_mutex_unlock(&i2c_mutex);
      return -2;
    }
  }
}
// 3557C: using guessed type int dword_3557C;
// 35810: using guessed type int dword_35810;
// 235C58: using guessed type int platform_is_t9;
// 236190: using guessed type pthread_mutex_t i2c_mutex;
// 2361A8: using guessed type int i2c_ctx_map;

//----- (00020CE0) --------------------------------------------------------
int __fastcall i2c_write(int a1, int a2, unsigned int a3)
{
  int v7; // [sp+Ch] [bp+Ch] BYREF
  void *ptr; // [sp+10h] [bp+10h] BYREF
  _DWORD *v9; // [sp+14h] [bp+14h]
  int v10; // [sp+18h] [bp+18h]
  unsigned int i; // [sp+1Ch] [bp+1Ch]

  v7 = a1;
  i = 0;
  if ( pthread_mutex_lock(&i2c_mutex) )
  {
    printf("%s:%d", "i2c_write", 186);
    puts("failed to i2c lock");
    return -1;
  }
  else
  {
    v10 = 0;
    ptr = 0;
    if ( find_c_map((int *)i2c_ctx_map, (int)&v7, &ptr) == 1 )
    {
      v9 = ptr;
      for ( i = 0; i < a3; ++i )
      {
        v10 = *(unsigned __int8 *)(a2 + i) | (*v9 << 26) | (v9[1] >> 4 << 20) | (((v9[1] >> 1) & 7) << 16);
        if ( !wait4i2c_ready() )
        {
          free(ptr);
          printf("%s:%d", "i2c_write", 200);
          puts("iic not ready 4 write");
          pthread_mutex_unlock(&i2c_mutex);
          return -2;
        }
        if ( platform_is_t9 )
          fpga_write(dword_3557C, v10);
        else
          fpga_write(dword_35810, v10);
      }
      free(ptr);
      pthread_mutex_unlock(&i2c_mutex);
      return a3;
    }
    else
    {
      printf("%s:%d", "i2c_write", 210);
      printf("ctx %d not inited\n", v7);
      pthread_mutex_unlock(&i2c_mutex);
      return -2;
    }
  }
}
// 3557C: using guessed type int dword_3557C;
// 35810: using guessed type int dword_35810;
// 235C58: using guessed type int platform_is_t9;
// 236190: using guessed type pthread_mutex_t i2c_mutex;
// 2361A8: using guessed type int i2c_ctx_map;

//----- (00020E68) --------------------------------------------------------
int __fastcall i2c_read_reg(int a1, unsigned __int8 *a2, int a3, int a4, unsigned int a5)
{
  int v9; // [sp+Ch] [bp+Ch] BYREF
  void *ptr; // [sp+10h] [bp+10h] BYREF
  _DWORD *v11; // [sp+14h] [bp+14h]
  int v12; // [sp+18h] [bp+18h]
  unsigned int i; // [sp+1Ch] [bp+1Ch]

  v9 = a1;
  i = 0;
  if ( a3 == 1 )
  {
    if ( pthread_mutex_lock(&i2c_mutex) )
    {
      printf("%s:%d", "i2c_read_reg", 236);
      puts("failed to i2c lock");
      return -1;
    }
    else
    {
      v12 = 0;
      ptr = 0;
      if ( find_c_map((int *)i2c_ctx_map, (int)&v9, &ptr) == 1 )
      {
        v11 = ptr;
        for ( i = 0; i < a5; ++i )
        {
          if ( *v11 == 1 )
            v12 = (((v11[1] >> 1) & 7) << 16) | (*v11 << 26) | (v11[1] >> 4 << 20) | 0x2000000;
          else
            v12 = ((*a2 + i) << 8) | (*v11 << 26) | (v11[1] >> 4 << 20) | (((v11[1] >> 1) & 7) << 16) | 0x3000000;
          if ( !wait4i2c_ready() )
          {
            printf("%s:%d", "i2c_read_reg", 254);
            puts("iic not ready 4 read1");
            free(ptr);
            pthread_mutex_unlock(&i2c_mutex);
            return -2;
          }
          if ( platform_is_t9 )
            fpga_write(dword_3557C, v12);
          else
            fpga_write(dword_35810, v12);
          if ( !wait4i2c_data((_BYTE *)(a4 + i)) )
          {
            printf("%s:%d", "i2c_read_reg", 266);
            puts("iic failed to read data");
            free(ptr);
            pthread_mutex_unlock(&i2c_mutex);
            return -3;
          }
        }
        free(ptr);
        pthread_mutex_unlock(&i2c_mutex);
        return a5;
      }
      else
      {
        printf("%s:%d", "i2c_read_reg", 274);
        printf("ctx %d not inited\n", v9);
        pthread_mutex_unlock(&i2c_mutex);
        return -2;
      }
    }
  }
  else
  {
    printf("%s:%d", "i2c_read_reg", 232);
    puts("more than one byte reg address is not supported");
    return -3;
  }
}
// 3557C: using guessed type int dword_3557C;
// 35810: using guessed type int dword_35810;
// 235C58: using guessed type int platform_is_t9;
// 236190: using guessed type pthread_mutex_t i2c_mutex;
// 2361A8: using guessed type int i2c_ctx_map;

//----- (000210B0) --------------------------------------------------------
int __fastcall i2c_write_reg(int a1, unsigned __int8 *a2, int a3, int a4, unsigned int a5)
{
  int v9; // [sp+Ch] [bp+Ch] BYREF
  void *ptr; // [sp+10h] [bp+10h] BYREF
  _DWORD *v11; // [sp+14h] [bp+14h]
  unsigned int v12; // [sp+18h] [bp+18h]
  unsigned int i; // [sp+1Ch] [bp+1Ch]

  v9 = a1;
  i = 0;
  if ( a3 == 1 )
  {
    if ( pthread_mutex_lock(&i2c_mutex) )
    {
      printf("%s:%d", "i2c_write_reg", 300);
      puts("failed to i2c lock");
      return -1;
    }
    else
    {
      v12 = 0;
      ptr = 0;
      if ( find_c_map((int *)i2c_ctx_map, (int)&v9, &ptr) == 1 )
      {
        v11 = ptr;
        for ( i = 0; i < a5; ++i )
        {
          v12 = *(unsigned __int8 *)(a4 + i)
              | (*v11 << 26)
              | (v11[1] >> 4 << 20)
              | (((v11[1] >> 1) & 7) << 16)
              | ((*a2 + i) << 8)
              | 0x1000000;
          if ( !wait4i2c_ready() )
          {
            printf("%s:%d", "i2c_write_reg", 315);
            puts("iic not ready 4 write");
            free(ptr);
            pthread_mutex_unlock(&i2c_mutex);
            return -2;
          }
          if ( platform_is_t9 )
            fpga_write(dword_3557C, v12);
          else
            fpga_write(dword_35810, v12);
        }
        free(ptr);
        pthread_mutex_unlock(&i2c_mutex);
        return a5;
      }
      else
      {
        printf("%s:%d", "i2c_write_reg", 326);
        printf("ctx %d not inited\n", v9);
        pthread_mutex_unlock(&i2c_mutex);
        return -2;
      }
    }
  }
  else
  {
    printf("%s:%d", "i2c_write_reg", 296);
    puts("more than one byte reg address is not supported");
    return -3;
  }
}
// 3557C: using guessed type int dword_3557C;
// 35810: using guessed type int dword_35810;
// 235C58: using guessed type int platform_is_t9;
// 236190: using guessed type pthread_mutex_t i2c_mutex;
// 2361A8: using guessed type int i2c_ctx_map;

//----- (00021284) --------------------------------------------------------
int __fastcall i2c_ioctl(int a1, __int16 a2, int a3)
{
  _DWORD v8[2]; // [sp+10h] [bp+10h] BYREF
  void *ptr; // [sp+18h] [bp+18h]
  int v10; // [sp+1Ch] [bp+1Ch]
  _DWORD *v11; // [sp+20h] [bp+20h]
  int i; // [sp+24h] [bp+24h]

  if ( pthread_mutex_lock(&i2c_mutex) )
  {
    printf("%s:%d", "i2c_ioctl", 346);
    puts("failed to i2c lock");
    return -4;
  }
  else
  {
    v11 = new_iterator_c_map(i2c_ctx_map);
    for ( i = ((int (__fastcall *)(_DWORD *))*v11)(v11); i; i = ((int (__fastcall *)(_DWORD *))*v11)(v11) )
    {
      v10 = v11[5];
      if ( a1 == ***(_DWORD ***)(v10 + 16) )
      {
        ptr = (void *)((int (__fastcall *)(int))v11[2])(i);
        if ( a2 == 1795 )
        {
          v8[0] = *(_DWORD *)ptr;
          v8[1] = a3;
          ((void (__fastcall *)(_DWORD *, _DWORD *, int))v11[1])(v11, v8, 8);
          printf("%s:%d", "i2c_ioctl", 360);
          printf("update the slave address to %d\n", a3);
          free(ptr);
        }
        break;
      }
    }
    delete_iterator_c_map(v11);
    pthread_mutex_unlock(&i2c_mutex);
    return 0;
  }
}
// 236190: using guessed type pthread_mutex_t i2c_mutex;
// 2361A8: using guessed type int i2c_ctx_map;

//----- (00021390) --------------------------------------------------------
int __fastcall i2c_select(int a1, int a2)
{
  _DWORD v6[2]; // [sp+8h] [bp+8h] BYREF
  void *ptr; // [sp+10h] [bp+10h]
  int v8; // [sp+14h] [bp+14h]
  _DWORD *v9; // [sp+18h] [bp+18h]
  int i; // [sp+1Ch] [bp+1Ch]

  if ( pthread_mutex_lock(&i2c_mutex) )
  {
    printf("%s:%d", "i2c_select", 379);
    puts("failed to i2c lock");
    return -4;
  }
  else
  {
    v9 = new_iterator_c_map(i2c_ctx_map);
    for ( i = ((int (__fastcall *)(_DWORD *))*v9)(v9); i; i = ((int (__fastcall *)(_DWORD *))*v9)(v9) )
    {
      v8 = v9[5];
      if ( a1 == ***(_DWORD ***)(v8 + 16) )
      {
        ptr = (void *)((int (__fastcall *)(int))v9[2])(i);
        v6[0] = a2;
        v6[1] = *((_DWORD *)ptr + 1);
        ((void (__fastcall *)(_DWORD *, _DWORD *, int))v9[1])(v9, v6, 8);
        printf("%s:%d", "i2c_select", 390);
        printf("update the master address to %d\n", a2);
        free(ptr);
        break;
      }
    }
    delete_iterator_c_map(v9);
    pthread_mutex_unlock(&i2c_mutex);
    return 0;
  }
}
// 236190: using guessed type pthread_mutex_t i2c_mutex;
// 2361A8: using guessed type int i2c_ctx_map;

//----- (00021488) --------------------------------------------------------
void __cdecl json_decref(json_t *json)
{
  if ( json && *((_DWORD *)json + 1) != -1 && !--*((_DWORD *)json + 1) )
    json_delete((void **)json);
}

//----- (000214C0) --------------------------------------------------------
int __fastcall hal_load_conf(const char *a1)
{
  int v2; // r0
  int v3; // r0
  int v4; // r0
  int v5; // r0
  size_t v6; // r4
  int v7; // r0
  int v8; // r0
  int v9; // r0
  size_t v10; // r4
  _BYTE v13[252]; // [sp+8h] [bp+8h] BYREF
  int v14; // [sp+104h] [bp+104h]
  int v15; // [sp+108h] [bp+108h]
  int v16; // [sp+10Ch] [bp+10Ch]
  int v17; // [sp+110h] [bp+110h]
  int v18; // [sp+114h] [bp+114h]
  int v19; // [sp+118h] [bp+118h]
  int v20; // [sp+11Ch] [bp+11Ch]
  void *ptr; // [sp+120h] [bp+120h]
  json_t *v22; // [sp+124h] [bp+124h]
  const json_t *v23; // [sp+128h] [bp+128h]
  json_t *file; // [sp+12Ch] [bp+12Ch]
  signed int j; // [sp+130h] [bp+130h]
  signed int i; // [sp+134h] [bp+134h]

  file = 0;
  v23 = 0;
  v22 = 0;
  ptr = 0;
  memset(chains, 255, sizeof(chains));
  memset(fans, 255, sizeof(fans));
  file = json_load_file(a1, 0, (json_error_t *)v13);
  if ( file && !*(_DWORD *)file )
  {
    ptr = json_dumps(file, 0);
    printf("%s:%d", "hal_load_conf", 46);
    printf("json = %s \n", (const char *)ptr);
    free(ptr);
    v23 = (const json_t *)json_object_get(file, "chain");
    if ( v23 && *(_DWORD *)v23 == 1 )
    {
      for ( i = 0; ; ++i )
      {
        v6 = i;
        if ( v6 >= json_array_size(v23) || i > 15 )
          break;
        v22 = json_array_get(v23, i);
        if ( !v22 || *(_DWORD *)v22 )
        {
          printf("%s:%d", "hal_load_conf", 62);
          printf("%s,%d bad object in chain\n", "platform/7007/src/hal_conf.c", 62);
          json_decref(file);
          return -3;
        }
        v20 = json_object_get(v22, "id");
        v2 = json_integer_value(v20);
        chains[4 * i] = v2;
        v19 = json_object_get(v22, "uart");
        v3 = json_integer_value(v19);
        chains[4 * i + 1] = v3;
        v18 = json_object_get(v22, "plug");
        v4 = json_integer_value(v18);
        chains[4 * i + 2] = v4;
        v17 = json_object_get(v22, "reset");
        v5 = json_integer_value(v17);
        chains[4 * i + 3] = v5;
      }
      v23 = (const json_t *)json_object_get(file, "fan");
      if ( v23 && *(_DWORD *)v23 == 1 )
      {
        for ( j = 0; ; ++j )
        {
          v10 = j;
          if ( v10 >= json_array_size(v23) || j > 5 )
            break;
          v22 = json_array_get(v23, j);
          if ( !v22 || *(_DWORD *)v22 )
          {
            printf("%s:%d", "hal_load_conf", 88);
            printf("%s,%d bad object in fan\n", "platform/7007/src/hal_conf.c", 88);
            json_decref(file);
            return -5;
          }
          v16 = json_object_get(v22, "id");
          v7 = json_integer_value(v16);
          fans[3 * j] = v7;
          v15 = json_object_get(v22, "name");
          v8 = json_integer_value(v15);
          fans[3 * j + 1] = v8;
          v14 = json_object_get(v22, "max");
          v9 = json_integer_value(v14);
          fans[3 * j + 2] = v9;
        }
        v22 = (json_t *)json_object_get(file, "red");
        if ( v22 && *(_DWORD *)v22 == 3 )
        {
          red_addr = json_integer_value((int)v22);
          v22 = (json_t *)json_object_get(file, "green");
          if ( v22 && *(_DWORD *)v22 == 3 )
          {
            green_addr = json_integer_value((int)v22);
            v22 = (json_t *)json_object_get(file, "reset");
            if ( v22 && *(_DWORD *)v22 == 3 )
            {
              reset_addr = json_integer_value((int)v22);
              v22 = (json_t *)json_object_get(file, "ipreport");
              if ( v22 && *(_DWORD *)v22 == 3 )
              {
                ipreport_addr = json_integer_value((int)v22);
                json_decref(file);
                conf_loaded = 1;
                return 0;
              }
              else
              {
                printf("%s:%d", "hal_load_conf", 127);
                printf("%s,%d bad ipreport\n", "platform/7007/src/hal_conf.c", 127);
                json_decref(file);
                return -9;
              }
            }
            else
            {
              printf("%s:%d", "hal_load_conf", 119);
              printf("%s,%d bad reset\n", "platform/7007/src/hal_conf.c", 119);
              json_decref(file);
              return -8;
            }
          }
          else
          {
            printf("%s:%d", "hal_load_conf", 111);
            printf("%s,%d bad green\n", "platform/7007/src/hal_conf.c", 111);
            json_decref(file);
            return -7;
          }
        }
        else
        {
          printf("%s:%d", "hal_load_conf", 103);
          printf("%s,%d bad red\n", "platform/7007/src/hal_conf.c", 103);
          json_decref(file);
          return -6;
        }
      }
      else
      {
        printf("%s:%d", "hal_load_conf", 79);
        printf("%s,%d bad fan format\n", "platform/7007/src/hal_conf.c", 79);
        json_decref(file);
        return -4;
      }
    }
    else
    {
      printf("%s:%d", "hal_load_conf", 52);
      printf("%s,%d bad chain format\n", "platform/7007/src/hal_conf.c", 52);
      json_decref(file);
      return -2;
    }
  }
  else
  {
    printf("%s:%d", "hal_load_conf", 42);
    printf("%s,%d bad json format\n", "platform/7007/src/hal_conf.c", 42);
    return -1;
  }
}
// 2361B0: using guessed type int conf_loaded;
// 2361B4: using guessed type _DWORD chains[64];
// 2362B4: using guessed type _DWORD fans[18];
// 2362FC: using guessed type int red_addr;
// 236300: using guessed type int green_addr;
// 236304: using guessed type int reset_addr;
// 236308: using guessed type int ipreport_addr;

//----- (00021AE8) --------------------------------------------------------
int hal_led_red_addr()
{
  if ( conf_loaded )
    return red_addr;
  else
    return -1;
}
// 2361B0: using guessed type int conf_loaded;
// 2362FC: using guessed type int red_addr;

//----- (00021B14) --------------------------------------------------------
int hal_led_green_addr()
{
  if ( conf_loaded )
    return green_addr;
  else
    return -1;
}
// 2361B0: using guessed type int conf_loaded;
// 236300: using guessed type int green_addr;

//----- (00021B40) --------------------------------------------------------
int hal_key_reset_addr()
{
  if ( conf_loaded )
    return reset_addr;
  else
    return -1;
}
// 2361B0: using guessed type int conf_loaded;
// 236304: using guessed type int reset_addr;

//----- (00021B6C) --------------------------------------------------------
int hal_key_ipreport_addr()
{
  if ( conf_loaded )
    return ipreport_addr;
  else
    return -1;
}
// 2361B0: using guessed type int conf_loaded;
// 236308: using guessed type int ipreport_addr;

//----- (00021B98) --------------------------------------------------------
int __fastcall hal_chain_uart_addr(int a1)
{
  int i; // [sp+Ch] [bp+Ch]

  if ( !conf_loaded )
    return -1;
  for ( i = 0; i <= 15; ++i )
  {
    if ( chains[4 * i] == a1 )
      return chains[4 * i + 1];
  }
  return -2;
}
// 2361B0: using guessed type int conf_loaded;
// 2361B4: using guessed type _DWORD chains[64];

//----- (00021C00) --------------------------------------------------------
int __fastcall hal_chain_plug_addr(int a1)
{
  int i; // [sp+Ch] [bp+Ch]

  if ( !conf_loaded )
    return -1;
  for ( i = 0; i <= 15; ++i )
  {
    if ( chains[4 * i] == a1 )
      return chains[4 * i + 2];
  }
  return -2;
}
// 2361B0: using guessed type int conf_loaded;
// 2361B4: using guessed type _DWORD chains[64];

//----- (00021C68) --------------------------------------------------------
int __fastcall hal_chain_reset_addr(int a1)
{
  int i; // [sp+Ch] [bp+Ch]

  if ( !conf_loaded )
    return -1;
  for ( i = 0; i <= 15; ++i )
  {
    if ( chains[4 * i] == a1 )
      return chains[4 * i + 3];
  }
  return -2;
}
// 2361B0: using guessed type int conf_loaded;
// 2361B4: using guessed type _DWORD chains[64];

//----- (00021CD0) --------------------------------------------------------
int hal_chain_max_num()
{
  int i; // [sp+4h] [bp+4h]

  if ( !conf_loaded )
    return -1;
  for ( i = 0;
        i <= 15
     && (chains[4 * i] != 255 || chains[4 * i + 1] != 255 || chains[4 * i + 2] != 255 || chains[4 * i + 3] != 255);
        ++i )
  {
    ;
  }
  return i;
}
// 2361B0: using guessed type int conf_loaded;
// 2361B4: using guessed type _DWORD chains[64];

//----- (00021D6C) --------------------------------------------------------
int __fastcall hal_fan_addr(int a1)
{
  int i; // [sp+Ch] [bp+Ch]

  if ( !conf_loaded )
    return -1;
  for ( i = 0; i <= 5; ++i )
  {
    if ( fans[3 * i] == a1 )
      return fans[3 * i + 1];
  }
  return -2;
}
// 2361B0: using guessed type int conf_loaded;
// 2362B4: using guessed type _DWORD fans[18];

//----- (00021DE0) --------------------------------------------------------
int __fastcall hal_fan_max_speed(int a1)
{
  int i; // [sp+Ch] [bp+Ch]

  if ( !conf_loaded )
    return -1;
  for ( i = 0; i <= 5; ++i )
  {
    if ( fans[3 * i] == a1 )
      return fans[3 * i + 2];
  }
  return -1;
}
// 2361B0: using guessed type int conf_loaded;
// 2362B4: using guessed type _DWORD fans[18];

//----- (00021E54) --------------------------------------------------------
int hal_fan_number()
{
  int i; // [sp+0h] [bp+0h]
  int v3; // [sp+4h] [bp+4h]

  v3 = 0;
  if ( !conf_loaded )
    return -1;
  for ( i = 0; i <= 5; ++i )
  {
    if ( fans[3 * i] != -1 )
      ++v3;
  }
  return v3;
}
// 2361B0: using guessed type int conf_loaded;
// 2362B4: using guessed type _DWORD fans[18];

//----- (00021EB4) --------------------------------------------------------
_DWORD *__fastcall new_c_map(int a1, int a2, int a3)
{
  _DWORD *v8; // [sp+14h] [bp+14h]

  v8 = malloc(4u);
  if ( !v8 )
    return 0;
  *v8 = new_c_rb(a1, a2, a3);
  if ( *v8 )
    return v8;
  else
    return 0;
}

//----- (00021EFC) --------------------------------------------------------
int __fastcall insert_c_map(int *a1, const void *a2, size_t a3, const void *a4, size_t a5)
{
  if ( a1 )
    return insert_c_rb(*a1, a2, a3, a4, a5);
  else
    return 501;
}

//----- (00021F38) --------------------------------------------------------
bool __fastcall exists_c_map(int *a1, int a2)
{
  return a1 && find_c_rb(*a1, a2) != 0;
}

//----- (00021F74) --------------------------------------------------------
int __fastcall remove_c_map(int *a1, int a2)
{
  void *ptr; // [sp+Ch] [bp+Ch] BYREF
  void *v5; // [sp+10h] [bp+10h]
  int v6; // [sp+14h] [bp+14h]

  v6 = 0;
  if ( !a1 )
    return 501;
  v5 = remove_c_rb(*a1, a2);
  if ( v5 )
  {
    get_raw_clib_object(*((_DWORD *)v5 + 4), &ptr);
    free(ptr);
    delete_clib_object(*((void ***)v5 + 4));
    get_raw_clib_object(*((_DWORD *)v5 + 5), &ptr);
    free(ptr);
    delete_clib_object(*((void ***)v5 + 5));
    free(v5);
  }
  return v6;
}

//----- (00021FF8) --------------------------------------------------------
int __fastcall find_c_map(int *a1, int a2, void **a3)
{
  _DWORD *c_rb; // [sp+14h] [bp+14h]

  if ( !a1 )
    return 0;
  c_rb = find_c_rb(*a1, a2);
  if ( !c_rb )
    return 0;
  get_raw_clib_object(c_rb[5], a3);
  return 1;
}

//----- (00022040) --------------------------------------------------------
int __fastcall delete_c_map(void ****a1)
{
  int v3; // [sp+Ch] [bp+Ch]

  v3 = 0;
  if ( a1 )
  {
    v3 = delete_c_rb(*a1);
    free(a1);
  }
  return v3;
}

//----- (00022070) --------------------------------------------------------
_DWORD *__fastcall minimum_c_map(int *a1)
{
  return minimum_c_rb(*a1, *(_DWORD **)*a1);
}

//----- (00022098) --------------------------------------------------------
int __fastcall get_next_c_map(int a1)
{
  if ( *(_DWORD *)(a1 + 20) )
    *(_DWORD *)(a1 + 20) = tree_successor(**(int ***)(a1 + 12), *(_DWORD *)(a1 + 20));
  else
    *(_DWORD *)(a1 + 20) = minimum_c_map(*(int **)(a1 + 12));
  if ( *(_DWORD *)(a1 + 20) )
    return *(_DWORD *)(*(_DWORD *)(a1 + 20) + 20);
  else
    return 0;
}

//----- (000220F4) --------------------------------------------------------
void *__fastcall get_value_c_map(int a1)
{
  void *v2; // [sp+Ch] [bp+Ch] BYREF

  get_raw_clib_object(a1, &v2);
  return v2;
}

//----- (00022114) --------------------------------------------------------
void *__fastcall replace_value_c_map(int a1, const void *a2, size_t a3)
{
  void *v7; // [sp+10h] [bp+10h] BYREF
  int v8; // [sp+14h] [bp+14h]

  v8 = *(_DWORD *)(a1 + 12);
  if ( *(_DWORD *)(*(_DWORD *)v8 + 32) )
  {
    get_raw_clib_object(*(_DWORD *)(a1 + 20), &v7);
    (*(void (__fastcall **)(void *))(*(_DWORD *)v8 + 32))(v7);
  }
  return replace_raw_clib_object(*(void ***)(*(_DWORD *)(a1 + 20) + 20), a2, a3);
}

//----- (00022164) --------------------------------------------------------
_DWORD *__fastcall new_iterator_c_map(int a1)
{
  _DWORD *result; // r0

  result = malloc(0x18u);
  *result = get_next_c_map;
  result[2] = get_value_c_map;
  result[1] = replace_value_c_map;
  result[3] = a1;
  result[4] = 0;
  result[5] = 0;
  return result;
}

//----- (000221B8) --------------------------------------------------------
void __fastcall delete_iterator_c_map(void *a1)
{
  free(a1);
}

//----- (000221D0) --------------------------------------------------------
_DWORD *__fastcall _left_rotate(_DWORD *result, _DWORD *a2)
{
  _DWORD *v2; // [sp+Ch] [bp+Ch]

  v2 = (_DWORD *)a2[1];
  a2[1] = *v2;
  if ( (_DWORD *)*v2 != result + 1 )
    *(_DWORD *)(*v2 + 8) = a2;
  if ( result + 1 != v2 )
    v2[2] = a2[2];
  if ( a2[2] )
  {
    if ( *(_DWORD **)a2[2] == a2 )
      *(_DWORD *)a2[2] = v2;
    else
      *(_DWORD *)(a2[2] + 4) = v2;
  }
  else
  {
    *result = v2;
  }
  *v2 = a2;
  if ( result + 1 != a2 )
    a2[2] = v2;
  return result;
}

//----- (0002225C) --------------------------------------------------------
_DWORD *__fastcall _right_rotate(_DWORD *result, _DWORD *a2)
{
  _DWORD *v2; // [sp+Ch] [bp+Ch]

  v2 = (_DWORD *)*a2;
  *a2 = *(_DWORD *)(*a2 + 4);
  if ( (_DWORD *)v2[1] != result + 1 )
    *(_DWORD *)(v2[1] + 8) = a2;
  if ( result + 1 != v2 )
    v2[2] = a2[2];
  if ( a2[2] )
  {
    if ( *(_DWORD **)(a2[2] + 4) == a2 )
      *(_DWORD *)(a2[2] + 4) = v2;
    else
      *(_DWORD *)a2[2] = v2;
  }
  else
  {
    *result = v2;
  }
  v2[1] = a2;
  if ( result + 1 != a2 )
    a2[2] = v2;
  return result;
}

//----- (000222E8) --------------------------------------------------------
_DWORD *__fastcall new_c_rb(int a1, int a2, int a3)
{
  _DWORD *s; // [sp+14h] [bp+14h]

  s = malloc(0x28u);
  if ( !s )
    return 0;
  memset(s, 0, 0x28u);
  s[9] = a1;
  s[7] = a2;
  s[8] = a3;
  *s = s + 1;
  s[1] = s + 1;
  s[2] = s + 1;
  s[3] = 0;
  s[4] = 0;
  return s;
}

//----- (00022354) --------------------------------------------------------
_DWORD *__fastcall _rb_insert_fixup(_DWORD *result, _DWORD *a2)
{
  _DWORD *v3; // [sp+4h] [bp+4h]
  int v4; // [sp+8h] [bp+8h]
  int v5; // [sp+Ch] [bp+Ch]

  v3 = result;
  while ( (_DWORD *)*v3 != a2 && *(_DWORD *)(a2[2] + 12) == 1 )
  {
    if ( a2[2] == **(_DWORD **)(a2[2] + 8) )
    {
      v5 = *(_DWORD *)(*(_DWORD *)(a2[2] + 8) + 4);
      if ( *(_DWORD *)(v5 + 12) == 1 )
      {
        *(_DWORD *)(a2[2] + 12) = 0;
        *(_DWORD *)(v5 + 12) = 0;
        *(_DWORD *)(*(_DWORD *)(a2[2] + 8) + 12) = 1;
        a2 = *(_DWORD **)(a2[2] + 8);
      }
      else
      {
        if ( *(_DWORD **)(a2[2] + 4) == a2 )
        {
          a2 = (_DWORD *)a2[2];
          _left_rotate(v3, a2);
        }
        *(_DWORD *)(a2[2] + 12) = 0;
        *(_DWORD *)(*(_DWORD *)(a2[2] + 8) + 12) = 1;
        result = _right_rotate(v3, *(_DWORD **)(a2[2] + 8));
      }
    }
    else
    {
      v4 = **(_DWORD **)(a2[2] + 8);
      if ( *(_DWORD *)(v4 + 12) == 1 )
      {
        *(_DWORD *)(a2[2] + 12) = 0;
        *(_DWORD *)(v4 + 12) = 0;
        *(_DWORD *)(*(_DWORD *)(a2[2] + 8) + 12) = 1;
        a2 = *(_DWORD **)(a2[2] + 8);
      }
      else
      {
        if ( *(_DWORD **)a2[2] == a2 )
        {
          a2 = (_DWORD *)a2[2];
          _right_rotate(v3, a2);
        }
        *(_DWORD *)(a2[2] + 12) = 0;
        *(_DWORD *)(*(_DWORD *)(a2[2] + 8) + 12) = 1;
        result = _left_rotate(v3, *(_DWORD **)(a2[2] + 8));
      }
    }
  }
  *(_DWORD *)(*v3 + 12) = 0;
  return result;
}

//----- (00022474) --------------------------------------------------------
_DWORD *__fastcall find_c_rb(int a1, int a2)
{
  _DWORD *v2; // r3
  void *ptr; // [sp+Ch] [bp+Ch] BYREF
  int v8; // [sp+10h] [bp+10h]
  _DWORD *i; // [sp+14h] [bp+14h]

  for ( i = *(_DWORD **)a1; (_DWORD *)(a1 + 4) != i; i = v2 )
  {
    v8 = 0;
    get_raw_clib_object(i[4], &ptr);
    v8 = (*(int (__fastcall **)(int, void *))(a1 + 36))(a2, ptr);
    free(ptr);
    if ( !v8 )
      break;
    if ( v8 >= 0 )
      v2 = (_DWORD *)i[1];
    else
      v2 = (_DWORD *)*i;
  }
  if ( (_DWORD *)(a1 + 4) == i )
    return 0;
  else
    return i;
}

//----- (000224EC) --------------------------------------------------------
int __fastcall insert_c_rb(int a1, const void *a2, size_t a3, const void *a4, size_t a5)
{
  void *v11; // [sp+10h] [bp+10h] BYREF
  void *v12; // [sp+14h] [bp+14h] BYREF
  void *v13; // [sp+18h] [bp+18h] BYREF
  void *ptr; // [sp+1Ch] [bp+1Ch] BYREF
  int v15; // [sp+20h] [bp+20h]
  int v16; // [sp+24h] [bp+24h]
  _DWORD *v17; // [sp+28h] [bp+28h]
  int v18; // [sp+2Ch] [bp+2Ch]
  _DWORD *v19; // [sp+30h] [bp+30h]
  _DWORD *v20; // [sp+34h] [bp+34h]

  v18 = 0;
  v17 = malloc(0x18u);
  if ( !v17 )
    return 2;
  *v17 = a1 + 4;
  v17[1] = a1 + 4;
  v17[3] = 1;
  v17[4] = new_clib_object(a2, a3);
  if ( a4 )
    v17[5] = new_clib_object(a4, a5);
  else
    v17[5] = 0;
  v20 = *(_DWORD **)a1;
  v19 = 0;
  while ( (_DWORD *)(a1 + 4) != v20 )
  {
    v16 = 0;
    get_raw_clib_object(v20[4], &ptr);
    get_raw_clib_object(v17[4], &v13);
    v16 = (*(int (__fastcall **)(void *, void *))(a1 + 36))(v13, ptr);
    free(ptr);
    free(v13);
    if ( !v16 )
      return 401;
    v19 = v20;
    if ( v16 >= 0 )
      v20 = (_DWORD *)v20[1];
    else
      v20 = (_DWORD *)*v20;
  }
  v17[2] = v19;
  if ( v19 )
  {
    v15 = 0;
    get_raw_clib_object(v19[4], &v12);
    get_raw_clib_object(v17[4], &v11);
    v15 = (*(int (__fastcall **)(void *, void *))(a1 + 36))(v11, v12);
    free(v12);
    free(v11);
    if ( v15 >= 0 )
      v19[1] = v17;
    else
      *v19 = v17;
  }
  else
  {
    *(_DWORD *)a1 = v17;
  }
  _rb_insert_fixup((_DWORD *)a1, v17);
  debug_verify_properties((int *)a1);
  return v18;
}

//----- (00022658) --------------------------------------------------------
int *__fastcall _rb_remove_fixup(int *result, int a2)
{
  int *v3; // [sp+4h] [bp+4h]
  _DWORD *v4; // [sp+8h] [bp+8h]
  _DWORD *v5; // [sp+Ch] [bp+Ch]

  v3 = result;
  while ( *v3 != a2 && !*(_DWORD *)(a2 + 12) )
  {
    if ( **(_DWORD **)(a2 + 8) == a2 )
    {
      v5 = *(_DWORD **)(*(_DWORD *)(a2 + 8) + 4);
      if ( v5[3] == 1 )
      {
        v5[3] = 0;
        *(_DWORD *)(*(_DWORD *)(a2 + 8) + 12) = 1;
        result = _left_rotate(v3, *(_DWORD **)(a2 + 8));
        v5 = *(_DWORD **)(*(_DWORD *)(a2 + 8) + 4);
      }
      if ( *(_DWORD *)(*v5 + 12) || *(_DWORD *)(v5[1] + 12) )
      {
        if ( !*(_DWORD *)(v5[1] + 12) )
        {
          *(_DWORD *)(*v5 + 12) = 0;
          v5[3] = 1;
          _right_rotate(v3, v5);
          v5 = *(_DWORD **)(*(_DWORD *)(a2 + 8) + 4);
        }
        v5[3] = *(_DWORD *)(*(_DWORD *)(a2 + 8) + 12);
        *(_DWORD *)(*(_DWORD *)(a2 + 8) + 12) = 0;
        *(_DWORD *)(v5[1] + 12) = 0;
        result = _left_rotate(v3, *(_DWORD **)(a2 + 8));
        a2 = *v3;
      }
      else
      {
        v5[3] = 1;
        a2 = *(_DWORD *)(a2 + 8);
      }
    }
    else
    {
      v4 = **(_DWORD ***)(a2 + 8);
      if ( v4[3] == 1 )
      {
        v4[3] = 0;
        *(_DWORD *)(*(_DWORD *)(a2 + 8) + 12) = 1;
        result = _right_rotate(v3, *(_DWORD **)(a2 + 8));
        v4 = **(_DWORD ***)(a2 + 8);
      }
      if ( *(_DWORD *)(v4[1] + 12) || *(_DWORD *)(*v4 + 12) )
      {
        if ( !*(_DWORD *)(*v4 + 12) )
        {
          *(_DWORD *)(v4[1] + 12) = 0;
          v4[3] = 1;
          _left_rotate(v3, v4);
          v4 = **(_DWORD ***)(a2 + 8);
        }
        v4[3] = *(_DWORD *)(*(_DWORD *)(a2 + 8) + 12);
        *(_DWORD *)(*(_DWORD *)(a2 + 8) + 12) = 0;
        *(_DWORD *)(*v4 + 12) = 0;
        result = _right_rotate(v3, *(_DWORD **)(a2 + 8));
        a2 = *v3;
      }
      else
      {
        v4[3] = 1;
        a2 = *(_DWORD *)(a2 + 8);
      }
    }
  }
  *(_DWORD *)(a2 + 12) = 0;
  return result;
}

//----- (000227E4) --------------------------------------------------------
int *__fastcall _remove_c_rb(int *a1, int **a2)
{
  int v4; // [sp+Ch] [bp+Ch]
  int v5; // [sp+Ch] [bp+Ch]
  int *i; // [sp+10h] [bp+10h]
  int v7; // [sp+14h] [bp+14h]

  if ( *a2 == a1 + 1 || a2[1] == a1 + 1 )
  {
    i = (int *)a2;
  }
  else
  {
    for ( i = a2[1]; (int *)*i != a1 + 1; i = (int *)*i )
      ;
  }
  if ( (int *)*i == a1 + 1 )
    v7 = i[1];
  else
    v7 = *i;
  *(_DWORD *)(v7 + 8) = i[2];
  if ( i[2] )
  {
    if ( *(int **)i[2] == i )
      *(_DWORD *)i[2] = v7;
    else
      *(_DWORD *)(i[2] + 4) = v7;
  }
  else
  {
    *a1 = v7;
  }
  if ( i != (int *)a2 )
  {
    v4 = (int)a2[4];
    a2[4] = (int *)i[4];
    i[4] = v4;
    v5 = (int)a2[5];
    a2[5] = (int *)i[5];
    i[5] = v5;
  }
  if ( !i[3] )
    _rb_remove_fixup(a1, v7);
  debug_verify_properties(a1);
  return i;
}

//----- (000228D0) --------------------------------------------------------
int *__fastcall remove_c_rb(int a1, int a2)
{
  int *v2; // r3
  void *ptr; // [sp+Ch] [bp+Ch] BYREF
  int v8; // [sp+10h] [bp+10h]
  int **i; // [sp+14h] [bp+14h]

  i = 0;
  for ( i = *(int ***)a1; (int **)(a1 + 4) != i; i = (int **)v2 )
  {
    v8 = 0;
    get_raw_clib_object((int)i[4], &ptr);
    v8 = (*(int (__fastcall **)(int, void *))(a1 + 36))(a2, ptr);
    free(ptr);
    if ( !v8 )
      break;
    if ( v8 >= 0 )
      v2 = i[1];
    else
      v2 = *i;
  }
  if ( (int **)(a1 + 4) == i )
    return 0;
  else
    return _remove_c_rb((int *)a1, i);
}

//----- (00022954) --------------------------------------------------------
void __fastcall _delete_c_rb_node(int a1, int a2)
{
  void *v4; // [sp+8h] [bp+8h] BYREF
  void *v5; // [sp+Ch] [bp+Ch] BYREF

  if ( *(_DWORD *)(a1 + 28) )
  {
    get_raw_clib_object(*(_DWORD *)(a2 + 16), &v5);
    (*(void (__fastcall **)(void *))(a1 + 28))(v5);
  }
  delete_clib_object(*(void ***)(a2 + 16));
  if ( *(_DWORD *)(a2 + 20) )
  {
    if ( *(_DWORD *)(a1 + 32) )
    {
      get_raw_clib_object(*(_DWORD *)(a2 + 20), &v4);
      (*(void (__fastcall **)(void *))(a1 + 32))(v4);
    }
    delete_clib_object(*(void ***)(a2 + 20));
  }
}

//----- (000229C8) --------------------------------------------------------
int __fastcall delete_c_rb(void ***a1)
{
  void **ptr; // [sp+Ch] [bp+Ch]

  ptr = *a1;
  while ( a1 + 1 != (void ***)ptr )
  {
    if ( *ptr == a1 + 1 )
    {
      if ( ptr[1] == a1 + 1 )
      {
        _delete_c_rb_node((int)a1, (int)ptr);
        if ( ptr[2] )
        {
          ptr = (void **)ptr[2];
          if ( *ptr == a1 + 1 )
          {
            if ( ptr[1] != a1 + 1 )
            {
              free(ptr[1]);
              ptr[1] = a1 + 1;
            }
          }
          else
          {
            free(*ptr);
            *ptr = a1 + 1;
          }
        }
        else
        {
          free(ptr);
          ptr = (void **)(a1 + 1);
        }
      }
      else
      {
        ptr = (void **)ptr[1];
      }
    }
    else
    {
      ptr = (void **)*ptr;
    }
  }
  free(a1);
  return 0;
}

//----- (00022A84) --------------------------------------------------------
_DWORD *__fastcall minimum_c_rb(int a1, _DWORD *a2)
{
  while ( *a2 != a1 + 4 )
    a2 = (_DWORD *)*a2;
  return a2;
}

//----- (00022AB0) --------------------------------------------------------
int __fastcall maximum_c_rb(int a1, int a2)
{
  while ( *(_DWORD *)(a2 + 4) != a1 + 4 )
    a2 = *(_DWORD *)(a2 + 4);
  return a2;
}

//----- (00022ADC) --------------------------------------------------------
bool __fastcall empty_c_rb(_DWORD *a1)
{
  return *a1 != (_DWORD)(a1 + 1);
}

//----- (00022B04) --------------------------------------------------------
int *__fastcall tree_successor(int *a1, int a2)
{
  int v4; // [sp+0h] [bp+0h]
  int *i; // [sp+Ch] [bp+Ch]

  v4 = a2;
  if ( *(int **)(a2 + 4) != a1 + 1 )
    return minimum_c_rb((int)a1, *(_DWORD **)(a2 + 4));
  if ( maximum_c_rb((int)a1, *a1) == a2 )
    return 0;
  for ( i = *(int **)(v4 + 8); a1 + 1 != i && i[1] == v4; i = (int *)i[2] )
    v4 = (int)i;
  return i;
}

//----- (00022B78) --------------------------------------------------------
int __fastcall debug_verify_properties(int *a1)
{
  debug_verify_property_1((int)a1, (_DWORD *)*a1);
  debug_verify_property_2((int)a1, *a1);
  debug_verify_property_4((int)a1, (int *)*a1);
  return debug_verify_property_5((int)a1, (_DWORD *)*a1);
}

//----- (00022BB8) --------------------------------------------------------
int __fastcall debug_verify_property_1(int a1, _DWORD *a2)
{
  int result; // r0

  result = debug_node_color(a1, (int)a2);
  if ( result != 1 )
  {
    result = debug_node_color(a1, (int)a2);
    if ( result )
      _assert_fail(
        "debug_node_color(pTree,n) == 1 || debug_node_color(pTree,n) == 0",
        "3rdparty/cstl/src/c_rb.c",
        0x1DFu,
        "debug_verify_property_1");
  }
  if ( (_DWORD *)(a1 + 4) != a2 )
  {
    debug_verify_property_1(a1, (_DWORD *)*a2);
    return debug_verify_property_1(a1, (_DWORD *)a2[1]);
  }
  return result;
}

//----- (00022C2C) --------------------------------------------------------
int __fastcall debug_verify_property_2(int a1, int a2)
{
  int result; // r0

  result = debug_node_color(a1, a2);
  if ( result )
    _assert_fail("debug_node_color(pTree,root) == 0", "3rdparty/cstl/src/c_rb.c", 0x1E6u, "debug_verify_property_2");
  return result;
}

//----- (00022C6C) --------------------------------------------------------
int __fastcall debug_node_color(int a1, int a2)
{
  if ( a1 + 4 == a2 )
    return 0;
  else
    return *(_DWORD *)(a2 + 12);
}

//----- (00022C94) --------------------------------------------------------
int __fastcall debug_verify_property_4(int a1, int *a2)
{
  int result; // r0

  result = debug_node_color(a1, (int)a2);
  if ( result == 1 )
  {
    if ( debug_node_color(a1, *a2) )
      _assert_fail(
        "debug_node_color(pTree,n->left) == 0",
        "3rdparty/cstl/src/c_rb.c",
        0x1EFu,
        "debug_verify_property_4");
    if ( debug_node_color(a1, a2[1]) )
      _assert_fail(
        "debug_node_color(pTree,n->right) == 0",
        "3rdparty/cstl/src/c_rb.c",
        0x1F0u,
        "debug_verify_property_4");
    result = debug_node_color(a1, a2[2]);
    if ( result )
      _assert_fail(
        "debug_node_color(pTree,n->parent) == 0",
        "3rdparty/cstl/src/c_rb.c",
        0x1F1u,
        "debug_verify_property_4");
  }
  if ( (int *)(a1 + 4) != a2 )
  {
    debug_verify_property_4(a1, (int *)*a2);
    return debug_verify_property_4(a1, (int *)a2[1]);
  }
  return result;
}

//----- (00022D70) --------------------------------------------------------
int __fastcall debug_verify_property_5(int a1, _DWORD *a2)
{
  int v3; // [sp+Ch] [bp+Ch] BYREF

  v3 = -1;
  return debug_verify_property_5_helper(a1, a2, 0, &v3);
}

//----- (00022D98) --------------------------------------------------------
int __fastcall debug_verify_property_5_helper(int a1, _DWORD *a2, int a3, _DWORD *a4)
{
  int result; // r0

  result = debug_node_color(a1, (int)a2);
  if ( !result )
    ++a3;
  if ( (_DWORD *)(a1 + 4) == a2 )
  {
    if ( *a4 == -1 )
    {
      *a4 = a3;
    }
    else if ( *a4 != a3 )
    {
      _assert_fail(
        "black_count == *path_black_count",
        "3rdparty/cstl/src/c_rb.c",
        0x205u,
        "debug_verify_property_5_helper");
    }
  }
  else
  {
    debug_verify_property_5_helper(a1, (_DWORD *)*a2, a3, a4);
    return debug_verify_property_5_helper(a1, (_DWORD *)a2[1], a3, a4);
  }
  return result;
}

//----- (00022E2C) --------------------------------------------------------
void *__fastcall clib_copy(void *a1, const void *a2, size_t a3)
{
  return memcpy(a1, a2, a3);
}

//----- (00022E4C) --------------------------------------------------------
void *__fastcall clib_get(void *a1, const void *a2, size_t a3)
{
  return memcpy(a1, a2, a3);
}

//----- (00022E6C) --------------------------------------------------------
void **__fastcall new_clib_object(const void *a1, size_t a2)
{
  void **ptr; // [sp+Ch] [bp+Ch]

  ptr = (void **)malloc(8u);
  if ( !ptr )
    return 0;
  ptr[1] = (void *)a2;
  *ptr = malloc(a2);
  if ( *ptr )
  {
    memcpy(*ptr, a1, a2);
    return ptr;
  }
  else
  {
    free(ptr);
    return 0;
  }
}

//----- (00022ECC) --------------------------------------------------------
int __fastcall get_raw_clib_object(int a1, void **a2)
{
  *a2 = malloc(*(_DWORD *)(a1 + 4));
  if ( !*a2 )
    return 3;
  memcpy(*a2, *(const void **)a1, *(_DWORD *)(a1 + 4));
  return 0;
}

//----- (00022F18) --------------------------------------------------------
void *__fastcall replace_raw_clib_object(void **a1, const void *a2, size_t a3)
{
  free(*a1);
  *a1 = malloc(a3);
  return memcpy(*a1, a2, a3);
}

//----- (00022F54) --------------------------------------------------------
void __fastcall delete_clib_object(void **a1)
{
  if ( a1 )
  {
    free(*a1);
    free(a1);
  }
}

//----- (00022F7C) --------------------------------------------------------
char *__fastcall clib_strdup(const char *a1)
{
  return strdup(a1);
}

//----- (00022F98) --------------------------------------------------------
int __cdecl dump_to_strbuffer(const char *buffer, size_t size, void *data)
{
  return strbuffer_append_bytes((strbuffer_t *)data, buffer, size);
}

//----- (00022FBC) --------------------------------------------------------
int __cdecl dump_to_file(const char *buffer, size_t size, void *data)
{
  if ( fwrite(buffer, size, 1u, (FILE *)data) == 1 )
    return 0;
  else
    return -1;
}

//----- (00022FF0) --------------------------------------------------------
int __fastcall dump_indent(char a1, int a2, int a3, int (__fastcall *a4)(const char *, int, int), int a5)
{
  int i; // [sp+14h] [bp+14h]

  if ( (a1 & 0x1F) == 0 )
  {
    if ( a3 && (a1 & 0x20) == 0 )
      return a4(" ", 1, a5);
    return 0;
  }
  if ( !a4("\n", 1, a5) )
  {
    for ( i = 0; i < a2; ++i )
    {
      if ( a4("                                ", a1 & 0x1F, a5) )
        return -1;
    }
    return 0;
  }
  return -1;
}

//----- (00023090) --------------------------------------------------------
int __fastcall dump_string(char *a1, int (__fastcall *a2)(unsigned __int8 *, int, int), int a3, __int16 a4)
{
  char s[16]; // [sp+14h] [bp+14h] BYREF
  int v11; // [sp+24h] [bp+24h] BYREF
  int v12; // [sp+28h] [bp+28h]
  int v13; // [sp+2Ch] [bp+2Ch]
  int v14; // [sp+30h] [bp+30h]
  char *v15; // [sp+34h] [bp+34h]
  char *i; // [sp+38h] [bp+38h]
  char *v17; // [sp+3Ch] [bp+3Ch]

  if ( !a2("\"", 1, a3) )
  {
    v17 = a1;
    for ( i = a1; ; a1 = i )
    {
      while ( *i )
      {
        i = utf8_iterate(v17, &v11);
        if ( !i )
          return -1;
        if ( v11 == 92 || v11 == 34 || v11 <= 31 || (a4 & 0x400) != 0 && v11 == 47 || (a4 & 0x40) != 0 && v11 > 127 )
          break;
        v17 = i;
      }
      if ( v17 != a1 && a2((unsigned __int8 *)a1, v17 - a1, a3) )
        return -1;
      if ( i == v17 )
        return a2("\"", 1, a3);
      v14 = 2;
      if ( v11 == 12 )
      {
        v15 = "\\f";
        goto LABEL_43;
      }
      if ( v11 > 12 )
      {
        if ( v11 == 34 )
        {
          v15 = "\\\"";
          goto LABEL_43;
        }
        if ( v11 > 34 )
        {
          if ( v11 == 47 )
          {
            v15 = "\\/";
            goto LABEL_43;
          }
          if ( v11 == 92 )
          {
            v15 = "\\\\";
            goto LABEL_43;
          }
        }
        else if ( v11 == 13 )
        {
          v15 = "\\r";
          goto LABEL_43;
        }
      }
      else
      {
        switch ( v11 )
        {
          case 9:
            v15 = "\\t";
            goto LABEL_43;
          case 10:
            v15 = "\\n";
            goto LABEL_43;
          case 8:
            v15 = "\\b";
            goto LABEL_43;
        }
      }
      if ( v11 > 0xFFFF )
      {
        v11 -= 0x10000;
        v13 = ((int)((unsigned int)&unk_FFC00 & v11) >> 10) | 0xD800;
        v12 = v11 & 0x3FF | 0xDC00;
        sprintf(s, "\\u%04x\\u%04x", v13, v12);
        v14 = 12;
      }
      else
      {
        sprintf(s, "\\u%04x", v11);
        v14 = 6;
      }
      v15 = s;
LABEL_43:
      if ( a2((unsigned __int8 *)v15, v14, a3) )
        return -1;
      v17 = i;
    }
  }
  return -1;
}

//----- (00023298) --------------------------------------------------------
int __fastcall object_key_compare_keys(int a1, int a2)
{
  return strcmp(*(const char **)(a1 + 4), *(const char **)(a2 + 4));
}

//----- (000232C0) --------------------------------------------------------
int __fastcall object_key_compare_serials(_DWORD *a1, _DWORD *a2)
{
  if ( *a1 < *a2 )
    return -1;
  else
    return *a1 != *a2;
}

//----- (00023300) --------------------------------------------------------
int __fastcall do_dump(json_t *a1, int a2, int a3, int (__fastcall *a4)(const char *, int, int), int a5)
{
  double v5; // d0
  __int64 v7; // r0
  char *v8; // r0
  json_t *v9; // r0
  char *v10; // r0
  _DWORD *v11; // r0
  char s[100]; // [sp+18h] [bp+10h] BYREF
  _DWORD *v18; // [sp+7Ch] [bp+74h]
  char *v19; // [sp+80h] [bp+78h]
  void *base; // [sp+84h] [bp+7Ch]
  size_t nmemb; // [sp+88h] [bp+80h]
  void *v22; // [sp+8Ch] [bp+84h]
  json_t *v23; // [sp+90h] [bp+88h]
  signed int v24; // [sp+94h] [bp+8Ch]
  json_t *v25; // [sp+98h] [bp+90h]
  int v26; // [sp+9Ch] [bp+94h]
  double v27; // [sp+A0h] [bp+98h]
  unsigned int v28; // [sp+ACh] [bp+A4h]
  __compar_fn_t compar; // [sp+B0h] [bp+A8h]
  size_t i; // [sp+B4h] [bp+ACh]
  int v31; // [sp+B8h] [bp+B0h]
  const char *v32; // [sp+BCh] [bp+B4h]
  void *v33; // [sp+C0h] [bp+B8h]
  signed int v34; // [sp+C4h] [bp+BCh]

  if ( a1 )
  {
    switch ( *(_DWORD *)a1 )
    {
      case 0:
        if ( (a2 & 0x20) != 0 )
        {
          v32 = ":";
          v31 = 1;
        }
        else
        {
          v32 = ": ";
          v31 = 2;
        }
        v23 = a1;
        if ( *((_DWORD *)a1 + 8) )
          goto LABEL_74;
        *((_DWORD *)v23 + 8) = 1;
        v33 = json_object_iter(a1);
        if ( a4("{", 1, a5) )
          goto LABEL_74;
        if ( !v33 )
          goto LABEL_36;
        if ( dump_indent(a2, a3 + 1, 0, a4, a5) )
          goto LABEL_74;
        if ( (a2 & 0x80) != 0 || (a2 & 0x100) != 0 )
        {
          nmemb = json_object_size(a1);
          base = jsonp_malloc(8 * nmemb);
          if ( !base )
          {
LABEL_74:
            *((_DWORD *)v23 + 8) = 0;
            return -1;
          }
          i = 0;
          while ( v33 )
          {
            *((_DWORD *)base + 2 * i) = hashtable_iter_serial((int)v33);
            *((_DWORD *)base + 2 * i + 1) = json_object_iter_key(v33);
            v33 = json_object_iter_next(a1, v33);
            ++i;
          }
          if ( i != nmemb )
            _assert_fail("i == size", "3rdparty/jansson-2.6/src/dump.c", 0x141u, "do_dump");
          if ( (a2 & 0x80) != 0 )
            compar = (__compar_fn_t)object_key_compare_keys;
          else
            compar = (__compar_fn_t)object_key_compare_serials;
          qsort(base, nmemb, 8u, compar);
          for ( i = 0; i < nmemb; ++i )
          {
            v19 = (char *)*((_DWORD *)base + 2 * i + 1);
            v18 = (_DWORD *)json_object_get(a1, v19);
            if ( !v18 )
              _assert_fail("value", "3rdparty/jansson-2.6/src/dump.c", 0x151u, "do_dump");
            dump_string(v19, (int (__fastcall *)(unsigned __int8 *, int, int))a4, a5, a2);
            if ( a4(v32, v31, a5) || do_dump(v18, a2, a3 + 1, a4, a5) )
            {
LABEL_60:
              jsonp_free(base);
              goto LABEL_74;
            }
            if ( nmemb - 1 <= i )
            {
              if ( dump_indent(a2, a3, 0, a4, a5) )
                goto LABEL_60;
            }
            else if ( a4(",", 1, a5) || dump_indent(a2, a3 + 1, 1, a4, a5) )
            {
              goto LABEL_60;
            }
          }
          jsonp_free(base);
        }
        else
        {
          while ( v33 )
          {
            v22 = json_object_iter_next(a1, v33);
            v10 = (char *)json_object_iter_key(v33);
            dump_string(v10, (int (__fastcall *)(unsigned __int8 *, int, int))a4, a5, a2);
            if ( a4(v32, v31, a5) )
              goto LABEL_74;
            v11 = (_DWORD *)json_object_iter_value((int)v33);
            if ( do_dump(v11, a2, a3 + 1, a4, a5) )
              goto LABEL_74;
            if ( v22 )
            {
              if ( a4(",", 1, a5) || dump_indent(a2, a3 + 1, 1, a4, a5) )
                goto LABEL_74;
            }
            else if ( dump_indent(a2, a3, 0, a4, a5) )
            {
              goto LABEL_74;
            }
            v33 = v22;
          }
        }
LABEL_36:
        *((_DWORD *)v23 + 8) = 0;
        return a4("}", 1, a5);
      case 1:
        v25 = a1;
        if ( *((_DWORD *)a1 + 5) )
          goto LABEL_29;
        *((_DWORD *)v25 + 5) = 1;
        v24 = json_array_size(a1);
        if ( a4("[", 1, a5) )
          goto LABEL_29;
        if ( !v24 )
          goto LABEL_17;
        if ( dump_indent(a2, a3 + 1, 0, a4, a5) )
          goto LABEL_29;
        v34 = 0;
        while ( 2 )
        {
          if ( v34 >= v24 )
          {
LABEL_17:
            *((_DWORD *)v25 + 5) = 0;
            return a4("]", 1, a5);
          }
          v9 = json_array_get(a1, v34);
          if ( do_dump(v9, a2, a3 + 1, a4, a5) )
            break;
          if ( v24 - 1 <= v34 )
          {
            if ( !dump_indent(a2, a3, 0, a4, a5) )
            {
LABEL_26:
              ++v34;
              continue;
            }
          }
          else if ( !a4(",", 1, a5) && !dump_indent(a2, a3 + 1, 1, a4, a5) )
          {
            goto LABEL_26;
          }
          break;
        }
LABEL_29:
        *((_DWORD *)v25 + 5) = 0;
        return -1;
      case 2:
        v8 = (char *)json_string_value(a1);
        return dump_string(v8, (int (__fastcall *)(unsigned __int8 *, int, int))a4, a5, a2);
      case 3:
        v7 = json_integer_value((int)a1);
        v28 = snprintf(s, 0x64u, "%lld", v7);
        if ( v28 < 0x64 )
          return a4(s, v28, a5);
        else
          return -1;
      case 4:
        json_real_value(a1);
        v27 = v5;
        v26 = jsonp_dtostr(s, 0x64u);
        if ( v26 >= 0 )
          return a4(s, v26, a5);
        else
          return -1;
      case 5:
        return a4("true", 4, a5);
      case 6:
        return a4("false", 5, a5);
      case 7:
        return a4("null", 4, a5);
      default:
        return -1;
    }
  }
  return -1;
}
// 233E8: variable 'v5' is possibly undefined

//----- (00023970) --------------------------------------------------------
char *__cdecl json_dumps(const json_t *json, size_t flags)
{
  const char *v3; // r0
  __int16 v5; // [sp+0h] [bp+0h]
  _BYTE v7[12]; // [sp+8h] [bp+8h] BYREF
  char *v8; // [sp+14h] [bp+14h]

  v5 = flags;
  if ( strbuffer_init((strbuffer_t *)v7) )
    return 0;
  if ( json_dump_callback(json, (int (__fastcall *)(const char *, int, int))dump_to_strbuffer, (int)v7, v5) )
  {
    v8 = 0;
  }
  else
  {
    v3 = (const char *)strbuffer_value((int)v7);
    v8 = (char *)jsonp_strdup(v3);
  }
  strbuffer_close((strbuffer_t *)v7);
  return v8;
}

//----- (000239DC) --------------------------------------------------------
int __cdecl json_dumpf(const json_t *json, FILE *output, size_t flags)
{
  return json_dump_callback(json, (int (__fastcall *)(const char *, int, int))dump_to_file, (int)output, flags);
}

//----- (00023A08) --------------------------------------------------------
int __cdecl json_dump_file(const json_t *json, const char *path, size_t flags)
{
  int v7; // [sp+10h] [bp+10h]
  FILE *stream; // [sp+14h] [bp+14h]

  stream = fopen(path, "w");
  if ( !stream )
    return -1;
  v7 = json_dumpf(json, stream, flags);
  fclose(stream);
  return v7;
}

//----- (00023A50) --------------------------------------------------------
int __fastcall json_dump_callback(json_t *a1, int (__fastcall *a2)(const char *, int, int), int a3, __int16 a4)
{
  if ( (a4 & 0x200) != 0 || a1 && *(_DWORD *)a1 == 1 || a1 && !*(_DWORD *)a1 )
    return do_dump(a1, a4, 0, a2, a3);
  else
    return -1;
}
// 23A50: invalid function type 'int __cdecl json_dump_callback(const json_t *json, json_dump_callback_t callback, void *data, size_t flags)' has been ignored

//----- (00023AA8) --------------------------------------------------------
void __fastcall json_decref_0(int a1)
{
  if ( a1 && *(_DWORD *)(a1 + 4) != -1 && !--*(_DWORD *)(a1 + 4) )
    json_delete((void **)a1);
}

//----- (00023AE0) --------------------------------------------------------
int __fastcall hash_str(_BYTE *a1)
{
  int v2; // [sp+10h] [bp+10h]

  v2 = 5381;
  while ( *a1 )
    v2 = 33 * v2 + (unsigned __int8)*a1++;
  return v2;
}

//----- (00023B24) --------------------------------------------------------
_DWORD *__fastcall list_init(_DWORD *result)
{
  result[1] = result;
  *result = result;
  return result;
}

//----- (00023B44) --------------------------------------------------------
void __cdecl list_insert(list_t *list, list_t *node)
{
  *((_DWORD *)node + 1) = list;
  *(_DWORD *)node = *(_DWORD *)list;
  *(_DWORD *)(*(_DWORD *)list + 4) = node;
  *(_DWORD *)list = node;
}

//----- (00023B74) --------------------------------------------------------
void __cdecl list_remove(list_t *list)
{
  *(_DWORD *)(*(_DWORD *)list + 4) = *((_DWORD *)list + 1);
  **((_DWORD **)list + 1) = *(_DWORD *)list;
}

//----- (00023B9C) --------------------------------------------------------
int __cdecl bucket_is_empty(hashtable_t *hashtable, bucket_t *bucket)
{
  return *(hashtable_t **)bucket == (hashtable_t *)((char *)hashtable + 12)
      && *(_DWORD *)bucket == *((_DWORD *)bucket + 1);
}

//----- (00023BD0) --------------------------------------------------------
void __cdecl insert_to_bucket(hashtable_t *hashtable, bucket_t *bucket, list_t *list)
{
  if ( bucket_is_empty(hashtable, bucket) )
  {
    list_insert((hashtable_t *)((char *)hashtable + 12), list);
    *((_DWORD *)bucket + 1) = list;
    *(_DWORD *)bucket = *((_DWORD *)bucket + 1);
  }
  else
  {
    list_insert(*(list_t **)bucket, list);
    *(_DWORD *)bucket = list;
  }
}

//----- (00023C20) --------------------------------------------------------
int __fastcall num_buckets(int a1)
{
  return primes[*(_DWORD *)(a1 + 8)];
}
// 2CEC0: using guessed type _DWORD primes[29];

//----- (00023C44) --------------------------------------------------------
int __fastcall hashtable_find_pair(hashtable_t *a1, bucket_t *a2, const char *a3, int a4)
{
  int i; // [sp+14h] [bp+14h]

  if ( bucket_is_empty(a1, a2) )
    return 0;
  for ( i = *(_DWORD *)a2; ; i = *(_DWORD *)(i + 4) )
  {
    if ( *(_DWORD *)(i - 4) == a4 && !strcmp((const char *)(i + 16), a3) )
      return i - 4;
    if ( *((_DWORD *)a2 + 1) == i )
      break;
  }
  return 0;
}

//----- (00023CB0) --------------------------------------------------------
int __fastcall hashtable_do_del(hashtable_t *a1, const char *a2, unsigned int a3)
{
  int pair; // [sp+14h] [bp+14h]
  unsigned int v9; // [sp+18h] [bp+18h]

  v9 = *((_DWORD *)a1 + 1) + 8 * (a3 % num_buckets((int)a1));
  pair = hashtable_find_pair(a1, (bucket_t *)v9, a2, a3);
  if ( !pair )
    return -1;
  if ( pair + 4 == *(_DWORD *)v9 && pair + 4 == *(_DWORD *)(v9 + 4) )
  {
    *(_DWORD *)(v9 + 4) = (char *)a1 + 12;
    *(_DWORD *)v9 = *(_DWORD *)(v9 + 4);
  }
  else if ( pair + 4 == *(_DWORD *)v9 )
  {
    *(_DWORD *)v9 = *(_DWORD *)(pair + 8);
  }
  else if ( pair + 4 == *(_DWORD *)(v9 + 4) )
  {
    *(_DWORD *)(v9 + 4) = *(_DWORD *)(pair + 4);
  }
  list_remove((list_t *)(pair + 4));
  json_decref_0(*(_DWORD *)(pair + 12));
  jsonp_free((void *)pair);
  --*(_DWORD *)a1;
  return 0;
}

//----- (00023D80) --------------------------------------------------------
void __fastcall hashtable_do_clear(int a1)
{
  int v2; // [sp+10h] [bp+10h]
  int i; // [sp+14h] [bp+14h]

  for ( i = *(_DWORD *)(a1 + 16); a1 + 12 != i; i = v2 )
  {
    v2 = *(_DWORD *)(i + 4);
    json_decref_0(*(_DWORD *)(i + 8));
    jsonp_free((void *)(i - 4));
  }
}

//----- (00023DC4) --------------------------------------------------------
int __fastcall hashtable_do_rehash(int a1)
{
  _DWORD *v2; // r2
  int v5; // [sp+10h] [bp+10h]
  unsigned int v6; // [sp+14h] [bp+14h]
  unsigned int i; // [sp+18h] [bp+18h]
  int v8; // [sp+1Ch] [bp+1Ch]

  jsonp_free(*(void **)(a1 + 4));
  ++*(_DWORD *)(a1 + 8);
  v6 = num_buckets(a1);
  *(_DWORD *)(a1 + 4) = jsonp_malloc(8 * v6);
  if ( !*(_DWORD *)(a1 + 4) )
    return -1;
  for ( i = 0; num_buckets(a1) > i; ++i )
  {
    v2 = (_DWORD *)(*(_DWORD *)(a1 + 4) + 8 * i);
    v2[1] = a1 + 12;
    *v2 = v2[1];
  }
  v8 = *(_DWORD *)(a1 + 16);
  list_init((_DWORD *)(a1 + 12));
  while ( a1 + 12 != v8 )
  {
    v5 = *(_DWORD *)(v8 + 4);
    insert_to_bucket(
      (hashtable_t *)a1,
      (bucket_t *)(*(_DWORD *)(a1 + 4) + 8 * (*(_DWORD *)(v8 - 4) % v6)),
      (list_t *)v8);
    v8 = v5;
  }
  return 0;
}

//----- (00023EA0) --------------------------------------------------------
int __fastcall hashtable_init(_DWORD *a1)
{
  int v1; // r0
  _DWORD *v3; // r2
  unsigned int i; // [sp+Ch] [bp+Ch]

  *a1 = 0;
  a1[2] = 0;
  v1 = num_buckets((int)a1);
  a1[1] = jsonp_malloc(8 * v1);
  if ( !a1[1] )
    return -1;
  list_init(a1 + 3);
  for ( i = 0; num_buckets((int)a1) > i; ++i )
  {
    v3 = (_DWORD *)(a1[1] + 8 * i);
    v3[1] = a1 + 3;
    *v3 = v3[1];
  }
  return 0;
}

//----- (00023F28) --------------------------------------------------------
void __cdecl hashtable_close(hashtable_t *hashtable)
{
  hashtable_do_clear((int)hashtable);
  jsonp_free(*((void **)hashtable + 1));
}

//----- (00023F48) --------------------------------------------------------
int __fastcall hashtable_set(hashtable_t *a1, char *a2, int a3, int a4)
{
  unsigned int v4; // r4
  size_t v6; // r0
  int pair; // [sp+10h] [bp+10h]
  char *v13; // [sp+10h] [bp+10h]
  bucket_t *v14; // [sp+14h] [bp+14h]
  unsigned int v15; // [sp+1Ch] [bp+1Ch]

  v4 = *(_DWORD *)a1;
  if ( v4 < num_buckets((int)a1) || !hashtable_do_rehash((int)a1) )
  {
    v15 = hash_str(a2);
    v14 = (bucket_t *)(*((_DWORD *)a1 + 1) + 8 * (v15 % num_buckets((int)a1)));
    pair = hashtable_find_pair(a1, v14, a2, v15);
    if ( pair )
    {
      json_decref_0(*(_DWORD *)(pair + 12));
      *(_DWORD *)(pair + 12) = a4;
    }
    else
    {
      v6 = strlen(a2);
      v13 = (char *)jsonp_malloc(v6 + 21);
      if ( !v13 )
        return -1;
      *(_DWORD *)v13 = v15;
      *((_DWORD *)v13 + 4) = a3;
      strcpy(v13 + 20, a2);
      *((_DWORD *)v13 + 3) = a4;
      list_init((_DWORD *)v13 + 1);
      insert_to_bucket(a1, v14, (list_t *)(v13 + 4));
      ++*(_DWORD *)a1;
    }
    return 0;
  }
  return -1;
}

//----- (00024034) --------------------------------------------------------
int __fastcall hashtable_get(int a1, char *a2)
{
  int v2; // r4
  int pair; // [sp+Ch] [bp+Ch]
  bucket_t *v8; // [sp+10h] [bp+10h]
  unsigned int v9; // [sp+14h] [bp+14h]

  v9 = hash_str(a2);
  v2 = *(_DWORD *)(a1 + 4);
  v8 = (bucket_t *)(v2 + 8 * (v9 % num_buckets(a1)));
  pair = hashtable_find_pair((hashtable_t *)a1, v8, a2, v9);
  if ( pair )
    return *(_DWORD *)(pair + 12);
  else
    return 0;
}

//----- (0002408C) --------------------------------------------------------
int __fastcall hashtable_del(hashtable_t *a1, char *a2)
{
  unsigned int v5; // [sp+Ch] [bp+Ch]

  v5 = hash_str(a2);
  return hashtable_do_del(a1, a2, v5);
}

//----- (000240B4) --------------------------------------------------------
_DWORD *__fastcall hashtable_clear(_DWORD *a1)
{
  _DWORD *v1; // r2
  _DWORD *result; // r0
  unsigned int i; // [sp+Ch] [bp+Ch]

  hashtable_do_clear((int)a1);
  for ( i = 0; num_buckets((int)a1) > i; ++i )
  {
    v1 = (_DWORD *)(a1[1] + 8 * i);
    v1[1] = a1 + 3;
    *v1 = v1[1];
  }
  result = list_init(a1 + 3);
  *a1 = 0;
  return result;
}

//----- (00024114) --------------------------------------------------------
int __fastcall hashtable_iter(int a1)
{
  return hashtable_iter_next(a1, a1 + 12);
}

//----- (00024134) --------------------------------------------------------
int __fastcall hashtable_iter_at(int a1, char *a2)
{
  int v2; // r4
  int pair; // [sp+Ch] [bp+Ch]
  bucket_t *v8; // [sp+10h] [bp+10h]
  unsigned int v9; // [sp+14h] [bp+14h]

  v9 = hash_str(a2);
  v2 = *(_DWORD *)(a1 + 4);
  v8 = (bucket_t *)(v2 + 8 * (v9 % num_buckets(a1)));
  pair = hashtable_find_pair((hashtable_t *)a1, v8, a2, v9);
  if ( pair )
    return pair + 4;
  else
    return 0;
}

//----- (0002418C) --------------------------------------------------------
int __fastcall hashtable_iter_next(int a1, int a2)
{
  if ( *(_DWORD *)(a2 + 4) == a1 + 12 )
    return 0;
  else
    return *(_DWORD *)(a2 + 4);
}

//----- (000241BC) --------------------------------------------------------
int __fastcall hashtable_iter_key(int a1)
{
  return a1 + 16;
}

//----- (000241DC) --------------------------------------------------------
int __fastcall hashtable_iter_serial(int a1)
{
  return *(_DWORD *)(a1 + 12);
}

//----- (000241FC) --------------------------------------------------------
int __fastcall hashtable_iter_value(int a1)
{
  return *(_DWORD *)(a1 + 8);
}

//----- (0002421C) --------------------------------------------------------
void __fastcall hashtable_iter_set(int a1, int a2)
{
  int v3; // [sp+Ch] [bp+Ch]

  v3 = a1 - 4;
  json_decref_0(*(_DWORD *)(a1 + 8));
  *(_DWORD *)(v3 + 12) = a2;
}

//----- (00024244) --------------------------------------------------------
json_t *__cdecl json_incref(json_t *json)
{
  if ( json )
  {
    if ( *((_DWORD *)json + 1) != -1 )
      ++*((_DWORD *)json + 1);
  }
  return json;
}

//----- (00024274) --------------------------------------------------------
void __fastcall json_decref_1(int a1)
{
  if ( a1 && *(_DWORD *)(a1 + 4) != -1 && !--*(_DWORD *)(a1 + 4) )
    json_delete((void **)a1);
}

//----- (000242AC) --------------------------------------------------------
int __cdecl json_object_set_nocheck(json_t *object, const char *key, json_t *value)
{
  json_t *v3; // r0

  v3 = json_incref(value);
  return json_object_set_new_nocheck(object, (char *)key, v3);
}

//----- (000242D8) --------------------------------------------------------
int __cdecl json_array_append(json_t *array, json_t *value)
{
  json_t *v2; // r0

  v2 = json_incref(value);
  return json_array_append_new(array, v2);
}

//----- (00024300) --------------------------------------------------------
void error_set(json_error_t *error, const lex_t *lex, const char *msg, ...)
{
  char v5[159]; // [sp+10h] [bp+8h] BYREF
  char v6; // [sp+AFh] [bp+A7h]
  char s[160]; // [sp+B0h] [bp+A8h] BYREF
  __gnuc_va_list arg; // [sp+150h] [bp+148h]
  const char *v9; // [sp+154h] [bp+14Ch]
  char v10[4]; // [sp+158h] [bp+150h]
  int v11; // [sp+15Ch] [bp+154h]
  int v12; // [sp+160h] [bp+158h]
  int v13; // [sp+164h] [bp+15Ch]
  const char *varg_r2; // [sp+170h] [bp+168h]
  va_list varg_r3; // [sp+174h] [bp+16Ch] BYREF

  va_start(varg_r3, msg);
  varg_r2 = msg;
  v13 = -1;
  v12 = -1;
  v11 = 0;
  *(_DWORD *)v10 = s;
  if ( error )
  {
    va_copy(arg, varg_r3);
    vsnprintf(s, 0xA0u, varg_r2, varg_r3);
    s[159] = 0;
    if ( lex )
    {
      v9 = (const char *)strbuffer_value((int)lex + 40);
      v13 = *((_DWORD *)lex + 6);
      v12 = *((_DWORD *)lex + 7);
      v11 = *((_DWORD *)lex + 9);
      if ( v9 && *v9 )
      {
        if ( *((_DWORD *)lex + 11) <= 0x14u )
        {
          snprintf(v5, 0xA0u, "%s near '%s'", s, v9);
          v6 = 0;
          *(_DWORD *)v10 = v5;
        }
      }
      else if ( *((_DWORD *)lex + 5) == -2 )
      {
        *(_DWORD *)v10 = s;
      }
      else
      {
        snprintf(v5, 0xA0u, "%s near end of file", s);
        v6 = 0;
        *(_DWORD *)v10 = v5;
      }
    }
    jsonp_error_set(error, v13, v12, v11, "%s", *(const char **)v10);
  }
}

//----- (00024450) --------------------------------------------------------
int __fastcall stream_init(int result, int a2, int a3)
{
  *(_DWORD *)result = a2;
  *(_DWORD *)(result + 4) = a3;
  *(_BYTE *)(result + 8) = 0;
  *(_DWORD *)(result + 16) = 0;
  *(_DWORD *)(result + 20) = 0;
  *(_DWORD *)(result + 24) = 1;
  *(_DWORD *)(result + 28) = 0;
  *(_DWORD *)(result + 36) = 0;
  return result;
}
// 24450: invalid function type 'void __cdecl stream_init(stream_t *stream, get_func get, void *data)' has been ignored

//----- (00024498) --------------------------------------------------------
int __fastcall stream_get(int a1, json_error_t *a2)
{
  int v3; // r3
  signed int v7; // [sp+Ch] [bp+Ch]
  int v8; // [sp+10h] [bp+10h]
  int v9; // [sp+10h] [bp+10h]
  int i; // [sp+14h] [bp+14h]

  if ( *(_DWORD *)(a1 + 20) )
    return *(_DWORD *)(a1 + 20);
  if ( !*(_BYTE *)(a1 + *(_DWORD *)(a1 + 16) + 8) )
  {
    v8 = (*(int (__fastcall **)(_DWORD))a1)(*(_DWORD *)(a1 + 4));
    if ( v8 == -1 )
    {
      *(_DWORD *)(a1 + 20) = -1;
      return -1;
    }
    *(_BYTE *)(a1 + 8) = v8;
    *(_DWORD *)(a1 + 16) = 0;
    if ( v8 <= 127 || v8 > 255 )
    {
      *(_BYTE *)(a1 + 9) = 0;
    }
    else
    {
      v7 = utf8_check_first(v8);
      if ( !v7 )
        goto LABEL_22;
      if ( v7 <= 1 )
        _assert_fail("count >= 2", "3rdparty/jansson-2.6/src/load.c", 0xAFu, "stream_get");
      for ( i = 1; i < v7; *(_BYTE *)(a1 + i++ + 8) = (*(int (__fastcall **)(_DWORD))a1)(*(_DWORD *)(a1 + 4)) )
        ;
      if ( !utf8_check_full((char *)(a1 + 8), v7, 0) )
      {
LABEL_22:
        *(_DWORD *)(a1 + 20) = -2;
        error_set(a2, (const lex_t *)a1, "unable to decode byte 0x%x", v8);
        return -2;
      }
      *(_BYTE *)(a1 + v7 + 8) = 0;
    }
  }
  v3 = *(_DWORD *)(a1 + 16);
  v9 = *(unsigned __int8 *)(a1 + v3 + 8);
  *(_DWORD *)(a1 + 16) = v3 + 1;
  ++*(_DWORD *)(a1 + 36);
  if ( v9 == 10 )
  {
    ++*(_DWORD *)(a1 + 24);
    *(_DWORD *)(a1 + 32) = *(_DWORD *)(a1 + 28);
    *(_DWORD *)(a1 + 28) = 0;
  }
  else if ( utf8_check_first(v9) )
  {
    ++*(_DWORD *)(a1 + 28);
  }
  return v9;
}

//----- (00024610) --------------------------------------------------------
_DWORD *__fastcall stream_unget(_DWORD *result, int a2)
{
  _DWORD *v3; // [sp+4h] [bp+4h]

  v3 = result;
  if ( a2 != -1 && a2 != -2 )
  {
    --result[9];
    if ( a2 == 10 )
    {
      --result[6];
      result[7] = result[8];
    }
    else
    {
      result = (_DWORD *)utf8_check_first(a2);
      if ( result )
        --v3[7];
    }
    if ( !v3[4] )
      _assert_fail("stream->buffer_pos > 0", "3rdparty/jansson-2.6/src/load.c", 0xE0u, "stream_unget");
    if ( *((unsigned __int8 *)v3 + --v3[4] + 8) != a2 )
      _assert_fail("stream->buffer[stream->buffer_pos] == c", "3rdparty/jansson-2.6/src/load.c", 0xE2u, "stream_unget");
  }
  return result;
}

//----- (000246D4) --------------------------------------------------------
int __cdecl lex_get(lex_t *lex, json_error_t *error)
{
  return stream_get((int)lex, error);
}

//----- (000246F4) --------------------------------------------------------
void __cdecl lex_save(lex_t *lex, int c)
{
  strbuffer_append_byte((lex_t *)((char *)lex + 40), c);
}

//----- (00024718) --------------------------------------------------------
int __cdecl lex_get_save(lex_t *lex, json_error_t *error)
{
  int v4; // [sp+Ch] [bp+Ch]

  v4 = stream_get((int)lex, error);
  if ( v4 != -1 && v4 != -2 )
    lex_save(lex, v4);
  return v4;
}

//----- (00024754) --------------------------------------------------------
_DWORD *__fastcall lex_unget(_DWORD *a1, int a2)
{
  return stream_unget(a1, a2);
}

//----- (00024770) --------------------------------------------------------
_DWORD *__fastcall lex_unget_unsave(_DWORD *result, int a2)
{
  _DWORD *v3; // [sp+4h] [bp+4h]

  v3 = result;
  if ( a2 != -1 && a2 != -2 )
  {
    stream_unget(result, a2);
    result = (_DWORD *)strbuffer_pop((strbuffer_t *)(v3 + 10));
    if ( (unsigned __int8)result != a2 )
      _assert_fail("c == d", "3rdparty/jansson-2.6/src/load.c", 0x10Cu, "lex_unget_unsave");
  }
  return result;
}

//----- (000247D4) --------------------------------------------------------
void __cdecl lex_save_cached(lex_t *lex)
{
  while ( *((_BYTE *)lex + *((_DWORD *)lex + 4) + 8) )
  {
    lex_save(lex, *((unsigned __int8 *)lex + *((_DWORD *)lex + 4) + 8));
    ++*((_DWORD *)lex + 4);
    ++*((_DWORD *)lex + 9);
  }
}

//----- (0002481C) --------------------------------------------------------
int __fastcall decode_unicode_escape(_BYTE *a1)
{
  unsigned __int8 v2; // [sp+Fh] [bp+Fh]
  int v3; // [sp+10h] [bp+10h]
  int v4; // [sp+10h] [bp+10h]
  int i; // [sp+14h] [bp+14h]

  v3 = 0;
  if ( *a1 != 117 )
    _assert_fail("str[0] == 'u'", "3rdparty/jansson-2.6/src/load.c", 0x120u, "decode_unicode_escape");
  for ( i = 1; i <= 4; ++i )
  {
    v2 = a1[i];
    v4 = 16 * v3;
    if ( v2 <= 0x2Fu || v2 > 0x39u )
    {
      if ( v2 <= 0x60u || v2 > 0x7Au )
      {
        if ( v2 <= 0x40u || v2 > 0x5Au )
          _assert_fail("0", "3rdparty/jansson-2.6/src/load.c", 0x12Cu, "decode_unicode_escape");
        v3 = v4 + v2 - 55;
      }
      else
      {
        v3 = v4 + v2 - 87;
      }
    }
    else
    {
      v3 = v4 + v2 - 48;
    }
  }
  return v3;
}

//----- (000248E8) --------------------------------------------------------
void __fastcall lex_scan_string(int a1, json_error_t *a2)
{
  int v2; // r3
  size_t n; // [sp+10h] [bp+8h] BYREF
  char src[4]; // [sp+14h] [bp+Ch] BYREF
  int v7; // [sp+18h] [bp+10h]
  int32_t v8; // [sp+1Ch] [bp+14h]
  int j; // [sp+20h] [bp+18h]
  void *dest; // [sp+24h] [bp+1Ch]
  _BYTE *i; // [sp+28h] [bp+20h]
  int save; // [sp+2Ch] [bp+24h]

  *(_DWORD *)(a1 + 56) = 0;
  *(_DWORD *)(a1 + 52) = -1;
  save = lex_get_save((lex_t *)a1, a2);
  while ( 1 )
  {
    if ( save == 34 )
    {
      *(_DWORD *)(a1 + 56) = jsonp_malloc(*(_DWORD *)(a1 + 44) + 1);
      if ( !*(_DWORD *)(a1 + 56) )
        goto LABEL_79;
      dest = *(void **)(a1 + 56);
      for ( i = (_BYTE *)(strbuffer_value(a1 + 40) + 1); ; ++i )
      {
        while ( 1 )
        {
          while ( 1 )
          {
            if ( *i == 34 )
            {
              *(_BYTE *)dest = 0;
              *(_DWORD *)(a1 + 52) = 256;
              return;
            }
            if ( *i == 92 )
              break;
            *(_BYTE *)dest = *i;
            dest = (char *)dest + 1;
            ++i;
          }
          if ( *++i != 117 )
            break;
          v8 = decode_unicode_escape(i);
          i += 5;
          if ( v8 <= 55295 || v8 > 56319 )
          {
            if ( v8 > 56319 && v8 <= 57343 )
            {
LABEL_49:
              error_set(a2, (const lex_t *)a1, "invalid Unicode '\\u%04X'", v8);
              goto LABEL_79;
            }
            if ( !v8 )
            {
              error_set(a2, (const lex_t *)a1, "\\u0000 is not allowed");
              goto LABEL_79;
            }
          }
          else
          {
            if ( *i != 92 || i[1] != 117 )
              goto LABEL_49;
            v7 = decode_unicode_escape(++i);
            i += 5;
            if ( v7 <= 56319 || v7 > 57343 )
            {
              error_set(a2, (const lex_t *)a1, "invalid Unicode '\\u%04X\\u%04X'", v8, v7);
              goto LABEL_79;
            }
            v8 = ((v8 - 55296) << 10) + v7 - 56320 + 0x10000;
          }
          if ( utf8_encode(v8, src, &n) )
            _assert_fail("0", "3rdparty/jansson-2.6/src/load.c", 0x1AEu, "lex_scan_string");
          memcpy(dest, src, n);
          dest = (char *)dest + n;
        }
        v2 = (unsigned __int8)*i;
        if ( v2 == 102 )
        {
          *(_BYTE *)dest = 12;
        }
        else if ( (unsigned __int8)*i > 0x66u )
        {
          switch ( v2 )
          {
            case 'r':
              *(_BYTE *)dest = 13;
              break;
            case 't':
              *(_BYTE *)dest = 9;
              break;
            case 'n':
              *(_BYTE *)dest = 10;
              break;
            default:
              goto LABEL_74;
          }
        }
        else
        {
          if ( v2 == 92 )
            goto LABEL_68;
          if ( (unsigned __int8)*i <= 0x5Cu )
          {
            if ( v2 != 34 && v2 != 47 )
LABEL_74:
              _assert_fail("0", "3rdparty/jansson-2.6/src/load.c", 0x1BCu, "lex_scan_string");
LABEL_68:
            *(_BYTE *)dest = *i;
            goto LABEL_75;
          }
          if ( v2 != 98 )
            goto LABEL_74;
          *(_BYTE *)dest = 8;
        }
LABEL_75:
        dest = (char *)dest + 1;
      }
    }
    if ( save == -2 )
      goto LABEL_79;
    if ( save == -1 )
      break;
    if ( (unsigned int)save < 0x20 )
    {
      lex_unget_unsave((_DWORD *)a1, save);
      if ( save == 10 )
        error_set(a2, (const lex_t *)a1, "unexpected newline", 10);
      else
        error_set(a2, (const lex_t *)a1, "control character 0x%x", save);
      goto LABEL_79;
    }
    if ( save != 92 )
      goto LABEL_32;
    save = lex_get_save((lex_t *)a1, a2);
    if ( save == 117 )
    {
      save = lex_get_save((lex_t *)a1, a2);
      for ( j = 0; j <= 3; ++j )
      {
        if ( (save <= 47 || save > 57) && (save <= 64 || save > 70) && (save <= 96 || save > 102) )
          goto LABEL_18;
        save = lex_get_save((lex_t *)a1, a2);
      }
    }
    else
    {
      if ( save != 34
        && save != 92
        && save != 47
        && save != 98
        && save != 102
        && save != 110
        && save != 114
        && save != 116 )
      {
LABEL_18:
        error_set(a2, (const lex_t *)a1, "invalid escape");
        goto LABEL_79;
      }
LABEL_32:
      save = lex_get_save((lex_t *)a1, a2);
    }
  }
  error_set(a2, (const lex_t *)a1, "premature end of input");
LABEL_79:
  jsonp_free(*(void **)(a1 + 56));
}

//----- (00024CA0) --------------------------------------------------------
int __fastcall lex_scan_number(int a1, int a2, json_error_t *a3)
{
  int save; // [sp+8h] [bp+8h]
  int v7; // [sp+8h] [bp+8h]
  double v9; // [sp+10h] [bp+10h] BYREF
  char *endptr; // [sp+1Ch] [bp+1Ch] BYREF
  __int64 v11; // [sp+20h] [bp+20h]
  char *nptr; // [sp+2Ch] [bp+2Ch]

  save = a2;
  *(_DWORD *)(a1 + 52) = -1;
  if ( a2 == 45 )
    save = lex_get_save((lex_t *)a1, a3);
  if ( save == 48 )
  {
    save = lex_get_save((lex_t *)a1, a3);
    if ( save > 47 && save <= 57 )
    {
LABEL_6:
      lex_unget_unsave((_DWORD *)a1, save);
      return -1;
    }
  }
  else
  {
    if ( save <= 47 || save > 57 )
      goto LABEL_6;
    do
      save = lex_get_save((lex_t *)a1, a3);
    while ( save > 47 && save <= 57 );
  }
  if ( save == 46 || save == 69 || save == 101 )
  {
    if ( save == 46 )
    {
      v7 = lex_get((lex_t *)a1, a3);
      if ( v7 <= 47 || v7 > 57 )
      {
        lex_unget((_DWORD *)a1, v7);
        return -1;
      }
      lex_save((lex_t *)a1, v7);
      for ( save = lex_get_save((lex_t *)a1, a3); save > 47 && save <= 57; save = lex_get_save((lex_t *)a1, a3) )
        ;
    }
    if ( save == 69 || save == 101 )
    {
      save = lex_get_save((lex_t *)a1, a3);
      if ( save == 43 || save == 45 )
        save = lex_get_save((lex_t *)a1, a3);
      if ( save <= 47 || save > 57 )
        goto LABEL_6;
      do
        save = lex_get_save((lex_t *)a1, a3);
      while ( save > 47 && save <= 57 );
    }
    lex_unget_unsave((_DWORD *)a1, save);
    if ( jsonp_strtod(a1 + 40, &v9) )
    {
      error_set(a3, (const lex_t *)a1, "real number overflow");
      return -1;
    }
    *(_DWORD *)(a1 + 52) = 258;
    *(double *)(a1 + 56) = v9;
    return 0;
  }
  else
  {
    lex_unget_unsave((_DWORD *)a1, save);
    nptr = (char *)strbuffer_value(a1 + 40);
    *_errno_location() = 0;
    v11 = strtoll(nptr, &endptr, 10);
    if ( *_errno_location() == 34 )
    {
      if ( v11 >= 0 )
        error_set(a3, (const lex_t *)a1, "too big integer");
      else
        error_set(a3, (const lex_t *)a1, "too big negative integer");
      return -1;
    }
    if ( &nptr[*(_DWORD *)(a1 + 44)] != endptr )
      _assert_fail(
        "end == saved_text + lex->saved_text.length",
        "3rdparty/jansson-2.6/src/load.c",
        0x206u,
        "lex_scan_number");
    *(_DWORD *)(a1 + 52) = 257;
    *(_QWORD *)(a1 + 56) = v11;
    return 0;
  }
}
// 24CA0: too many cbuild loops

//----- (00024EF4) --------------------------------------------------------
int __fastcall lex_scan(int a1, json_error_t *a2)
{
  char *s1; // [sp+8h] [bp+8h]
  int v6; // [sp+Ch] [bp+Ch]
  int save; // [sp+Ch] [bp+Ch]

  strbuffer_clear((strbuffer_t *)(a1 + 40));
  if ( *(_DWORD *)(a1 + 52) == 256 )
  {
    jsonp_free(*(void **)(a1 + 56));
    *(_DWORD *)(a1 + 56) = 0;
  }
  do
  {
    do
      v6 = lex_get((lex_t *)a1, a2);
    while ( v6 == 32 );
  }
  while ( v6 == 9 || v6 == 10 || v6 == 13 );
  if ( v6 == -1 )
  {
    *(_DWORD *)(a1 + 52) = 0;
  }
  else if ( v6 == -2 )
  {
    *(_DWORD *)(a1 + 52) = -1;
  }
  else
  {
    lex_save((lex_t *)a1, v6);
    if ( v6 == 123 || v6 == 125 || v6 == 91 || v6 == 93 || v6 == 58 || v6 == 44 )
    {
      *(_DWORD *)(a1 + 52) = v6;
    }
    else if ( v6 == 34 )
    {
      lex_scan_string(a1, a2);
    }
    else if ( v6 > 47 && v6 <= 57 || v6 == 45 )
    {
      lex_scan_number(a1, v6, a2);
    }
    else if ( (v6 <= 64 || v6 > 90) && (v6 <= 96 || v6 > 122) )
    {
      lex_save_cached((lex_t *)a1);
      *(_DWORD *)(a1 + 52) = -1;
    }
    else
    {
      do
      {
        do
          save = lex_get_save((lex_t *)a1, a2);
        while ( save > 64 && save <= 90 );
      }
      while ( save > 96 && save <= 122 );
      lex_unget_unsave((_DWORD *)a1, save);
      s1 = (char *)strbuffer_value(a1 + 40);
      if ( !strcmp(s1, "true") )
      {
        *(_DWORD *)(a1 + 52) = 259;
      }
      else if ( !strcmp(s1, "false") )
      {
        *(_DWORD *)(a1 + 52) = 260;
      }
      else if ( !strcmp(s1, "null") )
      {
        *(_DWORD *)(a1 + 52) = 261;
      }
      else
      {
        *(_DWORD *)(a1 + 52) = -1;
      }
    }
  }
  return *(_DWORD *)(a1 + 52);
}

//----- (000250B4) --------------------------------------------------------
int __fastcall lex_steal_string(int a1)
{
  int v2; // [sp+Ch] [bp+Ch]

  v2 = 0;
  if ( *(_DWORD *)(a1 + 52) == 256 )
  {
    v2 = *(_DWORD *)(a1 + 56);
    *(_DWORD *)(a1 + 56) = 0;
  }
  return v2;
}

//----- (000250E4) --------------------------------------------------------
int __fastcall lex_init(int a1, int a2, int a3)
{
  stream_init(a1, a2, a3);
  if ( strbuffer_init((strbuffer_t *)(a1 + 40)) )
    return -1;
  *(_DWORD *)(a1 + 52) = -1;
  return 0;
}

//----- (00025128) --------------------------------------------------------
void __fastcall lex_close(int a1)
{
  if ( *(_DWORD *)(a1 + 52) == 256 )
    jsonp_free(*(void **)(a1 + 56));
  strbuffer_close((strbuffer_t *)(a1 + 40));
}

//----- (00025158) --------------------------------------------------------
json_t *__fastcall parse_object(const lex_t *a1, unsigned int a2, json_error_t *a3)
{
  json_t *v8; // [sp+14h] [bp+14h]
  void *v9; // [sp+18h] [bp+18h]
  json_t *v10; // [sp+1Ch] [bp+1Ch]

  v10 = (json_t *)json_object();
  if ( !v10 )
    return 0;
  lex_scan((int)a1, a3);
  if ( *((_DWORD *)a1 + 13) == 125 )
    return v10;
  while ( 1 )
  {
    if ( *((_DWORD *)a1 + 13) != 256 )
    {
      error_set(a3, a1, "string or '}' expected");
      goto LABEL_23;
    }
    v9 = (void *)lex_steal_string((int)a1);
    if ( !v9 )
      return 0;
    if ( (a2 & 1) != 0 && json_object_get(v10, (char *)v9) )
    {
      jsonp_free(v9);
      error_set(a3, a1, "duplicate object key");
      goto LABEL_23;
    }
    lex_scan((int)a1, a3);
    if ( *((_DWORD *)a1 + 13) != 58 )
    {
      jsonp_free(v9);
      error_set(a3, a1, "':' expected");
      goto LABEL_23;
    }
    lex_scan((int)a1, a3);
    v8 = (json_t *)parse_value(COERCE_DOUBLE(__PAIR64__(a2, (unsigned int)a1)), (int)a3);
    if ( !v8 )
    {
      jsonp_free(v9);
      goto LABEL_23;
    }
    if ( json_object_set_nocheck(v10, (const char *)v9, v8) )
    {
      jsonp_free(v9);
      json_decref_1((int)v8);
      goto LABEL_23;
    }
    json_decref_1((int)v8);
    jsonp_free(v9);
    lex_scan((int)a1, a3);
    if ( *((_DWORD *)a1 + 13) != 44 )
      break;
    lex_scan((int)a1, a3);
  }
  if ( *((_DWORD *)a1 + 13) == 125 )
    return v10;
  error_set(a3, a1, "'}' expected");
LABEL_23:
  json_decref_1((int)v10);
  return 0;
}

//----- (000252A8) --------------------------------------------------------
json_t *__fastcall parse_array(const lex_t *a1, unsigned int a2, json_error_t *a3)
{
  json_t *v8; // [sp+10h] [bp+10h]
  json_t *v9; // [sp+14h] [bp+14h]

  v9 = (json_t *)json_array();
  if ( !v9 )
    return 0;
  lex_scan((int)a1, a3);
  if ( *((_DWORD *)a1 + 13) == 93 )
    return v9;
  while ( *((_DWORD *)a1 + 13) )
  {
    v8 = (json_t *)parse_value(COERCE_DOUBLE(__PAIR64__(a2, (unsigned int)a1)), (int)a3);
    if ( !v8 )
      goto LABEL_14;
    if ( json_array_append(v9, v8) )
    {
      json_decref_1((int)v8);
      goto LABEL_14;
    }
    json_decref_1((int)v8);
    lex_scan((int)a1, a3);
    if ( *((_DWORD *)a1 + 13) != 44 )
      break;
    lex_scan((int)a1, a3);
  }
  if ( *((_DWORD *)a1 + 13) == 93 )
    return v9;
  error_set(a3, a1, "']' expected");
LABEL_14:
  json_decref_1((int)v9);
  return 0;
}

//----- (00025360) --------------------------------------------------------
_DWORD *__fastcall parse_value(double a1, json_error_t *a2)
{
  int v2; // r3
  double v3; // r0
  const lex_t *v7; // [sp+Ch] [bp+Ch]
  double v8; // [sp+10h] [bp+10h] BYREF
  _DWORD *v9; // [sp+1Ch] [bp+1Ch]

  v7 = (const lex_t *)LODWORD(a1);
  v2 = *(_DWORD *)(LODWORD(a1) + 52);
  if ( v2 == 257 )
  {
    if ( (BYTE4(a1) & 8) != 0 )
    {
      LODWORD(v3) = jsonp_strtod(LODWORD(a1) + 40, &v8);
      if ( LODWORD(v3) )
      {
        error_set(a2, v7, "real number overflow");
        return 0;
      }
      v9 = json_real(v3);
    }
    else
    {
      v9 = json_integer(*(_QWORD *)(LODWORD(a1) + 56));
    }
    goto LABEL_29;
  }
  if ( v2 > 257 )
  {
    if ( v2 == 259 )
    {
      v9 = json_true();
    }
    else if ( v2 < 259 )
    {
      v9 = json_real(a1);
    }
    else if ( v2 == 260 )
    {
      v9 = json_false();
    }
    else
    {
      if ( v2 != 261 )
        goto LABEL_28;
      v9 = json_null();
    }
    goto LABEL_29;
  }
  if ( v2 == 91 )
  {
    v9 = parse_array((const lex_t *)LODWORD(a1), HIDWORD(a1), a2);
LABEL_29:
    if ( v9 )
      return v9;
    else
      return 0;
  }
  if ( v2 > 91 )
  {
    if ( v2 == 123 )
    {
      v9 = parse_object((const lex_t *)LODWORD(a1), HIDWORD(a1), a2);
    }
    else
    {
      if ( v2 != 256 )
        goto LABEL_28;
      v9 = json_string_nocheck(*(const char **)(LODWORD(a1) + 56));
    }
    goto LABEL_29;
  }
  if ( v2 != -1 )
  {
LABEL_28:
    error_set(a2, (const lex_t *)LODWORD(a1), "unexpected token");
    return 0;
  }
  error_set(a2, (const lex_t *)LODWORD(a1), "invalid token");
  return 0;
}
// 25360: too many cbuild loops
// 25408: variable 'v3' is possibly undefined

//----- (000254A8) --------------------------------------------------------
_DWORD *__fastcall parse_json(const lex_t *a1, unsigned int a2, int a3)
{
  _DWORD *v8; // [sp+14h] [bp+14h]

  lex_scan((int)a1, (json_error_t *)a3);
  if ( (a2 & 4) != 0 || *((_DWORD *)a1 + 13) == 91 || *((_DWORD *)a1 + 13) == 123 )
  {
    v8 = parse_value(COERCE_DOUBLE(__PAIR64__(a2, (unsigned int)a1)), (json_error_t *)a3);
    if ( v8 )
    {
      if ( (a2 & 2) != 0 || (lex_scan((int)a1, (json_error_t *)a3), !*((_DWORD *)a1 + 13)) )
      {
        if ( a3 )
          *(_DWORD *)(a3 + 8) = *((_DWORD *)a1 + 9);
        return v8;
      }
      else
      {
        error_set((json_error_t *)a3, a1, "end of file expected");
        json_decref_1((int)v8);
        return 0;
      }
    }
    else
    {
      return 0;
    }
  }
  else
  {
    error_set((json_error_t *)a3, a1, "'[' or '{' expected");
    return 0;
  }
}

//----- (00025550) --------------------------------------------------------
int __cdecl string_get(void *data)
{
  unsigned __int8 v3; // [sp+Bh] [bp+Bh]

  v3 = *(_BYTE *)(*(_DWORD *)data + *((_DWORD *)data + 1));
  if ( !v3 )
    return -1;
  ++*((_DWORD *)data + 1);
  return v3;
}

//----- (00025590) --------------------------------------------------------
_DWORD *__fastcall json_loads(int a1, unsigned int a2, json_error_t *a3)
{
  _DWORD v8[2]; // [sp+10h] [bp+10h] BYREF
  _BYTE v9[68]; // [sp+18h] [bp+18h] BYREF
  _DWORD *v10; // [sp+5Ch] [bp+5Ch]

  jsonp_error_init(a3, "<string>");
  if ( a1 )
  {
    v8[0] = a1;
    v8[1] = 0;
    if ( lex_init((int)v9, (int)string_get, (int)v8) )
    {
      return 0;
    }
    else
    {
      v10 = parse_json((const lex_t *)v9, a2, (int)a3);
      lex_close((int)v9);
      return v10;
    }
  }
  else
  {
    error_set(a3, 0, "wrong arguments");
    return 0;
  }
}

//----- (00025614) --------------------------------------------------------
int __cdecl buffer_get(void *data)
{
  if ( *((_DWORD *)data + 2) >= *((_DWORD *)data + 1) )
    return -1;
  return *(unsigned __int8 *)(*(_DWORD *)data + (*((_DWORD *)data + 2))++);
}

//----- (00025658) --------------------------------------------------------
_DWORD *__fastcall json_loadb(int a1, int a2, unsigned int a3, json_error_t *a4)
{
  _DWORD v10[3]; // [sp+14h] [bp+14h] BYREF
  _BYTE v11[68]; // [sp+20h] [bp+20h] BYREF
  _DWORD *v12; // [sp+64h] [bp+64h]

  jsonp_error_init(a4, "<buffer>");
  if ( a1 )
  {
    v10[0] = a1;
    v10[2] = 0;
    v10[1] = a2;
    if ( lex_init((int)v11, (int)buffer_get, (int)v10) )
    {
      return 0;
    }
    else
    {
      v12 = parse_json((const lex_t *)v11, a3, (int)a4);
      lex_close((int)v11);
      return v12;
    }
  }
  else
  {
    error_set(a4, 0, "wrong arguments");
    return 0;
  }
}

//----- (000256E4) --------------------------------------------------------
_DWORD *__fastcall json_loadf(int a1, unsigned int a2, json_error_t *a3)
{
  _BYTE v8[64]; // [sp+10h] [bp+10h] BYREF
  _DWORD *v9; // [sp+50h] [bp+50h]
  const char *v10; // [sp+54h] [bp+54h]

  if ( a1 == stdin )
    v10 = "<stdin>";
  else
    v10 = "<stream>";
  jsonp_error_init(a3, v10);
  if ( a1 )
  {
    if ( lex_init((int)v8, (int)fgetc, a1) )
    {
      return 0;
    }
    else
    {
      v9 = parse_json((const lex_t *)v8, a2, (int)a3);
      lex_close((int)v8);
      return v9;
    }
  }
  else
  {
    error_set(a3, 0, "wrong arguments");
    return 0;
  }
}
// 35AA0: using guessed type int stdin;

//----- (0002577C) --------------------------------------------------------
json_t *__cdecl json_load_file(const char *path, size_t flags, json_error_t *error)
{
  int *v4; // r0
  char *v5; // r0
  json_t *v10; // [sp+18h] [bp+10h]
  FILE *stream; // [sp+1Ch] [bp+14h]

  jsonp_error_init(error, path);
  if ( path )
  {
    stream = fopen(path, "rb");
    if ( stream )
    {
      v10 = (json_t *)json_loadf((int)stream, flags, error);
      fclose(stream);
      return v10;
    }
    else
    {
      v4 = _errno_location();
      v5 = strerror(*v4);
      error_set(error, 0, "unable to open %s: %s", path, v5);
      return 0;
    }
  }
  else
  {
    error_set(error, 0, "wrong arguments");
    return 0;
  }
}

//----- (00025808) --------------------------------------------------------
int __cdecl callback_get(void *data)
{
  if ( *((_DWORD *)data + 257) >= *((_DWORD *)data + 256) )
  {
    *((_DWORD *)data + 257) = 0;
    *((_DWORD *)data + 256) = (*((int (__fastcall **)(void *, int, _DWORD))data + 258))(
                                data,
                                1024,
                                *((_DWORD *)data + 259));
    if ( !*((_DWORD *)data + 256) || *((_DWORD *)data + 256) == -1 )
      return -1;
  }
  return (unsigned __int8)*((_BYTE *)data + (*((_DWORD *)data + 257))++);
}

//----- (0002588C) --------------------------------------------------------
_DWORD *__fastcall json_load_callback(int a1, int a2, unsigned int a3, json_error_t *a4)
{
  json_error_t *v6; // [sp+0h] [bp+0h]
  unsigned int v7; // [sp+4h] [bp+4h]
  int v8; // [sp+8h] [bp+8h]
  int v9; // [sp+Ch] [bp+Ch]
  _DWORD s[260]; // [sp+10h] [bp+10h] BYREF
  _BYTE v11[68]; // [sp+420h] [bp+420h] BYREF
  _DWORD *v12; // [sp+464h] [bp+464h]

  v9 = a1;
  v8 = a2;
  v7 = a3;
  v6 = a4;
  memset(s, 0, sizeof(s));
  s[258] = v9;
  s[259] = v8;
  jsonp_error_init(v6, "<callback>");
  if ( v9 )
  {
    if ( lex_init((int)v11, (int)callback_get, (int)s) )
    {
      return 0;
    }
    else
    {
      v12 = parse_json((const lex_t *)v11, v7, (int)v6);
      lex_close((int)v11);
      return v12;
    }
  }
  else
  {
    error_set(v6, 0, "wrong arguments");
    return 0;
  }
}

//----- (00025958) --------------------------------------------------------
void *__cdecl jsonp_malloc(size_t size)
{
  if ( size )
    return do_malloc(size);
  else
    return 0;
}
// 35A80: using guessed type void *(*do_malloc)(size_t size);

//----- (00025984) --------------------------------------------------------
void __cdecl jsonp_free(void *ptr)
{
  if ( ptr )
    do_free(ptr);
}
// 35A84: using guessed type void (*do_free)(void *ptr);

//----- (000259AC) --------------------------------------------------------
void *__fastcall jsonp_strdup(const char *a1)
{
  void *dest; // [sp+8h] [bp+8h]
  size_t v5; // [sp+Ch] [bp+Ch]

  v5 = strlen(a1);
  if ( v5 == -1 )
    return 0;
  dest = jsonp_malloc(v5 + 1);
  if ( !dest )
    return 0;
  memcpy(dest, a1, v5 + 1);
  return dest;
}

//----- (000259F8) --------------------------------------------------------
void *(*__fastcall json_set_alloc_funcs(void *(*result)(size_t size), void (*a2)(void *ptr)))(size_t size)
{
  do_malloc = result;
  do_free = a2;
  return result;
}
// 259F8: invalid function type 'void __cdecl json_set_alloc_funcs(json_malloc_t malloc_fn, json_free_t free_fn)' has been ignored
// 35A80: using guessed type void *(*do_malloc)(size_t size);
// 35A84: using guessed type void (*do_free)(void *ptr);

//----- (00025A24) --------------------------------------------------------
int __cdecl strbuffer_init(strbuffer_t *strbuff)
{
  *((_DWORD *)strbuff + 2) = 16;
  *((_DWORD *)strbuff + 1) = 0;
  *(_DWORD *)strbuff = jsonp_malloc(*((_DWORD *)strbuff + 2));
  if ( !*(_DWORD *)strbuff )
    return -1;
  **(_BYTE **)strbuff = 0;
  return 0;
}

//----- (00025A6C) --------------------------------------------------------
void __cdecl strbuffer_close(strbuffer_t *strbuff)
{
  if ( *(_DWORD *)strbuff )
    jsonp_free(*(void **)strbuff);
  *((_DWORD *)strbuff + 2) = 0;
  *((_DWORD *)strbuff + 1) = 0;
  *(_DWORD *)strbuff = 0;
}

//----- (00025AA0) --------------------------------------------------------
void __cdecl strbuffer_clear(strbuffer_t *strbuff)
{
  *((_DWORD *)strbuff + 1) = 0;
  **(_BYTE **)strbuff = 0;
}

//----- (00025AC0) --------------------------------------------------------
int __fastcall strbuffer_value(int a1)
{
  return *(_DWORD *)a1;
}

//----- (00025AD8) --------------------------------------------------------
char *__cdecl strbuffer_steal_value(strbuffer_t *strbuff)
{
  char *v2; // [sp+Ch] [bp+Ch]

  v2 = *(char **)strbuff;
  *(_DWORD *)strbuff = 0;
  return v2;
}

//----- (00025AFC) --------------------------------------------------------
int __fastcall strbuffer_append(strbuffer_t *a1, const char *a2)
{
  size_t v2; // r0

  v2 = strlen(a2);
  return strbuffer_append_bytes(a1, a2, v2);
}

//----- (00025B24) --------------------------------------------------------
int __cdecl strbuffer_append_byte(strbuffer_t *strbuff, char byte)
{
  char v3; // [sp+3h] [bp+3h] BYREF
  strbuffer_t *v4; // [sp+4h] [bp+4h]

  v4 = strbuff;
  v3 = byte;
  return strbuffer_append_bytes(strbuff, &v3, 1u);
}

//----- (00025B48) --------------------------------------------------------
int __cdecl strbuffer_append_bytes(strbuffer_t *strbuff, const char *data, size_t size)
{
  size_t v4; // r3
  void *dest; // [sp+10h] [bp+10h]
  size_t v10; // [sp+14h] [bp+14h]

  if ( *((_DWORD *)strbuff + 2) - *((_DWORD *)strbuff + 1) > size )
    goto LABEL_11;
  if ( *((int *)strbuff + 2) >= 0 && size != -1 && *((_DWORD *)strbuff + 1) <= -2 - size )
  {
    v4 = 2 * *((_DWORD *)strbuff + 2);
    if ( *((_DWORD *)strbuff + 1) + size + 1 >= v4 )
      v4 = *((_DWORD *)strbuff + 1) + size + 1;
    v10 = v4;
    dest = jsonp_malloc(v4);
    if ( !dest )
      return -1;
    memcpy(dest, *(const void **)strbuff, *((_DWORD *)strbuff + 1));
    jsonp_free(*(void **)strbuff);
    *(_DWORD *)strbuff = dest;
    *((_DWORD *)strbuff + 2) = v10;
LABEL_11:
    memcpy((void *)(*(_DWORD *)strbuff + *((_DWORD *)strbuff + 1)), data, size);
    *((_DWORD *)strbuff + 1) += size;
    *(_BYTE *)(*(_DWORD *)strbuff + *((_DWORD *)strbuff + 1)) = 0;
    return 0;
  }
  return -1;
}

//----- (00025C1C) --------------------------------------------------------
char __cdecl strbuffer_pop(strbuffer_t *strbuff)
{
  int v1; // r2
  char v4; // [sp+Fh] [bp+Fh]

  if ( !*((_DWORD *)strbuff + 1) )
    return 0;
  v1 = *(_DWORD *)strbuff;
  --*((_DWORD *)strbuff + 1);
  v4 = *(_BYTE *)(v1 + *((_DWORD *)strbuff + 1));
  *(_BYTE *)(*(_DWORD *)strbuff + *((_DWORD *)strbuff + 1)) = 0;
  return v4;
}

//----- (00025C64) --------------------------------------------------------
void __cdecl to_locale(strbuffer_t *strbuffer)
{
  struct lconv *v1; // r0
  char *v3; // [sp+8h] [bp+8h]
  char *decimal_point; // [sp+Ch] [bp+Ch]

  v1 = localeconv();
  decimal_point = v1->decimal_point;
  if ( *v1->decimal_point != 46 )
  {
    v3 = strchr(*(const char **)strbuffer, 46);
    if ( v3 )
      *v3 = *decimal_point;
  }
}

//----- (00025CA8) --------------------------------------------------------
void __cdecl from_locale(char *buffer)
{
  struct lconv *v1; // r0
  char *v3; // [sp+8h] [bp+8h]

  v1 = localeconv();
  if ( *v1->decimal_point != 46 )
  {
    v3 = strchr(buffer, *(unsigned __int8 *)v1->decimal_point);
    if ( v3 )
      *v3 = 46;
  }
}

//----- (00025CE8) --------------------------------------------------------
int __fastcall jsonp_strtod(int a1, double *a2)
{
  double v2; // d0
  char *endptr; // [sp+Ch] [bp+Ch] BYREF
  double v8; // [sp+10h] [bp+10h]

  to_locale((strbuffer_t *)a1);
  *_errno_location() = 0;
  strtod(*(const char **)a1, &endptr);
  v8 = v2;
  if ( (char *)(*(_DWORD *)a1 + *(_DWORD *)(a1 + 4)) != endptr )
    _assert_fail(
      "end == strbuffer->value + strbuffer->length",
      "3rdparty/jansson-2.6/src/strconv.c",
      0x46u,
      "jsonp_strtod");
  if ( *_errno_location() == 34 && v8 != 0.0 )
    return -1;
  *a2 = v8;
  return 0;
}
// 25D12: variable 'v2' is possibly undefined

//----- (00025D7C) --------------------------------------------------------
int __fastcall jsonp_dtostr(char *a1, size_t a2)
{
  double v2; // d0
  int v7; // [sp+18h] [bp+10h]
  int v8; // [sp+1Ch] [bp+14h]
  _BYTE *src; // [sp+20h] [bp+18h]
  char *dest; // [sp+24h] [bp+1Ch]
  _BYTE *desta; // [sp+24h] [bp+1Ch]

  v7 = snprintf(a1, a2, "%.17g", v2);
  if ( v7 < 0 )
    return -1;
  v8 = v7;
  if ( v7 >= a2 )
    return -1;
  from_locale(a1);
  if ( !strchr(a1, 46) && !strchr(a1, 101) )
  {
    if ( v7 + 3 >= a2 )
      return -1;
    a1[v7] = 46;
    a1[v7 + 1] = 48;
    a1[v7 + 2] = 0;
    v8 = v7 + 2;
  }
  dest = strchr(a1, 101);
  if ( dest )
  {
    desta = dest + 1;
    src = desta + 1;
    if ( *desta == 45 )
      ++desta;
    while ( *src == 48 )
      ++src;
    if ( src != desta )
    {
      memmove(desta, src, a1 - src + v8);
      v8 += desta - src;
    }
  }
  return v8;
}
// 25D9E: variable 'v2' is possibly undefined

//----- (00025E90) --------------------------------------------------------
int __cdecl utf8_encode(int32_t codepoint, char *buffer, size_t *size)
{
  if ( codepoint >= 0 )
  {
    if ( codepoint > 127 )
    {
      if ( codepoint > 2047 )
      {
        if ( codepoint > 0xFFFF )
        {
          if ( codepoint > 1114111 )
            return -1;
          *buffer = ((codepoint & 0x1C0000) >> 18) - 16;
          buffer[1] = ((codepoint & 0x3F000) >> 12) + 0x80;
          buffer[2] = ((codepoint & 0xFC0) >> 6) + 0x80;
          buffer[3] = (codepoint & 0x3F) + 0x80;
          *size = 4;
        }
        else
        {
          *buffer = ((codepoint & 0xF000) >> 12) - 32;
          buffer[1] = ((codepoint & 0xFC0) >> 6) + 0x80;
          buffer[2] = (codepoint & 0x3F) + 0x80;
          *size = 3;
        }
      }
      else
      {
        *buffer = ((codepoint & 0x7C0) >> 6) - 64;
        buffer[1] = (codepoint & 0x3F) + 0x80;
        *size = 2;
      }
    }
    else
    {
      *buffer = codepoint;
      *size = 1;
    }
    return 0;
  }
  return -1;
}

//----- (00025FBC) --------------------------------------------------------
size_t __cdecl utf8_check_first(char byte)
{
  if ( byte >= 0 )
    return 1;
  if ( (unsigned __int8)byte <= 0xBFu )
    return 0;
  if ( (unsigned __int8)byte == 192 || (unsigned __int8)byte == 193 )
    return 0;
  if ( (unsigned __int8)byte > 0xC1u && (unsigned __int8)byte <= 0xDFu )
    return 2;
  if ( (unsigned __int8)byte > 0xDFu && (unsigned __int8)byte <= 0xEFu )
    return 3;
  if ( (unsigned __int8)byte <= 0xEFu || (unsigned __int8)byte > 0xF4u )
    return 0;
  return 4;
}

//----- (00026038) --------------------------------------------------------
int __fastcall utf8_check_full(char *a1, int a2, int *a3)
{
  char v5; // [sp+17h] [bp+17h]
  char v6; // [sp+17h] [bp+17h]
  int v7; // [sp+18h] [bp+18h]
  int i; // [sp+1Ch] [bp+1Ch]

  v5 = *a1;
  switch ( a2 )
  {
    case 2:
      v7 = v5 & 0x1F;
      break;
    case 3:
      v7 = v5 & 0xF;
      break;
    case 4:
      v7 = v5 & 7;
      break;
    default:
      return 0;
  }
  for ( i = 1; i < a2; ++i )
  {
    v6 = a1[i];
    if ( v6 >= 0 || (unsigned __int8)v6 > 0xBFu )
      return 0;
    v7 = (v7 << 6) + (v6 & 0x3F);
  }
  if ( v7 > 1114111 )
    return 0;
  if ( v7 > 55295 && v7 <= 57343 )
    return 0;
  if ( a2 == 2 && v7 <= 127 || a2 == 3 && v7 <= 2047 || a2 == 4 && v7 <= 0xFFFF )
    return 0;
  if ( a3 )
    *a3 = v7;
  return 1;
}

//----- (00026134) --------------------------------------------------------
char *__fastcall utf8_iterate(char *a1, _DWORD *a2)
{
  int v6; // [sp+8h] [bp+8h] BYREF
  int v7; // [sp+Ch] [bp+Ch]

  if ( !*a1 )
    return a1;
  v7 = utf8_check_first(*a1);
  if ( v7 <= 0 )
    return 0;
  if ( v7 == 1 )
  {
    v6 = (unsigned __int8)*a1;
  }
  else if ( !utf8_check_full(a1, v7, &v6) )
  {
    return 0;
  }
  if ( a2 )
    *a2 = v6;
  return &a1[v7];
}

//----- (000261A4) --------------------------------------------------------
int __fastcall utf8_check_string(const char *a1, signed int a2)
{
  signed int v4; // [sp+0h] [bp+0h]
  signed int v6; // [sp+8h] [bp+8h]
  int i; // [sp+Ch] [bp+Ch]

  v4 = a2;
  if ( a2 == -1 )
    v4 = strlen(a1);
  for ( i = 0; i < v4; ++i )
  {
    v6 = utf8_check_first(a1[i]);
    if ( !v6 )
      return 0;
    if ( v6 > 1 )
    {
      if ( i + v6 > v4 )
        return 0;
      if ( !utf8_check_full((char *)&a1[i], v6, 0) )
        return 0;
      i += v6 - 1;
    }
  }
  return 1;
}

//----- (00026234) --------------------------------------------------------
int __fastcall json_incref_0(int result)
{
  if ( result )
  {
    if ( *(_DWORD *)(result + 4) != -1 )
      ++*(_DWORD *)(result + 4);
  }
  return result;
}

//----- (00026264) --------------------------------------------------------
void __fastcall json_decref_2(int a1)
{
  if ( a1 && *(_DWORD *)(a1 + 4) != -1 && !--*(_DWORD *)(a1 + 4) )
    json_delete((void **)a1);
}

//----- (0002629C) --------------------------------------------------------
int __fastcall json_object_set_nocheck_0(_DWORD *a1, char *a2, int a3)
{
  _DWORD *v3; // r0

  v3 = (_DWORD *)json_incref_0(a3);
  return json_object_set_new_nocheck(a1, a2, v3);
}

//----- (000262C8) --------------------------------------------------------
int __fastcall json_array_append_0(json_t *a1, int a2)
{
  json_t *v2; // r0

  v2 = (json_t *)json_incref_0(a2);
  return json_array_append_new(a1, v2);
}

//----- (000262F0) --------------------------------------------------------
_DWORD *__fastcall json_init(_DWORD *result, int a2)
{
  *result = a2;
  result[1] = 1;
  return result;
}
// 262F0: invalid function type 'void __cdecl json_init(json_t *json, json_type type)' has been ignored

//----- (00026310) --------------------------------------------------------
_DWORD *json_object()
{
  _DWORD *v2; // [sp+4h] [bp+4h]

  v2 = jsonp_malloc(0x24u);
  if ( !v2 )
    return 0;
  json_init(v2, 0);
  if ( hashtable_init(v2 + 2) )
  {
    jsonp_free(v2);
    return 0;
  }
  else
  {
    v2[7] = 0;
    v2[8] = 0;
    return v2;
  }
}

//----- (00026364) --------------------------------------------------------
void __cdecl json_delete_object(json_object_t *object)
{
  hashtable_close((json_object_t *)((char *)object + 8));
  jsonp_free(object);
}

//----- (00026384) --------------------------------------------------------
size_t __cdecl json_object_size(const json_t *json)
{
  if ( json && !*(_DWORD *)json )
    return *((_DWORD *)json + 2);
  else
    return 0;
}

//----- (000263B4) --------------------------------------------------------
int __fastcall json_object_get(_DWORD *a1, char *a2)
{
  if ( a1 && !*a1 )
    return hashtable_get((int)(a1 + 2), a2);
  else
    return 0;
}

//----- (000263EC) --------------------------------------------------------
int __fastcall json_object_set_new_nocheck(_DWORD *a1, char *a2, _DWORD *a3)
{
  int v4; // r2

  if ( !a3 )
    return -1;
  if ( a2 )
  {
    if ( a1 )
    {
      if ( !*a1 && a1 != a3 )
      {
        v4 = a1[7];
        a1[7] = v4 + 1;
        if ( !hashtable_set((hashtable_t *)(a1 + 2), a2, v4, (int)a3) )
          return 0;
      }
    }
  }
  json_decref_2((int)a3);
  return -1;
}

//----- (0002646C) --------------------------------------------------------
int __fastcall json_object_set_new(_DWORD *a1, char *a2, _DWORD *a3)
{
  if ( a2 && utf8_check_string(a2, -1) )
    return json_object_set_new_nocheck(a1, a2, a3);
  json_decref_2((int)a3);
  return -1;
}

//----- (000264B0) --------------------------------------------------------
int __fastcall json_object_del(_DWORD *a1, char *a2)
{
  if ( a1 && !*a1 )
    return hashtable_del((hashtable_t *)(a1 + 2), a2);
  else
    return -1;
}

//----- (000264EC) --------------------------------------------------------
int __fastcall json_object_clear(_DWORD *a1)
{
  if ( !a1 || *a1 )
    return -1;
  hashtable_clear(a1 + 2);
  a1[7] = 0;
  return 0;
}

//----- (00026528) --------------------------------------------------------
int __cdecl json_object_update(json_t *object, json_t *other)
{
  void *v3; // r0
  void *v4; // r0
  void *v5; // r0
  int v6; // r0
  int v10; // [sp+8h] [bp+8h]
  char *i; // [sp+Ch] [bp+Ch]

  if ( !object || *(_DWORD *)object || !other || *(_DWORD *)other )
    return -1;
  v3 = json_object_iter(other);
  for ( i = (char *)json_object_iter_key(v3); i; i = (char *)json_object_iter_key(v5) )
  {
    v6 = json_object_key_to_iter((int)i);
    v10 = json_object_iter_value(v6);
    if ( !v10 )
      break;
    if ( json_object_set_nocheck_0(object, i, v10) )
      return -1;
    v4 = (void *)json_object_key_to_iter((int)i);
    v5 = json_object_iter_next(other, v4);
  }
  return 0;
}

//----- (000265C0) --------------------------------------------------------
int __cdecl json_object_update_existing(json_t *object, json_t *other)
{
  void *v3; // r0
  void *v4; // r0
  void *v5; // r0
  int v6; // r0
  int v10; // [sp+8h] [bp+8h]
  char *i; // [sp+Ch] [bp+Ch]

  if ( !object || *(_DWORD *)object || !other || *(_DWORD *)other )
    return -1;
  v3 = json_object_iter(other);
  for ( i = (char *)json_object_iter_key(v3); i; i = (char *)json_object_iter_key(v5) )
  {
    v6 = json_object_key_to_iter((int)i);
    v10 = json_object_iter_value(v6);
    if ( !v10 )
      break;
    if ( json_object_get(object, i) )
      json_object_set_nocheck_0(object, i, v10);
    v4 = (void *)json_object_key_to_iter((int)i);
    v5 = json_object_iter_next(other, v4);
  }
  return 0;
}

//----- (00026658) --------------------------------------------------------
int __cdecl json_object_update_missing(json_t *object, json_t *other)
{
  void *v3; // r0
  void *v4; // r0
  void *v5; // r0
  int v6; // r0
  int v10; // [sp+8h] [bp+8h]
  char *i; // [sp+Ch] [bp+Ch]

  if ( !object || *(_DWORD *)object || !other || *(_DWORD *)other )
    return -1;
  v3 = json_object_iter(other);
  for ( i = (char *)json_object_iter_key(v3); i; i = (char *)json_object_iter_key(v5) )
  {
    v6 = json_object_key_to_iter((int)i);
    v10 = json_object_iter_value(v6);
    if ( !v10 )
      break;
    if ( !json_object_get(object, i) )
      json_object_set_nocheck_0(object, i, v10);
    v4 = (void *)json_object_key_to_iter((int)i);
    v5 = json_object_iter_next(other, v4);
  }
  return 0;
}

//----- (000266F0) --------------------------------------------------------
void *__cdecl json_object_iter(json_t *json)
{
  if ( json && !*(_DWORD *)json )
    return (void *)hashtable_iter((int)json + 8);
  else
    return 0;
}

//----- (00026724) --------------------------------------------------------
json_t *__cdecl json_object_iter_at_0(const json_t *json, const char *key)
{
  if ( key && json && !*(_DWORD *)json )
    return (json_t *)hashtable_iter_at((int)json + 8, (char *)key);
  else
    return 0;
}

//----- (00026764) --------------------------------------------------------
void *__cdecl json_object_iter_next(json_t *json, void *iter)
{
  if ( json && !*(_DWORD *)json && iter )
    return (void *)hashtable_iter_next((int)json + 8, (int)iter);
  else
    return 0;
}

//----- (000267A4) --------------------------------------------------------
const char *__cdecl json_object_iter_key(void *iter)
{
  if ( iter )
    return (const char *)hashtable_iter_key((int)iter);
  else
    return 0;
}

//----- (000267C8) --------------------------------------------------------
int __fastcall json_object_iter_value(int a1)
{
  if ( a1 )
    return hashtable_iter_value(a1);
  else
    return 0;
}

//----- (000267EC) --------------------------------------------------------
int __cdecl json_object_iter_set_new(json_t *json, void *iter, json_t *value)
{
  if ( !json || *(_DWORD *)json || !iter || !value )
    return -1;
  hashtable_iter_set((int)iter, (int)value);
  return 0;
}

//----- (0002682C) --------------------------------------------------------
int __fastcall json_object_key_to_iter(int a1)
{
  if ( a1 )
    return a1 - 16;
  else
    return 0;
}

//----- (00026850) --------------------------------------------------------
int __cdecl json_object_equal(json_t *object1, json_t *object2)
{
  size_t v2; // r4
  void *v4; // r0
  void *v5; // r0
  void *v6; // r0
  int v7; // r0
  json_t *v11; // [sp+Ch] [bp+Ch]
  json_t *v12; // [sp+10h] [bp+10h]
  char *i; // [sp+14h] [bp+14h]

  v2 = json_object_size(object1);
  if ( v2 != json_object_size(object2) )
    return 0;
  v4 = json_object_iter(object1);
  for ( i = (char *)json_object_iter_key(v4); i; i = (char *)json_object_iter_key(v6) )
  {
    v7 = json_object_key_to_iter((int)i);
    v12 = (json_t *)json_object_iter_value(v7);
    if ( !v12 )
      break;
    v11 = (json_t *)json_object_get(object2, i);
    if ( !json_equal(v12, v11) )
      return 0;
    v5 = (void *)json_object_key_to_iter((int)i);
    v6 = json_object_iter_next(object1, v5);
  }
  return 1;
}

//----- (000268E4) --------------------------------------------------------
json_t *__cdecl json_object_copy(json_t *object)
{
  void *v2; // r0
  void *v3; // r0
  void *v4; // r0
  int v5; // r0
  int v8; // [sp+Ch] [bp+Ch]
  json_t *v9; // [sp+10h] [bp+10h]
  char *i; // [sp+14h] [bp+14h]

  v9 = (json_t *)json_object();
  if ( !v9 )
    return 0;
  v2 = json_object_iter(object);
  for ( i = (char *)json_object_iter_key(v2); i; i = (char *)json_object_iter_key(v4) )
  {
    v5 = json_object_key_to_iter((int)i);
    v8 = json_object_iter_value(v5);
    if ( !v8 )
      break;
    json_object_set_nocheck_0(v9, i, v8);
    v3 = (void *)json_object_key_to_iter((int)i);
    v4 = json_object_iter_next(object, v3);
  }
  return v9;
}

//----- (0002695C) --------------------------------------------------------
json_t *__cdecl json_object_deep_copy(const json_t *object)
{
  json_t *v2; // r0
  const json_t *v5; // [sp+8h] [bp+8h]
  char *v6; // [sp+Ch] [bp+Ch]
  json_t *v7; // [sp+10h] [bp+10h]
  void *i; // [sp+14h] [bp+14h]

  v7 = (json_t *)json_object();
  if ( !v7 )
    return 0;
  for ( i = json_object_iter(object); i; i = json_object_iter_next(object, i) )
  {
    v6 = (char *)json_object_iter_key(i);
    v5 = (const json_t *)json_object_iter_value((int)i);
    v2 = json_deep_copy(v5);
    json_object_set_new_nocheck(v7, v6, v2);
  }
  return v7;
}

//----- (000269BC) --------------------------------------------------------
_DWORD *json_array()
{
  _DWORD *v2; // [sp+4h] [bp+4h]

  v2 = jsonp_malloc(0x18u);
  if ( !v2 )
    return 0;
  json_init(v2, 1);
  v2[3] = 0;
  v2[2] = 8;
  v2[4] = jsonp_malloc(4 * v2[2]);
  if ( v2[4] )
  {
    v2[5] = 0;
    return v2;
  }
  else
  {
    jsonp_free(v2);
    return 0;
  }
}

//----- (00026A20) --------------------------------------------------------
void __cdecl json_delete_array(json_array_t *array)
{
  unsigned int i; // [sp+Ch] [bp+Ch]

  for ( i = 0; *((_DWORD *)array + 3) > i; ++i )
    json_decref_2(*(_DWORD *)(*((_DWORD *)array + 4) + 4 * i));
  jsonp_free(*((void **)array + 4));
  jsonp_free(array);
}

//----- (00026A68) --------------------------------------------------------
size_t __cdecl json_array_size(const json_t *json)
{
  if ( json && *(_DWORD *)json == 1 )
    return *((_DWORD *)json + 3);
  else
    return 0;
}

//----- (00026A94) --------------------------------------------------------
json_t *__cdecl json_array_get(const json_t *json, size_t index)
{
  if ( !json || *(_DWORD *)json != 1 )
    return 0;
  if ( *((_DWORD *)json + 3) > index )
    return *(json_t **)(*((_DWORD *)json + 4) + 4 * index);
  return 0;
}

//----- (00026ADC) --------------------------------------------------------
int __cdecl json_array_set_new(json_t *json, size_t index, json_t *value)
{
  if ( !value )
    return -1;
  if ( json && *(_DWORD *)json == 1 && json != value && *((_DWORD *)json + 3) > index )
  {
    json_decref_2(*(_DWORD *)(*((_DWORD *)json + 4) + 4 * index));
    *(_DWORD *)(*((_DWORD *)json + 4) + 4 * index) = value;
    return 0;
  }
  else
  {
    json_decref_2((int)value);
    return -1;
  }
}

//----- (00026B5C) --------------------------------------------------------
void __cdecl array_move(json_array_t *array, size_t dest, size_t src, size_t count)
{
  memmove((void *)(*((_DWORD *)array + 4) + 4 * dest), (const void *)(*((_DWORD *)array + 4) + 4 * src), 4 * count);
}

//----- (00026B94) --------------------------------------------------------
void __cdecl array_copy(json_t **dest, size_t dpos, json_t **src, size_t spos, size_t count)
{
  memcpy(&dest[dpos], &src[spos], 4 * count);
}

//----- (00026BC8) --------------------------------------------------------
json_t **__cdecl json_array_grow(json_array_t *array, size_t amount, int copy)
{
  size_t v4; // r3
  void *v8; // [sp+1Ch] [bp+14h]
  size_t v9; // [sp+20h] [bp+18h]
  json_t **v10; // [sp+24h] [bp+1Ch]

  if ( *((_DWORD *)array + 3) + amount <= *((_DWORD *)array + 2) )
    return (json_t **)*((_DWORD *)array + 4);
  v10 = (json_t **)*((_DWORD *)array + 4);
  v4 = *((_DWORD *)array + 2) + amount;
  if ( 2 * *((_DWORD *)array + 2) >= v4 )
    v4 = 2 * *((_DWORD *)array + 2);
  v9 = v4;
  v8 = jsonp_malloc(4 * v4);
  if ( !v8 )
    return 0;
  *((_DWORD *)array + 2) = v9;
  *((_DWORD *)array + 4) = v8;
  if ( !copy )
    return v10;
  array_copy(*((json_t ***)array + 4), 0, v10, 0, *((_DWORD *)array + 3));
  jsonp_free(v10);
  return (json_t **)*((_DWORD *)array + 4);
}

//----- (00026C5C) --------------------------------------------------------
int __cdecl json_array_append_new(json_t *json, json_t *value)
{
  if ( !value )
    return -1;
  if ( json && *(_DWORD *)json == 1 && json != value && json_array_grow(json, 1u, 1) )
  {
    *(_DWORD *)(*((_DWORD *)json + 4) + 4 * (*((_DWORD *)json + 3))++) = value;
    return 0;
  }
  else
  {
    json_decref_2((int)value);
    return -1;
  }
}

//----- (00026CDC) --------------------------------------------------------
int __cdecl json_array_insert_new(json_t *json, size_t index, json_t *value)
{
  json_t **v8; // [sp+18h] [bp+10h]

  if ( !value )
    return -1;
  if ( json && *(_DWORD *)json == 1 && json != value && *((_DWORD *)json + 3) >= index )
  {
    v8 = json_array_grow(json, 1u, 0);
    if ( v8 )
    {
      if ( *((json_t ***)json + 4) == v8 )
      {
        array_move(json, index + 1, index, *((_DWORD *)json + 3) - index);
      }
      else
      {
        array_copy(*((json_t ***)json + 4), 0, v8, 0, index);
        array_copy(*((json_t ***)json + 4), index + 1, v8, index, *((_DWORD *)json + 3) - index);
        jsonp_free(v8);
      }
      *(_DWORD *)(*((_DWORD *)json + 4) + 4 * index) = value;
      ++*((_DWORD *)json + 3);
      return 0;
    }
    else
    {
      json_decref_2((int)value);
      return -1;
    }
  }
  else
  {
    json_decref_2((int)value);
    return -1;
  }
}

//----- (00026DCC) --------------------------------------------------------
int __cdecl json_array_remove(json_t *json, size_t index)
{
  if ( !json || *(_DWORD *)json != 1 )
    return -1;
  if ( *((_DWORD *)json + 3) <= index )
    return -1;
  json_decref_2(*(_DWORD *)(*((_DWORD *)json + 4) + 4 * index));
  if ( *((_DWORD *)json + 3) - 1 > index )
    array_move(json, index, index + 1, *((_DWORD *)json + 3) - index - 1);
  --*((_DWORD *)json + 3);
  return 0;
}

//----- (00026E48) --------------------------------------------------------
int __cdecl json_array_clear(json_t *json)
{
  unsigned int i; // [sp+Ch] [bp+Ch]

  if ( !json || *(_DWORD *)json != 1 )
    return -1;
  for ( i = 0; *((_DWORD *)json + 3) > i; ++i )
    json_decref_2(*(_DWORD *)(*((_DWORD *)json + 4) + 4 * i));
  *((_DWORD *)json + 3) = 0;
  return 0;
}

//----- (00026EA4) --------------------------------------------------------
int __cdecl json_array_extend(json_t *json, json_t *other_json)
{
  unsigned int i; // [sp+1Ch] [bp+14h]

  if ( !json || *(_DWORD *)json != 1 || !other_json || *(_DWORD *)other_json != 1 )
    return -1;
  if ( !json_array_grow(json, *((_DWORD *)other_json + 3), 1) )
    return -1;
  for ( i = 0; *((_DWORD *)other_json + 3) > i; ++i )
    json_incref_0(*(_DWORD *)(*((_DWORD *)other_json + 4) + 4 * i));
  array_copy(
    *((json_t ***)json + 4),
    *((_DWORD *)json + 3),
    *((json_t ***)other_json + 4),
    0,
    *((_DWORD *)other_json + 3));
  *((_DWORD *)json + 3) += *((_DWORD *)other_json + 3);
  return 0;
}

//----- (00026F54) --------------------------------------------------------
int __cdecl json_array_equal(json_t *array1, json_t *array2)
{
  json_t *v6; // [sp+8h] [bp+8h]
  json_t *v7; // [sp+Ch] [bp+Ch]
  size_t v8; // [sp+10h] [bp+10h]
  size_t i; // [sp+14h] [bp+14h]

  v8 = json_array_size(array1);
  if ( json_array_size(array2) != v8 )
    return 0;
  for ( i = 0; i < v8; ++i )
  {
    v7 = json_array_get(array1, i);
    v6 = json_array_get(array2, i);
    if ( !json_equal(v7, v6) )
      return 0;
  }
  return 1;
}

//----- (00026FC0) --------------------------------------------------------
json_t *__cdecl json_array_copy(json_t *array)
{
  json_t *v2; // r0
  json_t *v5; // [sp+8h] [bp+8h]
  size_t i; // [sp+Ch] [bp+Ch]

  v5 = (json_t *)json_array();
  if ( !v5 )
    return 0;
  for ( i = 0; json_array_size(array) > i; ++i )
  {
    v2 = json_array_get(array, i);
    json_array_append_0(v5, (int)v2);
  }
  return v5;
}

//----- (00027010) --------------------------------------------------------
json_t *__cdecl json_array_deep_copy(const json_t *array)
{
  json_t *v2; // r0
  json_t *v3; // r0
  json_t *v6; // [sp+8h] [bp+8h]
  size_t i; // [sp+Ch] [bp+Ch]

  v6 = (json_t *)json_array();
  if ( !v6 )
    return 0;
  for ( i = 0; json_array_size(array) > i; ++i )
  {
    v2 = json_array_get(array, i);
    v3 = (json_t *)json_deep_copy(v2);
    json_array_append_new(v6, v3);
  }
  return v6;
}
// 27758: using guessed type int __fastcall json_deep_copy(_DWORD);

//----- (00027068) --------------------------------------------------------
_DWORD *__fastcall json_string_nocheck(const char *a1)
{
  _DWORD *v4; // [sp+Ch] [bp+Ch]

  if ( !a1 )
    return 0;
  v4 = jsonp_malloc(0xCu);
  if ( !v4 )
    return 0;
  json_init(v4, 2);
  v4[2] = jsonp_strdup(a1);
  if ( v4[2] )
    return v4;
  jsonp_free(v4);
  return 0;
}

//----- (000270C0) --------------------------------------------------------
_DWORD *__fastcall json_string(const char *a1)
{
  if ( a1 && utf8_check_string(a1, -1) )
    return json_string_nocheck(a1);
  else
    return 0;
}

//----- (000270F4) --------------------------------------------------------
const char *__cdecl json_string_value(const json_t *json)
{
  if ( json && *(_DWORD *)json == 2 )
    return (const char *)*((_DWORD *)json + 2);
  else
    return 0;
}

//----- (00027120) --------------------------------------------------------
int __fastcall json_string_set_nocheck(int a1, const char *a2)
{
  void *v5; // [sp+Ch] [bp+Ch]

  if ( !a1 || *(_DWORD *)a1 != 2 || !a2 )
    return -1;
  v5 = jsonp_strdup(a2);
  if ( !v5 )
    return -1;
  jsonp_free(*(void **)(a1 + 8));
  *(_DWORD *)(a1 + 8) = v5;
  return 0;
}

//----- (00027178) --------------------------------------------------------
int __fastcall json_string_set(int a1, const char *a2)
{
  if ( a2 && utf8_check_string(a2, -1) )
    return json_string_set_nocheck(a1, a2);
  else
    return -1;
}

//----- (000271B4) --------------------------------------------------------
void __cdecl json_delete_string(json_string_t *string)
{
  jsonp_free(*((void **)string + 2));
  jsonp_free(string);
}

//----- (000271D4) --------------------------------------------------------
bool __fastcall json_string_equal(const json_t *a1, const json_t *a2)
{
  const char *v2; // r4
  const char *v3; // r0

  v2 = json_string_value(a1);
  v3 = json_string_value(a2);
  return strcmp(v2, v3) == 0;
}

//----- (0002720C) --------------------------------------------------------
_DWORD *__fastcall json_string_copy(const json_t *a1)
{
  const char *v1; // r0

  v1 = json_string_value(a1);
  return json_string_nocheck(v1);
}

//----- (00027230) --------------------------------------------------------
_QWORD *__fastcall json_integer(__int64 a1)
{
  _QWORD *v4; // [sp+Ch] [bp+Ch]

  v4 = jsonp_malloc(0x10u);
  if ( !v4 )
    return 0;
  json_init(v4, 3);
  v4[1] = a1;
  return v4;
}
// 27230: invalid function type 'json_t *__cdecl json_integer(json_int_t value)' has been ignored

//----- (0002726C) --------------------------------------------------------
__int64 __fastcall json_integer_value(int a1)
{
  if ( a1 && *(_DWORD *)a1 == 3 )
    return *(_QWORD *)(a1 + 8);
  else
    return 0;
}
// 2726C: invalid function type 'json_int_t __cdecl json_integer_value(const json_t *json)' has been ignored

//----- (000272A0) --------------------------------------------------------
int __fastcall json_integer_set(int a1, __int64 a2)
{
  if ( !a1 || *(_DWORD *)a1 != 3 )
    return -1;
  *(_QWORD *)(a1 + 8) = a2;
  return 0;
}
// 272A0: invalid function type 'int __cdecl json_integer_set(json_t *json, json_int_t value)' has been ignored

//----- (000272D8) --------------------------------------------------------
void __fastcall json_delete_integer(void *a1)
{
  jsonp_free(a1);
}

//----- (000272F0) --------------------------------------------------------
int __cdecl json_integer_equal(json_t *integer1, json_t *integer2)
{
  __int64 v2; // r4

  v2 = json_integer_value((int)integer1);
  return v2 == json_integer_value((int)integer2);
}

//----- (00027328) --------------------------------------------------------
json_t *__cdecl json_integer_copy(const json_t *integer)
{
  __int64 v1; // r0

  v1 = json_integer_value((int)integer);
  return (json_t *)json_integer(v1);
}

//----- (00027350) --------------------------------------------------------
json_t *__cdecl json_real(double value)
{
  __int64 v1; // d0
  double v2; // r0
  json_t *v5; // [sp+Ch] [bp+Ch]

  LODWORD(v2) = _isnan(value);
  if ( LODWORD(v2) || _isinf(v2) )
    return 0;
  v5 = (json_t *)jsonp_malloc(0x10u);
  if ( !v5 )
    return 0;
  json_init(v5, 4);
  *((_QWORD *)v5 + 1) = v1;
  return v5;
}
// 2736C: variable 'v2' is possibly undefined
// 2739C: variable 'v1' is possibly undefined

//----- (000273AC) --------------------------------------------------------
double __cdecl json_real_value(const json_t *json)
{
  double result; // r0

  LODWORD(result) = json;
  return result;
}
// 273AC: variable 'result' is possibly undefined

//----- (000273E4) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
int __cdecl json_real_set(json_t *json, double value)
{
  __int64 v2; // d0
  double v3; // r0

  if ( !json )
    return -1;
  if ( *(_DWORD *)json != 4 )
    return -1;
  LODWORD(v3) = _isnan(*(double *)&json);
  if ( LODWORD(v3) || _isinf(v3) )
    return -1;
  *((_QWORD *)json + 1) = v2;
  return 0;
}
// 273E4: variables would overlap: r0.4 and r0.8

//----- (00027438) --------------------------------------------------------
void __fastcall json_delete_real(void *a1)
{
  jsonp_free(a1);
}

//----- (00027450) --------------------------------------------------------
int __cdecl json_real_equal(json_t *real1, json_t *real2)
{
  json_real_value(real1);
  json_real_value(real2);
  return 1;
}

//----- (00027490) --------------------------------------------------------
json_t *__cdecl json_real_copy(const json_t *real)
{
  double v1; // r0

  v1 = json_real_value(real);
  return json_real(v1);
}

//----- (000274B8) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
double __cdecl json_number_value(const json_t *json)
{
  double result; // r0

  if ( json && *(_DWORD *)json == 3 )
  {
    *(double *)&json = (double)json_integer_value((int)json);
  }
  else if ( json && *(_DWORD *)json == 4 )
  {
    *(double *)&json = json_real_value(json);
  }
  LODWORD(result) = json;
  return result;
}
// 274B8: variables would overlap: r0.4 and r0.8

//----- (00027518) --------------------------------------------------------
void *json_true()
{
  return &the_true_7280;
}

//----- (0002752C) --------------------------------------------------------
void *json_false()
{
  return &the_false_7284;
}

//----- (00027540) --------------------------------------------------------
void *json_null()
{
  return &the_null_7288;
}

//----- (00027554) --------------------------------------------------------
void __fastcall json_delete(void **a1)
{
  if ( !a1 || *a1 )
  {
    if ( a1 && *a1 == (void *)1 )
    {
      json_delete_array((json_array_t *)a1);
    }
    else if ( a1 && *a1 == (void *)2 )
    {
      json_delete_string((json_string_t *)a1);
    }
    else if ( a1 && *a1 == (void *)3 )
    {
      json_delete_integer(a1);
    }
    else if ( a1 )
    {
      if ( *a1 == (void *)4 )
        json_delete_real(a1);
    }
  }
  else
  {
    json_delete_object((json_object_t *)a1);
  }
}

//----- (000275D0) --------------------------------------------------------
int __fastcall json_equal(json_t *a1, json_t *a2)
{
  if ( !a1 || !a2 )
    return 0;
  if ( *(_DWORD *)a1 != *(_DWORD *)a2 )
    return 0;
  if ( a1 == a2 )
    return 1;
  switch ( *(_DWORD *)a1 )
  {
    case 0:
      return json_object_equal(a1, a2);
    case 1:
      return json_array_equal(a1, a2);
    case 2:
      return json_string_equal(a1, a2);
    case 3:
      return json_integer_equal(a1, a2);
    case 4:
      return json_real_equal(a1, a2);
  }
  return 0;
}
// 2760A: conditional instruction was optimized away because r0.4!=0
// 27624: conditional instruction was optimized away because r0.4!=0
// 2763E: conditional instruction was optimized away because r0.4!=0
// 27658: conditional instruction was optimized away because r0.4!=0
// 27672: conditional instruction was optimized away because r0.4!=0

//----- (00027694) --------------------------------------------------------
json_t *__fastcall json_copy(json_t *a1)
{
  if ( !a1 )
    return 0;
  switch ( *(_DWORD *)a1 )
  {
    case 0:
      return json_object_copy(a1);
    case 1:
      return json_array_copy(a1);
    case 2:
      return (json_t *)json_string_copy(a1);
    case 3:
      return json_integer_copy(a1);
    case 4:
      return json_real_copy(a1);
    case 5:
    case 6:
    case 7:
      return a1;
  }
  return 0;
}
// 276C2: conditional instruction was optimized away because r0.4!=0
// 276DA: conditional instruction was optimized away because r0.4!=0
// 276F2: conditional instruction was optimized away because r0.4!=0
// 2770A: conditional instruction was optimized away because r0.4!=0
// 27722: conditional instruction was optimized away because r0.4!=0
// 27730: conditional instruction was optimized away because r0.4!=0
// 2773E: conditional instruction was optimized away because r0.4!=0

//----- (00027758) --------------------------------------------------------
json_t *__fastcall json_deep_copy(const json_t *a1)
{
  if ( !a1 )
    return 0;
  switch ( *(_DWORD *)a1 )
  {
    case 0:
      return json_object_deep_copy(a1);
    case 1:
      return json_array_deep_copy(a1);
    case 2:
      return (json_t *)json_string_copy(a1);
    case 3:
      return json_integer_copy(a1);
    case 4:
      return json_real_copy(a1);
    case 5:
    case 6:
    case 7:
      return a1;
  }
  return 0;
}
// 27786: conditional instruction was optimized away because r0.4!=0
// 2779E: conditional instruction was optimized away because r0.4!=0
// 277B6: conditional instruction was optimized away because r0.4!=0
// 277CE: conditional instruction was optimized away because r0.4!=0
// 277E6: conditional instruction was optimized away because r0.4!=0
// 277F4: conditional instruction was optimized away because r0.4!=0
// 27802: conditional instruction was optimized away because r0.4!=0

//----- (0002781C) --------------------------------------------------------
void __cdecl jsonp_error_init(json_error_t *error, const char *source)
{
  if ( error )
  {
    *((_BYTE *)error + 92) = 0;
    *(_DWORD *)error = -1;
    *((_DWORD *)error + 1) = -1;
    *((_DWORD *)error + 2) = 0;
    if ( source )
      jsonp_error_set_source((char *)error, source);
    else
      *((_BYTE *)error + 12) = 0;
  }
}

//----- (00027868) --------------------------------------------------------
char *__fastcall jsonp_error_set_source(char *result, const char *a2)
{
  char *v3; // [sp+4h] [bp+4h]
  size_t v4; // [sp+Ch] [bp+Ch]

  v3 = result;
  if ( result && a2 )
  {
    v4 = strlen(a2);
    if ( v4 > 0x4F )
    {
      strcpy(v3 + 12, "...");
      return strcpy(v3 + 15, &a2[v4 - 76]);
    }
    else
    {
      return strcpy(v3 + 12, a2);
    }
  }
  return result;
}

//----- (000278D4) --------------------------------------------------------
void jsonp_error_set(json_error_t *error, int line, int column, size_t position, const char *msg, ...)
{
  va_list va; // [sp+2Ch] [bp+24h] BYREF

  va_start(va, msg);
  jsonp_error_vset(error, line, column, position, msg, va);
}

//----- (00027904) --------------------------------------------------------
void __cdecl jsonp_error_vset(json_error_t *error, int line, int column, size_t position, const char *msg, va_list ap)
{
  if ( error )
  {
    if ( !*((_BYTE *)error + 92) )
    {
      *(_DWORD *)error = line;
      *((_DWORD *)error + 1) = column;
      *((_DWORD *)error + 2) = position;
      vsnprintf((char *)error + 92, 0xA0u, msg, ap);
      *((_BYTE *)error + 251) = 0;
    }
  }
}

//----- (00027BDE) --------------------------------------------------------
int __fastcall divsi3_skip_div0_test(int result, unsigned int a2)
{
  char v2; // nf
  signed int v3; // r12
  unsigned int v4; // r3

  v3 = result ^ a2;
  if ( v2 )
    a2 = -a2;
  if ( a2 == 1 )
  {
    if ( (v3 ^ result) < 0 )
      return -result;
  }
  else
  {
    v4 = result;
    if ( result < 0 )
      v4 = -result;
    if ( v4 <= a2 )
    {
      if ( v4 < a2 )
        result = 0;
      if ( v4 == a2 )
        return (v3 >> 31) | 1;
    }
    else if ( (a2 & (a2 - 1)) != 0 )
    {
      return ((int (__fastcall *)(_DWORD))((char *)&loc_27C20 + 16 * (31 - (__clz(a2) - __clz(v4)))))(0);
    }
    else
    {
      result = v4 >> (31 - __clz(a2));
      if ( v3 < 0 )
        return -result;
    }
  }
  return result;
}
// 27BE2: variable 'v2' is possibly undefined

//----- (000281F8) --------------------------------------------------------
// Alternative name is '__aeabi_idiv0'
int _aeabi_ldiv0()
{
  return raise(8);
}

//----- (00028204) --------------------------------------------------------
int __fastcall init(int a1, int a2, int a3)
{
  int result; // r0
  int v7; // r9
  unsigned int v8; // r5
  int i; // r4
  int (__fastcall *v10)(int, int, int); // t1

  result = init_proc();
  v7 = &_do_global_dtors_aux_fini_array_entry - &_frame_dummy_init_array_entry;
  if ( v7 )
  {
    v8 = 0x35320u;
    for ( i = 0; i != v7; ++i )
    {
      v10 = *(int (__fastcall **)(int, int, int))(v8 + 4);
      v8 += 4;
      result = v10(a1, a2, a3);
    }
  }
  return result;
}
// 35324: using guessed type _UNKNOWN *_frame_dummy_init_array_entry;
// 35328: using guessed type _UNKNOWN *_do_global_dtors_aux_fini_array_entry;

//----- (0002824C) --------------------------------------------------------
// Alternative name is '_fini'
void term_proc()
{
  ;
}

// nfuncs=644 queued=507 decompiled=507 lumina nreq=0 worse=0 better=0
// ALL OK, 507 function(s) have been successfully decompiled
